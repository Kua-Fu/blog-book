# 动态更新索引

下一个需要被解决的问题是怎样在保留不变性的前提下实现倒排索引的更新？

答案是: 用更多的索引。

通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到—​从最早的开始—​查询完后再对结果进行合并。

Elasticsearch 基于 Lucene, 这个 java 库引入了 按段搜索 的概念。 每一 段 本身都是一个倒排索引， 但 索引 在 Lucene 中除表示所有 段 的集合外， 还增加了 提交点 的概念 — 一个列出了所有已知段的文件，就像在 “一个 Lucene 索引包含一个提交点和三个段” 中描绘的那样。

![一个 Lucene 索引包含一个提交点和三个段](https://github.com/Kua-Fu/blog-book-images/blob/main/elastic/basic/elas_1101.png?raw=true)


> **索引与分片的比较**
>
> 被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个 Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片(Lucene 索引)，然后像 执行分布式检索 提到的那样，合并每个分片的结果到一个全局的结果集。

“一个在内存缓存中包含新文档的 Lucene 索引” 所示，新的文档首先被添加到内存索引缓存中，然后写入到一个基于磁盘的段，

逐段搜索会以如下流程进行工作：

1. 新文档被收集到内存索引缓存

1. 不时地, 缓存被 提交 ：

	* 一个新的段—​一个追加的倒排索引—​被写入磁盘。

	* 一个新的包含新段名字的 提交点 被写入磁盘。

	* 磁盘进行 同步 — 所有在文件系统缓存中等待的写入都刷新到磁盘，以确保它们被写入物理文件。

1. 新的段被开启，让它包含的文档可见以被搜索。

1. 内存缓存被清空，等待接收新的文档。

![一个在内存缓存中包含新文档的 Lucene 索引](https://github.com/Kua-Fu/blog-book-images/blob/main/elastic/basic/elas_1102.png?raw=true)


如“在一次提交后，一个新的段被添加到提交点而且缓存被清空。” 所示。

![在一次提交后，一个新的段被添加到提交点而且缓存被清空](https://github.com/Kua-Fu/blog-book-images/blob/main/elastic/basic/elas_1103.png?raw=true)

当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。 这种方式可以用相对较低的成本将新文档添加到索引。

## 删除和更新

段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。 取而代之的是，每个提交点会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。

当一个文档被 “删除” 时，它实际上只是在 .del 文件中被 标记 删除。一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。

文档更新也是类似的操作方式：当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。 可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。

在 段合并 , 我们展示了一个被删除的文档是怎样被文件系统移除的。
