<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>è¯­å¥å’ŒçŠ¶æ€ - crafting-interpreters-zh</title>


        <!-- Custom HTML head -->
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4717236929129160" crossorigin="anonymous"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MMN1K84KRS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-MMN1K84KRS');
</script>


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../index.html">å‰è¨€</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">æ¬¢è¿</li><li class="chapter-item "><a href="../welcome/welcome.html"><strong aria-hidden="true">1.</strong> æ¬¢è¿</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../welcome/introduction.html"><strong aria-hidden="true">1.1.</strong> ä»‹ç»</a></li><li class="chapter-item "><a href="../welcome/a-map-of-the-territory.html"><strong aria-hidden="true">1.2.</strong> æ€»è§ˆå›¾</a></li><li class="chapter-item "><a href="../welcome/the-lox-language.html"><strong aria-hidden="true">1.3.</strong> Loxè¯­è¨€</a></li></ol></li><li class="chapter-item "><li class="part-title">è§£ææ ‘</li><li class="chapter-item expanded "><a href="../tree/tree.html"><strong aria-hidden="true">2.</strong> è§£ææ ‘</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tree/scanning.html"><strong aria-hidden="true">2.1.</strong> æ‰«æ</a></li><li class="chapter-item "><a href="../tree/representing-code.html"><strong aria-hidden="true">2.2.</strong> ä»£ç è¡¨ç¤º</a></li><li class="chapter-item "><a href="../tree/parsing-expression.html"><strong aria-hidden="true">2.3.</strong> è§£æè¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="../tree/evaluating-expression.html"><strong aria-hidden="true">2.4.</strong> è®¡ç®—è¡¨è¾¾å¼</a></li><li class="chapter-item expanded "><a href="../tree/statements-and-state.html" class="active"><strong aria-hidden="true">2.5.</strong> è¯­å¥å’ŒçŠ¶æ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">crafting-interpreters-zh</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/Kua-Fu/blog-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="è¯­å¥å’ŒçŠ¶æ€"><a class="header" href="#è¯­å¥å’ŒçŠ¶æ€">è¯­å¥å’ŒçŠ¶æ€</a></h1>
<blockquote>
<p>All my life, my heart has yearned for a thing I cannot name.</p>
<p>åœ¨æˆ‘çš„ä¸€ç”Ÿä¸­ï¼Œæˆ‘ä¸€ç›´æ¸´æœ›ä¸€ä»¶æ— æ³•å‘½åçš„äº‹æƒ…ã€‚</p>
<p align="center">AndrÃ© Breton, Mad Love </p>
</blockquote>
<p>The interpreter we have so far feels less like programming a real language and more like punching buttons on a calculator. â€œProgrammingâ€ to me means building up a system out of smaller pieces. We canâ€™t do that yet because we have no way to bind a name to some data or function. We canâ€™t compose software without a way to refer to the pieces</p>
<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬æ‹¥æœ‰çš„è§£é‡Šå™¨ï¼Œæ„Ÿè§‰ä¸åƒæ˜¯åœ¨ç¼–ç¨‹ä¸€ç§çœŸæ­£çš„è¯­è¨€ï¼Œæ›´åƒæ˜¯åœ¨è®¡ç®—å™¨ä¸ŠæŒ‰ä¸‹æŒ‰é’®ã€‚å¯¹æˆ‘æ¥è¯´ï¼Œç¼–ç¨‹æ„å‘³ç€ä½¿ç”¨æ›´å°çš„éƒ¨ä»¶ï¼Œæ„é€ ä¸€ä¸ªç³»ç»Ÿã€‚ç°åœ¨æˆ‘ä»¬è¿˜æ— æ³•åšåˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºï¼Œæˆ‘ä»¬è¿˜æ— æ³•å°†åç§°ç»‘å®šåˆ°æŸäº›æ•°æ®æˆ–è€…å‡½æ•°ä¸Šï¼Œæˆ‘ä»¬æ— æ³•åœ¨æ²¡æœ‰å¼•ç”¨è¿™äº›ç‰‡æ®µï¼ˆæ•°æ®ã€å‡½æ•°ï¼‰çš„æƒ…å†µä¸‹ç¼–å†™è½¯ä»¶ã€‚</p>
<p>To support bindings, our interpreter needs internal state. When you define a variable at the beginning of the program and use it at the end, the interpreter has to hold on to the value of that variable in the meantime. So in this chapter, we will give our interpreter a brain that can not just process, but remember.</p>
<p>ä¸ºäº†æ”¯æŒç»‘å®šï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨éœ€è¦å†…éƒ¨çŠ¶æ€ï¼Œå½“æˆ‘ä»¬åœ¨ç¨‹åºçš„å¼€å§‹ï¼Œå®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œå¹¶ä¸”åœ¨ç¨‹åºç»“å°¾ä½¿ç”¨å®ƒï¼Œè§£é‡Šå™¨å¿…é¡»åŒæ—¶ä¿æŒè¯¥å˜é‡çš„å€¼ã€‚æ‰€ä»¥åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç»™è§£é‡Šå™¨ä¸€ä¸ªå¤§è„‘ï¼Œå®ƒä¸ä»…ä»…å¯ä»¥è®¡ç®—ï¼Œè€Œä¸”å¯ä»¥è®°å¿†ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/brain.png?raw=true" alt="brain" /></p>
<p>State and statements go hand in hand. Since statements, by definition, donâ€™t evaluate to a value, they need to do something else to be useful. That something is called a side effect. It could mean producing user-visible output or modifying some state in the interpreter that can be detected later. The latter makes them a great fit for defining variables or other named entities.</p>
<p>çŠ¶æ€å’Œè¯­å¥æ˜¯é½å¤´å¹¶è¿›çš„ï¼Œæ ¹æ®å®šä¹‰ï¼Œè¯­å¥çš„æ±‚å€¼ç»“æœä¸æ˜¯ä¸€ä¸ªå€¼ï¼Œå› æ­¤ï¼Œå®ƒä»¬éœ€è¦åšå…¶ä»–æœ‰ç”¨çš„äº‹æƒ…ï¼Œè¿™è¢«ç§°ä¸ºå‰¯ä½œç”¨ã€‚è¿™å¯èƒ½æ„å‘³ç€ç”Ÿæˆç”¨æˆ·å¯è§çš„è¾“å‡ºï¼Œæˆ–è€…ä¿®æ”¹è§£é‡Šå™¨ä¸­çš„çŠ¶æ€ï¼Œå¯ä»¥è¢«æ£€æµ‹åˆ°ã€‚åè€…ï¼Œä½¿å¾—å®ƒä»¬éå¸¸é€‚åˆå®šä¹‰å˜é‡æˆ–è€…å…¶ä»–å‘½åçš„å®ä½“ã€‚</p>
<blockquote>
<p>You could make a language that treats variable declarations as expressions that both create a binding and produce a value. The only language I know that does that is Tcl.  Scheme seems like a contender, but note that after a let expression is evaluated, the variable it bound is forgotten. The define syntax is not an expression.</p>
<p>ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªè¯­è¨€ï¼Œå°†å˜é‡å£°æ˜è§†ä¸ºæ—¢åˆ›å»ºç»‘å®šï¼Œåˆç”Ÿæˆå€¼çš„è¡¨è¾¾å¼çš„è¯­è¨€ã€‚æˆ‘æ‰€çŸ¥é“çš„ï¼Œå”¯ä¸€åšåˆ°è¿™ä¸€ç‚¹çš„è¯­è¨€æ˜¯Tclï¼ŒSchemeçœ‹èµ·æ¥æ˜¯ä¸€ä¸ªç«äº‰è€…ï¼Œä½†æ˜¯è¯·æ³¨æ„ï¼Œåœ¨è®¡ç®— letè¡¨è¾¾å¼åï¼Œå®ƒç»‘å®šçš„å˜é‡å°†è¢«é—å¼ƒã€‚define è¯­å¥ä¸æ˜¯è¡¨è¾¾å¼ã€‚</p>
</blockquote>
<p>In this chapter, weâ€™ll do all of that. Weâ€™ll define statements that produce output (print) and create state (var). Weâ€™ll add expressions to access and assign to variables. Finally, weâ€™ll add blocks and local scope. Thatâ€™s a lot to stuff into one chapter, but weâ€™ll chew through it all one bite at a time.</p>
<p>åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†å®Œæˆæ‰€æœ‰è¿™äº›ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸¤ç§è¯­å¥ï¼Œè¾“å‡ºè¯­å¥(print) å’Œ åˆ›å»ºçŠ¶æ€è¯­å¥(var). æˆ‘ä»¬å°†æ·»åŠ è¡¨è¾¾å¼æ¥è®¿é—®å’Œåˆ†é…å˜é‡ã€‚æœ€åï¼Œæˆ‘ä»¬å°†æ·»åŠ å—å’Œå±€éƒ¨ä½œç”¨åŸŸï¼Œè¿™ä¸€ç« å°†ä¼šæ¶‰åŠå¾ˆå¤šå†…å®¹ï¼Œä½†æ˜¯æˆ‘ä»¬å°†ä¸€ç‚¹ä¸€ç‚¹å»å­¦ä¹ ã€‚</p>
<h2 id="ä¸€statements"><a class="header" href="#ä¸€statements">ä¸€ã€Statements</a></h2>
<p>è¯­å¥</p>
<p>We start by extending Loxâ€™s grammar with statements. They arenâ€™t very different from expressions. We start with the two simplest kinds:</p>
<p>æˆ‘ä»¬é¦–å…ˆç”¨è¯­å¥ï¼Œå»æ‰©å±•Loxè¯­è¨€çš„è¯­æ³•ã€‚å®ƒä»¬å’Œè¡¨è¾¾å¼æ²¡æœ‰éå¸¸å¤§çš„åŒºåˆ«ï¼Œæˆ‘ä»¬ä»ä¸¤ç§æœ€ç®€å•çš„ç±»å‹å¼€å§‹ã€‚</p>
<ol>
<li>
<p>An expression statement lets you place an expression where a statement is expected. They exist to evaluate expressions that have side effects. You may not notice them, but you use them all the time in C, Java, and other languages. Any time you see a function or method call followed by a ;, youâ€™re looking at an expression statement.</p>
<p>è¡¨è¾¾å¼è¯­å¥ï¼Œå…è®¸æˆ‘ä»¬å°†è¡¨è¾¾å¼æ”¾ç½®åœ¨éœ€è¦è¯­å¥çš„åœ°æ–¹ï¼Œå®ƒä»¬çš„å­˜åœ¨æ˜¯ä¸ºäº†è¯„ä¼°å…·æœ‰å‰¯ä½œç”¨çš„è¡¨è¾¾å¼. ä½ å¯èƒ½æ²¡æœ‰æ³¨æ„åˆ°å®ƒä»¬ï¼Œä½†æ˜¯ï¼Œåœ¨C/Java å’Œå…¶ä»–è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ä½¿ç”¨å®ƒä»¬ã€‚æ¯å½“æˆ‘ä»¬çœ‹åˆ°å‡½æ•°æˆ–è€…æ–¹æ³•è°ƒç”¨è¯­å¥ï¼Œåé¢ç´§è·Ÿä¸€ä¸ªï¼›ç¬¦å·ï¼Œæˆ‘ä»¬å®é™…ä¸Šåœ¨ä½¿ç”¨è¡¨è¾¾å¼è¯­å¥ã€‚</p>
</li>
<li>
<p>A print statement evaluates an expression and displays the result to the user. I admit itâ€™s weird to bake printing right into the language instead of making it a library function. Doing so is a concession to the fact that weâ€™re building this interpreter one chapter at a time and want to be able to play with it before itâ€™s all done. To make print a library function, weâ€™d have to wait until we had all of the machinery for defining and calling functions before we could witness any side effects.</p>
<p>printè¯­å¥è®¡ç®—è¡¨è¾¾å¼ï¼Œå¹¶ä¸”å°†ç»“æœå±•ç¤ºç»™ç”¨æˆ·ã€‚æˆ‘æ‰¿è®¤ï¼Œå°†printå½“ä½œä¸€ä¸ªè¯­å¥æ·»åŠ åˆ°è¯­è¨€ä¸­ï¼Œè€Œä¸æ˜¯ä½¿å…¶ä½œä¸ºä¸€ä¸ªåº“å‡½æ•°ï¼Œéå¸¸å¥‡æ€ªã€‚è¿™æ ·åšï¼Œæ˜¯å¯¹äºè¿™æ ·ä¸€ä¸ªäº‹å®çš„è®©æ­¥ï¼Œå³æˆ‘ä»¬å°†ä¸€ç« ä¸€ç« çš„æ„å»ºè§£é‡Šå™¨ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›åœ¨å®Œå…¨æ„å»ºå¥½è§£é‡Šå™¨ä¹‹å‰ï¼Œå°±å¯ä»¥ä½¿ç”¨å®ƒã€‚å¦‚æœè¦è®© print æˆä¸ºä¸€ä¸ªåº“å‡½æ•°ï¼Œå¿…é¡»ç­‰åˆ°æ‹¥æœ‰äº†å®šä¹‰å’Œè°ƒç”¨å‡½æ•°çš„æ‰€æœ‰æœºåˆ¶åï¼Œæ‰å¯ä»¥å®ç°ã€‚</p>
</li>
</ol>
<blockquote>
<p>Pascal is an outlier. It distinguishes between procedures and functions. Functions return values, but procedures cannot. There is a statement form for calling a procedure, but functions can only be called where an expression is expected. There are no expression statements in Pascal.</p>
<p>Pascal è¯­è¨€æœ‰äº›ä¸åŒï¼Œå®ƒä¼šåŒºåˆ†è¿‡ç¨‹å’Œå‡½æ•°ï¼Œå‡½æ•°è¿”å›å€¼ï¼Œä½†æ˜¯ï¼Œè¿‡ç¨‹ä¸ä¼šè¿”å›ç»“æœã€‚æœ‰ä¸€ç§ç”¨äºè°ƒç”¨è¿‡ç¨‹çš„è¯­å¥å½¢å¼ï¼Œä½†æ˜¯åªèƒ½åœ¨éœ€è¦è¡¨è¾¾å¼çš„åœ°æ–¹è°ƒç”¨å‡½æ•°ã€‚Pascalä¸­æ²¡æœ‰è¡¨è¾¾å¼è¯­å¥ã€‚</p>
</blockquote>
<blockquote>
<p>I will note with only a modicum of defensiveness that BASIC and Python have dedicated print statements and they are real languages. Granted, Python did remove their print statement in 3.0â€‰.â€‰.â€‰. </p>
<p>æˆ‘åªä¼šç¨å¾®è¾©è§£ä¸€ä¸‹ï¼ŒBASIC å’Œ Pythonæ˜¯çœŸæ­£çš„è¯­è¨€ï¼Œä½†æ˜¯å®ƒä»¬ä¹Ÿå­˜åœ¨printè¯­å¥ï¼Œå½“ç„¶ï¼Œåœ¨Python3.0 ä»¥åï¼Œåˆ é™¤äº† print è¯­å¥ğŸ˜„ã€‚</p>
</blockquote>
<p>New syntax means new grammar rules. In this chapter, we finally gain the ability to parse an entire Lox script. Since Lox is an imperative, dynamically typed language, the â€œtop levelâ€ of a script is simply a list of statements. The new rules are:</p>
<p>æ–°çš„è¯­æ³•æ„å‘³ç€æ–°çš„è¯­æ³•è§„åˆ™ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬æœ€ç»ˆå°†è·å¾—è§£ææ•´ä¸ªLoxè„šæœ¬çš„èƒ½åŠ›ã€‚å› ä¸ºï¼ŒLoxæ˜¯ä¸€é—¨å‘½ä»¤å¼çš„åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œæ‰€ä»¥ï¼Œè„šæœ¬çš„é¡¶å±‚è¯­æ³•è§„åˆ™ï¼Œåªæ˜¯ä¸€ä¸ªè¯­å¥çš„åˆ—è¡¨ã€‚æ–°çš„è¯­æ³•è§„åˆ™åŒ…å«ï¼š</p>
<pre><code>program      â€”â€”&gt; statement* EOF ;

statement    â€”â€”&gt; exprStmt
             | printStmt ;
			 
exprStmt     â€”â€”&gt; expression &quot;;&quot; ;
printStmt    â€”â€”&gt; &quot;print&quot; expression &quot;;&quot; ;

</code></pre>
<p>The first rule is now program, which is the starting point for the grammar and represents a complete Lox script or REPL entry. A program is a list of statements followed by the special â€œend of fileâ€ token. The mandatory end token ensures the parser consumes the entire input and doesnâ€™t silently ignore erroneous unconsumed tokens at the end of a script.</p>
<p>Right now, statement only has two cases for the two kinds of statements weâ€™ve described. Weâ€™ll fill in more later in this chapter and in the following ones. The next step is turning this grammar into something we can store in memoryâ€”syntax trees.</p>
<p>ç¬¬ä¸€æ¡è§„åˆ™ç°åœ¨æ˜¯ç¨‹åºï¼Œå®ƒæ˜¯è¯­æ³•çš„èµ·ç‚¹ï¼Œè¡¨ç¤ºä¸€ä¸ªå®Œæ•´çš„Loxè„šæœ¬æˆ–è€…REPL è¿‡ç¨‹ï¼Œç¨‹åºæ˜¯ä¸€ä¸ªè¯­å¥åˆ—è¡¨ï¼Œåé¢è·Ÿéšè€…æ–‡ä»¶ç»“æŸæ ‡å¿— EOF, å¼ºåˆ¶ç»“æŸ tokenï¼Œç¡®ä¿è§£é‡Šå™¨å¯ä»¥ä½¿ç”¨æ•´ä¸ªè¾“å…¥ï¼Œå¹¶ä¸”ä¸ä¼šåœ¨è„šæœ¬ç»“æŸæ—¶å€™ï¼Œå¿½ç•¥é”™è¯¯çš„æœªä½¿ç”¨çš„token</p>
<p>ç°åœ¨ï¼Œå¯¹äºæˆ‘ä»¬æè¿°çš„è¯­å¥ï¼Œæˆ‘ä»¬åªæœ‰ä¸¤ç§ç±»å‹ã€‚æˆ‘ä»¬å°†åœ¨æœ¬ç« çš„æœ€åï¼Œå¡«å†™æ›´å¤šçš„å†…å®¹ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬å°†å°è¯•å°†è¿™ç§è¯­æ³•ï¼Œè½¬æ¢ä¸ºå¯ä»¥ä¿å­˜åœ¨è¯­æ³•æ ‘ä¸­çš„ä¸œè¥¿ã€‚</p>
<h3 id="11-statement-syntax-trees"><a class="header" href="#11-statement-syntax-trees">1.1 Statement syntax trees</a></h3>
<p>è¯­å¥è¯­æ³•æ ‘</p>
<p>There is no place in the grammar where both an expression and a statement are allowed. The operands of, say, + are always expressions, never statements. The body of a while loop is always a statement.</p>
<p>Since the two syntaxes are disjoint, we donâ€™t need a single base class that they all inherit from. Splitting expressions and statements into separate class hierarchies enables the Java compiler to help us find dumb mistakes like passing a statement to a Java method that expects an expression.</p>
<p>That means a new base class for statements. As our elders did before us, we will use the cryptic name â€œStmtâ€. With great foresight, I have designed our little AST metaprogramming script in anticipation of this. Thatâ€™s why we passed in â€œExprâ€ as a parameter to defineAst(). Now we add another call to define Stmt and its subclasses.</p>
<p>è¯­æ³•è§„åˆ™ä¸­ï¼Œä¸å…è®¸åŒæ—¶ä½¿ç”¨è¡¨è¾¾å¼å’Œè¯­å¥ã€‚ä¾‹å¦‚ï¼š+ è¿ç®—ç¬¦ï¼Œå§‹ç»ˆæ˜¯è¡¨è¾¾å¼ï¼Œè€Œä¸æ˜¯è¯­å¥ã€‚while å¾ªç¯çš„ä¸»ä½“æ°¸è¿œæ˜¯è¯­å¥ã€‚</p>
<p>å› ä¸ºï¼Œè¯­å¥å’Œè¡¨è¾¾å¼æ˜¯ä¸ç›¸äº¤çš„ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä¸€ä¸ªè¯­å¥å’Œè¡¨è¾¾å¼éƒ½ç»§æ‰¿çš„åŸºç±»ã€‚å°†è¡¨è¾¾å¼å’Œè¯­å¥æ‹†åˆ†ä¸ºä¸åŒçš„ç±»ï¼Œå¯ä»¥ä½¿å¾—Javaç¼–è¯‘å™¨ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬å‘ç°ä¸€äº›æ„šè ¢çš„é”™è¯¯ï¼Œä¾‹å¦‚ï¼šå°†è¯­å¥ä¼ é€’ç»™éœ€è¦è¡¨è¾¾å¼çš„ Javaæ–¹æ³•ã€‚</p>
<p>è¿™æ„å‘³ç€ï¼Œè¯­å¥å­˜åœ¨ä¸€ä¸ªæ–°çš„åŸºç±»ã€‚æ­£å¦‚æˆ‘ä»¬çš„å‰è¾ˆé‚£æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨Stmt å½“ä½œæ–°çš„åŸºç±»çš„åç§°ã€‚æˆ‘ä»¬éå¸¸æœ‰è¿œè§çš„è®¾è®¡äº†ASTå…ƒç¼–ç¨‹è„šæœ¬ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬å°† &quot;Expr&quot; å½“ä½œå‚æ•°ä¼ é€’ç»™ defineAst()å‡½æ•°çš„åŸå› ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬å°†æ·»åŠ ä¸€ä¸ªæ–°çš„è°ƒç”¨ï¼Œæ¥å®šä¹‰Stmt å’Œå®ƒçš„å­ç±»ã€‚</p>
<blockquote>
<p>Not really foresight: I wrote all the code for the book before I sliced it into chapters.</p>
<p>å®é™…ä¸Šï¼Œæ²¡æœ‰ä»€ä¹ˆå…ˆè§ä¹‹æ˜ï¼Œæˆ‘æ˜¯å…ˆæŠŠæ‰€æœ‰ä»£ç éƒ½å®Œæˆåï¼Œæ‰å¼€å§‹å°†æœ¬ä¹¦åˆ†æˆè¿™äº›ç« èŠ‚çš„ã€‚</p>
</blockquote>
<pre><code class="language-java">
// tool/GenerateAst.java, in main()

      &quot;Unary    : Token operator, Expr right&quot;
    ));

    defineAst(outputDir, &quot;Stmt&quot;, Arrays.asList(
      &quot;Expression : Expr expression&quot;,
      &quot;Print      : Expr expression&quot;
    ));
  }
  
</code></pre>
<blockquote>
<p>The generated code for the new nodes is in Appendix II: Expression statement, Print statement.</p>
<p>ä¸ºæ–°èŠ‚ç‚¹ç”Ÿæˆçš„ä»£ç å¯ä»¥æŸ¥çœ‹ é™„å½•II, è¡¨è¾¾å¼è¯­å¥ï¼Œprintè¯­å¥ã€‚</p>
</blockquote>
<p>Run the AST generator script and behold the resulting â€œStmt.javaâ€ file with the syntax tree classes we need for expression and print statements. Donâ€™t forget to add the file to your IDE project or makefile or whatever.</p>
<p>è¿è¡Œ AST ç”Ÿæˆè„šæœ¬ï¼ŒæŸ¥çœ‹ç”Ÿæˆçš„ &quot;Stmt.java&quot; æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«è¡¨è¾¾å¼å’Œprintè¯­å¥ï¼Œæ‰€éœ€çš„è¯­æ³•æ ‘ç±»ã€‚ä¸è¦å¿˜è®°å°†ç”Ÿæˆçš„æ–‡ä»¶ï¼Œæ·»åŠ åˆ°é¡¹ç›®ä¸­ã€‚</p>
<h3 id="12-parsing-statements"><a class="header" href="#12-parsing-statements">1.2 Parsing statements</a></h3>
<p>è§£æè¯­å¥</p>
<p>The parserâ€™s parse() method that parses and returns a single expression was a temporary hack to get the last chapter up and running. Now that our grammar has the correct starting rule, program, we can turn parse() into the real deal.</p>
<p>è§£æå™¨çš„parse() æ–¹æ³•è§£æå¹¶ä¸”è¿”å›ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸´æ—¶çš„ç ´è§£æ–¹å¼ï¼Œè®©æœ€åä¸€ç« å¯åŠ¨è¿è¡Œã€‚æ—¢ç„¶ï¼Œæˆ‘ä»¬çš„ç¨‹åºæœ‰äº†æ­£ç¡®çš„å¼€å§‹è§„åˆ™ï¼Œ program, æˆ‘ä»¬å°±å¯ä»¥æŠŠparse() æ–¹æ³•å˜ä¸ºçœŸæ­£çš„å¤„ç†æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, method parse(), replace 7 lines

  List&lt;Stmt&gt; parse() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();
    while (!isAtEnd()) {
      statements.add(statement());
    }

    return statements; 
  }
</code></pre>
<blockquote>
<p>What about the code we had in here for catching ParseError exceptions? Weâ€™ll put better parse error handling in place soon when we add support for additional statement types.</p>
<p>æˆ‘ä»¬ä¹‹å‰ç”¨äºæ•è·ParseErrorå¼‚å¸¸çš„ä»£ç å‘¢ï¼Ÿå½“æˆ‘ä»¬æ·»åŠ å¯¹äºå…¶ä»–è¯­å¥ç±»å‹çš„æ”¯æŒæ—¶å€™ï¼Œæˆ‘ä»¬å°†å¾ˆå¿«å®ç°æ›´å¥½çš„è§£æé”™è¯¯å¤„ç†</p>
</blockquote>
<p>This parses a series of statements, as many as it can find until it hits the end of the input. This is a pretty direct translation of the program rule into recursive descent style. We must also chant a minor prayer to the Java verbosity gods since we are using ArrayList now.</p>
<p>è¿™ä¸ªæ–°çš„parse() æ–¹æ³•ï¼Œå°†ä¼šè§£æä¸€ç³»åˆ—çš„è¯­å¥ï¼Œå°½å¯èƒ½å¤šï¼Œç›´åˆ°è¾“å…¥çš„ç»“å°¾ã€‚è¿™æ˜¯å°†program è¯­æ³•è§„åˆ™ï¼Œéå¸¸ç›´æ¥çš„è½¬æ¢ä¸ºé€’å½’ä¸‹é™çš„æ ·å¼ã€‚ç”±äºæˆ‘ä»¬ç°åœ¨ä½¿ç”¨ ArrayList(),æ‰€ä»¥ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¼•å…¥ Javaçš„ ArrayListæ¨¡å—</p>
<pre><code class="language-java">
// lox/Parser.java

package com.craftinginterpreters.lox;

import java.util.ArrayList;
import java.util.List;

</code></pre>
<p>A program is a list of statements, and we parse one of those statements using this method:</p>
<p>ç¨‹åºæ˜¯ä¸€ç³»åˆ—çš„è¯­å¥ç»„æˆçš„ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ statement() æ–¹æ³•è§£æå…¶ä¸­çš„ä¸€ä¸ªè¯­å¥</p>
<pre><code class="language-java">
// lox/Parser.java, add after expression()

  private Stmt statement() {
    if (match(PRINT)) return printStatement();

    return expressionStatement();
  }
  
</code></pre>
<p>A little bare bones, but weâ€™ll fill it in with more statement types later. We determine which specific statement rule is matched by looking at the current token. A print token means itâ€™s obviously a print statement.</p>
<p>If the next token doesnâ€™t look like any known kind of statement, we assume it must be an expression statement. Thatâ€™s the typical final fallthrough case when parsing a statement, since itâ€™s hard to proactively recognize an expression from its first token.</p>
<p>ä¸Šé¢çš„å‡½æ•°æœ‰äº›ç®€å•ï¼Œä½†æ˜¯ï¼Œç¨åæˆ‘ä»¬å°†ä¼šä½¿ç”¨æ›´å¤šçš„è¯­å¥ç±»å‹æ¥å¡«å…… statement() ï¼Œé€šè¿‡æŸ¥çœ‹å½“å‰çš„tokenï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šåŒ¹é…å“ªä¸€ä¸ªç‰¹å®šçš„è¯­å¥è§„åˆ™ã€‚print tokenï¼Œè¡¨ç¤ºå½“å‰çš„è¯­å¥æ˜¯printè¯­å¥ã€‚</p>
<p>å¦‚æœï¼Œä¸‹ä¸€ä¸ªtokençœ‹èµ·æ¥ä¸åƒæ˜¯ä»»ä½•å·²çŸ¥çš„è¯­å¥ç±»å‹ï¼Œæˆ‘ä»¬å…ˆå‡è®¾å®ƒï¼Œå¿…é¡»æ˜¯è¡¨è¾¾å¼è¯­å¥ï¼Œè¿™æ˜¯è§£æè¯­å¥æ—¶å€™ï¼Œå…¸å‹çš„æœ€ç»ˆå¤±è´¥æ¡ˆä¾‹ï¼Œå› ä¸ºå¾ˆéš¾ä»ç¬¬ä¸€ä¸ªtokenï¼Œå°±åˆ¤æ–­å‡ºè¡¨è¾¾å¼</p>
<p>Each statement kind gets its own method. First print:</p>
<p>æ¯ä¸ªè¯­å¥éƒ½æœ‰è‡ªå·±çš„å¯¹åº”æ–¹æ³•ï¼Œé¦–å…ˆæ˜¯printè¯­å¥</p>
<pre><code class="language-java">
// lox/Parser.java, add after statement()

  private Stmt printStatement() {
    Expr value = expression();
    consume(SEMICOLON, &quot;Expect ';' after value.&quot;);
    return new Stmt.Print(value);
  }
</code></pre>
<p>Since we already matched and consumed the print token itself, we donâ€™t need to do that here. We parse the subsequent expression, consume the terminating semicolon, and emit the syntax tree.</p>
<p>å› ä¸ºæˆ‘ä»¬å·²ç»åŒ¹é…åˆ°å¹¶ä¸”ä½¿ç”¨äº† print token,æ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸éœ€è¦åœ¨è¿™é‡Œè¿™æ ·åšã€‚æˆ‘ä»¬å°†è§£æåç»­çš„è¡¨è¾¾å¼ï¼Œä½¿ç”¨ç»ˆæ­¢åˆ†å·ï¼Œç”Ÿæˆè¯­æ³•æ ‘ã€‚</p>
<p>If we didnâ€™t match a print statement, we must have one of these:</p>
<p>å¦‚æœæˆ‘ä»¬æ²¡æœ‰åŒ¹é…åˆ°print è¯­å¥ï¼Œåˆ™å¿…é¡»æ˜¯ä¸‹é¢çš„åœºæ™¯ä¹‹ä¸€</p>
<pre><code class="language-java">
// lox/Parser.java, add after printStatement()

  private Stmt expressionStatement() {
    Expr expr = expression();
    consume(SEMICOLON, &quot;Expect ';' after expression.&quot;);
    return new Stmt.Expression(expr);
  }


</code></pre>
<p>Similar to the previous method, we parse an expression followed by a semicolon. We wrap that Expr in a Stmt of the right type and return it.</p>
<p>ä¸å‰é¢çš„æ–¹æ³•ç±»ä¼¼ï¼Œæˆ‘ä»¬è§£æåé¢è·Ÿéšè€…åˆ†å·çš„è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å°†ExpråŒ…è£…åœ¨æ­£ç¡®çš„Stmtç±»å‹ä¸­ï¼Œå¹¶ä¸”è¿”å›ã€‚</p>
<h3 id="13-executing-statements"><a class="header" href="#13-executing-statements">1.3 Executing statements</a></h3>
<p>æ‰§è¡Œè¯­å¥</p>
<p>Weâ€™re running through the previous couple of chapters in microcosm, working our way through the front end. Our parser can now produce statement syntax trees, so the next and final step is to interpret them. As in expressions, we use the Visitor pattern, but we have a new visitor interface, Stmt.Visitor, to implement since statements have their own base class.</p>
<p>æˆ‘ä»¬åœ¨å¾®è§‚ä¸–ç•Œå®Œæˆäº†å‰é¢çš„å‡ ç« ï¼Œåœ¨å‰ç«¯å·¥ä½œã€‚æˆ‘ä»¬çš„è§£æå™¨ç°åœ¨å¯ä»¥ç”Ÿæˆè¯­æ³•æ ‘ï¼Œå› æ­¤ï¼Œä¸‹é¢çš„å¹¶ä¸”æ˜¯æœ€åçš„æ­¥éª¤æ˜¯ï¼Œå¦‚ä½•è§£é‡Šå®ƒä»¬ã€‚å’Œè¡¨è¾¾å¼ä¸€æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨è®¿é—®è€…æ¨¡å¼ï¼Œè®¿é—®è€…ï¼Œå› ä¸ºæ¯ä¸€ä¸ªå…·ä½“çš„statementç±»ï¼Œéƒ½æœ‰ç›¸åŒçš„åŸºç±»ã€‚</p>
<p>We add that to the list of interfaces Interpreter implements.</p>
<p>æˆ‘ä»¬å°†å…¶æ·»åŠ åˆ°è§£é‡Šå™¨å®ç°çš„æ¥å£åˆ—è¡¨ä¸­</p>
<pre><code class="language-java">
// lox/Interpreter.java, replace 1 line

class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
  void interpret(Expr expression) { 

</code></pre>
<blockquote>
<p>Java doesnâ€™t let you use lowercase â€œvoidâ€ as a generic type argument for obscure reasons having to do with type erasure and the stack. Instead, there is a separate â€œVoidâ€ type specifically for this use. Sort of a â€œboxed voidâ€, like â€œIntegerâ€ is for â€œintâ€.</p>
<p>Java ä¸­ä¸å…è®¸ä½¿ç”¨å°å†™çš„ void å½“ä½œæ³›å‹ç±»å‹å‚æ•°ï¼ŒåŸå› ä¸æ˜ï¼Œä¸ç±»å‹æ“¦é™¤å’Œå †æ ˆæœ‰å…³ï¼Œç›¸åï¼Œæœ‰ä¸€ä¸ªå•ç‹¬çš„Voidç±»å‹ï¼Œä¸“é—¨ç”¨äºè¿™ç§ç”¨é€”ï¼ŒVoidç±»å‹ä¹‹äº voidï¼Œæœ‰ç‚¹ç±»ä¼¼ Integerç±»å‹ä¹‹äº int</p>
</blockquote>
<p>Unlike expressions, statements produce no values, so the return type of the visit methods is Void, not Object. We have two statement types, and we need a visit method for each. The easiest is expression statements.</p>
<p>å’Œè¡¨è¾¾å¼ä¸åŒï¼Œè¯­å¥ä¸ç”Ÿæˆå€¼ï¼Œæ‰€ä»¥ï¼Œvisitæ–¹æ³•çš„è¿”å›å€¼ç±»å‹æ˜¯ Voidï¼Œè€Œä¸æ˜¯Objectï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§è¯­å¥ç±»å‹ï¼Œæ¯ä¸ªéƒ½éœ€è¦ä¸€ç§è®¿é—®æ–¹æ³•ï¼Œæœ€ç®€å•çš„æ˜¯è¡¨è¾¾å¼è¯­å¥ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after evaluate()

  @Override
  public Void visitExpressionStmt(Stmt.Expression stmt) {
    evaluate(stmt.expression);
    return null;
  }

</code></pre>
<p>We evaluate the inner expression using our existing evaluate() method and discard the value. Then we return null. Java requires that to satisfy the special capitalized Void return type. Weird, but what can you do?</p>
<p>æˆ‘ä»¬ä½¿ç”¨ä¹‹å‰å®ç°çš„æ–¹æ³• evaluate() è®¡ç®—è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä¸¢å¼ƒè®¡ç®—ç»“æœï¼Œè¿”å› nullï¼ŒJavaéœ€è¦æ»¡è¶³ç‰¹æ®Šçš„Void ç±»å‹çš„å€¼ã€‚æˆ‘ä»¬è¿˜éœ€è¦åšä»€ä¹ˆï¼Ÿ</p>
<blockquote>
<p>Appropriately enough, we discard the value returned by evaluate() by placing that call inside a Java expression statement.</p>
<p>åˆé€‚çš„æ˜¯ï¼Œæˆ‘ä»¬å°† evaluate() è¿”å›çš„å€¼ï¼Œæ”¾å…¥è¡¨è¾¾å¼è¯­å¥ä¸­ï¼Œä»è€Œä¸¢å¼ƒè¯¥å€¼</p>
</blockquote>
<p>The print statementâ€™s visit method isnâ€™t much different.</p>
<p>printè¯­å¥çš„è®¿é—®æ–¹æ³•ï¼Œæ²¡æœ‰å¤ªå¤šçš„ä¸åŒ</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitExpressionStmt()

  @Override
  public Void visitPrintStmt(Stmt.Print stmt) {
    Object value = evaluate(stmt.expression);
    System.out.println(stringify(value));
    return null;
  }


</code></pre>
<p>Before discarding the expressionâ€™s value, we convert it to a string using the stringify() method we introduced in the last chapter and then dump it to stdout.</p>
<p>åœ¨ä¸¢å¼ƒè¡¨è¾¾å¼çš„å€¼ä¹‹å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸Šä¸€ç« ä»‹ç»çš„ stringify() æ–¹æ³•å°†ç»“æœè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åï¼Œå°†å…¶å­˜å‚¨åˆ° stdout</p>
<p>Our interpreter is able to visit statements now, but we have some work to do to feed them to it. First, modify the old interpret() method in the Interpreter class to accept a list of statementsâ€”in other words, a program.</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨ï¼Œç°åœ¨å¯ä»¥è®¿é—®è¯­å¥ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦å…ˆåšä¸€äº›å·¥ä½œï¼Œæ¥å‘ä»–ä»¬æä¾›ä¿¡æ¯ï¼Œé¦–å…ˆï¼Œä¿®æ”¹æ—§çš„interpret() ï¼Œæ¥å—ä¸€ä¸ªè¯­å¥åˆ—è¡¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå‚æ•°æ˜¯ä¸€ä¸ªprogram</p>
<pre><code class="language-java">
// lox/Interpreter.java, method interpret(), replace 8 lines

  void interpret(List&lt;Stmt&gt; statements) {
    try {
      for (Stmt statement : statements) {
        execute(statement);
      }
    } catch (RuntimeError error) {
      Lox.runtimeError(error);
    }
  }
  
</code></pre>
<p>This replaces the old code which took a single expression. The new code relies on this tiny helper method:</p>
<p>è¿™å°†æ›¿æ¢é‡‡ç”¨å•ä¸ªè¡¨è¾¾å¼çš„æ—§ä»£ç ï¼Œæ–°çš„ä»£ç éœ€è¦ä¸€ä¸ª æ–°çš„ execute()å‡½æ•°</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after evaluate()

  private void execute(Stmt stmt) {
    stmt.accept(this);
  }


</code></pre>
<p>Thatâ€™s the statement analogue to the evaluate() method we have for expressions. Since weâ€™re working with lists now, we need to let Java know.</p>
<p>ä¸Šé¢æ˜¯ç±»ä¼¼äº evaluate() å¤„ç†è¡¨è¾¾å¼çš„å¤„ç†è¯­å¥æ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨å¤„ç†åˆ—è¡¨ï¼Œæ‰€ä»¥éœ€è¦å¼•å…¥ List</p>
<pre><code class="language-java">
// lox/Interpreter.java

package com.craftinginterpreters.lox;

import java.util.List;

class Interpreter implements Expr.Visitor&lt;Object&gt;,


</code></pre>
<p>The main Lox class is still trying to parse a single expression and pass it to the interpreter. We fix the parsing line like so:</p>
<p>ä¸»Lox ç±»ï¼Œä»ç„¶åœ¨å°è¯•è§£æå•ä¸ªè¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä¼ é€’ç»™è§£é‡Šå™¨ï¼Œæˆ‘ä»¬è¿™æ ·ä¿®å¤è§£æè¡Œ</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 1 line

 Parser parser = new Parser(tokens);
    List&lt;Stmt&gt; statements = parser.parse();

    // Stop if there was a syntax error.


</code></pre>
<p>And then replace the call to the interpreter with this:</p>
<p>ç„¶åï¼Œè§£é‡Šå™¨çš„è°ƒç”¨ï¼Œæ›¿æ¢ä¸º</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 1 line

    if (hadError) return;

    interpreter.interpret(statements);
  }
  
</code></pre>
<p>Basically just plumbing the new syntax through. OK, fire up the interpreter and give it a try. At this point, itâ€™s worth sketching out a little Lox program in a text file to run as a script. Something like:</p>
<p>åŸºæœ¬ä¸Šï¼Œå°±æ˜¯é€šè¿‡ç®¡é“ä¼ é€’æ–°è¯­æ³•ã€‚å¥½çš„ï¼Œæˆ‘ä»¬å¼€å§‹å¯åŠ¨ç¿»è¯‘ï¼Œå¹¶ä¸”å¼€å§‹è¿è¡Œã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ–‡ä»¶ä¸­æ„é€ ä¸€ä¸ªç®€å•çš„ç¨‹åºï¼Œå½“ä½œLoxè„šæœ¬æ‰§è¡Œã€‚</p>
<pre><code class="language-java">
print &quot;one&quot;;
print true;
print 2 + 1;

</code></pre>
<p>It almost looks like a real program! Note that the REPL, too, now requires you to enter a full statement instead of a simple expression. Donâ€™t forget your semicolons.</p>
<p>ä¸Šé¢çš„çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªçœŸæ˜¯çš„ç¨‹åºäº†ï¼Œè¯·æ³¨æ„ï¼ŒREPL ç°åœ¨ä¹Ÿè¦æ±‚æˆ‘ä»¬è¾“å…¥å®Œæ•´çš„è¯­å¥ï¼Œè€Œä¸æ˜¯ç®€å•çš„è¡¨è¾¾å¼ï¼Œä¸è¦å¿˜è®°åˆ†å·</p>
<h2 id="äºŒglobal-variables"><a class="header" href="#äºŒglobal-variables">äºŒã€Global Variables</a></h2>
<p>å…¨å±€å˜é‡</p>
<p>Now that we have statements, we can start working on state. Before we get into all of the complexity of lexical scoping, weâ€™ll start off with the easiest kind of variablesâ€”globals. We need two new constructs.</p>
<p>æ—¢ç„¶ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†è¯­å¥ï¼Œæˆ‘ä»¬å¯ä»¥ç ”ç©¶çŠ¶æ€äº†ï¼Œåœ¨æˆ‘ä»¬äº†è§£è¯æ±‡èŒƒå›´çš„å¤æ‚æ€§ä¹‹å‰ï¼Œæˆ‘ä»¬å°†ä»æœ€ç®€å•çš„å…¨å±€å˜é‡å¼€å§‹ã€‚æˆ‘ä»¬éœ€è¦ä¸¤ä¸ªæ–°çš„æ„é€ ã€‚</p>
<ol>
<li>
<p>A variable declaration statement brings a new variable into the world.</p>
<p>ä¸€ä¸ªå˜é‡å£°æ˜è¯­å¥ï¼Œä¸ºä¸–ç•Œå¸¦æ¥äº†ä¸€ä¸ªæ–°çš„å˜é‡</p>
<pre><code>var beverage = &quot;espresso&quot;;
</code></pre>
<p>This creates a new binding that associates a name (here â€œbeverageâ€) with a value (here, the string &quot;espresso&quot;).</p>
<p>ä¸Šé¢çš„å£°æ˜è¯­å¥ï¼Œå°†ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ç»‘å®šï¼Œç»‘å®šäº†ä¸€ä¸ªåç§°ï¼ˆbeverage) å’Œ å¯¹åº”çš„å€¼ï¼ˆ espressoï¼‰ä¹‹é—´çš„å…³ç³»</p>
</li>
<li>
<p>Once thatâ€™s done, a variable expression accesses that binding. When the identifier â€œbeverageâ€ is used as an expression, it looks up the value bound to that name and returns it.</p>
<p>å®Œæˆåï¼Œå˜é‡è¡¨è¾¾å¼å°†è®¿é—®è¯¥ç»‘å®šï¼Œå½“æ ‡è¯†ç¬¦ beverage ç”¨ä½œè¡¨è¾¾å¼æ—¶å€™ï¼Œå®ƒä¼šæŸ¥æ‰¾ç»‘å®šåˆ°è¯¥åç§°çš„å€¼ï¼Œå¹¶ä¸”è¿”å›è¯¥å€¼ã€‚</p>
<pre><code>
print beverage; // &quot;espresso&quot;.

</code></pre>
</li>
</ol>
<p>Later, weâ€™ll add assignment and block scope, but thatâ€™s enough to get moving.</p>
<p>ç¨åï¼Œæˆ‘ä»¬å°†ä»‹ç»èµ‹å€¼å’Œå—èŒƒå›´ï¼Œä½†æ˜¯ç°åœ¨è¶³å¤Ÿæˆ‘ä»¬å¼€å§‹äº†ã€‚</p>
<blockquote>
<p>Global state gets a bad rap. Sure, lots of global stateâ€”especially mutable stateâ€”makes it hard to maintain large programs. Itâ€™s good software engineering to minimize how much you use.</p>
<p>But when youâ€™re slapping together a simple programming language or, heck, even learning your first language, the flat simplicity of global variables helps. My first language was BASIC and, though I outgrew it eventually, it was nice that I didnâ€™t have to wrap my head around scoping rules before I could make a computer do fun stuff.</p>
<p>å…¨å±€çŠ¶æ€å—åˆ°äº†ä¸å¥½çš„è¯„ä»·ï¼Œå½“ç„¶ï¼Œè®¸å¤šå…¨å±€å˜é‡â€”â€”ç‰¹åˆ«æ˜¯å¯å˜å˜é‡ï¼Œä½¿å¾—ç»´æŠ¤å¤§å‹ç¨‹åºå˜å¾—å›°éš¾ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è½¯ä»¶å·¥ç¨‹ï¼Œå¯ä»¥æœ€å¤§é™åº¦çš„å‡å°‘ä½ çš„ä½¿ç”¨é‡ã€‚</p>
<p>ä½†æ˜¯ï¼Œå½“ä½ æ‹¼å‡‘ä¸€é—¨ç®€å•çš„ç¼–ç¨‹è¯­è¨€ï¼Œæˆ–è€…ï¼Œå½“ä½ å¼€å§‹å­¦ä¹ ç¬¬ä¸€é—¨ç¼–ç¨‹è¯­è¨€æ—¶å€™ï¼Œå…¨å±€å˜é‡çš„ç®€å•æ€§å°†ä¼šæä¾›å¸®åŠ©ã€‚æˆ‘çš„ç¬¬ä¸€é—¨è¯­è¨€æ˜¯ BASICï¼Œå°½ç®¡æœ€ç»ˆï¼Œæˆ‘æ²¡æœ‰ç”¨åˆ°å®ƒï¼Œä½†åœ¨æˆ‘å¯ä»¥è®©è®¡ç®—æœºåšå¾ˆå¤šæœ‰è¶£çš„äº‹æƒ…ä¹‹å‰ï¼Œä¸å¿…è®©è‡ªå·±å»è®°ä½å¤æ‚çš„èŒƒå›´è§„åˆ™ï¼Œè¿™å¾ˆå¥½ã€‚</p>
</blockquote>
<h3 id="21-variable-syntax"><a class="header" href="#21-variable-syntax">2.1 Variable syntax</a></h3>
<p>å˜é‡è¯­æ³•</p>
<p>As before, weâ€™ll work through the implementation from front to back, starting with the syntax. Variable declarations are statements, but they are different from other statements, and weâ€™re going to split the statement grammar in two to handle them. Thatâ€™s because the grammar restricts where some kinds of statements are allowed.</p>
<p>å’Œä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å°†ä»è¯­æ³•å¼€å§‹ï¼Œä»å‰åˆ°åå®Œæˆå®ç°ã€‚å˜é‡å£°æ˜æ˜¯è¯­å¥ï¼Œä½†æ˜¯å®ƒä»¬å’Œå…¶ä»–è¯­å¥ä¸åŒï¼Œæˆ‘ä»¬å°†è¯­å¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œæ¥å¤„ç†å®ƒä»¬ã€‚è¿™æ˜¯å› ä¸ºè¯­æ³•é™åˆ¶äº†ï¼Œå…è®¸æŸäº›ç±»å‹çš„è¯­å¥çš„ä½ç½®ã€‚</p>
<p>The clauses in control flow statementsâ€”think the then and else branches of an if statement or the body of a whileâ€”are each a single statement. But that statement is not allowed to be one that declares a name. This is OK:</p>
<pre><code>
if (monday) print &quot;Ugh, already?&quot;;

</code></pre>
<p>But this is not:</p>
<pre><code>if (monday) var beverage = &quot;espresso&quot;;
</code></pre>
<p>æ§åˆ¶æµè¯­å¥ä¸­çš„å­å¥è®¤ä¸ºif è¯­å¥çš„thenã€elseåˆ†æ”¯ï¼Œwhileè¯­å¥çš„ä¸»ä½“ï¼Œéƒ½æ˜¯å•ä¸ªè¯­å¥ã€‚ä½†æ˜¯ï¼Œè¿™ä¸ªè¯­å¥ä¸å…è®¸æ˜¯å£°æ˜è¯­å¥ã€‚ä¸¾ä¾‹ï¼š</p>
<p>We could allow the latter, but itâ€™s confusing. What is the scope of that beverage variable? Does it persist after the if statement? If so, what is its value on days other than Monday? Does the variable exist at all on those days?</p>
<p>Code like this is weird, so C, Java, and friends all disallow it. Itâ€™s as if there are two levels of â€œprecedenceâ€ for statements. Some places where a statement is allowedâ€”like inside a block or at the top levelâ€”allow any kind of statement, including declarations. Others allow only the â€œhigherâ€ precedence statements that donâ€™t declare names.</p>
<p>æˆ‘ä»¬Loxå¯ä»¥å…è®¸åé¢çš„ç¨‹åºï¼Œä½†æ˜¯è¿™ä¼šä»¤äººå›°æƒ‘ã€‚beverage å˜é‡çš„ä½œç”¨èŒƒå›´æ˜¯ä»€ä¹ˆï¼Ÿå®ƒåœ¨ ifè¯­å¥ä¹‹å¤–æ˜¯å¦æŒç»­å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨ï¼Œbeverage å˜é‡çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ªå˜é‡ beverage æ˜¯å¦ä¼šä¸€ç›´å­˜åœ¨ï¼Ÿ</p>
<p>è¿™æ ·çš„ä»£ç ä¼šéå¸¸å¥‡æ€ªï¼Œæ‰€ä»¥ï¼ŒC/Java/friends ç­‰è¯­è¨€ï¼Œéƒ½ä¸å…è®¸è¿™æ ·å†™ã€‚è¿™å¥½åƒæ˜¯è¯´ï¼Œè¯­å¥å­˜åœ¨ä¸¤ä¸ªä¼˜å…ˆçº§ã€‚æŸäº›å…è®¸è¯­å¥çš„åœ°æ–¹â€”â€”ä¾‹å¦‚ï¼Œå—å†…æˆ–è€…é¡¶å±‚ï¼Œå…è®¸ä»»ä½•ç±»å‹çš„è¯­å¥ï¼ŒåŒ…æ‹¬å£°æ˜è¯­å¥ã€‚å…¶ä»–åœ°æ–¹ï¼Œåªå…è®¸å‡ºç°æ›´é«˜çº§åˆ«çš„è¯­å¥ï¼Œä¸åŒ…æ‹¬å£°æ˜ã€‚</p>
<blockquote>
<p>In this analogy, block statements work sort of like parentheses do for expressions. A block is itself in the â€œhigherâ€ precedence level and can be used anywhere, like in the clauses of an if statement. But the statements it contains can be lower precedence. Youâ€™re allowed to declare variables and other names inside the block. The curlies let you escape back into the full statement grammar from a place where only some statements are allowed.</p>
<p>åœ¨ä¸Šé¢çš„ç±»æ¯”ä¸­ï¼Œå—è¯­å¥å¥½åƒæ˜¯è¡¨è¾¾å¼ä¸­çš„å°æ‹¬å·ï¼Œå—æœ¬èº«å¤„äºæ›´é«˜çš„ä¼˜å…ˆçº§ï¼Œå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼šifè¯­å¥çš„å­å¥ä¸­ã€‚ä½†æ˜¯ï¼Œå—åŒ…å«çš„è¯­å¥å¯ä»¥å…·æœ‰æ›´ä½çš„ä¼˜å…ˆçº§ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å—å†…ï¼Œå£°æ˜å˜é‡å’Œå…¶ä»–åç§°ï¼Œæ¸¸æ ‡ï¼Œå…è®¸æˆ‘ä»¬ä»åªå…è®¸æŸäº›è¯­å¥çš„åœ°æ–¹ï¼Œè¿”å›åˆ°å®Œæ•´çš„è¯­å¥è¯­æ³•ã€‚</p>
</blockquote>
<p>To accommodate the distinction, we add another rule for kinds of statements that declare names</p>
<p>ä¸ºäº†é€‚åº”è¿™ç§è§„åˆ™ï¼Œæˆ‘ä»¬ä¸ºå£°æ˜è¯­å¥æ·»åŠ äº†å¦å¤–ä¸€æ¡è¯­æ³•è§„åˆ™</p>
<pre><code>
program       â€”â€”&gt; declaration* EOF;

declaration   â€”â€”&gt; varDecl
	          |   statement;
			  
statement     â€”â€”&gt; exprStmt;
	          |   printStmt;
			  
</code></pre>
<p>Declaration statements go under the new declaration rule. Right now, itâ€™s only variables, but later it will include functions and classes. Any place where a declaration is allowed also allows non-declaring statements, so the declaration rule falls through to statement. Obviously, you can declare stuff at the top level of a script, so program routes to the new rule.</p>
<p>å£°æ˜è¯­å¥ï¼Œç¬¦åˆæœ€æ–°çš„å£°æ˜è¯­æ³•è§„åˆ™ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬çš„å£°æ˜è¯­å¥ï¼Œåªæ˜¯å˜é‡ã€‚ä½†æ˜¯ï¼Œç¨åï¼Œå®ƒå°†åŒ…å«å‡½æ•°å’Œç±»ï¼Œä»»ä½•å…è®¸å£°æ˜è¯­å¥çš„åœ°æ–¹ï¼Œä¹ŸåŒæ—¶å…è®¸å…¶ä»–è¯­å¥ï¼Œå› æ­¤ï¼Œå£°æ˜è§„åˆ™ï¼Œä¹Ÿé€‚åº”äºå…¶ä»–è¯­å¥ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è„šæœ¬çš„é¡¶å±‚å£°æ˜å†…å®¹ï¼Œå› æ­¤ï¼Œç¨‹åºå°†è·¯ç”±åˆ°æ–°è§„åˆ™ã€‚</p>
<p>The rule for declaring a variable looks like:</p>
<p>å£°æ˜å˜é‡çš„è§„åˆ™å¦‚ä¸‹</p>
<pre><code>varDecl      â€”â€”&gt; &quot;var&quot; IDENTIFIER ï¼ˆ &quot;=&quot; expression ) ? &quot;;&quot; ; 
</code></pre>
<p>Like most statements, it starts with a leading keyword. In this case, var. Then an identifier token for the name of the variable being declared, followed by an optional initializer expression. Finally, we put a bow on it with the semicolon</p>
<p>å’Œå¤§å¤šæ•°çš„è¯­å¥ä¸€æ ·ï¼Œå®ƒä»¥ä¸€ä¸ªå‰å¯¼å…³é”®å­—å¼€å§‹ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œå…³é”®å­—æ˜¯ varï¼Œç„¶åï¼Œæ˜¯å£°æ˜çš„å˜é‡çš„åç§°ï¼Œå³ä¸€ä¸ªæ ‡è¯†ç¬¦ tokenï¼Œæœ€åï¼Œè·Ÿéšç€ä¸€ä¸ªå¯é€‰çš„åˆå§‹å€¼è®¾å®šé¡¹è¡¨è¾¾å¼ã€‚åˆ«å¿˜äº†è¯­å¥çš„æœ€åæ˜¯ä¸€ä¸ªåˆ†å·</p>
<p>To access a variable, we define a new kind of primary expression.</p>
<p>ä¸ºäº†è®¿é—®å˜é‡ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„ä¸»è¡¨è¾¾å¼</p>
<pre><code>
primary           â€”â€”&gt; &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
                  |   NUMBER | STRING
				  | &quot;(&quot; expression &quot;)&quot;
				  | IDENTIFIER;

</code></pre>
<p>That IDENTIFIER clause matches a single identifier token, which is understood to be the name of the variable being accessed.</p>
<p>IDENTIFIER å­å¥ï¼ŒåŒ¹é…å•ä¸ªæ ‡è¯†ç¬¦tokenï¼Œè¯¥tokenå¯ä»¥è¢«ç†è§£ä¸ºæ­£åœ¨è®¿é—®çš„å˜é‡çš„åç§°ã€‚</p>
<p>These new grammar rules get their corresponding syntax trees. Over in the AST generator, we add a new statement node for a variable declaration.</p>
<p>è¿™äº›æ–°çš„è¯­æ³•è§„åˆ™ï¼Œå¾—åˆ°äº†ç›¸åº”çš„è¯­æ³•æ ‘ã€‚åœ¨ASTç”Ÿæˆå™¨ä¸­ï¼Œæˆ‘ä»¬ä¸ºå˜é‡å£°æ˜æ·»åŠ äº†ä¸€ä¸ªæ–°çš„è¯­å¥èŠ‚ç‚¹</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main(), add â€œ,â€ to previous line

   &quot;Expression : Expr expression&quot;,
      &quot;Print      : Expr expression&quot;,
      &quot;Var        : Token name, Expr initializer&quot;
    ));
	
</code></pre>
<p>It stores the name token so we know what itâ€™s declaring, along with the initializer expression. (If there isnâ€™t an initializer, that field is null.)</p>
<p>Varå˜é‡ä¸­ä¿å­˜åç§°tokenï¼Œä»¥ä¾¿æˆ‘ä»¬çŸ¥é“å®ƒåœ¨å£°æ˜ä»€ä¹ˆï¼Œä»¥åŠåˆå§‹å€¼è®¾å®šé¡¹è¡¨è¾¾å¼ï¼ˆå¦‚æœæ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼Œåˆ™è¯¥å­—æ®µä¸ºç©ºï¼‰</p>
<p>Then we add an expression node for accessing a variable.</p>
<p>ç„¶åï¼Œæˆ‘ä»¬è¿˜è¦åˆ›å»ºä¸€ä¸ªç”¨äºè®¿é—®å˜é‡çš„è¡¨è¾¾å¼èŠ‚ç‚¹</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main(), add â€œ,â€ to previous line

     &quot;Literal  : Object value&quot;,
      &quot;Unary    : Token operator, Expr right&quot;,
      &quot;Variable : Token name&quot;
    ));
	
</code></pre>
<p>Itâ€™s simply a wrapper around the token for the variable name. Thatâ€™s it. As always, donâ€™t forget to run the AST generator script so that you get updated â€œExpr.javaâ€ and â€œStmt.javaâ€ files.</p>
<p>å®ƒåªæ˜¯å˜é‡å tokençš„åŒ…è£…å™¨ï¼Œå°±æ˜¯è¿™æ ·ï¼Œä¸€å¦‚æ—¢å¾€ï¼Œä¸è¦å¿˜è®°è¿è¡ŒASTç”Ÿæˆå™¨è„šæœ¬ï¼Œä»¥ä¾¿è·å¾—æ›´æ–°çš„ &quot;Expr.java&quot; å’Œ &quot;Stmt.java&quot; æ–‡ä»¶</p>
<h3 id="22-è§£æå˜é‡"><a class="header" href="#22-è§£æå˜é‡">2.2 è§£æå˜é‡</a></h3>
<p>Before we parse variable statements, we need to shift around some code to make room for the new declaration rule in the grammar. The top level of a program is now a list of declarations, so the entrypoint method to the parser changes.</p>
<p>åœ¨è§£æè¯­å¥ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦è½¬æ¢ä¸€ä¸‹ä»£ç ï¼Œä¸ºè¯­æ³•ä¸­çš„æ–°å£°æ˜è§„åˆ™è…¾å‡ºç©ºé—´ï¼Œç¨‹åºçš„é¡¶éƒ¨æ˜¯å£°æ˜è¯­å¥ï¼Œå› æ­¤è§£æå™¨çš„å…¥å£ç‚¹å‘ç”Ÿäº†å˜åŒ–ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, in parse(), replace 1 line

  List&lt;Stmt&gt; parse() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();
    while (!isAtEnd()) {
      statements.add(declaration());
    }

    return statements; 
  }
  
</code></pre>
<p>That calls this new method:</p>
<p>å®ƒè°ƒç”¨äº†æ–°æ–¹æ³•ï¼Œ</p>
<pre><code class="language-java">
// lox/Parser.java, add after expression()

  private Stmt declaration() {
    try {
      if (match(VAR)) return varDeclaration();

      return statement();
    } catch (ParseError error) {
      synchronize();
      return null;
    }
  }
  
</code></pre>
<p>Hey, do you remember way back in that earlier chapter when we put the infrastructure in place to do error recovery? We are finally ready to hook that up.</p>
<p>This declaration() method is the method we call repeatedly when parsing a series of statements in a block or a script, so itâ€™s the right place to synchronize when the parser goes into panic mode. The whole body of this method is wrapped in a try block to catch the exception thrown when the parser begins error recovery. This gets it back to trying to parse the beginning of the next statement or declaration.</p>
<p>The real parsing happens inside the try block. First, it looks to see if weâ€™re at a variable declaration by looking for the leading var keyword. If not, it falls through to the existing statement() method that parses print and expression statements.</p>
<p>Remember how statement() tries to parse an expression statement if no other statement matches? And expression() reports a syntax error if it canâ€™t parse an expression at the current token? That chain of calls ensures we report an error if a valid declaration or statement isnâ€™t parsed.</p>
<p>å—¨ï¼Œä½ è¿˜è®°å¾—æˆ‘ä»¬åœ¨ä¸Šä¸€ç« ä¸­çš„æ‰§è¡Œé”™è¯¯æ¢å¤ä»£ç å—ï¼Ÿæˆ‘ä»¬ç»ˆäºå‡†å¤‡å¥½äº†</p>
<p>è¿™ä¸ª declaration() æ–¹æ³•æ˜¯æˆ‘ä»¬è§£æä»£ç å—æˆ–è€…è„šæœ¬ä¸­çš„ä¸€äº›åˆ—è¯­å¥æ—¶å€™ï¼Œä¼šåå¤è°ƒç”¨çš„æ–¹æ³•ï¼Œå› æ­¤ï¼Œå½“è§£æå™¨è¿›å…¥åˆ°ç´§æ€¥æ¨¡å¼åï¼Œå®ƒæ˜¯åŒæ­¥è¿›è¡Œçš„ä¸€ä¸ªä½ç½®ï¼Œè¿™ä¸ªæ–¹æ³•çš„æ•´ä¸ªä¸»ä½“è¢«åŒ…è£…åœ¨ä¸€ä¸ªtryå—ä¸­ï¼Œä»¥æ•è·è§£æå™¨å¼€å§‹é”™è¯¯æ¢å¤æ—¶å€™ï¼ŒæŠ›å‡ºçš„å¼‚å¸¸ã€‚è€Œè¿™æ ·ï¼Œæˆ‘ä»¬åˆå›åˆ°äº†å°è¯•è§£æä¸‹ä¸€ä¸ªè¯­å¥æˆ–è€…å£°æ˜çš„å¼€å¤´ã€‚</p>
<p>çœŸæ­£çš„è§£æå‘ç”Ÿåœ¨tryå†…ï¼Œé¦–å…ˆï¼Œå®ƒé€šè¿‡æŸ¥æ‰¾å‰å¯¼varå…³é”®å­—ï¼Œæ¥æŸ¥çœ‹æˆ‘ä»¬æ˜¯å¦åœ¨å˜é‡å£°æ˜ä¸­ã€‚å¦‚æœæ²¡æœ‰å‘ç° varï¼Œå°†ä¼šæ‰§è¡Œç°æœ‰çš„statement() æ–¹æ³•ï¼Œè§£æprintè¯­å¥å’Œè¡¨è¾¾å¼è¯­å¥ã€‚</p>
<p>è¿˜è®°å¾—ï¼Œå¦‚æœæ²¡æœ‰å…¶ä»–è¯­å¥åŒ¹é…ï¼Œstatement() æ–¹æ³•ï¼Œå¦‚ä½•å°è¯•è§£æè¡¨è¾¾å¼è¯­å¥å—ï¼Ÿå¦‚æœ expression() æ–¹æ³•æ— æ³•åœ¨å½“å‰çš„tokenå¤„ï¼Œè§£æè¡¨è¾¾å¼ï¼Œåˆ™ä¼šæŠ¥å‘Šè¯­æ³•é”™è¯¯ï¼Ÿå¦‚æœæœªè§£ææœ‰æ•ˆçš„å£°æ˜æˆ–è€…è¯­å¥ï¼Œè¯¥è°ƒç”¨é“¾å°†ä¿è¯æˆ‘ä»¬æŠ¥é”™é”™è¯¯ã€‚</p>
<p>When the parser matches a var token, it branches to:</p>
<p>å½“åŒ¹é…åˆ° Var tokenæ—¶å€™ï¼Œå°†ä¼šæ‰§è¡Œ</p>
<pre><code class="language-java">

// lox/Parser.java, add after printStatement()

  private Stmt varDeclaration() {
    Token name = consume(IDENTIFIER, &quot;Expect variable name.&quot;);

    Expr initializer = null;
    if (match(EQUAL)) {
      initializer = expression();
    }

    consume(SEMICOLON, &quot;Expect ';' after variable declaration.&quot;);
    return new Stmt.Var(name, initializer);
  }
  
</code></pre>
<p>As always, the recursive descent code follows the grammar rule. The parser has already matched the var token, so next it requires and consumes an identifier token for the variable name.</p>
<p>Then, if it sees an = token, it knows there is an initializer expression and parses it. Otherwise, it leaves the initializer null. Finally, it consumes the required semicolon at the end of the statement. All this gets wrapped in a Stmt.Var syntax tree node and weâ€™re groovy.</p>
<p>ä¸ä¹‹å‰ä¸€æ ·ï¼Œé€’å½’ä¸‹é™ä»£ç éµå¾ªè¯­æ³•è§„åˆ™ã€‚è§£æå™¨å·²ç»åŒ¹é…äº†varå…³é”®å­—ï¼Œå› æ­¤æ¥ä¸‹æ¥ï¼Œéœ€è¦å¹¶ä¸”ä¼šè·å– varåé¢çš„å˜é‡åã€‚</p>
<p>ç„¶åï¼Œå¦‚æœæ¥ä¸‹æ¥å¾—åˆ°ä¸€ä¸ª = tokenï¼Œæˆ‘ä»¬çŸ¥é“è¿™æ˜¯ä¸€ä¸ªåˆå§‹å€¼èµ‹å€¼è¡¨è¾¾å¼ï¼Œå¹¶ä¸”è§£æè¿™ä¸ªè¯­å¥ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬ä¼šå®šä¹‰åˆå§‹é¡¹ä¸ºnullï¼Œæœ€åï¼Œæˆ‘ä»¬åœ¨è¯­å¥çš„ç»“å°¾éœ€è¦åŒ…å« ; ã€‚æ‰€æœ‰è¿™äº›éƒ½è¢«å°è£…æˆä¸€ä¸ª Stmt.Var è¯­æ³•æ ‘ï¼Œæˆ‘ä»¬æ˜¯æœ‰è¶£çš„</p>
<p>Parsing a variable expression is even easier. In primary(), we look for an identifier token.</p>
<p>è§£æä¸€ä¸ªå˜é‡è¡¨è¾¾å¼æ›´åŠ å®¹æ˜“ã€‚åœ¨primary() æ–¹æ³•é‡Œé¢ï¼Œæˆ‘ä»¬ä¼šæŸ¥çœ‹å•ä¸ªæ ‡è¯†ç¬¦</p>
<pre><code>
// lox/Parser.java, in primary()

     return new Expr.Literal(previous().literal);
    }

    if (match(IDENTIFIER)) {
      return new Expr.Variable(previous());
    }

    if (match(LEFT_PAREN)) {
	
</code></pre>
<p>That gives us a working front end for declaring and using variables. All thatâ€™s left is to feed it into the interpreter. Before we get to that, we need to talk about where variables live in memory.</p>
<p>è¿™ä¸ºæˆ‘ä»¬å£°æ˜å’Œä½¿ç”¨ä¸€ä¸ªå˜é‡æä¾›äº†ä¸€ä¸ªæœ‰æ•ˆçš„å‰ç«¯ï¼Œå‰©ä¸‹çš„å°±æ˜¯è®©å®ƒç»§ç»­è§£æã€‚åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦è®¨è®ºå˜é‡åœ¨å†…å­˜ä¸­çš„ä½ç½®</p>
<h2 id="ä¸‰environments"><a class="header" href="#ä¸‰environments">ä¸‰ã€Environments</a></h2>
<p>ç¯å¢ƒ</p>
<p>The bindings that associate variables to values need to be stored somewhere. Ever since the Lisp folks invented parentheses, this data structure has been called an environment.</p>
<p>å°†å˜é‡å’Œå€¼å…³è”çš„ç»‘å®šå…³ç³»ï¼Œéœ€è¦ä¿å­˜åœ¨æŸä¸ªä½ç½®ï¼Œè‡ªä»lispå‘æ˜äº†æ‹¬å·ï¼Œè¿™ç§æ•°æ®ç»“æ„ç§°ä¸ºç¯å¢ƒ</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/environment.png?raw=true" alt="environment" /></p>
<blockquote>
<p>I like to imagine the environment literally, as a sylvan wonderland where variables and values frolic.</p>
<p>æˆ‘å–œæ¬¢æŠŠç¯å¢ƒæƒ³è±¡æˆä¸€ä¸ªæ£®æ—ä»™å¢ƒï¼Œå˜é‡å’Œå˜é‡å€¼åœ¨å…¶ä¸­å¬‰æˆã€‚</p>
</blockquote>
<p>You can think of it like a map where the keys are variable names and the values are the variableâ€™s, uh, values. In fact, thatâ€™s how weâ€™ll implement it in Java. We could stuff that map and the code to manage it right into Interpreter, but since it forms a nicely delineated concept, weâ€™ll pull it out into its own class.</p>
<p>æˆ‘ä»¬å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªæ˜ å°„ï¼Œå…¶ä¸­keyæ˜¯å˜é‡åï¼Œvalueæ˜¯å˜é‡åå¯¹åº”çš„å€¼ã€‚äº‹å®ä¸Šï¼Œè¿™å°±æ˜¯æˆ‘ä»¬ç”¨Javaå®ç°çš„æ–¹å¼ã€‚æˆ‘ä»¬å¯ä»¥å°†è¯¥æ˜ å°„å’Œç®¡ç†å®ƒçš„ä»£ç ï¼Œå¡«å……åˆ°è§£é‡Šå™¨ä¸­ï¼Œä½†æ˜¯ï¼Œç”±äºå®ƒå½¢æˆäº†ä¸€ä¸ªå¾ˆå¥½çš„æ¦‚å¿µï¼Œæ‰€ä»¥æˆ‘ä»¬å°†æŠŠå®ƒæ”¾åˆ°è‡ªå·±çš„ç±»ä¸­ã€‚</p>
<blockquote>
<p>Java calls them maps or hashmaps. Other languages call them hash tables, dictionaries (Python and C#), hashes (Ruby and Perl), tables (Lua), or associative arrays (PHP). Way back when, they were known as scatter tables.</p>
<p>Javaä¸­ç§°ä¸º map æˆ–è€… hashmap, å…¶ä»–è¯­è¨€ç§°å®ƒæ˜¯ hash table, dictionaries(Python å’Œ C#ï¼‰ï¼Œhash(Ruby å’Œ Perl),table(Lua) , associative arrays(PHP), è€Œå¾ˆä¹…ä»¥å‰ï¼Œå®ƒè¢«ç§°ä¸º æ•£ç‚¹è¡¨</p>
</blockquote>
<p>Start a new file and add:</p>
<p>æ·»åŠ ä¸€ä¸ªæ–°çš„æ–‡ä»¶</p>
<pre><code class="language-java">
// lox/Environment.java, create new file

package com.craftinginterpreters.lox;

import java.util.HashMap;
import java.util.Map;

class Environment {
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
}

</code></pre>
<p>Thereâ€™s a Java Map in there to store the bindings. It uses bare strings for the keys, not tokens. A token represents a unit of code at a specific place in the source text, but when it comes to looking up variables, all identifier tokens with the same name should refer to the same variable (ignoring scope for now). Using the raw string ensures all of those tokens refer to the same map key.</p>
<p>æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªjava Mapæ¥å­˜å‚¨ç»‘å®šå…³ç³»ï¼Œå®ƒä½¿ç”¨å­—ç¬¦ä¸²å½“ä½œkeyï¼Œè€Œä¸æ˜¯token. tokenè¡¨ç¤ºæºæ–‡ä»¶ç‰¹å®šä½ç½®çš„ä»£ç å•å…ƒï¼Œä½†æ˜¯åœ¨æŸ¥æ‰¾å˜é‡æ—¶å€™ï¼Œæ‰€æœ‰å…·æœ‰å½¢åŒåç§°çš„æ ‡è¯†ç¬¦tokenï¼Œéƒ½å·²ç»å¼•ç”¨ç›¸åŒçš„å˜é‡ï¼ˆæš‚æ—¶å¿½ç•¥èŒƒå›´ï¼‰. ä½¿ç”¨åŸå§‹å­—ç¬¦ä¸²ï¼Œå¯ä»¥ä¿è¯è¿™äº›tokenéƒ½å¯¹åº”ç€åŒä¸€ä¸ªmap key.</p>
<p>There are two operations we need to support. First, a variable definition binds a new name to a value.</p>
<p>æˆ‘ä»¬è¿˜éœ€è¦æ”¯æŒä¸¤ç§æ“ä½œï¼Œé¦–å…ˆï¼Œå˜é‡å®šä¹‰å°†æ–°åç§°ç»‘å®šåˆ°ä¸€ä¸ªå…·ä½“çš„å€¼</p>
<pre><code>
lox/Environment.java, in class Environment

  void define(String name, Object value) {
    values.put(name, value);
  }
  
</code></pre>
<p>Not exactly brain surgery, but we have made one interesting semantic choice. When we add the key to the map, we donâ€™t check to see if itâ€™s already present. That means that this program works:</p>
<p>ä¸æ˜¯ä¸€ä¸ªè„‘éƒ¨æ‰‹æœ¯ï¼Œä½†æ˜¯æˆ‘ä»¬åšäº†ä¸€ä¸ªæœ‰è¶£çš„è¯­ä¹‰é€‰æ‹©ã€‚å½“æˆ‘ä»¬å°†keyæ·»åŠ åˆ°mapä¸­åï¼Œæˆ‘ä»¬ä¸ä¼šæ£€æŸ¥å®ƒæ˜¯å¦å·²ç»å­˜åœ¨ï¼Œè¿™æ„å‘³ç€ï¼Œè¿™ä¸ªç¨‹åºå¯ä»¥æ˜¯ </p>
<pre><code class="language-java">
var a = &quot;before&quot;;
print a; // &quot;before&quot;.
var a = &quot;after&quot;;
print a; // &quot;after&quot;.

</code></pre>
<p>A variable statement doesnâ€™t just define a new variable, it can also be used to redefine an existing variable. We could choose to make this an error instead. The user may not intend to redefine an existing variable. (If they did mean to, they probably would have used assignment, not var.) Making redefinition an error would help them find that bug.</p>
<p>However, doing so interacts poorly with the REPL.  In the middle of a REPL session, itâ€™s nice to not have to mentally track which variables youâ€™ve already defined. We could allow redefinition in the REPL but not in scripts, but then users would have to learn two sets of rules, and code copied and pasted from one form to the other might not work.</p>
<p>å˜é‡è¯­å¥ä¸ä»…ä»…å®šä¹‰ä¸€ä¸ªæ–°å˜é‡ï¼Œå®ƒè¿˜å¯ä»¥ç”¨äºé‡æ–°å®šä¹‰ä¸€ä¸ªç°æœ‰å˜é‡ã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹©å°†å…¶è®¾ç½®ä¸ºé”™è¯¯ï¼Œç”¨æˆ·å¯èƒ½ä¸æ‰“ç®—é‡æ–°å®šä¹‰ç°æœ‰å˜é‡ï¼Œï¼ˆå¦‚æœç”¨æˆ·çœŸçš„æƒ³è¦è¿™æ ·åšï¼Œå¯èƒ½ä¼šä½¿ç”¨èµ‹å€¼ï¼Œè€Œä¸æ˜¯å˜é‡ï¼‰ï¼Œé‡æ–°å®šä¹‰é”™è¯¯ï¼Œå°†å¸®åŠ©ç”¨æˆ·æ‰¾åˆ°é”™è¯¯ã€‚</p>
<p>ç„¶è€Œï¼Œè¿™æ ·åšå°†ä¼šä½¿å¾— REPL çš„äº¤äº’å¾ˆå·®ï¼Œåœ¨ä¸€ä¸ªREPLçš„ä¼šè¯ä¸­ï¼Œæœ€å¥½ä¸è¦è·Ÿè¸ªå·²ç»å®šä¹‰çš„å˜é‡ã€‚æˆ‘ä»¬å¯ä»¥å…è®¸åœ¨ REPLä¸­é‡æ–°å®šä¹‰ï¼Œä½†æ˜¯ä¸å…è®¸åœ¨è„šæœ¬ä¸­é‡æ–°å®šä¹‰ã€‚ä½†æ˜¯ï¼Œç”¨æˆ·å¿…é¡»å­¦ä¹ ä¸¤ç»„è§„åˆ™ï¼Œä»£ç ä»ä¸€ä¸ªåœ°æ–¹å¤åˆ¶åˆ°å…¶ä»–åœ°æ–¹ï¼Œå¯èƒ½ä¸èµ·ä½œç”¨ã€‚</p>
<blockquote>
<p>My rule about variables and scoping is, â€œWhen in doubt, do what Scheme doesâ€. The Scheme folks have probably spent more time thinking about variable scope than we ever willâ€”one of the main goals of Scheme was to introduce lexical scoping to the worldâ€”so itâ€™s hard to go wrong if you follow in their footsteps.</p>
<p>Scheme allows redefining variables at the top level.</p>
<p>æˆ‘å…³äºå˜é‡å’Œä½œç”¨èŒƒå›´çš„è§„åˆ™æ˜¯ï¼Œå½“æœ‰ç–‘é—®æ—¶å€™ï¼ŒåšSchemeåšçš„äº‹ã€‚Schemeå¯èƒ½èŠ±è´¹äº†æ›´å¤šçš„æ—¶é—´æ¥æ€è€ƒå˜é‡èŒƒå›´ï¼ŒSchemeçš„ä¸»è¦ç›®æ ‡æ˜¯å‘å…¨ä¸–ç•Œä»‹ç»è¯æ±‡èŒƒå›´ï¼Œæ‰€ä»¥å¦‚æœä½ è¿½éšä»–ä»¬çš„è„šæ­¥ï¼Œå°†å¾ˆéš¾å‡ºé”™</p>
<p>Schemeå…è®¸åœ¨é¡¶å±‚é‡æ–°å®šä¹‰å˜é‡</p>
</blockquote>
<p>So, to keep the two modes consistent, weâ€™ll allow itâ€”at least for global variables. Once a variable exists, we need a way to look it up.</p>
<p>æ‰€ä»¥ï¼Œä¸ºäº†ä¿æŒä¸¤ç§æ¨¡å¼çš„ä¸€è‡´æ€§ï¼Œæˆ‘ä»¬è‡³å°‘å…è®¸å…¨å±€å˜é‡ä½¿ç”¨è¿™ç§æ¨¡å¼ï¼Œä¸€æ—¦å˜é‡å·²ç»å­˜åœ¨ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¸€ç§æ–¹æ³•æ¥æŸ¥æ‰¾å®ƒã€‚</p>
<pre><code class="language-java">
// lox/Environment.java, in class Environment

class Environment {
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();

  Object get(Token name) {
    if (values.containsKey(name.lexeme)) {
      return values.get(name.lexeme);
    }

    throw new RuntimeError(name,
        &quot;Undefined variable '&quot; + name.lexeme + &quot;'.&quot;);
  }

  void define(String name, Object value) {
  
</code></pre>
<p>This is a little more semantically interesting. If the variable is found, it simply returns the value bound to it. But what if itâ€™s not? Again, we have a choice:</p>
<ul>
<li>
<p>Make it a syntax error.</p>
</li>
<li>
<p>Make it a runtime error.</p>
</li>
<li>
<p>Allow it and return some default value like nil.</p>
</li>
</ul>
<p>è¿™åœ¨è¯­ä¹‰ä¸Šæ›´æœ‰æ„æ€ï¼Œå¦‚æœæ‰¾åˆ°äº†å˜é‡ï¼Œæˆ‘ä»¬åªä¼šè¿”å›å˜é‡ç»‘å®šçš„å€¼ï¼Œå¦‚æœæ‰¾ä¸åˆ°å˜é‡ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•é€‰æ‹©å‘¢ï¼Ÿ</p>
<ul>
<li>
<p>åˆ¤æ–­ä¸ºè¯­æ³•é”™è¯¯</p>
</li>
<li>
<p>è§¦å‘è¿è¡Œæ—¶é”™è¯¯</p>
</li>
<li>
<p>å…è®¸è¿™ç§åœºæ™¯ï¼Œå¹¶ä¸”è¿”å›ä¸€äº›é»˜è®¤åˆå§‹å€¼ï¼Œä¾‹å¦‚: nil</p>
</li>
</ul>
<p>Lox is pretty lax, but the last option is a little too permissive to me. Making it a syntax errorâ€”a compile-time errorâ€”seems like a smart choice. Using an undefined variable is a bug, and the sooner you detect the mistake, the better.</p>
<p>The problem is that using a variable isnâ€™t the same as referring to it. You can refer to a variable in a chunk of code without immediately evaluating it if that chunk of code is wrapped inside a function. If we make it a static error to mention a variable before itâ€™s been declared, it becomes much harder to define recursive functions.</p>
<p>Loxè¯­è¨€éå¸¸å®½æ¾ï¼Œä½†æ˜¯æœ€åä¸€ä¸ªé€‰é¡¹ï¼Œå¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œè¿‡äºå®½æ¾äº†ï¼Œå°†å…¶ä½œä¸ºä¸€ä¸ªè¯­æ³•é”™è¯¯ï¼ˆç¼–è¯‘æ—¶é”™è¯¯ï¼‰çœ‹èµ·æ¥æ˜¯ä¸€ä¸ªæ˜æ™ºçš„é€‰æ‹©ï¼Œä½¿ç”¨æœªå®šä¹‰çš„å˜é‡æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œè¶Šæ—©å‘ç°è¶Šå¥½ã€‚</p>
<p>é—®é¢˜æ˜¯ï¼Œä½¿ç”¨å˜é‡å’Œå¼•ç”¨å˜é‡ä¸åŒï¼Œå¦‚æœä»£ç å—å°è£…åœ¨å‡½æ•°ä¸­ï¼Œåˆ™å¯ä»¥å¼•ç”¨ä»£ç å—ä¸­çš„å˜é‡ï¼Œè€Œæ— éœ€ç«‹å³å¯¹å…¶æ±‚å€¼ï¼›å¦‚æœæˆ‘ä»¬åœ¨å£°æ˜å˜é‡ä¹‹å‰ä½¿ç”¨å®ƒï¼Œæ˜¯ä¸€ä¸ªé™æ€é”™è¯¯ï¼Œé‚£ä¹ˆå®šä¹‰é€’å½’å‡½æ•°ï¼Œå°±ä¼šå˜å¾—æ›´åŠ å›°éš¾ã€‚</p>
<p>We could accommodate single recursionâ€”a function that calls itselfâ€”by declaring the functionâ€™s own name before we examine its body. But that doesnâ€™t help with mutually recursive procedures that call each other. Consider:</p>
<p>æˆ‘ä»¬å¯ä»¥å®¹çº³å•ä¸ªé€’å½’ï¼Œå³åœ¨æ£€æŸ¥å‡½æ•°ä½“ä¹‹å‰ï¼Œå£°æ˜å‡½æ•°è‡ªèº«çš„åç§°ï¼Œæ¥è°ƒç”¨è‡ªèº«çš„å‡½æ•°ï¼Œä½†è¿™å¯¹ç›¸äº’è°ƒç”¨çš„é€’å½’è¿‡ç¨‹æ²¡æœ‰å¸®åŠ©ï¼Œä¾‹å¦‚:</p>
<pre><code class="language-java">
fun isOdd(n) {
  if (n == 0) return false;
  return isEven(n - 1);
}

fun isEven(n) {
  if (n == 0) return true;
  return isOdd(n - 1);
}


</code></pre>
<p>The isEven() function isnâ€™t defined by the time we are looking at the body of isOdd() where itâ€™s called. If we swap the order of the two functions, then isOdd() isnâ€™t defined when weâ€™re looking at isEven()â€™s body.</p>
<p>isEven() å‡½æ•°åœ¨isOdd() è¿è¡Œåˆ°å¯¹åº”ä»£ç æ—¶å€™ï¼Œè¿˜æ²¡å®šä¹‰ï¼Œå¦‚æœæˆ‘ä»¬äº¤æ¢è¿™ä¸¤ä¸ªå‡½æ•°çš„ä½ç½®ï¼Œé‚£ä¹ˆï¼Œå½“æˆ‘ä»¬è¿è¡Œ isEven() å‡½æ•°åˆ°isOdd() å‡½æ•°æ—¶å€™ï¼ŒisOdd() å‡½æ•°åŒæ ·æ²¡æœ‰å®šä¹‰ã€‚</p>
<blockquote>
<p>Granted, this is probably not the most efficient way to tell if a number is even or odd (not to mention the bad things that happen if you pass a non-integer or negative number to them). Bear with me.</p>
<p>å½“ç„¶ï¼Œä¸Šé¢çš„æ–¹æ³•ä¸æ˜¯åˆ¤æ–­ä¸€ä¸ªæ•°å­—å¥‡å¶æ€§çš„æœ€æœ‰æ•ˆçš„æ–¹æ³•ï¼Œï¼ˆæ›´ä¸ç”¨è¯´ï¼Œå¦‚æœæˆ‘ä»¬ä¼ é€’ä¸€ä¸ªéæ•´æ•°æˆ–è€…è´Ÿæ•°ä¼šå‘ç”Ÿä»€ä¹ˆï¼‰ï¼Œå…ˆå¿å—è¿™ä¸ªä»£ç å§</p>
<p>Some statically typed languages like Java and C# solve this by specifying that the top level of a program isnâ€™t a sequence of imperative statements. Instead, a program is a set of declarations which all come into being simultaneously. The implementation declares all of the names before looking at the bodies of any of the functions.</p>
<p>ä¸€äº›é™æ€è¯­è¨€ï¼ˆä¾‹å¦‚: Java, C#) ,é€šè¿‡æŒ‡å®šç¨‹åºçš„é¡¶å±‚ä¸æ˜¯å‘½ä»¤è¯­å¥åºåˆ—æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œç›¸åçš„ï¼Œé¡¶å±‚çš„ç¨‹åºæ˜¯ä¸€ç»„åŒæ—¶å‡ºç°çš„å£°æ˜ï¼Œåœ¨æŸ¥çœ‹ä»»ä½•å‡½æ•°ä¸»ä½“ä¹‹å‰ï¼Œå…ˆå£°æ˜æ‰€æœ‰å‡½æ•°åç§°ã€‚</p>
<p>Older languages like C and Pascal donâ€™t work like this. Instead, they force you to add explicit forward declarations to declare a name before itâ€™s fully defined. That was a concession to the limited computing power at the time. They wanted to be able to compile a source file in one single pass through the text, so those compilers couldnâ€™t gather up all of the declarations first before processing function bodies.</p>
<p>åƒæ˜¯ C/Pascal è¿™æ ·çš„è¯­è¨€æ— æ³•è¿™æ ·å·¥ä½œï¼Œç›¸åï¼Œå®ƒä¼šè¦æ±‚ä½¿ç”¨è€…ï¼Œæ·»åŠ æ˜¾å¼çš„å£°æ˜ï¼Œåœ¨å®Œå…¨å®šä¹‰ä¹‹å‰ã€‚è¿™æ˜¯å¯¹å½“æ—¶ï¼Œæœ‰é™çš„è®¡ç®—èƒ½åŠ›çš„å¦¥åã€‚å®ƒä»¬å¸Œæœ›èƒ½å¤Ÿåœ¨æ–‡æœ¬çš„ä¸€æ¬¡ä¼ é€’ä¸­ç¼–è¯‘ä¸€ä¸ªæºæ–‡ä»¶ï¼Œå› æ­¤è¿™äº›ç¼–è¯‘å™¨ï¼Œæ— æ³•åœ¨å¤„ç†å‡½æ•°ä½“ä¹‹å‰ï¼Œæ”¶é›†åˆ°æ‰€æœ‰å£°æ˜ã€‚</p>
</blockquote>
<p>Since making it a static error makes recursive declarations too difficult, weâ€™ll defer the error to runtime. Itâ€™s OK to refer to a variable before itâ€™s defined as long as you donâ€™t evaluate the reference. That lets the program for even and odd numbers work, but youâ€™d get a runtime error in:</p>
<p>ç”±äºå°†å…¶è®¾ç½®ä¸ºé™æ€è¯­æ³•é”™è¯¯ï¼Œä¼šä½¿å¾—é€’å½’å‡½æ•°çš„å®šä¹‰éå¸¸å›°éš¾ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†é”™è¯¯å»¶è¿Ÿåˆ°è¿è¡Œæ—¶ï¼Œåªè¦ä¸è®¡ç®—å¼•ç”¨ï¼Œåœ¨å®šä¹‰å˜é‡ä¹‹å‰ï¼Œå¼•ç”¨å˜é‡æ˜¯å…è®¸çš„ï¼Œè¿™ä½¿å¾—ä¸Šé¢çš„åˆ¤æ–­æ•°å­—å¥‡å¶æ€§æ–¹æ³•å¯ä»¥è¿è¡Œã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ï¼Œå¦‚æœ:</p>
<pre><code class="language-java">
print a;
var a = &quot;too late!&quot;;

</code></pre>
<p>As with type errors in the expression evaluation code, we report a runtime error by throwing an exception. The exception contains the variableâ€™s token so we can tell the user where in their code they messed up.</p>
<p>ä¸è¡¨è¾¾å¼æ±‚å€¼ä»£ç ä¸­çš„ç±»å‹é”™è¯¯ä¸€æ ·ï¼Œæˆ‘ä»¬é€šè¿‡æŠ›å‡ºå¼‚å¸¸æ¥æŠ¥å‘Šè¿è¡Œé”™è¯¯ï¼Œå¼‚å¸¸åŒ…å«äº†å˜é‡çš„tokenï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å‘Šè¯‰ç”¨æˆ·ä»–ä»¬åœ¨ä»£ç å“ªé‡Œå‡ºé”™äº†</p>
<h3 id="31-interpreting-global-variables"><a class="header" href="#31-interpreting-global-variables">3.1 Interpreting global variables</a></h3>
<p>è§£é‡Šå…¨å±€å˜é‡</p>
<p>The Interpreter class gets an instance of the new Environment class.</p>
<p>è§£é‡Šå™¨ç±»å‹ï¼Œè·å–ä¸€ä¸ªæ–°çš„Envç±»å®ä¾‹</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
  private Environment environment = new Environment();

  void interpret(List&lt;Stmt&gt; statements) {


</code></pre>
<p>We store it as a field directly in Interpreter so that the variables stay in memory as long as the interpreter is still running.</p>
<p>æˆ‘ä»¬åœ¨è§£æå™¨ä¸­ï¼ŒæŠŠè¿™ä¸ªå®ä¾‹ä½œä¸ºå­—æ®µï¼Œç›´æ¥å­˜å‚¨èµ·æ¥ï¼Œè¿™æ ·ï¼Œåªè¦è§£é‡Šå™¨ä»ç„¶åœ¨è¿è¡Œï¼Œå˜é‡å°±å¯ä»¥ç•™åœ¨å†…å­˜ä¸­ã€‚</p>
<p>We have two new syntax trees, so thatâ€™s two new visit methods. The first is for declaration statements.</p>
<p>æˆ‘ä»¬æœ‰ä¸¤ä¸ªæ–°çš„è¯­æ³•æ ‘ï¼Œè¿™ä¸¤ä¸ªæ–°çš„è®¿é—®æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªæ˜¯å£°æ˜è¯­å¥ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitPrintStmt()

  @Override
  public Void visitVarStmt(Stmt.Var stmt) {
    Object value = null;
    if (stmt.initializer != null) {
      value = evaluate(stmt.initializer);
    }

    environment.define(stmt.name.lexeme, value);
    return null;
  }

</code></pre>
<p>If the variable has an initializer, we evaluate it. If not, we have another choice to make. We could have made this a syntax error in the parser by requiring an initializer. Most languages donâ€™t, though, so it feels a little harsh to do so in Lox.</p>
<p>We could make it a runtime error. Weâ€™d let you define an uninitialized variable, but if you accessed it before assigning to it, a runtime error would occur. Itâ€™s not a bad idea, but most dynamically typed languages donâ€™t do that. Instead, weâ€™ll keep it simple and say that Lox sets a variable to nil if it isnâ€™t explicitly initialized.</p>
<p>å¦‚æœå˜é‡æœ‰ä¸€ä¸ªåˆå§‹å€¼ï¼Œæˆ‘ä»¬å°±å¯¹å…¶æ±‚å€¼ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹å€¼ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªé€‰æ‹©ï¼Œå¯èƒ½éœ€è¦ä¸€ä¸ªåˆå§‹å€¼è®¾å®šé¡¹ï¼Œä»è€Œä½¿è¿™æˆä¸ºè§£é‡Šå™¨ä¸­çš„è¯­æ³•é”™è¯¯ï¼Œç„¶è€Œï¼Œå¤§å¤šæ•°è¯­è¨€éƒ½ä¸è¿™æ ·åšï¼Œæ‰€ä»¥ï¼ŒLoxè¿™æ ·åšï¼Œæœ‰äº›è‹›åˆ»ã€‚</p>
<p>æˆ‘ä»¬å¯èƒ½ä¼šè®©å®ƒå˜ä¸ºè¿è¡Œæ—¶é”™è¯¯ï¼Œæˆ‘ä»¬å…è®¸ç”¨æˆ·å®šä¹‰ä¸€ä¸ªæœªåˆå§‹åŒ–çš„å˜é‡ï¼Œä½†æ˜¯ï¼Œå¦‚æœä»£ç åœ¨åˆ†é…å€¼ä¹‹å‰ï¼Œè®¿é—®äº†è¯¥å˜é‡ï¼Œåˆ™ä¼šæŠ¥é”™ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªåä¸»æ„ï¼Œä½†æ˜¯å¤§å¤šæ•°çš„åŠ¨æ€ç±»å‹è¯­è¨€ä¸ä¼šè¿™æ ·åšï¼Œç›¸åï¼Œæˆ‘ä»¬å°†ä¿æŒç®€å•ã€‚å¦‚æœæ²¡æœ‰æ˜¾å¼åˆå§‹åŒ–ï¼Œåˆ™Loxå°†å˜é‡è®¾ç½®ä¸ºnil</p>
<pre><code class="language-java">
var a;
print a; // &quot;nil&quot;.

</code></pre>
<p>Thus, if there isnâ€™t an initializer, we set the value to null, which is the Java representation of Loxâ€™s nil value. Then we tell the environment to bind the variable to that value.</p>
<p>å› æ­¤ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼Œæˆ‘ä»¬å°†å€¼è®¾ç½®ä¸ºnullï¼Œè¿™æ˜¯Loxè¯­è¨€ä¸­çš„nilçš„Javaè¡¨ç¤ºï¼Œç„¶åï¼Œæˆ‘ä»¬å°†Envå®ä¾‹ä¸­ï¼Œå¯¹åº”å˜é‡çš„å€¼è®¾ç½®ä¸ºnil</p>
<p>Next, we evaluate a variable expression.</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è®¡ç®—ä¸€ä¸ªå˜é‡è¡¨è¾¾å¼</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitUnaryExpr()

  @Override
  public Object visitVariableExpr(Expr.Variable expr) {
    return environment.get(expr.name);
  }
  
</code></pre>
<p>This simply forwards to the environment which does the heavy lifting to make sure the variable is defined. With that, weâ€™ve got rudimentary variables working. Try this out:</p>
<p>è¿™åªæ˜¯ç®€å•çš„è½¬å‘åˆ°Envï¼Œenvè¿›è¡Œè®¡ç®—ï¼Œç¡®ä¿å®šä¹‰äº†å˜é‡ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å°±æœ‰äº†åŸºæœ¬çš„å˜é‡ï¼Œ</p>
<pre><code class="language-java">
var a = 1;
var b = 2;
print a + b;

</code></pre>
<p>We canâ€™t reuse code yet, but we can start to build up programs that reuse data.</p>
<p>æˆ‘ä»¬è¿˜ä¸èƒ½å¤ç”¨ä»£ç ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹æ„å»ºå¤ç”¨æ•°æ®çš„ç¨‹åºã€‚</p>
<h2 id="å››assignment"><a class="header" href="#å››assignment">å››ã€Assignment</a></h2>
<p>èµ‹å€¼</p>
<p>Itâ€™s possible to create a language that has variables but does not let you reassignâ€”or mutateâ€”them. Haskell is one example. SML supports only mutable references and arraysâ€”variables cannot be reassigned. Rust steers you away from mutation by requiring a mut modifier to enable assignment.</p>
<p>Mutating a variable is a side effect and, as the name suggests, some language folks think side effects are dirty or inelegant. Code should be pure math that produces valuesâ€”crystalline, unchanging onesâ€”like an act of divine creation. Not some grubby automaton that beats blobs of data into shape, one imperative grunt at a time.</p>
<p>å¯ä»¥åˆ›å»ºä¸€ç§è¯­è¨€ï¼Œå…·æœ‰å˜é‡ï¼Œä½†æ˜¯ä¸å…è®¸é‡æ–°èµ‹å€¼ï¼Œæˆ–è€…ä¿®æ”¹å˜é‡å€¼ï¼ŒHaskellå°±æ˜¯è¿™æ ·çš„ä¸€é—¨è¯­è¨€ã€‚SMLä»…æ”¯æŒå¯å˜å¼•ç”¨ï¼Œå¹¶ä¸”ä¸èƒ½é‡æ–°èµ‹å€¼æ•°ç»„å˜é‡ã€‚Rusté€šè¿‡ mutä¿®æ”¹å™¨ï¼Œé‡æ–°èµ‹å€¼ï¼Œå¼•å¯¼æˆ‘ä»¬è¿œç¦»çªå˜ã€‚</p>
<p>ä¸€ä¸ªå˜é‡çš„çªå˜æ˜¯ä¸€ä¸ªå‰¯ä½œç”¨ï¼Œæ­£å¦‚åå­—æ‰€æš—ç¤ºçš„ï¼Œä¸€äº›è¯­è¨€å­¦å®¶è®¤ä¸ºå‰¯ä½œç”¨æ˜¯ä¸å¥½çš„ï¼Œä»£ç åº”è¯¥æ˜¯çº¯ç²¹çš„æ•°å­¦ï¼Œå®ƒå¯ä»¥äº§ç”Ÿç»“æ™¶çš„ã€ä¸å˜çš„ä»·å€¼è§‚ï¼Œå°±åƒæ˜¯ç¥åˆ›é€ çš„è¡Œä¸ºä¸€æ ·ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªè‚®è„çš„æœºå™¨äººï¼Œä¸€æ¬¡åªèƒ½å‘å‡ºä¸€å£°å‘½ä»¤æ€§çš„å’•å™œå£°éŸ³ï¼ŒæŠŠä¸€å †å †æ•°æ®æ‰“æˆå½¢çŠ¶ã€‚</p>
<blockquote>
<p>I find it delightful that the same group of people who pride themselves on dispassionate logic are also the ones who canâ€™t resist emotionally loaded terms for their work: â€œpureâ€, â€œside effectâ€, â€œlazyâ€, â€œpersistentâ€, â€œfirst-classâ€, â€œhigher-orderâ€.</p>
<p>æˆ‘è§‰å¾—ä»¤äººå…´å¥‹çš„æ˜¯ï¼ŒåŒæ ·ä¸€ç¾¤ä»¥å†·é™çš„é€»è¾‘ä¸ºè£çš„äººï¼Œä¹Ÿæ— æ³•æŠ—æ‹’ä»–ä»¬å·¥ä½œä¸­å……æ»¡æƒ…æ„Ÿçš„æœ¯è¯­ï¼Œçº¯ç²¹ã€å‰¯ä½œç”¨ã€æ‡’æƒ°ã€æ‰§ç€ã€ä¸€æµã€é«˜é˜¶ã€‚</p>
</blockquote>
<p>Lox is not so austere. Lox is an imperative language, and mutation comes with the territory. Adding support for assignment doesnâ€™t require much work. Global variables already support redefinition, so most of the machinery is there now. Mainly, weâ€™re missing an explicit assignment notation.</p>
<p>Loxå¹¶æ²¡æœ‰é‚£ä¹ˆä¸¥è‚ƒï¼ŒLoxæ˜¯ä¸€ç§å‘½ä»¤å¼è¯­è¨€ï¼Œå¯å˜æ€§ä¼´éšç€ä½œç”¨åŸŸè€Œæ¥ï¼ŒLoxæ”¯æŒèµ‹å€¼ä¸éœ€è¦åšå¾ˆå¤šçš„å·¥ä½œã€‚å…¨å±€å˜é‡å·²ç»æ”¯æŒé‡æ–°å®šä¹‰ï¼Œæ‰€ä»¥ç°åœ¨å¤§å¤šæ•°çš„æœºåˆ¶å·²ç»å­˜åœ¨ï¼Œä¸»è¦é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬ç°åœ¨ç¼ºå°‘ä¸€ä¸ªæ˜ç¡®çš„èµ‹å€¼ç¬¦å·ã€‚</p>
<h3 id="41-assignment-syntax"><a class="header" href="#41-assignment-syntax">4.1 Assignment syntax</a></h3>
<p>èµ‹å€¼è¯­æ³•</p>
<p>That little = syntax is more complex than it might seem. Like most C-derived languages, assignment is an expression and not a statement. As in C, it is the lowest precedence expression form. That means the rule slots between expression and equality (the next lowest precedence expression).</p>
<p>= ç¬¦å·çš„è¯­æ³•æ¯”çœ‹èµ·æ¥æ›´åŠ å¤æ‚ï¼Œä¸å¤§å¤šæ•°çš„Cæ´¾ç”Ÿè¯­è¨€ä¸€æ ·ï¼Œèµ‹å€¼æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼è€Œä¸æ˜¯ä¸€ä¸ªè¯­å¥ï¼Œå’ŒCä¸­ä¸€æ ·ï¼Œå®ƒæ˜¯æœ€ä½ä¼˜å…ˆçº§çš„è¡¨è¾¾å¼å½¢å¼ï¼Œè¿™æ„å‘³ç€è§„åˆ™ä»‹äºè¡¨è¾¾å¼å’Œç›¸ç­‰ä¹‹é—´ã€‚</p>
<blockquote>
<p>In some other languages, like Pascal, Python, and Go, assignment is a statement.</p>
<p>åœ¨ä¸€äº›å…¶ä»–è¯­è¨€ä¸­ï¼Œåƒæ˜¯ Pascal, Python, Go, èµ‹å€¼æ˜¯ä¸€ä¸ªè¯­å¥</p>
</blockquote>
<pre><code class="language-java">
expression     â†’ assignment ;
assignment     â†’ IDENTIFIER &quot;=&quot; assignment
               | equality ;

</code></pre>
<p>This says an assignment is either an identifier followed by an = and an expression for the value, or an equality (and thus any other) expression. Later, assignment will get more complex when we add property setters on objects, like:</p>
<p>ä¸Šé¢çš„è¯­æ³•è§„åˆ™æ„å‘³ç€ï¼Œèµ‹å€¼è¡¨è¾¾å¼æ˜¯ ä¸€ä¸ªæ ‡è¯†ç¬¦è·Ÿéšè€…ä¸€ä¸ª= ç¬¦å· å’Œä¸€ä¸ªå€¼è¡¨è¾¾å¼ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªç­‰å¼è¡¨è¾¾å¼ï¼Œç¨åï¼Œæˆ‘ä»¬åœ¨å¯¹è±¡ä¸Šï¼Œæ·»åŠ å±æ€§è®¾ç½®ï¼Œèµ‹å€¼å°†å˜å¾—æ›´åŠ å¤æ‚ï¼Œä¾‹å¦‚ï¼š</p>
<pre><code class="language-java">
instance.field = &quot;value&quot;;

</code></pre>
<p>The easy part is adding the new syntax tree node.</p>
<p>æœ€ç®€å•çš„æ–¹å¼æ˜¯ï¼Œæ·»åŠ æ–°çš„è¯­æ³•æ ‘èŠ‚ç‚¹ã€‚</p>
<pre><code>
// tool/GenerateAst.java, in main()

 defineAst(outputDir, &quot;Expr&quot;, Arrays.asList(
      &quot;Assign   : Token name, Expr value&quot;,
      &quot;Binary   : Expr left, Token operator, Expr right&quot;,
	  
</code></pre>
<p>It has a token for the variable being assigned to, and an expression for the new value. After you run the AstGenerator to get the new Expr.Assign class, swap out the body of the parserâ€™s existing expression() method to match the updated rule.</p>
<p>å®ƒæœ‰ä¸€ä¸ªè¢«èµ‹å€¼å˜é‡çš„tokenï¼Œå’Œä¸€ä¸ªæ–°å€¼çš„è¡¨è¾¾å¼ï¼Œåœ¨æˆ‘ä»¬è¿è¡ŒAstGeneratoråï¼Œå°†ä¼šå¾—åˆ°ä¸€ä¸ªæ–°çš„Expr.Assign ç±»ï¼Œäº¤æ¢è§£æå™¨ç°æœ‰expression() æ–¹æ³•ï¼ŒåŒ¹é…æ›´æ–°åçš„è§„åˆ™ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, in expression(), replace 1 line

 private Expr expression() {
    return assignment();
  }


</code></pre>
<p>Here is where it gets tricky. A single token lookahead recursive descent parser canâ€™t see far enough to tell that itâ€™s parsing an assignment until after it has gone through the left-hand side and stumbled onto the =. You might wonder why it even needs to. After all, we donâ€™t know weâ€™re parsing a + expression until after weâ€™ve finished parsing the left operand.</p>
<p>The difference is that the left-hand side of an assignment isnâ€™t an expression that evaluates to a value. Itâ€™s a sort of pseudo-expression that evaluates to a â€œthingâ€ you can assign to. Consider:</p>
<p>è¿™å°±æ˜¯æ£˜æ‰‹çš„åœ°æ–¹ï¼Œä¸€ä¸ªå•ä¸€çš„tokenï¼Œå‰ç»é€’å½’ä¸‹é™è§£æå™¨çœ‹ä¸åˆ°è¶³å¤Ÿè¿œçš„åœ°æ–¹ï¼Œç›´åˆ°å®ƒé€šè¿‡å·¦ä¾§å¹¶ä¸”å¶ç„¶å‘ç°= ç¬¦å·ä¹‹åï¼Œæ‰èƒ½åˆ¤æ–­å‡ºå®ƒæ­£åœ¨è§£æèµ‹å€¼ã€‚ä½ å¯èƒ½æƒ³çŸ¥é“å®ƒä¸ºä»€ä¹ˆéœ€è¦è¿™æ ·åšã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬åœ¨åˆ†æè¿‡å·¦æ“ä½œæ•°åï¼Œæ‰èƒ½çŸ¥é“æˆ‘ä»¬æ­£åœ¨è§£æä¸€ä¸ª+ è¡¨è¾¾å¼</p>
<p>ä¸åŒä¹‹å¤„æ˜¯ï¼Œèµ‹å€¼è¡¨è¾¾å¼çš„å·¦ä¾§ï¼Œä¸æ˜¯è®¡ç®—ä¸ºå€¼çš„è¡¨è¾¾å¼ï¼Œè¿™æ˜¯ä¸€ç§ä¼ªè¡¨è¾¾å¼ï¼Œå…¶è®¡ç®—ç»“æœå¯ä»¥æ˜¯èµ‹å€¼è¡¨è¾¾å¼çš„èµ‹å€¼å¯¹è±¡ï¼Œè¯·è€ƒè™‘ï¼š</p>
<pre><code class="language-java">

var a = &quot;before&quot;;
a = &quot;value&quot;;


</code></pre>
<p>On the second line, we donâ€™t evaluate a (which would return the string â€œbeforeâ€). We figure out what variable a refers to so we know where to store the right-hand side expressionâ€™s value. The classic terms for these two constructs are l-value and r-value. All of the expressions that weâ€™ve seen so far that produce values are r-values. An l-value â€œevaluatesâ€ to a storage location that you can assign into.</p>
<p>ä¸Šé¢ä»£ç çš„ç¬¬äºŒè¡Œï¼Œæˆ‘ä»¬ä¸è®¡ç®—a çš„å€¼ï¼ˆæ­¤æ—¶ï¼Œaå˜é‡å°†ä¼šè¿”å›å­—ç¬¦ä¸² before), æˆ‘ä»¬å¼„æ¸…æ¥šå˜é‡a æ‰€æŒ‡çš„æ˜¯ä»€ä¹ˆï¼Œè¿™æ ·æˆ‘ä»¬å°±çŸ¥é“åœ¨å“ªé‡Œï¼Œå­˜å‚¨å³ä¾§è¡¨è¾¾å¼çš„å€¼ã€‚è¿™ä¸¤ä¸ªæ„é€ çš„ç»å…¸æœ¯è¯­æ˜¯ï¼Œå·¦å€¼å’Œå³å€¼ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬é‡åˆ°çš„æ‰€æœ‰äº§ç”Ÿå€¼çš„è¡¨è¾¾å¼éƒ½æ˜¯å³å€¼ï¼Œå·¦å€¼çš„æ±‚å€¼ï¼Œæ˜¯å¯ä»¥å­˜å‚¨å³å€¼çš„ä½ç½®ã€‚</p>
<blockquote>
<p>In fact, the names come from assignment expressions: l-values appear on the left side of the = in an assignment, and r-values on the right.</p>
<p>äº‹å®ä¸Šï¼Œè¿™äº›åç§°æ¥è‡ªèµ‹å€¼è¡¨è¾¾å¼ï¼Œåœ¨èµ‹å€¼è¡¨è¾¾å¼ä¸­ï¼Œå·¦å€¼å‡ºç°åœ¨å·¦ä¾§ï¼Œå³å€¼å‡ºç°åœ¨å³ä¾§ã€‚</p>
</blockquote>
<p>We want the syntax tree to reflect that an l-value isnâ€™t evaluated like a normal expression. Thatâ€™s why the Expr.Assign node has a Token for the left-hand side, not an Expr. The problem is that the parser doesnâ€™t know itâ€™s parsing an l-value until it hits the =. In a complex l-value, that may occur many tokens later.</p>
<p>æˆ‘ä»¬å¸Œæœ›è¯­æ³•æ ‘ååº”çš„å·¦å€¼ä¸åƒæ˜¯æ™®é€šè¡¨è¾¾å¼é‚£æ ·çš„æ±‚å€¼ï¼Œè¿™å°±æ˜¯ Expr.Assign èŠ‚ç‚¹åœ¨å·¦ä¾§æœ‰ä¸€ä¸ªtokenï¼Œè€Œä¸æ˜¯ Exprï¼Œé—®é¢˜æ˜¯ï¼Œè§£æå™¨åœ¨è§£æåˆ° = ç¬¦å·ä¹‹å‰ï¼Œä¸çŸ¥é“å®ƒæ­£åœ¨è§£æå·¦å€¼ï¼Œåœ¨å¤æ‚çš„å·¦å€¼åœºæ™¯ï¼Œè¿™å¯èƒ½ä¼šåœ¨ä»¥åçš„è®¸å¤štokenä¸­å‡ºç°ã€‚</p>
<pre><code class="language-java">
makeList().head.next = node;

</code></pre>
<blockquote>
<p>Since the receiver of a field assignment can be any expression, and expressions can be as long as you want to make them, it may take an unbounded number of tokens of lookahead to find the =.</p>
<p>ç”±äºå­—æ®µèµ‹å€¼çš„æ¥æ”¶è€…å¯ä»¥æ˜¯ä»»ä½•è¡¨è¾¾å¼ï¼Œå¹¶ä¸”è¡¨è¾¾å¼å¯ä»¥æ˜¯ä»»æ„é•¿åº¦ï¼Œå› æ­¤å¯èƒ½éœ€è¦æ— é™æ•°é‡çš„ tokenåï¼Œæ‰èƒ½å‘ç° = ç¬¦å·</p>
</blockquote>
<p>We have only a single token of lookahead, so what do we do? We use a little trick, and it looks like this:</p>
<p>æˆ‘ä»¬åªæœ‰ä¸€ä¸ªå‰ç»æ€§çš„ tokenï¼Œé‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•å®ç°å‘¢ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªå°æŠ€å·§ï¼Œçœ‹èµ·æ¥åƒè¿™æ ·</p>
<pre><code class="language-java">
// lox/Parser.java, add after expressionStatement()

  private Expr assignment() {
    Expr expr = equality();

    if (match(EQUAL)) {
      Token equals = previous();
      Expr value = assignment();

      if (expr instanceof Expr.Variable) {
        Token name = ((Expr.Variable)expr).name;
        return new Expr.Assign(name, value);
      }

      error(equals, &quot;Invalid assignment target.&quot;); 
    }

    return expr;
  }
  
</code></pre>
<p>Most of the code for parsing an assignment expression looks similar to that of the other binary operators like +. We parse the left-hand side, which can be any expression of higher precedence. If we find an =, we parse the right-hand side and then wrap it all up in an assignment expression tree node.</p>
<p>ç”¨äºè§£æèµ‹å€¼è¡¨è¾¾å¼çš„ä»£ç  çœ‹èµ·æ¥å’Œå¤§éƒ¨åˆ†è§£æäºŒå…ƒè¿ç®—ç¬¦çš„ä»£ç ç›¸ä¼¼ï¼Œæˆ‘ä»¬è§£æå·¦ä¾§ï¼Œå®ƒå¯ä»¥æ˜¯ä»»ä½•ä¼˜å…ˆçº§æ›´é«˜çš„è¡¨è¾¾å¼ï¼Œå¦‚æœæ‰¾åˆ° = ï¼Œæˆ‘ä»¬è§£æå³ä¾§ï¼Œç„¶åå°†å…¶å…¨éƒ¨åŒ…è£…åœ¨èµ‹å€¼è¡¨è¾¾å¼æ ‘èŠ‚ç‚¹ä¸­ã€‚</p>
<blockquote>
<p>We report an error if the left-hand side isnâ€™t a valid assignment target, but we donâ€™t throw it because the parser isnâ€™t in a confused state where we need to go into panic mode and synchronize.</p>
<p>å¦‚æœå·¦ä¾§ä¸æ˜¯æœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡ï¼Œæˆ‘ä»¬ä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸ä¼šæŠ›å‡ºé”™è¯¯ï¼Œå› æ­¤è§£æå™¨æ²¡æœ‰å¤„äºæ··ä¹±çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦è¿›å…¥ç´§æ€¥æ¨¡å¼å¹¶è¿›è¡ŒåŒæ­¥ã€‚</p>
</blockquote>
<p>One slight difference from binary operators is that we donâ€™t loop to build up a sequence of the same operator. Since assignment is right-associative, we instead recursively call assignment() to parse the right-hand side.</p>
<p>The trick is that right before we create the assignment expression node, we look at the left-hand side expression and figure out what kind of assignment target it is. We convert the r-value expression node into an l-value representation.</p>
<p>ä¸äºŒè¿›åˆ¶è¿ç®—ç¬¦çš„ä¸€ä¸ªç»†å¾®åŒºåˆ«æ˜¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦å¾ªç¯æ¥æ„å»ºåŒä¸€ä¸ªè¿ç®—ç¬¦çš„åºåˆ—ï¼Œç”±äºèµ‹å€¼æ˜¯å³å…³è”çš„ï¼Œå› æ­¤æˆ‘ä»¬ä¼šé€’å½’è°ƒç”¨ assign() æ¥è§£æå³ä¾§ã€‚</p>
<p>æŠ€å·§æ˜¯ï¼Œåœ¨åˆ›å»ºèµ‹å€¼è¡¨è¾¾å¼èŠ‚ç‚¹å‰ï¼Œæˆ‘ä»¬æŸ¥çœ‹å·¦ä¾§çš„è¡¨è¾¾å¼ï¼Œæ‰¾å‡ºå®ƒæ˜¯ä»€ä¹ˆç±»å‹çš„èµ‹å€¼ç›®æ ‡ï¼Œæˆ‘ä»¬å°†å³å€¼è¡¨è¾¾å¼èŠ‚ç‚¹ï¼Œè½¬æ¢ä¸ºå·¦å€¼è¡¨ç¤ºã€‚</p>
<p>This conversion works because it turns out that every valid assignment target happens to also be valid syntax as a normal expression. Consider a complex field assignment like:</p>
<p>è¿™ç§è½¬æ¢ä¹‹æ‰€ä»¥æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºå®ƒè¯æ˜äº†æ¯ä¸€ä¸ªæœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡éƒ½æ˜¯ä½œä¸ºæ™®é€šè¡¨è¾¾å¼çš„æœ‰æ•ˆè¯­æ³•ï¼Œè€ƒè™‘ä¸€ä¸ªå¤æ‚çš„å­—æ®µèµ‹å€¼ï¼Œä¾‹å¦‚ï¼š</p>
<pre><code>
newPoint(x + 2, 0).y = 3;

</code></pre>
<p>The left-hand side of that assignment could also work as a valid expression.</p>
<p>ä¸Šé¢çš„èµ‹å€¼è¡¨è¾¾å¼çš„å·¦ä¾§ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„è¡¨è¾¾å¼</p>
<pre><code>newPoint(x + 2, 0).y;

</code></pre>
<p>The first example sets the field, the second gets it.</p>
<p>ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼Œè®¾ç½®å­—æ®µå€¼ï¼Œç¬¬äºŒä¸ªç¤ºä¾‹è·å–å­—æ®µå€¼</p>
<p>This means we can parse the left-hand side as if it were an expression and then after the fact produce a syntax tree that turns it into an assignment target. If the left-hand side expression isnâ€™t a valid assignment target, we fail with a syntax error. That ensures we report an error on code like this:</p>
<p>è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åƒè§£æè¡¨è¾¾å¼ä¸€æ ·ï¼Œè§£æå·¦å€¼ï¼Œç„¶ååœ¨äº‹å®å‘ç”Ÿåï¼Œç”Ÿæˆä¸€ä¸ªè¯­æ³•æ ‘ï¼Œå°†å…¶è½¬æ¢ä¸ºèµ‹å€¼ç›®æ ‡ï¼Œå¦‚æœå·¦ä¾§çš„è¡¨è¾¾å¼ä¸æ˜¯æœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡ï¼Œæˆ‘ä»¬å°†æŠ¥é”™ï¼Œäº§ç”Ÿè¯­æ³•é”™è¯¯ï¼Œè¿™æ ·ï¼Œç¡®ä¿äº†å¦‚ä¸‹ä»£ç ä¼šæŠ¥é”™</p>
<pre><code>
a + b = c;

</code></pre>
<p>Right now, the only valid target is a simple variable expression, but weâ€™ll add fields later. The end result of this trick is an assignment expression tree node that knows what it is assigning to and has an expression subtree for the value being assigned. All with only a single token of lookahead and no backtracking.</p>
<p>ç°åœ¨ï¼Œå”¯ä¸€æœ‰æ•ˆçš„ç›®æ ‡æ˜¯ä¸€ä¸ªç®€å•çš„å˜é‡è¡¨è¾¾å¼ï¼Œä½†æ˜¯æˆ‘ä»¬ç¨åå°†æ·»åŠ å­—æ®µï¼Œè¿™ä¸ªæŠ€å·§çš„æœ€ç»ˆç»“æœæ˜¯ä¸€ä¸ªèµ‹å€¼è¡¨è¾¾å¼æ ‘èŠ‚ç‚¹ï¼Œå®ƒçŸ¥é“è¦èµ‹å€¼çš„å¯¹è±¡ï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªèµ‹å€¼çš„è¡¨è¾¾å¼å­æ ‘ï¼Œæ‰€æœ‰è¿™äº›éƒ½æ˜¯ä¸€ä¸ªå‰ç»tokenï¼Œæ²¡æœ‰å›æº¯</p>
<blockquote>
<p>You can still use this trick even if there are assignment targets that are not valid expressions. Define a cover grammar, a looser grammar that accepts all of the valid expression and assignment target syntaxes. When you hit an =, report an error if the left-hand side isnâ€™t within the valid assignment target grammar. Conversely, if you donâ€™t hit an =, report an error if the left-hand side isnâ€™t a valid expression.</p>
<p>å³ä½¿å­˜åœ¨æ— æ•ˆè¡¨è¾¾å¼çš„èµ‹å€¼ç›®æ ‡ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ­¤æŠ€å·§ï¼Œå®šä¹‰ä¸€ä¸ªè¦†ç›–è¯­æ³•ï¼Œä¸€ä¸ªæ¥å—æ‰€æœ‰æœ‰æ•ˆè¡¨è¾¾å¼å’Œèµ‹å€¼ç›®æ ‡è¯­æ³•çš„è¾ƒå®½æ¾çš„è¯­æ³•ï¼Œå½“æˆ‘ä»¬é‡åˆ° = æ—¶å€™ï¼Œå¦‚æœå·¦ä¾§ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡æ—¶å€™ï¼Œåˆ™æŠ¥å‘Šé”™è¯¯ï¼Œç›¸åï¼Œå¦‚æœæ²¡æœ‰é‡åˆ° = ï¼Œ å·¦ä¾§ä¸æ˜¯æœ‰æ•ˆçš„è¡¨è¾¾å¼ï¼Œåˆ™æŠ¥é”™é”™è¯¯</p>
</blockquote>
<blockquote>
<p>Way back in the parsing chapter, I said we represent parenthesized expressions in the syntax tree because weâ€™ll need them later. This is why. We need to be able to distinguish these cases:</p>
<p>åœ¨è§£æé‚£ä¸€ç« ï¼Œè¯´è¿‡åœ¨è¯­æ³•æ ‘ä¸­è¡¨ç¤ºå¸¦æ‹¬å·çš„è¡¨è¾¾å¼ï¼Œå› ä¸ºæˆ‘ä»¬ç¨åä¼šéœ€è¦å®ƒï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤ŸåŒºåˆ†è¿™äº›æƒ…å†µ</p>
<p>a = 3; // ok</p>
<p>(a) = 3; // error</p>
</blockquote>
<h3 id="42--assignment-semantics"><a class="header" href="#42--assignment-semantics">4.2  Assignment semantics</a></h3>
<p>We have a new syntax tree node, so our interpreter gets a new visit method.</p>
<p>æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–°çš„è¯­æ³•æ ‘èŠ‚ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„è§£é‡Šå™¨æœ‰ä¸€ä¸ªæ–°çš„è®¿é—®æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitVarStmt()

  @Override
  public Object visitAssignExpr(Expr.Assign expr) {
    Object value = evaluate(expr.value);
    environment.assign(expr.name, value);
    return value;
  }
  
</code></pre>
<p>For obvious reasons, itâ€™s similar to variable declaration. It evaluates the right-hand side to get the value, then stores it in the named variable. Instead of using define() on Environment, it calls this new method:</p>
<p>ç”±äºæ˜æ˜¾çš„åŸå› ï¼Œå®ƒç±»ä¼¼äºå˜é‡çš„å£°æ˜ï¼Œå®ƒè®¡ç®—å³ä¾§çš„å€¼ï¼Œç„¶åå°†å…¶å­˜å‚¨åœ¨å‘½åå˜é‡ä¸­ï¼Œå®ƒä¸æ˜¯åœ¨environmentä¸Šä½¿ç”¨define() æ–¹æ³•ï¼Œè€Œæ˜¯è°ƒç”¨æ–°çš„æ–¹æ³•</p>
<pre><code class="language-java">
// lox/Environment.java, add after get()

  void assign(Token name, Object value) {
    if (values.containsKey(name.lexeme)) {
      values.put(name.lexeme, value);
      return;
    }

    throw new RuntimeError(name,
        &quot;Undefined variable '&quot; + name.lexeme + &quot;'.&quot;);
  }
  
</code></pre>
<p>The key difference between assignment and definition is that assignment is not allowed to create a new variable. In terms of our implementation, that means itâ€™s a runtime error if the key doesnâ€™t already exist in the environmentâ€™s variable map.</p>
<p>èµ‹å€¼å’Œå®šä¹‰ä¹‹é—´çš„å…³é”®åŒºåˆ«æ˜¯ï¼Œä¸å…è®¸èµ‹å€¼åˆ›å»ºæ–°å˜é‡ï¼Œå°±æˆ‘ä»¬çš„å®ç°è€Œè¨€ï¼Œè¿™æ„å‘³ç€å¦‚æœ environment çš„values ä¸­å¦‚æœä¸å­˜åœ¨é”®ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚</p>
<p>The last thing the visit() method does is return the assigned value. Thatâ€™s because assignment is an expression that can be nested inside other expressions, like so:</p>
<p>visit() æ–¹æ³•æ‰€åšçš„æœ€åä¸€ä»¶äº‹æƒ…æ˜¯è¿”å›æŒ‡å®šçš„å€¼ï¼Œè¿™æ˜¯å› ä¸ºèµ‹å€¼æ˜¯ä¸€ä¸ªå¯ä»¥åµŒå¥—åœ¨å…¶ä»–è¡¨è¾¾å¼ä¸­çš„è¡¨è¾¾å¼ï¼Œå¦‚ä¸‹æ‰€ç¤º:</p>
<pre><code class="language-java">
var a = 1;
print a = 2; // &quot;2&quot;.

</code></pre>
<p>Our interpreter can now create, read, and modify variables. Itâ€™s about as sophisticated as early BASICs. Global variables are simple, but writing a large program when any two chunks of code can accidentally step on each otherâ€™s state is no fun. We want local variables, which means itâ€™s time for scope.</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨ï¼Œç°åœ¨å¯ä»¥åˆ›å»ºã€è¯»å–ã€ä¿®æ”¹å˜é‡ï¼Œå®ƒå’Œæ—©æœŸçš„BASICä¸€æ ·å¤æ‚ï¼Œå…¨å±€å˜é‡å¾ˆç®€å•ï¼Œä½†æ˜¯å½“ä»»æ„ä¸¤ä¸ªä»£ç å—å¯èƒ½æ„å¤–çš„è·å–åˆ°å½¼æ­¤çš„çŠ¶æ€æ—¶å€™ï¼Œç¼–å†™ä¸€ä¸ªå¤§å‹ç¨‹åºå¹¶ä¸æœ‰è¶£ã€‚æˆ‘ä»¬éœ€è¦å±€éƒ¨å˜é‡ï¼Œè¿™æ„å‘³ç€ç°åœ¨æ˜¯æˆ‘ä»¬è¿›å…¥åˆ°ä½œç”¨åŸŸçš„æ—¶å€™äº†ã€‚</p>
<blockquote>
<p>Unlike Python and Ruby, Lox doesnâ€™t do implicit variable declaration.</p>
<p>å’ŒPython,Rubyä¸ä¸€æ ·ï¼ŒLoxä¸åšéšå¼å˜é‡å£°æ˜</p>
<p>Maybe a little better than that. Unlike some old BASICs, Lox can handle variable names longer than two characters.</p>
<p>ä¹Ÿè®¸æ¯”BASICå¥½ä¸€äº›ï¼Œä¸ä¸€äº›æ—§çš„BASICä¸åŒï¼ŒLoxå¯ä»¥å¤„ç†é•¿åº¦è¶…è¿‡ä¸¤ä¸ªå­—ç¬¦çš„å˜é‡å</p>
</blockquote>
<h2 id="äº”scope"><a class="header" href="#äº”scope">äº”ã€Scope</a></h2>
<p>ä½œç”¨åŸŸ</p>
<p>A scope defines a region where a name maps to a certain entity. Multiple scopes enable the same name to refer to different things in different contexts. In my house, â€œBobâ€ usually refers to me. But maybe in your town you know a different Bob. Same name, but different dudes based on where you say it.</p>
<p>Lexical scope (or the less commonly heard static scope) is a specific style of scoping where the text of the program itself shows where a scope begins and ends. In Lox, as in most modern languages, variables are lexically scoped. When you see an expression that uses some variable, you can figure out which variable declaration it refers to just by statically reading the code.</p>
<p>ä¸€ä¸ªä½œç”¨åŸŸå®šä¹‰äº†ä¸€ä¸ªåŒºåŸŸï¼Œå…¶ä¸­åŒ…å«åç§°æ˜ å°„åˆ°ç‰¹å®šå®ä½“ã€‚å¤šä¸ªä½œç”¨åŸŸå¯ä»¥ä½¿å¾—ï¼Œç›¸åŒåç§°çš„å˜é‡å¯ä»¥åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­å¼•ç”¨ä¸åŒçš„äº‹ç‰©ã€‚ä¾‹å¦‚ï¼šåœ¨æˆ‘å®¶ï¼ŒBob é€šå¸¸æŒ‡çš„å°±æ˜¯æˆ‘ï¼Œä½†ä¹Ÿè®¸åœ¨ä½ çš„å®¶ä¹¡ï¼Œä½ è¿˜è®¤è¯†ä¸€ä¸ªä¸åŒçš„Bobï¼Œç›¸åŒçš„åå­—ï¼Œä½†æ˜¯æ ¹æ®ä¸åŒçš„åœ°æ–¹ï¼Œå¯ä»¥æŒ‡ä»£ä¸åŒçš„äººã€‚</p>
<p>è¯æ±‡ä½œç”¨åŸŸï¼ˆæˆ–è€…ä¸å¤ªå¸¸è§çš„é™æ€ä½œç”¨åŸŸï¼‰æ˜¯ä¸€ç§ç‰¹å®šç±»å‹çš„ä½œç”¨åŸŸï¼Œç¨‹åºæ–‡æœ¬æœ¬èº«æ˜¾ç¤ºä½œç”¨åŸŸçš„å¼€å§‹å’Œç»“æŸä½ç½®ã€‚å’Œå¤§å¤šæ•°çš„ç°ä»£è¯­è¨€ä¸€æ ·ï¼Œåœ¨Loxä¸­, å˜é‡çš„ä½œç”¨åŸŸæ˜¯è¯æ±‡çš„ä½œç”¨åŸŸï¼Œå½“æˆ‘ä»¬çœ‹åˆ°ä½¿ç”¨å˜é‡çš„æŸä¸ªè¡¨è¾¾å¼æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é™æ€è¯»å–ä»£ç æ¥ç¡®å®šå®ƒå¼•ç”¨çš„æ˜¯å“ªä¸ªå˜é‡ã€‚</p>
<p>For example:</p>
<p>ä¾‹å¦‚: </p>
<pre><code class="language-java">
{
  var a = &quot;first&quot;;
  print a; // &quot;first&quot;.
}

{
  var a = &quot;second&quot;;
  print a; // &quot;second&quot;.
}

</code></pre>
<p>Here, we have two blocks with a variable a declared in each of them. You and I can tell just from looking at the code that the use of a in the first print statement refers to the first a, and the second one refers to the second.</p>
<p>è¿™é‡Œï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªä»£ç å—ï¼Œæ¯ä¸ªå—ä¸­éƒ½å£°æ˜äº†å˜é‡aï¼Œ æˆ‘ä»¬å¯ä»¥ä»ä»£ç ä¸­çœ‹åˆ°ï¼Œç¬¬ä¸€ä¸ªå—ä¸­çš„print æ˜¯æŒ‡firstï¼Œç¬¬äºŒä¸ªå—ä¸­çš„printæ˜¯æŒ‡ second</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/blocks.png?raw=true" alt="blocks" /></p>
<blockquote>
<p>â€œLexicalâ€ comes from the Greek â€œlexikosâ€ which means â€œrelated to wordsâ€. When we use it in programming languages, it usually means a thing you can figure out from source code itself without having to execute anything.</p>
<p>Lexical æ¥è‡ªäºå¸Œè…Šè¯­ Lexikos, æ„æ€æ˜¯ä¸å•è¯æœ‰å…³ï¼Œå½“æˆ‘ä»¬åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ä½¿ç”¨å®ƒæ—¶ï¼Œå®ƒé€šå¸¸æ„å‘³ç€ä½ å¯ä»¥ä»æºä»£ç ä¸­æ‰¾å‡ºï¼Œè€Œä¸å¿…æ‰§è¡Œä»»ä½•ä¸œè¥¿ã€‚</p>
<p>Lexical scope came onto the scene with ALGOL. Earlier languages were often dynamically scoped. Computer scientists back then believed dynamic scope was faster to execute. Today, thanks to early Scheme hackers, we know that isnâ€™t true. If anything, itâ€™s the opposite.</p>
<p>ALGOL è¯­è¨€ä¸­å‡ºç°äº†è¯æ±‡ä½œç”¨åŸŸæ¦‚å¿µï¼Œæ—©æœŸçš„è¯­è¨€ï¼Œé€šå¸¸æ˜¯åŠ¨æ€èŒƒå›´çš„ï¼Œå½“æ—¶çš„ç§‘å­¦å®¶è®¤ä¸ºåŠ¨æ€èŒƒå›´æ‰§è¡Œé€Ÿåº¦æ›´å¿«ï¼Œç°åœ¨ï¼Œå¤šäºäº†æ—©æœŸçš„Scheme é»‘å®¢ï¼Œæˆ‘ä»¬ç›´åˆ°è¿™ä¸ªç»“è®ºä¸å‡†ç¡®ï¼Œå¦‚æœè¦é‡æ–°ä¸‹ç»“è®ºï¼Œç­”æ¡ˆæ˜¯åŠ¨æ€ä½œç”¨åŸŸä¼šæ›´æ…¢ã€‚</p>
<p>Dynamic scope for variables lives on in some corners. Emacs Lisp defaults to dynamic scope for variables. The binding macro in Clojure provides it. The widely disliked with statement in JavaScript turns properties on an object into dynamically scoped variables.</p>
<p>å˜é‡çš„åŠ¨æ€ä½œç”¨åŸŸå­˜åœ¨äºæŸäº›è§’è½ï¼ŒEmacs Lispé»˜è®¤å˜é‡æ˜¯åŠ¨æ€ä½œç”¨åŸŸçš„ï¼ŒClojure é€šè¿‡ç»‘å®šå®æä¾›äº†å®ƒï¼ŒJavaScriptè¯­è¨€ä¸­å¹¿å—æ¬¢è¿çš„withè¯­å¥å°†å¯¹è±¡çš„å±æ€§è½¬æ¢ä¸ºåŠ¨æ€ä½œç”¨åŸŸçš„å˜é‡</p>
</blockquote>
<p>This is in contrast to dynamic scope where you donâ€™t know what a name refers to until you execute the code. Lox doesnâ€™t have dynamically scoped variables, but methods and fields on objects are dynamically scoped.</p>
<p>è¿™ä¸åŠ¨æ€ä½œç”¨åŸŸä¸åŒï¼Œåœ¨åŠ¨æ€ä½œç”¨åŸŸä¸­ï¼Œåœ¨æ‰§è¡Œä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸éœ€è¦çŸ¥é“åç§°æŒ‡ä»£çš„æ˜¯ä»€ä¹ˆï¼ŒLoxæ²¡æœ‰åŠ¨æ€ä½œç”¨åŸŸå˜é‡ï¼Œä½†æ˜¯å¯¹è±¡ä¸Šçš„æ–¹æ³•å’Œå­—æ®µæ˜¯åŠ¨æ€ä½œç”¨åŸŸçš„</p>
<pre><code class="language-java">

class Saxophone {
  play() {
    print &quot;Careless Whisper&quot;;
  }
}

class GolfClub {
  play() {
    print &quot;Fore!&quot;;
  }
}

fun playIt(thing) {
  thing.play();
}

</code></pre>
<p>When playIt() calls thing.play(), we donâ€™t know if weâ€™re about to hear â€œCareless Whisperâ€ or â€œFore!â€ It depends on whether you pass a Saxophone or a GolfClub to the function, and we donâ€™t know that until runtime.</p>
<p>å½“å‡½æ•°playIt() è°ƒç”¨thing.play() æ—¶å€™ï¼Œæˆ‘ä»¬ä¸çŸ¥é“è¿”å›å€¼æ˜¯ â€œCareless Whisperâ€ è¿˜æ˜¯ â€œFore!â€ï¼Œè¿™å–å†³äºä½ æ˜¯æŠŠ Saxophone è¿˜æ˜¯ GolfClub ä¼ é€ç»™å‡½æ•°ï¼Œè€Œæˆ‘ä»¬çŸ¥é“è¿è¡Œæ—¶å€™ï¼Œæ‰èƒ½çŸ¥é“å®å‚ä¿¡æ¯</p>
<p>Scope and environments are close cousins. The former is the theoretical concept, and the latter is the machinery that implements it. As our interpreter works its way through code, syntax tree nodes that affect scope will change the environment. In a C-ish syntax like Loxâ€™s, scope is controlled by curly-braced blocks. (Thatâ€™s why we call it block scope.)</p>
<p>ä½œç”¨åŸŸå’Œç¯å¢ƒæ˜¯ç›¸ä¼¼æ¦‚å¿µï¼Œä½œç”¨åŸŸæ˜¯ä¸€ä¸ªç†è®ºä¸Šçš„æ¦‚å¿µï¼Œç¯å¢ƒæ˜¯å®ç°ä½œç”¨åŸŸçš„ä¸€ä¸ªæœºåˆ¶ã€‚å½“æˆ‘ä»¬çš„è§£é‡Šå™¨ï¼Œç´§éšä»£ç è¿è¡Œæ—¶å€™ï¼Œä½œç”¨åŸŸå˜åŒ–ä¼šå¯¼è‡´è¯­æ³•æ ‘çš„èŠ‚ç‚¹çš„ç¯å¢ƒçš„å˜åŒ–ã€‚åœ¨ç±»Cè¯­è¨€ï¼Œä¾‹å¦‚Loxä¸­ï¼Œä½œç”¨åŸŸä½¿ç”¨å¤§æ‹¬å·æ§åˆ¶ï¼ˆè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ç§°ä½œç”¨åŸŸä¸ºå—èŒƒå›´çš„åŸå› ï¼‰</p>
<pre><code class="language-java">
{
  var a = &quot;in block&quot;;
}
print a; // Error! No more &quot;a&quot;.

</code></pre>
<p>The beginning of a block introduces a new local scope, and that scope ends when execution passes the closing }. Any variables declared inside the block disappear.</p>
<p>å—çš„å¼€å§‹å¼•å…¥äº†ä¸€ä¸ªæ–°çš„æœ¬åœ°å˜é‡ï¼Œå½“è¿è¡Œåˆ°å³æ‹¬å·æ—¶å€™ï¼Œä½œç”¨åŸŸç»“æŸã€‚å—å†…å£°æ˜çš„å˜é‡å°†ä¼šæ¶ˆå¤±ã€‚</p>
<h3 id="51-nesting-and-shadowing"><a class="header" href="#51-nesting-and-shadowing">5.1 Nesting and shadowing</a></h3>
<p>A first cut at implementing block scope might work like this:</p>
<ul>
<li>
<p>As we visit each statement inside the block, keep track of any variables declared.</p>
</li>
<li>
<p>After the last statement is executed, tell the environment to delete all of those variables.</p>
</li>
</ul>
<p>å®ç°å—èŒƒå›´çš„ç¬¬ä¸€æ­¥å¯èƒ½æ˜¯è¿™æ ·çš„ï¼Œ</p>
<ul>
<li>
<p>å½“æˆ‘ä»¬è®¿é—®å—å†…çš„æ¯ä¸€ä¸ªè¯­å¥æ—¶å€™ï¼Œä¼šè·Ÿè¸ªå£°æ˜çš„ä»»ä½•å˜é‡</p>
</li>
<li>
<p>æ‰§è¡Œæœ€åä¸€æ¡è¯­å¥æ—¶å€™ï¼Œå‘Šè¯‰ç¯å¢ƒåˆ é™¤æ‰€æœ‰çš„å˜é‡</p>
</li>
</ul>
<p>That would work for the previous example. But remember, one motivation for local scope is encapsulationâ€”a block of code in one corner of the program shouldnâ€™t interfere with some other block. Check this out:</p>
<p>è¿™é€‚ç”¨äºå‰é¢çš„æ¼”ç¤ºï¼Œä½†è¯·æ³¨æ„ï¼Œå±€éƒ¨å˜é‡çš„ä¸€ä¸ªåŠ¨æœºæ˜¯å°è£…â€”â€”ç¨‹åºæŸä¸ªéƒ¨åˆ†çš„ä»£ç ï¼Œä¸ä¼šå½±å“å¦å¤–ä¸€éƒ¨åˆ†çš„ä»£ç ï¼Œçœ‹çœ‹ä¸‹é¢</p>
<pre><code class="language-java">
// How loud?
var volume = 11;

// Silence.
volume = 0;

// Calculate size of 3x4x5 cuboid.
{
  var volume = 3 * 4 * 5;
  print volume;
}

</code></pre>
<p>Look at the block where we calculate the volume of the cuboid using a local declaration of volume. After the block exits, the interpreter will delete the global volume variable. That ainâ€™t right. When we exit the block, we should remove any variables declared inside the block, but if there is a variable with the same name declared outside of the block, thatâ€™s a different variable. It shouldnâ€™t get touched.</p>
<p>When a local variable has the same name as a variable in an enclosing scope, it shadows the outer one. Code inside the block canâ€™t see it any moreâ€”it is hidden in the â€œshadowâ€ cast by the inner oneâ€”but itâ€™s still there.</p>
<p>When we enter a new block scope, we need to preserve variables defined in outer scopes so they are still around when we exit the inner block. We do that by defining a fresh environment for each block containing only the variables defined in that scope. When we exit the block, we discard its environment and restore the previous one.</p>
<p>We also need to handle enclosing variables that are not shadowed.</p>
<p>çœ‹çœ‹è¿™ä¸ªå—ï¼Œæˆ‘ä»¬ç”¨æœ¬åœ°å˜é‡ volumeä¿å­˜é•¿æ–¹ä½“ä½“ç§¯è®¡ç®—å€¼ï¼Œå—é€€å‡ºåï¼Œè§£é‡Šå™¨å°†ä¼šåˆ é™¤å…¨å±€å˜é‡volume, è¿™æ˜¯ä¸å¯¹çš„ï¼Œå½“æˆ‘ä»¬åˆ é™¤å—æ—¶å€™ï¼Œæˆ‘ä»¬åº”è¯¥åˆ é™¤å—å†…æ‰€æœ‰çš„å˜é‡ï¼Œä½†æ˜¯ï¼Œå¦‚æœåœ¨å—å¤–å£°æ˜äº†ä¸€ä¸ªåŒåå˜é‡åï¼Œé‚£å°±æ˜¯å¦å¤–ä¸€ä¸ªå˜é‡ï¼Œå®ƒä¸åº”è¯¥è¢«è®¿é—®åˆ°</p>
<p>å½“å±€éƒ¨å˜é‡å’Œå—ä¸­çš„å˜é‡åŒåï¼Œå®ƒä¼šéšè—å¤–éƒ¨å˜é‡ï¼Œå—å†…çš„ä»£ç å°†æ— æ³•çœ‹åˆ°å¤–éƒ¨å˜é‡ï¼Œå®ƒéšè—åœ¨å†…éƒ¨ä»£ç æŠ•å°„çš„é˜´å½±ä¸­ï¼Œä½†æ˜¯å®ƒä»ç„¶å­˜åœ¨ã€‚</p>
<p>å½“æˆ‘ä»¬è¿›å…¥åˆ°ä¸€ä¸ªæ–°çš„å—ä½œç”¨åŸŸæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ä¿ç•™åœ¨å¤–éƒ¨èŒƒå›´å†…å£°æ˜çš„å˜é‡ï¼Œè¿™æ ·å½“ï¼Œæˆ‘ä»¬é€€å‡ºå†…éƒ¨å—æ—¶å€™ï¼Œè¿™äº›å¤–éƒ¨å˜é‡ä»ç„¶å­˜åœ¨ã€‚æˆ‘ä»¬é€šè¿‡ä¸ºæ¯ä¸€ä¸ªå—ï¼Œæä¾›ä¸€ä¸ªenvironmentï¼Œæ¥å®ç°ã€‚è¯¥ç¯å¢ƒä»…åŒ…å«åœ¨è¯¥ä½œç”¨åŸŸä¸­å®šä¹‰çš„å˜é‡, å½“æˆ‘ä»¬é€€å‡ºä»£ç å—æ—¶å€™ï¼Œæˆ‘ä»¬å°†ä¸¢å¼ƒå®ƒçš„ç¯å¢ƒï¼Œå¹¶ä¸”æ¢å¤ä»¥å‰çš„ç¯å¢ƒã€‚</p>
<p>æˆ‘ä»¬è¿˜éœ€è¦å¤„ç†æœªéšè—çš„å°é—­å˜é‡</p>
<pre><code class="language-java">
var global = &quot;outside&quot;;
{
  var local = &quot;inside&quot;;
  print global + local;
}

</code></pre>
<p>Here, global lives in the outer global environment and local is defined inside the blockâ€™s environment. In that print statement, both of those variables are in scope. In order to find them, the interpreter must search not only the current innermost environment, but also any enclosing ones.</p>
<p>We implement this by chaining the environments together. Each environment has a reference to the environment of the immediately enclosing scope. When we look up a variable, we walk that chain from innermost out until we find the variable. Starting at the inner scope is how we make local variables shadow outer ones.</p>
<p>åœ¨è¿™é‡Œï¼Œå˜é‡global å­˜åœ¨äºå¤–éƒ¨ç¯å¢ƒå˜é‡ä¸­ï¼Œå˜é‡ local å®šä¹‰åœ¨ä»£ç å—ä¸­ï¼Œåœ¨printè¯­å¥ä¸­ï¼Œè¿™ä¸¤ä¸ªå˜é‡éƒ½åœ¨ä½œç”¨åŸŸä¸­ï¼Œä¸ºäº†æ‰¾åˆ°å®ƒä»¬ï¼Œè§£é‡Šå™¨ä¸ä»…éœ€è¦æœç´¢å½“å‰æœ€å†…éƒ¨çš„ç¯å¢ƒï¼Œè¿˜å¿…é¡»æœç´¢ä»»ä½•å°é—­çš„ç¯å¢ƒã€‚</p>
<p>æˆ‘ä»¬é€šè¿‡å°†ç¯å¢ƒé“¾æ¥åœ¨ä¸€èµ·æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œæ¯ä¸ªç¯å¢ƒéƒ½å…·æœ‰å¯¹ç´§é‚»çš„å°é—­èŒƒå›´çš„ç¯å¢ƒçš„å¼•ç”¨ï¼Œå½“æˆ‘ä»¬æŸ¥æ‰¾ä¸€ä¸ªå˜é‡æ—¶å€™ï¼Œæˆ‘ä»¬ä»æœ€é‡Œé¢å‘å¤–éå†è¯¥é“¾ï¼Œç›´åˆ°æ‰¾åˆ°è¯¥å˜é‡ï¼Œä»å†…éƒ¨èŒƒå›´å¼€å§‹ï¼Œæˆ‘ä»¬å°†å¦‚ä½•ä½¿å¾—å±€éƒ¨å˜é‡è¦†ç›–å¤–éƒ¨å˜é‡</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/chaining.png?raw=true" alt="chain" /></p>
<blockquote>
<p>While the interpreter is running, the environments form a linear list of objects, but consider the full set of environments created during the entire execution. An outer scope may have multiple blocks nested within it, and each will point to the outer one, giving a tree-like structure, though only one path through the tree exists at a time.</p>
<p>å½“è§£é‡Šå™¨è¿è¡Œæ—¶å€™ï¼Œç¯å¢ƒå½¢æˆäº†ä¸€ä¸ªçº¿æ€§çš„å¯¹è±¡åˆ—è¡¨ï¼Œä½†è¦è€ƒè™‘åœ¨æ•´ä¸ªæ‰§è¡Œè¿‡ç¨‹ä¸­åˆ›å»ºçš„å…¨å¥—ç¯å¢ƒã€‚ä¸€ä¸ªå¤–éƒ¨ä½œç”¨åŸŸå¯èƒ½å­˜åœ¨å¤šä¸ªåµŒå¥—åœ¨å…¶ä¸­çš„å—ï¼Œæ¯ä¸ªå—éƒ½ä¼šæŒ‡å‘å¤–éƒ¨çš„å—ï¼Œä»è€Œå½¢æˆä¸€ä¸ªç±»ä¼¼æ ‘çš„ç»“æ„ï¼Œå°½ç®¡ä¸€æ¬¡åªä¼šå­˜åœ¨ä¸€æ¡é€šå‘æ ‘çš„è·¯å¾„</p>
<p>The boring name for this is a parent-pointer tree, but I much prefer the evocative cactus stack.</p>
<p>è¿™ä¸ªæ— èŠçš„åå­—æ˜¯ä¸€ä¸ªçˆ¶æŒ‡é’ˆæ ‘ï¼Œä½†æˆ‘æ›´åŠ å–œæ¬¢èƒ½å¼•å‘å…±é¸£çš„ä»™äººæŒå †æ ˆè¿™ä¸ªåå­—ã€‚</p>
</blockquote>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/cactus.png?raw=true" alt="cactus" /></p>
<p>Before we add block syntax to the grammar, weâ€™ll beef up our Environment class with support for this nesting. First, we give each environment a reference to its enclosing one.</p>
<p>åœ¨å°†å—è¯­æ³•æ·»åŠ åˆ°è¯­æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å°†å¢å¼ºenvironment ç±»å¯¹äºåµŒå¥—çš„æ”¯æŒï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬å°†ç»™æ¯ä¸ªenvironmentå¯¹å…¶å°é—­ç¯å¢ƒçš„å¼•ç”¨</p>
<pre><code class="language-java">
// lox/Environment.java, in class Environment

class Environment {
  final Environment enclosing;
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
  
</code></pre>
<p>This field needs to be initialized, so we add a couple of constructors.</p>
<p>è¿™ä¸ªå­—æ®µéœ€è¦åˆå§‹åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å°†æ·»åŠ ä¸€äº›æ„é€ å‡½æ•°</p>
<pre><code class="language-java">
// lox/Environment.java, in class Environment

  Environment() {
    enclosing = null;
  }

  Environment(Environment enclosing) {
    this.enclosing = enclosing;
  }
  
</code></pre>
<p>æ— å‚æ•°æ„é€ å‡½æ•°ï¼Œç”¨äºç»“æŸé“¾çš„å…¨å±€ä½œç”¨åŸŸç¯å¢ƒï¼Œå¦ä¸€ä¸ªæ„é€ å‡½æ•°åˆ›å»ºä¸€ä¸ªåµŒå¥—åœ¨ç»™å®šå¤–éƒ¨ä½œç”¨åŸŸå†…çš„æ–°çš„æœ¬åœ°ä½œç”¨åŸŸã€‚</p>
<p>We donâ€™t have to touch the define() methodâ€”a new variable is always declared in the current innermost scope. But variable lookup and assignment work with existing variables and they need to walk the chain to find them. First, lookup:</p>
<p>æˆ‘ä»¬ä¸éœ€è¦è§¦åŠdefine() æ–¹æ³•â€”â€”ä¸€ä¸ªæ–°çš„å˜é‡æ€»æ˜¯åœ¨å½“å‰æœ€å†…éƒ¨çš„ä½œç”¨åŸŸä¸­å£°æ˜ï¼Œä½†æ˜¯å˜é‡æŸ¥æ‰¾å’Œèµ‹å€¼ï¼Œå’Œç°æœ‰å˜é‡ä¸€èµ·å·¥ä½œã€‚å®ƒä»¬éœ€è¦éå†é“¾æ‰å¯ä»¥æ‰¾åˆ°ï¼Œé¦–å…ˆï¼ŒæŸ¥æ‰¾ï¼š</p>
<pre><code class="language-java">
// lox/Environment.java, in get()


      return values.get(name.lexeme);
    }

    if (enclosing != null) return enclosing.get(name);

    throw new RuntimeError(name,
        &quot;Undefined variable '&quot; + name.lexeme + &quot;'.&quot;);
		
</code></pre>
<p>If the variable isnâ€™t found in this environment, we simply try the enclosing one. That in turn does the same thing recursively, so this will ultimately walk the entire chain. If we reach an environment with no enclosing one and still donâ€™t find the variable, then we give up and report an error as before.</p>
<p>Assignment works the same way.</p>
<p>å¦‚æœåœ¨å½“å‰çš„ç¯å¢ƒä¸­æ— æ³•æ‰¾åˆ°æŸä¸ªå˜é‡ï¼Œæˆ‘ä»¬åªéœ€è¦å°è¯•ä½¿ç”¨å°é—­å˜é‡ï¼Œè¿™åè¿‡æ¥é€’å½’åšåŒæ ·çš„äº‹æƒ…ï¼Œæœ€ç»ˆå°†ä¼šéå†æ•´æ¡é“¾ï¼Œå¦‚æœæˆ‘ä»¬åˆ°è¾¾æŸä¸ªç¯å¢ƒï¼Œä¸å­˜åœ¨å°é—­å˜é‡ï¼Œä»ç„¶æ‰¾ä¸åˆ°å˜é‡ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†æ”¾å¼ƒï¼Œå¹¶ä¸”å‘ä¹‹å‰é‚£æ ·æŠ¥å‘Šé”™è¯¯ã€‚</p>
<p>å˜é‡èµ‹å€¼çš„å·¥ä½œæ–¹å¼ç›¸åŒã€‚</p>
<pre><code class="language-java">
// lox/Environment.java, in assign()

      values.put(name.lexeme, value);
      return;
    }

    if (enclosing != null) {
      enclosing.assign(name, value);
      return;
    }

    throw new RuntimeError(name,
	
</code></pre>
<blockquote>
<p>Itâ€™s likely faster to iteratively walk the chain, but I think the recursive solution is prettier. Weâ€™ll do something much faster in clox.</p>
<p>è¿­ä»£éå†é“¾å¯èƒ½æ›´å¿«ï¼Œä½†æ˜¯æˆ‘è®¤ä¸ºé€’å½’è§£å†³æ–¹æ¡ˆæ›´åŠ å¥½ï¼Œæˆ‘ä»¬å°†åœ¨cloxä¸­åšä¸€äº›æ›´å¿«çš„äº‹æƒ…ã€‚</p>
</blockquote>
<p>Again, if the variable isnâ€™t in this environment, it checks the outer one, recursively.</p>
<p>åŒæ ·ï¼Œå¦‚æœå˜é‡ä¸åœ¨å½“å‰ç¯å¢ƒä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæŸ¥è¯¢å¤–éƒ¨ç¯å¢ƒï¼Œä¸€ç›´é€’å½’ã€‚</p>
<h3 id="52-block-syntax-and-semantics"><a class="header" href="#52-block-syntax-and-semantics">5.2 Block syntax and semantics</a></h3>
<p>å—è¯­æ³•å’Œè¯­ä¹‰</p>
<p>Now that Environments nest, weâ€™re ready to add blocks to the language. Behold the grammar:</p>
<p>ç°åœ¨æˆ‘ä»¬æ”¯æŒäº†åµŒå¥—ç¯å¢ƒï¼Œæˆ‘ä»¬å‡†å¤‡å‘è¯­æ³•ä¸­æ·»åŠ å—è¯­æ³•ï¼Œ</p>
<pre><code>
statement      â†’ exprStmt
               | printStmt
               | block ;

block          â†’ &quot;{&quot; declaration* &quot;}&quot; ;

</code></pre>
<p>A block is a (possibly empty) series of statements or declarations surrounded by curly braces. A block is itself a statement and can appear anywhere a statement is allowed. The syntax tree node looks like this:</p>
<p>å—æ˜¯ç”±å¤§æ‹¬å·åŒ…å›´çš„ä¸€ç³»åˆ—è¯­å¥æˆ–è€…å£°æ˜ï¼ˆå¯èƒ½æ˜¯ç©ºçš„ï¼‰ï¼Œå—æœ¬èº«å°±æ˜¯ä¸€æ¡è¯­å¥ï¼Œå¯ä»¥å‡ºç°åœ¨å…è®¸è¯­å¥å‡ºç°çš„ä»»ä½•åœ°æ–¹ï¼Œè¯­æ³•æ ‘èŠ‚ç‚¹å¦‚ä¸‹æ‰€ç¤º</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main()

    defineAst(outputDir, &quot;Stmt&quot;, Arrays.asList(
      &quot;Block      : List&lt;Stmt&gt; statements&quot;,
      &quot;Expression : Expr expression&quot;,
	  
</code></pre>
<p>It contains the list of statements that are inside the block. Parsing is straightforward. Like other statements, we detect the beginning of a block by its leading tokenâ€”in this case the {. In the statement() method, we add:</p>
<p>å®ƒåŒ…å«å—å†…çš„è¯­å¥åˆ—è¡¨ï¼Œè§£æå¾ˆç®€å•ï¼Œä¸å…¶ä»–è¯­å¥ä¸€æ ·ï¼Œæˆ‘ä»¬é€šè¿‡å‰å¯¼tokenæ£€æµ‹å—çš„å¼€å§‹ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œæ˜¯ {, åœ¨ statement() æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ </p>
<pre><code class="language-java">
// lox/Parser.java, in statement()

    if (match(PRINT)) return printStatement();
    if (match(LEFT_BRACE)) return new Stmt.Block(block());

    return expressionStatement();
	
</code></pre>
<p>All the real work happens here:</p>
<p>çœŸçš„è§£æå‘ç”Ÿåœ¨</p>
<pre><code class="language-java">
// lox/Parser.java, add after expressionStatement()


  private List&lt;Stmt&gt; block() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();

    while (!check(RIGHT_BRACE) &amp;&amp; !isAtEnd()) {
      statements.add(declaration());
    }

    consume(RIGHT_BRACE, &quot;Expect '}' after block.&quot;);
    return statements;
  }
  
</code></pre>
<p>We create an empty list and then parse statements and add them to the list until we reach the end of the block, marked by the closing }. Note that the loop also has an explicit check for isAtEnd(). We have to be careful to avoid infinite loops, even when parsing invalid code. If the user forgets a closing }, the parser needs to not get stuck.</p>
<p>Thatâ€™s it for syntax. For semantics, we add another visit method to Interpreter.</p>
<p>æˆ‘ä»¬åˆ›å»º1ä¸ªç©ºåˆ—è¡¨ï¼Œç„¶åè§£æè¯­å¥ï¼Œå¹¶ä¸”å°†å®ƒä»¬æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œç›´åˆ°åˆ°è¾¾å—çš„ç»“å°¾ï¼Œæ ‡è®°æ˜¯ }, æ³¨æ„ï¼Œå¾ªç¯è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶æ˜¯isAtEnd() , ä¸ºäº†é˜²æ­¢è¿›å…¥æ— é™å¾ªç¯ä¸­ï¼Œå³ä½¿åœ¨è§£ææ— æ•ˆä»£ç æ—¶å€™ä¹Ÿåº”è¯¥è¿™æ ·åšã€‚å¦‚æœç”¨æˆ·å¿˜è®°äº†å—ç»“å°¾çš„ }, ä»£ç ä¹Ÿä¸ä¼šä¸€ç›´å¾ªç¯ã€‚</p>
<p>è¿™å°±æ˜¯è¯­æ³•ï¼Œå¯¹äºè¯­ä¹‰ï¼Œæˆ‘ä»¬éœ€è¦å‘è§£é‡Šå™¨æ·»åŠ ä¸€ä¸ªæ–°çš„è®¿é—®æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after execute()

  @Override
  public Void visitBlockStmt(Stmt.Block stmt) {
    executeBlock(stmt.statements, new Environment(environment));
    return null;
  }
  
</code></pre>
<blockquote>
<p>Having block() return the raw list of statements and leaving it to statement() to wrap the list in a Stmt.Block looks a little odd. I did it that way because weâ€™ll reuse block() later for parsing function bodies and we donâ€™t want that body wrapped in a Stmt.Block.</p>
<p>è®©block() æ–¹æ³•è¿”å›åŸå§‹è¯­å¥åˆ—è¡¨ï¼Œå¹¶å°†å…¶ç•™ç»™statement() æ–¹æ³•ï¼Œå°†åˆ—è¡¨åŒ…è£…åœ¨ Stmt.Blockä¸­ï¼Œçœ‹èµ·æ¥æœ‰äº›æ€ªï¼Œæˆ‘è¿™æ ·åšæ˜¯å› ä¸ºç¨åï¼Œæˆ‘ä»¬å°†å¤ç”¨block() æ¥è§£æå‡½æ•°ä½“ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›å‡½æ•°ä½“åŒ…è£…åœ¨ Stmt.Block ä¸­ã€‚</p>
</blockquote>
<p>To execute a block, we create a new environment for the blockâ€™s scope and pass it off to this other method:</p>
<p>è¦æ‰§è¡Œä¸€ä¸ªå—ï¼Œæˆ‘ä»¬ä¸ºå—çš„ä½œç”¨åŸŸåˆ›å»ºä¸€ä¸ªæ–°çš„environmentï¼Œå¹¶å°†å…¶ä¼ é€’ç»™å¦ä¸€ä¸ªæ–¹æ³•</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after execute()

  void executeBlock(List&lt;Stmt&gt; statements,
                    Environment environment) {
    Environment previous = this.environment;
    try {
      this.environment = environment;

      for (Stmt statement : statements) {
        execute(statement);
      }
    } finally {
      this.environment = previous;
    }
  }
</code></pre>
<p>This new method executes a list of statements in the context of a given environment. Up until now, the environment field in Interpreter always pointed to the same environmentâ€”the global one. Now, that field represents the current environment. Thatâ€™s the environment that corresponds to the innermost scope containing the code to be executed.</p>
<p>To execute code within a given scope, this method updates the interpreterâ€™s environment field, visits all of the statements, and then restores the previous value. As is always good practice in Java, it restores the previous environment using a finally clause. That way it gets restored even if an exception is thrown.</p>
<p>è¿™ä¸ªæ–°æ–¹æ³•åœ¨ç»™å®šç¯å¢ƒçš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œè¯­å¥åˆ—è¡¨ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼ŒInterpreterä¸­çš„environment å­—æ®µï¼Œå§‹ç»ˆæŒ‡å‘çš„æ˜¯å…¨å±€å˜é‡ environment,ç°åœ¨ï¼Œè¯¥å­—æ®µï¼Œè¡¨ç¤ºçš„æ˜¯å½“å‰çš„environment, è¿™æ˜¯ä¸åŒ…å«è¦æ‰§è¡Œçš„ä»£ç çš„æœ€å†…éƒ¨èŒƒå›´å¯¹åº”çš„environment.</p>
<p>è¦åœ¨ç»™å®šèŒƒå›´å†…æ‰§è¡Œä»£ç ï¼Œæ­¤æ–¹æ³•ä¼šæ›´æ–° interpreterçš„ environmentå­—æ®µï¼Œè®¿é—®æ‰€æœ‰çš„è¯­å¥ï¼Œç„¶åå†æ¢å¤ environment ä¸ºä¹‹å‰çš„å€¼ï¼Œæ­£å¦‚Javaçš„è‰¯å¥½å®è·µä¸€æ ·ï¼Œå®ƒä½¿ç”¨ finallyå­å¥æ¢å¤ä»¥å‰çš„ç¯å¢ƒï¼Œè¿™æ ·ï¼Œå³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œå®ƒä¹Ÿèƒ½æ¢å¤</p>
<blockquote>
<p>Manually changing and restoring a mutable environment field feels inelegant. Another classic approach is to explicitly pass the environment as a parameter to each visit method. To â€œchangeâ€ the environment, you pass a different one as you recurse down the tree. You donâ€™t have to restore the old one, since the new one lives on the Java stack and is implicitly discarded when the interpreter returns from the blockâ€™s visit method.</p>
<p>æ‰‹åŠ¨æ›´æ”¹å’Œæ¢å¤ä¸€ä¸ªå¯å˜çš„environmentå­—æ®µçœ‹èµ·æ¥ä¸å¤ªåˆé€‚ï¼Œå¦ä¸€ç§ç»å…¸çš„æ–¹å¼æ˜¯ï¼Œå°†environmentå½“ä½œå‚æ•°ï¼Œæ˜¾å¼ä¼ é€’ç»™æ¯ä¸ªè®¿é—®æ–¹æ³•ï¼Œè¦æ”¹å˜ç¯å¢ƒï¼Œåœ¨æ ‘ä¸‹é€’å½’æ—¶å€™ä¼ é€’ä¸€ä¸ªä¸åŒçš„environment,æˆ‘ä»¬ä¸éœ€è¦æ¢å¤æ—§çš„ï¼Œå› ä¸ºæ–°çš„environment å­˜åœ¨äºJavaå †æ ˆä¸­ï¼Œå¹¶ä¸”å½“è§£é‡Šå™¨ä»å—çš„è®¿é—®æ–¹æ³•è¿”å›æ—¶å€™ï¼Œè¢«éšå¼çš„ä¸¢å¼ƒ</p>
<p>I considered that for jlox, but itâ€™s kind of tedious and verbose adding an environment parameter to every single visit method. To keep the book a little simpler, I went with the mutable field.</p>
<p>æˆ‘è€ƒè™‘åœ¨jloxä¸­è¿™æ ·å®ç°ï¼Œä½†æ˜¯åœ¨æ¯ä¸ªå•ç‹¬çš„è®¿é—®æ–¹æ³•ä¸­æ·»åŠ ä¸€ä¸ªenvironmentå‚æ•°æœ‰äº›å†—ä½™ä¹å‘³ï¼Œä¸ºäº†è®©æœ¬ä¹¦æ›´åŠ ç®€æ´ï¼Œæˆ‘ä½¿ç”¨äº†å¯å˜å­—æ®µã€‚</p>
</blockquote>
<p>Surprisingly, thatâ€™s all we need to do in order to fully support local variables, nesting, and shadowing. Go ahead and try this out:</p>
<p>ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œä¸ºäº†å®Œå…¨æ”¯æŒå±€éƒ¨å˜é‡ã€åµŒå¥—å’Œéšè—ï¼Œæˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯è¿™äº›ï¼Œç»§ç»­å°è¯•ä¸‹é¢ä»£ç </p>
<pre><code class="language-java">
var a = &quot;global a&quot;;
var b = &quot;global b&quot;;
var c = &quot;global c&quot;;
{
  var a = &quot;outer a&quot;;
  var b = &quot;outer b&quot;;
  {
    var a = &quot;inner a&quot;;
    print a;
    print b;
    print c;
  }
  print a;
  print b;
  print c;
}
print a;
print b;
print c;

</code></pre>
<p>Our little interpreter can remember things now. We are inching closer to something resembling a full-featured programming language.</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨ç°åœ¨èƒ½è®°ä½ä¸œè¥¿äº†ï¼Œæˆ‘ä»¬æ­£é€æ­¥æ¥è¿‘ä¸€é—¨åŠŸèƒ½é½å…¨çš„ç¼–ç¨‹è¯­è¨€ã€‚</p>
<h2 id="å…­challenges"><a class="header" href="#å…­challenges">å…­ã€CHALLENGES</a></h2>
<p>ä¹ é¢˜</p>
<ol>
<li>
<p>The REPL no longer supports entering a single expression and automatically printing its result value. Thatâ€™s a drag. Add support to the REPL to let users type in both statements and expressions. If they enter a statement, execute it. If they enter an expression, evaluate it and display the result value.</p>
<p>REPL ä¸å†æ”¯æŒè¾“å…¥å•ä¸ªè¡¨è¾¾å¼å¹¶ä¸”è‡ªåŠ¨æ‰“å°ç»“æœå€¼ï¼Œè¿™æ˜¯ä¸€ä¸ªä¼˜åŒ–ç‚¹ï¼Œå‘REPL æ·»åŠ æ”¯æŒï¼Œå…è®¸ç”¨æˆ·åŒæ—¶è¾“å…¥è¡¨è¾¾å¼å’Œè¯­å¥ï¼Œå¦‚æœè¾“å…¥ä¸€æ¡è¯­å¥ï¼Œç›´æ¥æ‰§è¡Œï¼Œå¦‚æœè¾“å…¥è¡¨è¾¾å¼ï¼Œè®¡ç®—è¡¨è¾¾å¼å€¼ï¼Œç„¶åè¾“å‡ºç»“æœã€‚</p>
</li>
<li>
<p>Maybe you want Lox to be a little more explicit about variable initialization. Instead of implicitly initializing variables to nil, make it a runtime error to access a variable that has not been initialized or assigned to, as in:</p>
<pre><code class="language-java">
// No initializers.
var a;
var b;

a = &quot;assigned&quot;;
print a; // OK, was assigned first.

print b; // Error!

</code></pre>
<p>ä¹Ÿè®¸æˆ‘ä»¬å¸Œæœ›Loxï¼Œåœ¨å˜é‡åˆå§‹åŒ–æ–¹é¢æ›´åŠ æ˜ç¡®ä¸€äº›ï¼Œä¸å…¶éšå¼çš„å°†å˜é‡åˆå§‹åŒ–ä¸ºnilï¼Œä¸å¦‚å°†è®¿é—®å°šæœªåˆå§‹åŒ–æˆ–è€…èµ‹å€¼çš„å˜é‡è®¾ç½®ä¸ºè¿è¡Œæ—¶é”™è¯¯</p>
</li>
<li>
<p>What does the following program do?</p>
<p>ä»¥ä¸‹ç¨‹åºåšä»€ä¹ˆï¼Ÿ</p>
<pre><code class="language-java">
var a = 1;
{
  var a = a + 2;
  print a;
}
</code></pre>
<p>What did you expect it to do? Is it what you think it should do? What does analogous code in other languages you are familiar with do? What do you think users will expect this to do?</p>
<p>ä½ å¸Œæœ›å®ƒåšä»€ä¹ˆï¼Ÿè¿™æ˜¯ä½ è®¤ä¸ºå®ƒåº”è¯¥åšçš„å—ï¼Ÿä½ ç†Ÿæ‚‰çš„å…¶ä»–è¯­è¨€ä¸­æ˜¯è¿™æ ·çš„å—ï¼Ÿä½ è®¤ä¸ºç”¨æˆ·å¸Œæœ›çš„è¿”å›ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿ</p>
</li>
</ol>
<h2 id="ä¸ƒdesign-note-implicit-variable-declaration"><a class="header" href="#ä¸ƒdesign-note-implicit-variable-declaration">ä¸ƒã€DESIGN NOTE: IMPLICIT VARIABLE DECLARATION</a></h2>
<p>è®¾è®¡æ€æƒ³: éšå¼å˜é‡å£°æ˜</p>
<p>Lox has distinct syntax for declaring a new variable and assigning to an existing one. Some languages collapse those to only assignment syntax. Assigning to a non-existent variable automatically brings it into being. This is called implicit variable declaration and exists in Python, Ruby, and CoffeeScript, among others. JavaScript has an explicit syntax to declare variables, but can also create new variables on assignment. Visual Basic has an option to enable or disable implicit variables.</p>
<p>When the same syntax can assign or create a variable, each language must decide what happens when it isnâ€™t clear about which behavior the user intends. In particular, each language must choose how implicit declaration interacts with shadowing, and which scope an implicitly declared variable goes into.</p>
<p>Lox åœ¨å£°æ˜æ–°çš„å˜é‡å’Œå¯¹å˜é‡èµ‹å€¼ï¼Œæœ‰ä¸åŒçš„è¯­æ³•ï¼Œæœ‰äº›è¯­è¨€å°†å®ƒä»¬åˆå¹¶ä¸ºä¸€ç§è¯­æ³•ï¼Œå¯¹ä¸€ä¸ªä¸å­˜åœ¨çš„å˜é‡èµ‹å€¼ï¼Œä¼šè‡ªåŠ¨å£°æ˜ã€‚è¿™ç§°ä¸ºéšå¼å˜é‡å£°æ˜ã€‚æ”¯æŒéšå¼å˜é‡å£°æ˜çš„è¯­è¨€æœ‰Python/Ruby/CoffeeScriptç­‰ç­‰ã€‚JavaScriptå…·æœ‰å£°æ˜å˜é‡çš„æ˜¾å¼è¯­æ³•ï¼Œä½†æ˜¯ä¹Ÿæ”¯æŒåœ¨å˜é‡èµ‹å€¼æ—¶å€™ç›´æ¥åˆ›å»ºã€‚Visual Basic å…·æœ‰ç¦ç”¨å¯ç”¨éšå¼å˜é‡å£°æ˜çš„é€‰é¡¹ã€‚</p>
<p>å½“ç›¸åŒçš„è¯­æ³•å¯ä»¥èµ‹å€¼æˆ–è€…åˆ›å»ºå˜é‡æ—¶å€™ï¼Œæ¯ç§è¯­è¨€å¿…é¡»å†³å®šåœ¨ä¸æ¸…æ¥šç”¨æˆ·æƒ³è¦çš„è¡Œä¸ºæ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿç‰¹åˆ«æ˜¯ï¼Œæ¯ç§è¯­è¨€éƒ½å¿…é¡»é€‰æ‹©éšå¼å˜é‡å£°æ˜ä¸é˜´å½±å¦‚ä½•äº¤äº’ï¼Ÿä»¥åŠéšå¼å£°æ˜çš„å˜é‡å±äºä»€ä¹ˆä½œç”¨åŸŸï¼Ÿ</p>
<ul>
<li>In Python, assignment always creates a variable in the current functionâ€™s scope, even if there is a variable with the same name declared outside of the function.</li>
</ul>
<p>åœ¨Pythonä¸­ï¼Œèµ‹å€¼æ€»æ˜¯åœ¨å½“å‰å‡½æ•°çš„ä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªå˜é‡ï¼Œå³ä½¿åœ¨å‡½æ•°å¤–éƒ¨å·²ç»å­˜åœ¨ä¸€ä¸ªåŒåçš„å˜é‡</p>
<ul>
<li>Ruby avoids some ambiguity by having different naming rules for local and global variables. However, blocks in Ruby (which are more like closures than like â€œblocksâ€ in C) have their own scope, so it still has the problem. Assignment in Ruby assigns to an existing variable outside of the current block if there is one with the same name. Otherwise, it creates a new variable in the current blockâ€™s scope.</li>
</ul>
<p>Rubyé€šè¿‡å¯¹å…¨å±€å˜é‡å’Œå±€éƒ¨å˜é‡ä½¿ç”¨ä¸åŒçš„å‘½åè§„åˆ™ï¼Œæ¥é¿å…ä¸€äº›æ­§ä¹‰ã€‚ç„¶è€Œï¼ŒRubyä¸­çš„å—ï¼ˆæ›´åƒæ˜¯é—­åŒ…è€Œä¸æ˜¯Cä¸­çš„å—ï¼‰æœ‰è‡ªå·±çš„ä½œç”¨åŸŸï¼Œæ‰€ä»¥å®ƒä»ç„¶å­˜åœ¨é—®é¢˜ã€‚å¦‚æœå­˜åœ¨åŒåçš„å˜é‡ï¼ŒRubyä¸­çš„èµ‹å€¼ï¼Œå°†ä¼šèµ‹å€¼ç»™å½“å‰å—å¤–éƒ¨çš„åŒåå˜é‡ã€‚å¦åˆ™ï¼Œå¦‚æœå½“å‰å—çš„å¤–éƒ¨ä¸å­˜åœ¨åŒåå˜é‡ï¼Œæˆ‘ä»¬å°†åœ¨å½“å‰å—çš„ä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ã€‚</p>
<ul>
<li>
<p>CoffeeScript, which takes after Ruby in many ways, is similar. It explicitly disallows shadowing by saying that assignment always assigns to a variable in an outer scope if there is one, all the way up to the outermost global scope. Otherwise, it creates the variable in the current function scope.</p>
<p>CoffeeScriptåœ¨å¾ˆå¤šæ–¹é¢éƒ½å’ŒRubyç›¸åŒï¼Œå®ƒæ˜ç¡®ç¦æ­¢é˜´å½±ï¼Œè¡¨è¾¾å¼èµ‹å€¼æ€»æ˜¯åˆ†é…ç»™å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œä¸€ç›´åˆ°æœ€å¤–å±‚çš„å…¨å±€ä½œç”¨åŸŸï¼Œå¦åˆ™ï¼Œå®ƒå°†åœ¨å½“å‰å‡½æ•°ä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ã€‚</p>
</li>
<li>
<p>In JavaScript, assignment modifies an existing variable in any enclosing scope, if found. If not, it implicitly creates a new variable in the global scope.</p>
<p>åœ¨JavaScriptä¸­ï¼Œèµ‹å€¼ä¼šä¿®æ”¹å°é—­ä½œç”¨åŸŸå†…çš„å·²ç»å­˜åœ¨çš„å˜é‡ï¼Œå¦‚æœèƒ½æ‰¾åˆ°ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°†åœ¨å…¨å±€èŒƒå›´å†…ï¼Œéšå¼åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ã€‚</p>
</li>
</ul>
<p>The main advantage to implicit declaration is simplicity. Thereâ€™s less syntax and no â€œdeclarationâ€ concept to learn. Users can just start assigning stuff and the language figures it out.</p>
<p>Older, statically typed languages like C benefit from explicit declaration because they give the user a place to tell the compiler what type each variable has and how much storage to allocate for it. In a dynamically typed, garbage-collected language, that isnâ€™t really necessary, so you can get away with making declarations implicit. It feels a little more â€œscriptyâ€, more â€œyou know what I meanâ€.</p>
<p>éšå¼å˜é‡å£°æ˜çš„ä¼˜ç‚¹æ˜¯ç®€å•ï¼Œè¯­æ³•æ›´å°‘ï¼Œä¹Ÿä¸éœ€è¦å­¦ä¹ &quot;å£°æ˜&quot; ç­‰æœ¯è¯­ï¼Œç”¨æˆ·åªéœ€è¦èµ‹å€¼ï¼Œè¯­è¨€å°†ä¼šè§£å†³å£°æ˜ã€‚</p>
<p>è€çš„é™æ€ç±»å‹è¯­è¨€ï¼Œä¾‹å¦‚Cï¼Œä»æ˜¾å¼å£°æ˜ä¸­å—ç›Šï¼Œå› ä¸ºå®ƒä»¬ä¸ºç”¨æˆ·æä¾›äº†ä¸€ä¸ªåœ°æ–¹ï¼Œå¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæ¯ä¸ªå˜é‡çš„ç±»å‹ï¼Œä»¥åŠä¸ºå…¶åˆ†é…çš„å­˜å‚¨ç©ºé—´ã€‚åœ¨åŠ¨æ€ç±»å‹ï¼Œæ”¯æŒåƒåœ¾æ”¶é›†çš„è¯­è¨€ä¸­ï¼Œå˜é‡æ˜¾å¼å£°æ˜ï¼Œå¹¶ä¸æ˜¯å¿…é¡»çš„ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨éšå¼å˜é‡å£°æ˜ï¼Œ</p>
<p>But is that a good idea? Implicit declaration has some problems.</p>
<p>éšå¼å˜é‡å£°æ˜æ˜¯ä¸€ä¸ªå¥½ä¸»æ„å—ï¼Ÿå®é™…ä¸Šï¼Œå®ƒå­˜åœ¨ä¸€äº›é—®é¢˜ã€‚</p>
<ul>
<li>A user may intend to assign to an existing variable, but may have misspelled it. The interpreter doesnâ€™t know that, so it goes ahead and silently creates some new variable and the variable the user wanted to assign to still has its old value. This is particularly heinous in JavaScript where a typo will create a global variable, which may in turn interfere with other code.</li>
</ul>
<p>ç”¨æˆ·å¯èƒ½æ‰“ç®—å¯¹ä¸€ä¸ªå·²æœ‰å˜é‡èµ‹å€¼ï¼Œä½†æ˜¯å¯èƒ½æ‹¼é”™äº†ã€‚è§£é‡Šå™¨å¹¶ä¸çŸ¥é“ï¼Œæ‰€ä»¥ä¼šè‡ªåŠ¨åˆ›å»ºä¸€äº›æ–°çš„å˜é‡ã€‚è€Œç”¨æˆ·æƒ³è¦æ›´æ–°çš„å˜é‡æ²¡æœ‰å˜åŒ–ï¼Œè¿™åœ¨JavaScriptä¸­æ›´åŠ çªå‡ºï¼Œå› ä¸ºæ‹¼å†™é”™è¯¯ï¼Œä¼šåˆ›å»ºä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå¯èƒ½ä¼šå½±å“å…¶ä»–ä»£ç </p>
<ul>
<li>
<p>JS, Ruby, and CoffeeScript use the presence of an existing variable with the same nameâ€”even in an outer scopeâ€”to determine whether or not an assignment creates a new variable or assigns to an existing one. That means adding a new variable in a surrounding scope can change the meaning of existing code. What was once a local variable may silently turn into an assignment to that new outer variable.</p>
<p>JS,Ruby, CoffeeScript ä¸­ï¼Œé€šè¿‡åˆ¤æ–­ï¼Œå½“å‰å˜é‡æ˜¯å¦å­˜åœ¨ï¼ˆå³ä½¿å­˜åœ¨äºå¤–éƒ¨ä½œç”¨åŸŸä¸­ï¼‰ï¼Œæ¥å†³å®šåˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡è¿˜æ˜¯èµ‹å€¼ç»™ç°æœ‰å˜é‡ï¼Œè¿™æ„å‘³ç€åœ¨é™„è¿‘ä½œç”¨åŸŸä¸­æ·»åŠ æ–°å˜é‡ï¼Œå¯èƒ½ä¼šæ”¹å˜ç°æœ‰ä»£ç çš„å«ä¹‰ã€‚æ›¾ç»æ˜¯å±€éƒ¨å˜é‡çš„å†…å®¹å¯èƒ½ä¼šé»˜é»˜å˜ä¸ºå¯¹æ–°çš„å¤–éƒ¨å˜é‡çš„èµ‹å€¼ã€‚</p>
</li>
<li>
<p>In Python, you may want to assign to some variable outside of the current function instead of creating a new variable in the current one, but you canâ€™t.</p>
<p>åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¸Œæœ›èµ‹å€¼ç»™å½“å‰å‡½æ•°ä¹‹å¤–çš„æŸä¸ªå˜é‡ï¼Œè€Œä¸æ˜¯å‡½æ•°ä¸­æ–°åˆ›å»ºçš„å˜é‡ï¼Œä½†æ˜¯æ— æ³•å®ç°ã€‚</p>
</li>
</ul>
<p>Over time, the languages I know with implicit variable declaration ended up adding more features and complexity to deal with these problems.</p>
<p>éšç€æ—¶é—´çš„æ¨ç§»ï¼Œæˆ‘æ‰€çŸ¥é“çš„æ”¯æŒéšå¼å˜é‡å£°æ˜çš„è¯­è¨€ï¼Œæœ€ç»ˆå¢åŠ äº†æ›´å¤šçš„ç‰¹æ€§å’Œå¤æ‚æ€§æ¥å¤„ç†ï¼Œè¿™äº›é—®é¢˜ã€‚</p>
<ul>
<li>
<p>Implicit declaration of global variables in JavaScript is universally considered a mistake today. â€œStrict modeâ€ disables it and makes it a compile error.</p>
<p>JavaScript çš„å…¨å±€å˜é‡çš„éšå¼å£°æ˜ï¼Œè¢«æ™®éè®¤ä¸ºæ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œä¸¥æ ¼æ¨¡å¼å·²ç»ç¦ç”¨ï¼Œå¹¶ä¸”æŠŠå®ƒå½“ä½œä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚</p>
</li>
<li>
<p>Python added a global statement to let you explicitly assign to a global variable from within a function. Later, as functional programming and nested functions became more popular, they added a similar nonlocal statement to assign to variables in enclosing functions.</p>
<p>Pythonæ·»åŠ äº†ä¸€ä¸ª global è¯­å¥ï¼Œå…è®¸æˆ‘ä»¬åœ¨å†…éƒ¨å‡½æ•°ä¸­ï¼Œæ˜¾å¼çš„å¯¹å…¨å±€å˜é‡èµ‹å€¼ï¼Œåæ¥ï¼Œéšç€å‡½æ•°å¼ç¼–ç¨‹å’ŒåµŒå¥—å‡½æ•°è¶Šæ¥è¶Šæµè¡Œï¼ŒPython æ·»åŠ äº†ä¸€ä¸ªç±»å‹çš„è¯­å¥ nonlocal ï¼Œå¯¹å°é—­å‡½æ•°ä¸­çš„å˜é‡è¿›è¡Œèµ‹å€¼ã€‚</p>
</li>
<li>
<p>Ruby extended its block syntax to allow declaring certain variables to be explicitly local to the block even if the same name exists in an outer scope.</p>
<p>Ruby æ‰©å±•äº†è¯­æ³•ï¼Œå…è®¸å£°æ˜æŸäº›å˜é‡ä¸ºå—çš„æ˜¾å¼æœ¬åœ°å˜é‡ï¼Œå³ä½¿åœ¨å¤–éƒ¨ä½œç”¨åŸŸä¸­å­˜åœ¨ç›¸åŒåç§°çš„å˜é‡ã€‚</p>
</li>
</ul>
<p>Given those, I think the simplicity argument is mostly lost. There is an argument that implicit declaration is the right default but I personally find that less compelling.</p>
<p>My opinion is that implicit declaration made sense in years past when most scripting languages were heavily imperative and code was pretty flat. As programmers have gotten more comfortable with deep nesting, functional programming, and closures, itâ€™s become much more common to want access to variables in outer scopes. That makes it more likely that users will run into the tricky cases where itâ€™s not clear whether they intend their assignment to create a new variable or reuse a surrounding one.</p>
<p>So I prefer explicitly declaring variables, which is why Lox requires it.</p>
<p>è€ƒè™‘åˆ°è¿™äº›ï¼Œæˆ‘è®¤ä¸ºéšå¼å˜é‡å£°æ˜ç®€å•æ€§çš„ä¼˜ç‚¹å®é™…æ˜¯é”™è¯¯çš„ï¼Œæœ‰ä¸€ç§è§‚ç‚¹è®¤ä¸ºï¼Œéšå¼å˜é‡å£°æ˜æ˜¯æ­£ç¡®çš„é»˜è®¤æ–¹å¼ï¼Œæˆ‘ä¸ªäººä¸è¿™ä¹ˆè®¤ä¸ºã€‚</p>
<p>æˆ‘çš„è§‚ç‚¹æ˜¯ï¼Œåœ¨è¿‡å»çš„å‡ å¹´ä¸­ï¼Œéšå¼å£°æ˜æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå½“æ—¶å¤§å¤šæ•°çš„è„šæœ¬è¯­è¨€éƒ½æ˜¯å¿…è¦çš„ï¼Œè€Œä¸”ä»£ç è¯­æ³•éƒ½éå¸¸ç®€å•ï¼Œéšç€ç¨‹åºå‘˜è¶Šæ¥è¶Šç†Ÿæ‚‰æ·±åº¦åµŒå¥—ã€å‡½æ•°å¼ç¼–ç¨‹ã€é—­åŒ…ï¼Œæƒ³è¦è®¿é—®å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡çš„éœ€æ±‚è¶Šæ¥è¶Šæ™®éï¼Œè¿™ä½¿å¾—ç”¨æˆ·æ›´æœ‰å¯èƒ½é‡åˆ°æ£˜æ‰‹çš„çŠ¶å†µï¼Œå³ä»–ä»¬ä¸æ¸…æ¥šè‡ªå·±çš„èµ‹å€¼æ˜¯åˆ›å»ºæ–°çš„å˜é‡ï¼Œè¿˜æ˜¯å¯¹å‘¨å›´çš„åŒåå˜é‡èµ‹å€¼</p>
<p>æ‰€ä»¥ï¼Œæˆ‘æ›´å–œæ¬¢æ˜¾å¼å£°æ˜å˜é‡ï¼Œè¿™å°±æ˜¯Loxéœ€è¦æ˜¾å¼å£°æ˜çš„åŸå› ã€‚</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tree/evaluating-expression.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tree/evaluating-expression.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../giscus.js"></script>


    </body>
</html>
