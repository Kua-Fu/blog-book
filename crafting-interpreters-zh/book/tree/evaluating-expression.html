<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4717236929129160"
     crossorigin="anonymous"></script>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>è®¡ç®—è¡¨è¾¾å¼ - crafting-interpreters-zh</title>


        <!-- Custom HTML head -->
	<script src="https://static.guance.com/browser-sdk/v2/dataflux-rum.js" type="text/javascript"></script>
	<script>
	window.DATAFLUX_RUM &&
	window.DATAFLUX_RUM.init({
	applicationId: 'thewind_blog',
	datakitOrigin: 'https://www.poetries.cn/rum', 
	env: 'production',
	version: '1.0.0',
	trackInteractions: true,
	traceType: 'ddtrace',
	allowedTracingOrigins: [/https:\/\/.*\.poetries\.cn/, "https://poetries.cn"], 
	})
	</script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MMN1K84KRS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-MMN1K84KRS');
</script>


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../index.html">å‰è¨€</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">æ¬¢è¿</li><li class="chapter-item "><a href="../welcome/welcome.html"><strong aria-hidden="true">1.</strong> æ¬¢è¿</a></li><li class="chapter-item "><a href="../welcome/introduction.html"><strong aria-hidden="true">2.</strong> ä»‹ç»</a></li><li class="chapter-item "><a href="../welcome/a-map-of-the-territory.html"><strong aria-hidden="true">3.</strong> æ€»è§ˆå›¾</a></li><li class="chapter-item "><a href="../welcome/the-lox-language.html"><strong aria-hidden="true">4.</strong> Loxè¯­è¨€</a></li><li class="chapter-item affix "><li class="part-title">è§£ææ ‘</li><li class="chapter-item "><a href="../tree/tree.html"><strong aria-hidden="true">5.</strong> è§£ææ ‘</a></li><li class="chapter-item "><a href="../tree/scanning.html"><strong aria-hidden="true">6.</strong> æ‰«æ</a></li><li class="chapter-item "><a href="../tree/representing-code.html"><strong aria-hidden="true">7.</strong> ä»£ç è¡¨ç¤º</a></li><li class="chapter-item "><a href="../tree/parsing-expression.html"><strong aria-hidden="true">8.</strong> è§£æè¡¨è¾¾å¼</a></li><li class="chapter-item expanded "><a href="../tree/evaluating-expression.html" class="active"><strong aria-hidden="true">9.</strong> è®¡ç®—è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="../tree/statements-and-state.html"><strong aria-hidden="true">10.</strong> è¯­å¥å’ŒçŠ¶æ€</a></li><li class="chapter-item "><a href="../tree/control-flow.html"><strong aria-hidden="true">11.</strong> æ§åˆ¶æµç¨‹</a></li><li class="chapter-item "><a href="../tree/functions.html"><strong aria-hidden="true">12.</strong> å‡½æ•°</a></li><li class="chapter-item "><a href="../tree/resolving-and-binding.html"><strong aria-hidden="true">13.</strong> è§£æä¸ç»‘å®š</a></li><li class="chapter-item "><a href="../tree/classes.html"><strong aria-hidden="true">14.</strong> ç±»</a></li><li class="chapter-item "><a href="../tree/inheritance.html"><strong aria-hidden="true">15.</strong> ç»§æ‰¿</a></li><li class="chapter-item affix "><li class="part-title">è™šæ‹Ÿæœº</li><li class="chapter-item "><a href="../vm/bytecode-vm.html"><strong aria-hidden="true">16.</strong> è™šæ‹Ÿæœº</a></li><li class="chapter-item "><a href="../vm/bytecode-chunk.html"><strong aria-hidden="true">17.</strong> å­—èŠ‚ç å—</a></li><li class="chapter-item "><a href="../vm/a-virtual-machine.html"><strong aria-hidden="true">18.</strong> ä¸€ä¸ªè™šæ‹Ÿæœº</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">crafting-interpreters-zh</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/Kua-Fu/blog-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>


                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="è®¡ç®—è¡¨è¾¾å¼"><a class="header" href="#è®¡ç®—è¡¨è¾¾å¼">è®¡ç®—è¡¨è¾¾å¼</a></h1>
<blockquote>
<p>You are my creator, but I am your master; Obey!</p>
<p>ä½ æ˜¯æˆ‘çš„åˆ›é€ è€…ï¼Œä½†æˆ‘æ˜¯ä½ çš„ä¸»äººï¼Œæœä»å§ï¼</p>
<p align="right">â€”â€” Mary Shelley, Frankenstein ç›ä¸½.é›ªè±çš„ã€Šç§‘å­¦æ€ªäººã€‹ </p>
</blockquote>
<p>If you want to properly set the mood for this chapter, try to conjure up a thunderstorm, one of those swirling tempests that likes to yank open shutters at the climax of the story. Maybe toss in a few bolts of lightning. In this chapter, our interpreter will take breath, open its eyes, and execute some code.</p>
<p>å¦‚æœä½ æƒ³è¦ä¸ºè¿™ä¸€ç« æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„è®¾å®šæ°›å›´ï¼Œè¯•ç€æƒ³è±¡ä¸€åœºé›·é›¨ï¼Œä¸€åœºå–œæ¬¢åœ¨æ•…äº‹é«˜æ½®æ—¶å€™ï¼Œå¹å¼€ç™¾å¶çª—çš„æ—‹è½¬é£æš´ï¼Œä¹Ÿè®¸è¿˜ä¼šæ‰”å‡ºå‡ ä¸ªé—ªç”µï¼Œå“ˆå“ˆã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨å°†å±ä½å‘¼å¸ï¼Œçå¼€çœ¼ç›ï¼Œæ‰§è¡Œä¸€äº›ä»£ç ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lightning.png?raw=true" alt="lightning" /></p>
<blockquote>
<p>A decrepit Victorian mansion is optional, but adds to the ambiance.</p>
<p>ä¸€åº§ç ´æ—§çš„ç»´å¤šåˆ©äºšå¼è±ªå®…æ˜¯å¯é€‰çš„ï¼Œä½†æ˜¯å¢åŠ äº†æ°›å›´ã€‚</p>
</blockquote>
<p>There are all manner of ways that language implementations make a computer do what the userâ€™s source code commands. They can compile it to machine code, translate it to another high-level language, or reduce it to some bytecode format for a virtual machine to run. For our first interpreter, though, we are going to take the simplest, shortest path and execute the syntax tree itself.</p>
<p>è®©è®¡ç®—æœºæ‰§è¡Œç”¨æˆ·æºä»£ç çš„ï¼Œè¯­è¨€å®ç°æ–¹å¼å¤šç§å¤šæ ·ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶ç¼–è¯‘ä¸ºæœºå™¨ç ï¼Œå°†å…¶ç¿»è¯‘ä¸ºå¦å¤–ä¸€é—¨é«˜çº§è¯­è¨€ï¼Œæˆ–è€…å°†å…¶ç®€åŒ–ä¸ºæŸç§å­—èŠ‚ç æ ¼å¼ï¼Œä»¥ä¾›è™šæ‹Ÿæœºè¿è¡Œï¼Œç„¶è€Œï¼Œå¯¹äºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªè§£é‡Šå™¨ï¼Œæˆ‘ä»¬å°†é‡‡ç”¨æœ€ç®€å•ï¼Œæœ€çŸ­çš„è·¯å¾„ï¼Œæ‰§è¡Œè¯­æ³•æ ‘æœ¬èº«ã€‚</p>
<p>Right now, our parser only supports expressions. So, to â€œexecuteâ€ code, we will evaluate an expression and produce a value. For each kind of expression syntax we can parseâ€”literal, operator, etc.â€”we need a corresponding chunk of code that knows how to evaluate that tree and produce a result. That raises two questions:</p>
<ol>
<li>
<p>What kinds of values do we produce?</p>
</li>
<li>
<p>How do we organize those chunks of code?</p>
</li>
</ol>
<p>Taking them on one at a timeâ€‰.â€‰.â€‰. </p>
<p>å½“å‰ï¼Œæˆ‘ä»¬çš„è§£æå™¨åªæ”¯æŒè§£æè¡¨è¾¾å¼ï¼Œæ‰€ä»¥ï¼Œæ‰§è¡Œä»£ç ï¼Œè¡¨ç¤ºæˆ‘ä»¬å°†è®¡ç®—è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ç”Ÿæˆå€¼ã€‚å¯¹äºæ¯ä¸€ç§è¡¨è¾¾å¼è¯­æ³•ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥è§£ææ–‡å­—ã€è¿ç®—ç¬¦ç­‰ç­‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸€æ®µç›¸åº”çš„ä»£ç ï¼ŒçŸ¥é“å¦‚ä½•è®¡ç®—è¯­æ³•æ ‘ï¼Œå¹¶ä¸”è¿”å›è®¡ç®—ç»“æœã€‚è¿™å¼•å‘äº†ä¸¤ä¸ªé—®é¢˜ï¼š</p>
<ol>
<li>
<p>æˆ‘ä»¬å°†è®¡ç®—å‡ºä»€ä¹ˆå€¼</p>
</li>
<li>
<p>æˆ‘ä»¬å¦‚ä½•ç»„ç»‡ä»£ç </p>
</li>
</ol>
<p>è®©æˆ‘ä»¬ä¸€ä¸ªä¸ªè§£å†³é—®é¢˜ã€‚</p>
<h2 id="ä¸€representing-values"><a class="header" href="#ä¸€representing-values">ä¸€ã€Representing Values</a></h2>
<p>è¡¨ç¤ºè®¡ç®—å€¼</p>
<p>In Lox, values are created by literals, computed by expressions, and stored in variables. The user sees these as Lox objects, but they are implemented in the underlying language our interpreter is written in. That means bridging the lands of Loxâ€™s dynamic typing and Javaâ€™s static types. A variable in Lox can store a value of any (Lox) type, and can even store values of different types at different points in time. What Java type might we use to represent that?</p>
<p>åœ¨Loxä¸­ï¼Œå€¼ç”±æ–‡å­—åˆ›å»ºï¼Œè¡¨è¾¾å¼è®¡ç®—ï¼Œä¿å­˜åœ¨å˜é‡ä¸­ã€‚ç”¨æˆ·å°†è®¡ç®—å€¼å½“ä½œLoxä¸­çš„å¯¹è±¡ï¼Œä½†æ˜¯å®ƒä»¬æ˜¯ç”±è§£é‡Šå™¨åº•å±‚ç¼–å†™è¯­è¨€å®ç°çš„ã€‚è¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬åœ¨LoxåŠ¨æ€è¯­è¨€å’ŒJavaé™æ€è¯­è¨€ä¹‹é—´ï¼Œæ­å»ºäº†ä¸€åº§æ¡¥æ¢ã€‚Loxä¸­çš„å˜é‡å¯ä»¥ä¿å­˜ä»»ä½•Loxç±»å‹çš„å€¼ï¼Œç”šè‡³å¯ä»¥åœ¨ä¸åŒçš„æ—¶é—´ç‚¹å­˜å‚¨ä¸åŒçš„ç±»å‹çš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨Javaä¸­çš„ä»€ä¹ˆç±»å‹è¡¨ç¤ºå‘¢ï¼Ÿ</p>
<blockquote>
<p>Here, Iâ€™m using â€œvalueâ€ and â€œobjectâ€ pretty much interchangeably.</p>
<p>Later in the C interpreter weâ€™ll make a slight distinction between them, but thatâ€™s mostly to have unique terms for two different corners of the implementationâ€”in-place versus heap-allocated data. From the userâ€™s perspective, the terms are synonymous.</p>
<p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ value å’Œ objectå½“ä½œç›¸åŒçš„ä¸œè¥¿</p>
<p>ç¨åï¼Œåœ¨Cè§£é‡Šå™¨ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹å®ƒä»¬è¿›è¡Œç»†å¾®çš„åŒºåˆ†ï¼Œä½†æ˜¯ï¼Œè¿™åªæ˜¯ä¸ºäº†ä½¿å¾—ä¸¤ç§ä¸åŒçš„å®ç°æ–¹å¼ï¼ˆæ ˆåˆ†é…ã€å †åˆ†é…ï¼‰ï¼Œæœ‰ä¸åŒçš„å”¯ä¸€æœ¯è¯­ï¼Œä»ç”¨æˆ·çš„è§’åº¦ï¼Œå®ƒä»¬æ˜¯åŒä¸€å«ä¹‰ã€‚</p>
</blockquote>
<p>Given a Java variable with that static type, we must also be able to determine which kind of value it holds at runtime. When the interpreter executes a + operator, it needs to tell if it is adding two numbers or concatenating two strings. Is there a Java type that can hold numbers, strings, Booleans, and more? Is there one that can tell us what its runtime type is? There is! Good old java.lang.Object.</p>
<p>ç»™å®šä¸€ä¸ªå…·æœ‰é™æ€ç±»å‹çš„Javaå˜é‡ï¼Œæˆ‘ä»¬è¿˜å¿…é¡»èƒ½å¤Ÿç¡®å®šå®ƒåœ¨è¿è¡Œæ—¶å€™ï¼ŒæŒæœ‰å“ªç§ç±»å‹çš„å€¼ã€‚å½“è§£é‡Šå™¨æ‰§è¡Œ+ è¿ç®—æ—¶å€™ï¼Œå®ƒéœ€è¦åˆ¤æ–­æ˜¯ä¸¤ä¸ªæ•°å­—çš„åŠ æ³•ï¼Œè¿˜æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²çš„è¿æ¥ã€‚æ˜¯å¦æœ‰ä¸€ç§Javaç±»å‹ï¼Œå¯ä»¥ä¿å­˜æ•°å­—ã€å­—ç¬¦ä¸²ã€å¸ƒå°”å€¼ç­‰ï¼Œæœ‰æ²¡æœ‰ä¸€ä¸ªå¯ä»¥å‘ŠçŸ¥æˆ‘ä»¬è¿è¡Œæ—¶å€™ï¼Œæ˜¯ä»€ä¹ˆç±»å‹çš„Javaç±»å‹ï¼Œå½“ç„¶æœ‰ï¼Œå®ƒå°±æ˜¯Javaä¸­çš„ Objectç±»å‹ã€‚</p>
<p>In places in the interpreter where we need to store a Lox value, we can use Object as the type. Java has boxed versions of its primitive types that all subclass Object, so we can use those for Loxâ€™s built-in types:</p>
<p>åœ¨è§£é‡Šå™¨ä¸­ï¼Œéœ€è¦ä¿å­˜Loxå€¼çš„åœ°æ–¹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Objectå½“ä½œç±»å‹ï¼ŒJavaæœ‰å…¶æ‰€æœ‰åŸå§‹ç±»å‹ï¼Œå¯¹åº”çš„Objectå­ç±»ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬å½“ä½œLoxè¯­è¨€çš„å†…ç½®ç±»å‹ã€‚</p>
<table><thead><tr><th>Lox Type</th><th>Java representation</th></tr></thead><tbody>
<tr><td>Any Lox value</td><td>Object</td></tr>
<tr><td>nil</td><td>null</td></tr>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>number</td><td>double</td></tr>
<tr><td>string</td><td>String</td></tr>
</tbody></table>
<p>Given a value of static type Object, we can determine if the runtime value is a number or a string or whatever using Javaâ€™s built-in instanceof operator. In other words, the JVMâ€™s own object representation conveniently gives us everything we need to implement Loxâ€™s built-in types. Weâ€™ll have to do a little more work later when we add Loxâ€™s notions of functions, classes, and instances, but Object and the boxed primitive classes are sufficient for the types we need right now.</p>
<p>ç»™å®šä¸€ä¸ªé™æ€ç±»å‹çš„å¯¹è±¡ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Javaå†…ç½®çš„ instanceof æ“ä½œç¬¦ï¼Œæ¥ç¡®å®šè¿è¡Œæ—¶å€™ï¼Œè¯¥å¯¹è±¡çš„å€¼æ˜¯æ•°å­—ã€å­—ç¬¦ä¸²è¿˜æ˜¯å…¶ä»–ä»€ä¹ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒJVMè‡ªå·±çš„å¯¹è±¡è¡¨ç¤ºï¼Œå¯ä»¥æ–¹ä¾¿çš„ä¸ºæˆ‘ä»¬æä¾›å®ç°Lox å†…ç½®ç±»å‹çš„ä¸€åˆ‡ã€‚ç¨åï¼Œå½“æˆ‘ä»¬æ·»åŠ Loxçš„å‡½æ•°ã€ç±»ã€å®ä¾‹æ—¶å€™ï¼Œæˆ‘ä»¬å°†éœ€è¦åšæ›´å¤šçš„å·¥ä½œï¼Œä½†æ˜¯ï¼ŒObject å’Œ å°è£…çš„åŸå§‹ç±»ï¼Œå¯¹äºæˆ‘ä»¬éœ€è¦çš„ç±»å‹å·²ç»è¶³å¤Ÿäº†ã€‚</p>
<blockquote>
<p>Another thing we need to do with values is manage their memory, and Java does that too. A handy object representation and a really nice garbage collector are the main reasons weâ€™re writing our first interpreter in Java.</p>
<p>å¯¹äºå€¼ï¼Œæˆ‘ä»¬éœ€è¦åšçš„ä¸€ä»¶äº‹æƒ…æ˜¯ï¼Œç®¡ç†å®ƒä»¬çš„å†…å­˜ï¼ŒJavaä¹Ÿè¿™æ ·åšï¼Œæ–¹ä¾¿çš„å¯¹è±¡è¡¨ç¤ºå’Œéå¸¸å¥½çš„åƒåœ¾å›æ”¶ï¼Œæ˜¯æˆ‘ä»¬ç”¨Javaç¼–å†™ç¬¬ä¸€ä¸ªè§£é‡Šå™¨çš„ä¸»è¦åŸå› </p>
</blockquote>
<h2 id="äºŒevaluating-expressions"><a class="header" href="#äºŒevaluating-expressions">äºŒã€Evaluating Expressions</a></h2>
<p>è®¡ç®—è¡¨è¾¾å¼</p>
<p>Next, we need blobs of code to implement the evaluation logic for each kind of expression we can parse. We could stuff that code into the syntax tree classes in something like an interpret() method. In effect, we could tell each syntax tree node, â€œInterpret thyselfâ€. This is the Gang of Fourâ€™s Interpreter design pattern. Itâ€™s a neat pattern, but like I mentioned earlier, it gets messy if we jam all sorts of logic into the tree classes.</p>
<p>Instead, weâ€™re going to reuse our groovy Visitor pattern. In the previous chapter, we created an AstPrinter class. It took in a syntax tree and recursively traversed it, building up a string which it ultimately returned. Thatâ€™s almost exactly what a real interpreter does, except instead of concatenating strings, it computes values.</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦å†™ä»£ç ï¼Œå®ç°æˆ‘ä»¬å¯ä»¥è§£æçš„æ¯ä¸€ç§è¡¨è¾¾å¼çš„æ±‚å€¼é€»è¾‘ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ç±»ä¼¼äº interpret()æ–¹æ³•çš„æ–¹å¼ï¼Œå°†ä»£ç å¡«å†™åˆ°è¯­æ³•æ ‘ç±»ä¸­ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å‘Šè¯‰æ¯ä¸€ä¸ªè¯­æ³•æ ‘èŠ‚ç‚¹ï¼Œè§£é‡Šè‡ªå·±ã€‚è¿™æ˜¯è®¾è®¡æ¨¡å¼ä¹¦ç±ä¸­çš„<a href="https://en.wikipedia.org/wiki/Interpreter_pattern">è§£æå™¨æ¨¡å¼</a>, è¿™æ˜¯ä¸€ä¸ªæ•´æ´çš„æ¨¡å¼ï¼Œä½†æ˜¯ï¼Œæ­£å¦‚æˆ‘å‰é¢æåˆ°çš„ï¼Œå¦‚æœæˆ‘ä»¬æŠŠå„ç§é€»è¾‘éƒ½å¡åˆ°è¯­æ³•æ ‘ç±»ä¸­ï¼Œå°±ä¼šå˜å¾—éå¸¸æ··ä¹±ã€‚</p>
<p>ç›¸åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ›´åŠ å¸¸è§„çš„è®¿é—®è€…æ¨¡å¼ï¼Œåœ¨å…ˆå‰ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª AstPrinterç±»ï¼Œå®ƒæ¥å—ä¸€ä¸ªè¯­æ³•æ ‘ï¼Œç„¶åé€’å½’éå†å®ƒï¼Œæ„å»ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”æœ€ç»ˆè¿”å›è¿™ä¸ªå­—ç¬¦ä¸²ã€‚è¿™å‡ ä¹æ˜¯ï¼ŒçœŸæ­£çš„è§£é‡Šå™¨æ‰€åšçš„ï¼Œåªæ˜¯å®ƒä¸æ˜¯è¿æ¥å­—ç¬¦ä¸²ï¼Œè€Œæ˜¯è®¡ç®—å€¼ã€‚</p>
<p>We start with a new class.</p>
<p>æˆ‘ä»¬æ–°å»ºä¸€ä¸ªç±»</p>
<pre><code class="language-java">
// lox/Interpreter.java, create new file

package com.craftinginterpreters.lox;

class Interpreter implements Expr.Visitor&lt;Object&gt; {
}

</code></pre>
<p>The class declares that itâ€™s a visitor. The return type of the visit methods will be Object, the root class that we use to refer to a Lox value in our Java code. To satisfy the Visitor interface, we need to define visit methods for each of the four expression tree classes our parser produces. Weâ€™ll start with the simplestâ€‰.â€‰.â€‰. </p>
<p>Interpreterç±»ï¼Œå£°æ˜äº†å®ƒæ˜¯è®¿é—®è€…ï¼Œè®¿é—®æ–¹æ³•çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªobjectç±»å‹ï¼Œè¿™æ˜¯æˆ‘ä»¬Javaä»£ç ä¸­ç”¨æ¥å¼•ç”¨Loxå€¼çš„æ ¹ç±»ã€‚ä¸ºäº†æ»¡è¶³Visitoræ¥å£ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºè§£æå™¨ç”Ÿæˆçš„4ä¸ªè¡¨è¾¾å¼æ ‘ç±»ä¸­çš„æ¯ä¸€ä¸ªå®šä¹‰è®¿é—®æ–¹æ³•ï¼Œè®©æˆ‘ä»¬ä»æœ€ç®€å•çš„å¼€å§‹...</p>
<h3 id="21-evaluating-literals"><a class="header" href="#21-evaluating-literals">2.1 Evaluating literals</a></h3>
<p>è®¡ç®—æ–‡æœ¬</p>
<p>The leaves of an expression treeâ€”the atomic bits of syntax that all other expressions are composed ofâ€”are literals. Literals are almost values already, but the distinction is important. A literal is a bit of syntax that produces a value. A literal always appears somewhere in the userâ€™s source code. Lots of values are produced by computation and donâ€™t exist anywhere in the code itself. Those arenâ€™t literals. A literal comes from the parserâ€™s domain. Values are an interpreter concept, part of the runtimeâ€™s world.</p>
<p>è¡¨è¾¾å¼è¯­æ³•æ ‘çš„å¶å­ï¼Œæ‰€æœ‰å…¶ä»–è¡¨è¾¾å¼ç»„æˆçš„è¯­æ³•ï¼Œéƒ½æ˜¯åŸå­æ€§çš„æ–‡æœ¬ã€‚æ–‡æœ¬å‡ ä¹å·²ç»æ˜¯å€¼äº†ï¼Œä½†æ˜¯åŒºåˆ†ä¹Ÿå¾ˆé‡è¦ã€‚æ–‡æœ¬ä¹Ÿæ˜¯ä¸€ä¸ªäº§ç”Ÿå€¼çš„è¯­æ³•ï¼Œæ–‡æœ¬æ€»æ˜¯å‡ºç°åœ¨ç”¨æˆ·æºä»£ç ä¸­çš„æŸä¸ªä½ç½®ï¼Œå¾ˆå¤šå€¼éƒ½æ˜¯é€šè¿‡è®¡ç®—äº§ç”Ÿçš„ï¼Œå¹¶ä¸”ä¸å­˜åœ¨äºä»£ç çš„ä»»ä½•åœ°æ–¹ï¼Œå®ƒä»¬ä¸æ˜¯æ–‡æœ¬ï¼Œæ–‡æœ¬æ¥è‡ªè§£æå™¨çš„ä½œç”¨åŸŸï¼Œå€¼æ˜¯ä¸€ä¸ªè§£é‡Šå™¨æ¦‚å¿µï¼Œæ˜¯è¿è¡Œæ—¶çš„ä¸€éƒ¨åˆ†ã€‚</p>
<blockquote>
<p>In the next chapter, when we implement variables, weâ€™ll add identifier expressions, which are also leaf nodes.</p>
<p>åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œå½“æˆ‘ä»¬å®ç°å˜é‡æ—¶å€™ï¼Œæˆ‘ä»¬å°†æ·»åŠ æ ‡è¯†ç¬¦è¡¨è¾¾å¼ï¼Œå®ƒä»¬ä¹Ÿæ˜¯å¶èŠ‚ç‚¹ã€‚</p>
</blockquote>
<p>So, much like we converted a literal token into a literal syntax tree node in the parser, now we convert the literal tree node into a runtime value. That turns out to be trivial.</p>
<p>å› æ­¤ï¼Œå°±åƒæˆ‘ä»¬åœ¨è§£æå™¨ä¸­ï¼Œå°†æ–‡æœ¬ tokenè½¬å˜ä¸ºæ–‡æœ¬è¯­æ³•æ ‘èŠ‚ç‚¹ä¸€æ ·ï¼Œç°åœ¨æˆ‘ä»¬å°†æ–‡æœ¬è¯­æ³•æ ‘èŠ‚ç‚¹ï¼Œè½¬å˜ä¸ºè¿è¡Œæ—¶å€¼ï¼Œè½¬å˜æ˜¯éå¸¸ç®€å•çš„</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

  @Override
  public Object visitLiteralExpr(Expr.Literal expr) {
    return expr.value;
  }
  
</code></pre>
<p>We eagerly produced the runtime value way back during scanning and stuffed it in the token. The parser took that value and stuck it in the literal tree node, so to evaluate a literal, we simply pull it back out.</p>
<p>æˆ‘ä»¬åœ¨æ‰«æé˜¶æ®µç”Ÿæˆäº†è¿è¡Œæ—¶å€™å€¼ï¼Œå¹¶ä¸”å°†å®ƒå¡«å……åˆ°tokenä¸­ï¼Œè§£æå™¨è·å–åˆ°è¯¥å€¼ï¼Œå¹¶ä¸”å°†å…¶å›ºå®šåœ¨æ–‡æœ¬æ ‘èŠ‚ç‚¹ä¸­ï¼Œå› æ­¤ï¼Œæ¥ä¸‹æ¥æƒ³è¦è®¡ç®—æ–‡æœ¬ï¼Œæˆ‘ä»¬åªéœ€è¦å°†å…¶æ‹‰å‡ºæ¥å°±å¯ä»¥äº†ã€‚</p>
<h3 id="22-evaluating-parentheses"><a class="header" href="#22-evaluating-parentheses">2.2 Evaluating parentheses</a></h3>
<p>è®¡ç®—æ‹¬å·</p>
<p>The next simplest node to evaluate is groupingâ€”the node you get as a result of using explicit parentheses in an expression.</p>
<p>æ¥ä¸‹æ¥è¦å¤„ç†çš„èŠ‚ç‚¹ï¼Œæœ€ç®€å•ï¼Œæˆ‘ä»¬åªéœ€è¦æ˜¾ç¤ºçš„ç”¨æ‹¬å·ï¼Œå°†è·å–åˆ°çš„èŠ‚ç‚¹è¿›è¡Œåˆ†ç»„</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

 @Override
  public Object visitGroupingExpr(Expr.Grouping expr) {
    return evaluate(expr.expression);
  }
  
</code></pre>
<p>A grouping node has a reference to an inner node for the expression contained inside the parentheses. To evaluate the grouping expression itself, we recursively evaluate that subexpression and return it.</p>
<p>ä¸€ä¸ªåˆ†ç»„èŠ‚ç‚¹ï¼ŒåŒ…å«æœ‰å¯¹äºå†…éƒ¨è¡¨è¾¾å¼èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œä¸ºäº†è®¡ç®—è¡¨è¾¾å¼æœ¬èº«ï¼Œæˆ‘ä»¬éœ€è¦é€’å½’çš„è®¡ç®—å­è¡¨è¾¾å¼ï¼Œå¹¶ä¸”è¿”å›ç»“æœ</p>
<p>We rely on this helper method which simply sends the expression back into the interpreterâ€™s visitor implementation:</p>
<p>æˆ‘ä»¬å°†ä¾èµ–è¿™ä¸ªå¸®åŠ©æ–¹æ³•ï¼Œå®ƒåªéœ€è¦å°†è¡¨è¾¾å¼å‘é€å›è§£é‡Šå™¨çš„è®¿é—®è€…æ¨¡å¼å®ç°</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

  private Object evaluate(Expr expr) {
    return expr.accept(this);
  }
  
</code></pre>
<blockquote>
<p>Some parsers donâ€™t define tree nodes for parentheses. Instead, when parsing a parenthesized expression, they simply return the node for the inner expression. We do create a node for parentheses in Lox because weâ€™ll need it later to correctly handle the left-hand sides of assignment expressions.</p>
<p>æœ‰ä¸€äº›è§£æå™¨ä¸ä¼šä¸ºæ‹¬å·å®šä¹‰æ ‘èŠ‚ç‚¹ï¼Œç›¸åï¼Œå½“é‡åˆ°å¸¦æ‹¬å·çš„è¡¨è¾¾å¼æ—¶å€™ï¼Œå®ƒä»¬åªä¼šè¿”å›å†…éƒ¨è¡¨è¾¾å¼çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬ç¡®å®ä¸ºLoxè¯­è¨€ä¸­ä¸ºæ‹¬å·åˆ›å»ºäº†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºç¨åï¼Œæˆ‘ä»¬å°†ç”¨åˆ°å®ƒï¼Œæ¥æ­£ç¡®å¤„ç†èµ‹å€¼è¡¨è¾¾å¼çš„å·¦ä¾§ã€‚</p>
</blockquote>
<h2 id="23-evaluating-unary-expressions"><a class="header" href="#23-evaluating-unary-expressions">2.3 Evaluating unary expressions</a></h2>
<p>è®¡ç®—ä¸€å…ƒè¡¨è¾¾å¼</p>
<p>Like grouping, unary expressions have a single subexpression that we must evaluate first. The difference is that the unary expression itself does a little work afterwards.</p>
<p>å’Œåˆ†ç»„ä¸€æ ·ï¼Œä¸€å…ƒè¡¨è¾¾å¼ï¼Œæœ‰ä¸€ä¸ªå­è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦å…ˆè¿›è¡Œè®¡ç®—ï¼Œä¸åŒäºåˆ†ç»„ï¼Œæˆ‘ä»¬åœ¨ä¸€å…ƒè¡¨è¾¾å¼è®¡ç®—ç»“æœåï¼Œåˆåšäº†ä¸€äº›å·¥ä½œã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitLiteralExpr()

  @Override
  public Object visitUnaryExpr(Expr.Unary expr) {
    Object right = evaluate(expr.right);

    switch (expr.operator.type) {
      case MINUS:
        return -(double)right;
    }

    // Unreachable.
    return null;
  }
  
</code></pre>
<p>First, we evaluate the operand expression. Then we apply the unary operator itself to the result of that. There are two different unary expressions, identified by the type of the operator token.</p>
<p>Shown here is -, which negates the result of the subexpression. The subexpression must be a number. Since we donâ€™t statically know that in Java, we cast it before performing the operation. This type cast happens at runtime when the - is evaluated. Thatâ€™s the core of what makes a language dynamically typed right there.</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬è®¡ç®—å†…éƒ¨çš„æ“ä½œæ•°è¡¨è¾¾å¼ï¼Œç„¶åï¼Œæˆ‘ä»¬å°†ä¸€å…ƒè¿ç®—ç¬¦æœ¬èº«åº”ç”¨äºè®¡ç®—ç»“æœï¼Œæœ‰ä¸¤ä¸ªä¸åŒçš„ä¸€å…ƒè¿ç®—ç¬¦ï¼Œæ˜¯ç”±è¿ç®—ç¬¦tokençš„ç±»å‹å†³å®šçš„</p>
<p>ä¸Šé¢å±•ç¤ºçš„æ˜¯ -ï¼Œ å®ƒè¡¨ç¤ºå­è¡¨è¾¾å¼ç»“æœçš„è´Ÿå€¼ï¼Œå­è¡¨è¾¾å¼çš„ç»“æœå¿…é¡»æ˜¯æ•°å€¼ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨Javaä¸­ä¸çŸ¥é“è¿™ä¸€ç‚¹ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åœ¨è¿›è¡Œæ“ä½œä¹‹å‰ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œå½“è®¡ç®— - è¿ç®—æ—¶å€™ï¼Œæ­¤ç±»å‹è½¬æ¢åœ¨è¿è¡Œæ—¶å€™å‘ç”Ÿï¼Œè¿™æ­£æ˜¯åŠ¨æ€ç±»å‹è¯­è¨€çš„æ ¸å¿ƒæ‰€åœ¨ã€‚</p>
<blockquote>
<p>Youâ€™re probably wondering what happens if the cast fails. Fear not, weâ€™ll get into that soon.</p>
<p>ä½ å¯èƒ½æƒ³è¦çŸ¥é“å¦‚æœç±»å‹è½¬æ¢å¤±è´¥ï¼Œä¼šæœ‰ä»€ä¹ˆç»“æœï¼Œæˆ‘ä»¬é©¬ä¸Šå°±ä¼šä»‹ç»</p>
</blockquote>
<p>You can start to see how evaluation recursively traverses the tree. We canâ€™t evaluate the unary operator itself until after we evaluate its operand subexpression. That means our interpreter is doing a post-order traversalâ€”each node evaluates its children before doing its own work.</p>
<p>ä½ å¯ä»¥å¼€å§‹çœ‹åˆ°ï¼Œæ±‚å€¼å¦‚ä½•é€’å½’éå†æ ‘ï¼Œåœ¨è®¡ç®—ä¸€å…ƒè¡¨è¾¾å¼çš„å³è¾¹å­è¡¨è¾¾å¼ä¹‹å‰ï¼Œæˆ‘ä»¬æ— æ³•è®¡ç®—ä¸€å…ƒè¡¨è¾¾å¼çš„å€¼ï¼Œè¿™æ„å¤–ç€æˆ‘ä»¬çš„è§£é‡Šå™¨å°†è¿›è¡Œä¸€ä¸ªååºéå†â€”â€”æ‰§è¡Œè‡ªå·±æœ¬èº«ä¹‹å‰ï¼Œå…ˆå¯¹è‡ªå·±çš„å­èŠ‚ç‚¹è¿›è¡Œè®¡ç®—</p>
<p>The other unary operator is logical not.</p>
<p>è¿˜æœ‰ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦æ˜¯ å¸ƒå°”é</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitUnaryExpr()

    switch (expr.operator.type) {
      case BANG:
        return !isTruthy(right);
      case MINUS:
	  
</code></pre>
<p>The implementation is simple, but what is this â€œtruthyâ€ thing about? We need to make a little side trip to one of the great questions of Western philosophy: What is truth?</p>
<p>å®ç°éå¸¸ç®€å•ï¼Œä½†æ˜¯&quot;çœŸå®â€œ æ˜¯ä»€ä¹ˆä¸œè¥¿å‘¢ï¼Ÿæˆ‘ä»¬éœ€è¦å¯¹è¥¿æ–¹å“²å­¦çš„ä¸€ä¸ªé‡å¤§é—®é¢˜åšä¸€ä¸ªå°å°çš„æ—è§‚è€…â€”â€”ä»€ä¹ˆæ˜¯çœŸç†ï¼Ÿ</p>
<h3 id="24-truthiness-and-falsiness"><a class="header" href="#24-truthiness-and-falsiness">2.4 Truthiness and falsiness</a></h3>
<p>çœŸå®å’Œè™šå‡</p>
<p>OK, maybe weâ€™re not going to really get into the universal question, but at least inside the world of Lox, we need to decide what happens when you use something other than true or false in a logic operation like ! or any other place where a Boolean is expected.</p>
<p>We could just say itâ€™s an error because we donâ€™t roll with implicit conversions, but most dynamically typed languages arenâ€™t that ascetic. Instead, they take the universe of values of all types and partition them into two sets, one of which they define to be â€œtrueâ€, or â€œtruthfulâ€, or (my favorite) â€œtruthyâ€, and the rest which are â€œfalseâ€ or â€œfalseyâ€. This partitioning is somewhat arbitrary and gets weird in a few languages.</p>
<p>å¥½å§ï¼Œä¹Ÿè®¸æˆ‘ä»¬ä¸ä¼šå»æ€è€ƒè¿™ä¸ªé‡å¤§çš„å“²å­¦é—®é¢˜ï¼Œä½†æ˜¯ï¼Œè‡³å°‘åœ¨Loxçš„ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰å½“ æˆ‘ä»¬ä½¿ç”¨é true/falseè¿™æ ·çš„é€»è¾‘å€¼ï¼Œå’Œé€»è¾‘è¿ç®—ç¬¦ ï¼ï¼Œè®¡ç®—æ—¶å€™ï¼Œå°†ä¼šå¾—åˆ°ä»€ä¹ˆå‘¢ï¼Ÿæˆ–è€…å…¶ä»–éœ€è¦æä¾›ä¸€ä¸ªé€»è¾‘å€¼çš„åœ°æ–¹</p>
<p>æˆ‘ä»¬å¯ä»¥å®šä¹‰ï¼Œä¸æ”¯æŒå…¶ä»–ç±»å‹çš„é€»è¾‘éè¿ç®—ï¼Œå› ä¸ºæˆ‘ä»¬ä¸æ”¯æŒéšå¼è½¬æ¢ï¼Œä½†æ˜¯ï¼Œå¤§å¤šæ•°çš„åŠ¨æ€è¯­è¨€æ²¡æœ‰è¿™ä¹ˆä¸¥æ ¼çš„é™åˆ¶ï¼Œç›¸åï¼Œæˆ‘ä»¬ä¼šå°†æ‰€æœ‰ç±»å‹çš„å€¼åˆ†ä¸ºä¸¤ç»„ï¼Œå…¶ä¸­ä¸€ç»„å®šä¹‰ä¸ºçœŸï¼Œå¦å¤–ä¸€ç»„å®šä¹‰ä¸ºå‡ï¼Œè¿™ç§åˆ†åŒºæ¯”è¾ƒéšæ„ï¼Œåœ¨ä¸€äº›è¯­è¨€ä¸­ä¼šå˜å¾—æœ‰äº›å¥‡æ€ªã€‚</p>
<blockquote>
<p>In JavaScript, strings are truthy, but empty strings are not. Arrays are truthy but empty arrays areâ€‰.â€‰.â€‰. also truthy. The number 0 is falsey, but the string &quot;0&quot; is truthy.</p>
<p>In Python, empty strings are falsey like in JS, but other empty sequences are falsey too.</p>
<p>In PHP, both the number 0 and the string &quot;0&quot; are falsey. Most other non-empty strings are truthy.</p>
<p>Get all that?</p>
<p>åœ¨JavaScript ä¸­ï¼Œå­—ç¬¦ä¸²æ˜¯trueï¼Œç©ºå­—ç¬¦ä¸²æ˜¯falseï¼Œæ•°ç»„æ˜¯trueï¼Œä½†æ˜¯ç©ºæ•°ç»„ä¹Ÿæ˜¯trueï¼ŒğŸ˜„ï¼Œæ•°å­—0æ˜¯falseï¼Œä½†æ˜¯å­—ç¬¦ä¸²&quot;0&quot;æ˜¯true</p>
<p>åœ¨Pythonä¸­ï¼Œç©ºå­—ç¬¦ä¸²å’ŒJSç›¸ä¼¼ï¼Œä½†æ˜¯å…¶ä»–ç©ºåºåˆ—ä¹Ÿæ˜¯ false</p>
<p>åœ¨PHPä¸­ï¼Œæ— è®ºæ•°å­—0è¿˜æ˜¯å­—ç¬¦ä¸² &quot;0&quot; éƒ½æ˜¯falseï¼Œå¤§å¤šæ•°å…¶ä»–éç©ºå­—ç¬¦ä¸²éƒ½æ˜¯true</p>
<p>æ˜ç™½äº†å—ï¼Ÿ</p>
</blockquote>
<p>Lox follows Rubyâ€™s simple rule: false and nil are falsey, and everything else is truthy. We implement that like so:</p>
<p>Loxå€Ÿé‰´äº†Rubyä¸­çš„ç®€å•åˆ¤æ–­æ–¹æ³•ï¼Œfalseå’Œ nil æ˜¯è™šå‡çš„ï¼Œå…¶ä»–éƒ½æ˜¯çœŸå®çš„</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitUnaryExpr()

  private boolean isTruthy(Object object) {
    if (object == null) return false;
    if (object instanceof Boolean) return (boolean)object;
    return true;
  }
  
</code></pre>
<h3 id="25-evaluating-binary-operators"><a class="header" href="#25-evaluating-binary-operators">2.5 Evaluating binary operators</a></h3>
<p>è®¡ç®—äºŒå…ƒè¿ç®—ç¬¦</p>
<p>On to the last expression tree class, binary operators. Thereâ€™s a handful of them, and weâ€™ll start with the arithmetic ones.</p>
<p>æœ€åä¸€ä¸ªè¡¨è¾¾å¼è®¡ç®—ï¼ŒäºŒå…ƒè¿ç®—ç¬¦ï¼Œæˆ‘ä»¬å°†å…ˆä»ç®—æœ¯è¿ç®—ç¬¦å¼€å§‹</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after evaluate()

  @Override
  public Object visitBinaryExpr(Expr.Binary expr) {
    Object left = evaluate(expr.left);
    Object right = evaluate(expr.right); 

    switch (expr.operator.type) {
      case MINUS:
        return (double)left - (double)right;
      case SLASH:
        return (double)left / (double)right;
      case STAR:
        return (double)left * (double)right;
    }

    // Unreachable.
    return null;
  }
  
</code></pre>
<blockquote>
<p>Did you notice we pinned down a subtle corner of the language semantics here? In a binary expression, we evaluate the operands in left-to-right order. If those operands have side effects, that choice is user visible, so this isnâ€™t simply an implementation detail.</p>
<p>If we want our two interpreters to be consistent (hint: we do), weâ€™ll need to make sure clox does the same thing.</p>
<p>ä½ æ˜¯å¦æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬è¿™é‡Œäº†ä¸€ä¸ªè¯­è¨€è¯­ä¹‰çš„ä¸€ä¸ªè§’è½ï¼Œåœ¨äºŒå…ƒè¡¨è¾¾å¼ä¸­ï¼Œæˆ‘ä»¬ä¼šä»å·¦åˆ°å³è®¡ç®—æ“ä½œæ•°ï¼Œå¦‚æœè¿™äº›æ“ä½œæ•°æœ‰å‰¯ä½œç”¨ï¼Œç”¨æˆ·å¯ä»¥çœ‹åˆ°è¿™äº›é€‰é¡¹ï¼Œå› æ­¤ï¼Œè¿™ä¸ä»…ä»…æ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚</p>
<p>å¦‚æœä½ å¸Œæœ›æˆ‘ä»¬çš„ä¸¤ä¸ªè§£é‡Šå™¨ä¿æŒä¸€è‡´ï¼Œï¼ˆæˆ‘ä»¬çœŸçš„åšåˆ°äº†ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿cLoxè§£é‡Šå™¨ï¼Œå®ç°ç›¸åŒçš„æ“ä½œ</p>
</blockquote>
<p>I think you can figure out whatâ€™s going on here. The main difference from the unary negation operator is that we have two operands to evaluate.</p>
<p>I left out one arithmetic operator because itâ€™s a little special.</p>
<p>æˆ‘è®¤ä¸ºï¼Œä½ åº”è¯¥å¯ä»¥å¼„æ¸…æ¥šè¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Œä¸ä¸€å…ƒå¦å®šæ“ä½œç¬¦ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—å·¦/å³ä¸¤ä¸ªæ“ä½œæ•°</p>
<p>æˆ‘é—æ¼äº†ä¸€ä¸ªç®—æœ¯è¿ç®—ç¬¦ï¼Œå› ä¸ºå®ƒæœ‰äº›ç‰¹æ®Š</p>
<pre><code class="language-java">

// lox/Interpreter.java, in visitBinaryExpr()

    switch (expr.operator.type) {
      case MINUS:
        return (double)left - (double)right;
      case PLUS:
        if (left instanceof Double &amp;&amp; right instanceof Double) {
          return (double)left + (double)right;
        } 

        if (left instanceof String &amp;&amp; right instanceof String) {
          return (String)left + (String)right;
        }

        break;
      case SLASH:
	  
</code></pre>
<p>The + operator can also be used to concatenate two strings. To handle that, we donâ€™t just assume the operands are a certain type and cast them, we dynamically check the type and choose the appropriate operation. This is why we need our object representation to support instanceof.</p>
<ul>
<li>è¿ç®—ç¬¦ï¼Œå¯ä»¥ç”¨äºè¿æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œä¸ºäº†å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸åªæ˜¯å‡è®¾æ“ä½œæ•°æ˜¯æŸä¸ªç±»å‹ï¼Œå¹¶ä¸”è¿›è¡Œç±»å‹è½¬æ¢ï¼Œè€Œæ˜¯åŠ¨æ€æ£€æŸ¥ç±»å‹ï¼Œå¹¶ä¸”è¿›è¡Œé€‚å½“çš„æ“ä½œï¼Œè¿™å°±æ˜¯æˆ‘ä»¬ä¸ºä»€ä¹ˆéœ€è¦å¯¹è±¡æ”¯æŒ instanceof</li>
</ul>
<blockquote>
<p>We could have defined an operator specifically for string concatenation. Thatâ€™s what Perl (.), Lua (..), Smalltalk (,), Haskell (++), and others do.</p>
<p>I thought it would make Lox a little more approachable to use the same syntax as Java, JavaScript, Python, and others. This means that the + operator is overloaded to support both adding numbers and concatenating strings. Even in languages that donâ€™t use + for strings, they still often overload it for adding both integers and floating-point numbers.</p>
<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸²è¿æ¥çš„è¿ç®—ç¬¦ï¼Œè¿™ä¹Ÿæ˜¯ Perl(.) Lua(..) Smalltalk(,) Haskell(++) ç­‰è¯­è¨€æ‰€åšçš„</p>
<p>æˆ‘è®¤ä¸ºä½¿ç”¨å’ŒJava/JS/Pythonä¸€æ ·çš„è¯­æ³•ï¼Œä¼šè®©Loxæ›´åŠ å®¹æ˜“æ¥è¿‘ï¼Œè¿™æ„å‘³ç€ + è¿ç®—ç¬¦è¢«é‡è½½ï¼Œç”¨äºæ”¯æŒæ•°å­—çš„åŠ æ³•å’Œå­—ç¬¦ä¸²çš„è¿æ¥ï¼Œå³ä½¿åœ¨ä¸ä½¿ç”¨ + è¿æ¥å­—ç¬¦ä¸²çš„è¯­è¨€ä¸­ï¼Œå®ƒä»¬ä»ç„¶åœ¨è®¡ç®—æ•´æ•°å’Œæµ®ç‚¹æ•°åŠ æ³•è¿ç®—æ—¶ï¼Œé‡è½½ã€‚</p>
</blockquote>
<p>Next up are the comparison operators.</p>
<p>æ¥ä¸‹æ¥æ˜¯æ¯”è¾ƒè¿ç®—ç¬¦</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitBinaryExpr()

    switch (expr.operator.type) {
      case GREATER:
        return (double)left &gt; (double)right;
      case GREATER_EQUAL:
        return (double)left &gt;= (double)right;
      case LESS:
        return (double)left &lt; (double)right;
      case LESS_EQUAL:
        return (double)left &lt;= (double)right;
      case MINUS:
	  
</code></pre>
<p>They are basically the same as arithmetic. The only difference is that where the arithmetic operators produce a value whose type is the same as the operands (numbers or strings), the comparison operators always produce a Boolean.</p>
<p>å®ƒä»¬å’Œç®—æœ¯è¿ç®—ç¬¦ä¸€æ ·ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼Œç®—æœ¯è¿ç®—ç¬¦çš„è®¡ç®—ç»“æœæ€»æ˜¯å’Œæ“ä½œæ•°ç±»å‹ç›¸åŒï¼ˆæ•°å€¼æˆ–è€…stringï¼‰ï¼Œè€Œæ¯”è¾ƒè¿ç®—ç¬¦ç»“æœæ€»æ˜¯å¸ƒå°”å€¼</p>
<p>The last pair of operators are equality.</p>
<p>æœ€åï¼Œä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦æ˜¯ ç›¸ç­‰åˆ¤æ–­</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitBinaryExpr()

  case BANG_EQUAL: return !isEqual(left, right);
  case EQUAL_EQUAL: return isEqual(left, right);
</code></pre>
<p>Unlike the comparison operators which require numbers, the equality operators support operands of any type, even mixed ones. You canâ€™t ask Lox if 3 is less than &quot;three&quot;, but you can ask if itâ€™s equal to it.</p>
<p>ä¸éœ€è¦æ•°å­—çš„æ¯”è¾ƒè¿ç®—ç¬¦ä¸åŒï¼Œç›¸ç­‰è¿ç®—ç¬¦æ”¯æŒæ‰€æœ‰ç±»å‹çš„æ“ä½œæ•°ï¼Œç”šè‡³æ˜¯æ··åˆæ“ä½œæ•°ï¼Œä½ ä¸èƒ½é—®Loxè¯­è¨€ï¼Œ3æ˜¯å¦å°äº &quot;three&quot;, ä½†æ˜¯ä½ å¯ä»¥é—®Loxè¯­è¨€ï¼Œ3 æ˜¯å¦ç­‰äº &quot;three&quot;</p>
<blockquote>
<p>Spoiler alert: itâ€™s not.</p>
<p>å‰§é€æé†’ï¼Œä¸æ˜¯</p>
</blockquote>
<p>Like truthiness, the equality logic is hoisted out into a separate method.</p>
<p>å’Œ isTruthy() å‡½æ•°ä¸€æ ·ï¼ŒisEqual() å‡½æ•°ä¹Ÿæ˜¯ä¸€ä¸ªå•ç‹¬çš„æ–¹æ³•</p>
<pre><code>
// lox/Interpreter.java, add after isTruthy()

 private boolean isEqual(Object a, Object b) {
    if (a == null &amp;&amp; b == null) return true;
    if (a == null) return false;

    return a.equals(b);
  }
  
</code></pre>
<p>This is one of those corners where the details of how we represent Lox objects in terms of Java matter. We need to correctly implement Loxâ€™s notion of equality, which may be different from Javaâ€™s.</p>
<p>Fortunately, the two are pretty similar. Lox doesnâ€™t do implicit conversions in equality and Java does not either. We do have to handle nil/null specially so that we donâ€™t throw a NullPointerException if we try to call equals() on null. Otherwise, weâ€™re fine. Javaâ€™s equals() method on Boolean, Double, and String have the behavior we want for Lox.</p>
<p>è¿™æ˜¯æˆ‘ä»¬å¦‚ä½•ç”¨Javaå®ç°Lox å¯¹è±¡çš„ç»†èŠ‚æ‰€åœ¨çš„è§’è½ä¹‹ä¸€ï¼Œæˆ‘ä»¬éœ€è¦æ­£ç¡®çš„å®ç°Lox è¯­è¨€çš„ç›¸ç­‰æ¦‚å¿µï¼Œè¿™å¯èƒ½å’ŒJava ä¸ä¸€æ ·ã€‚</p>
<p>å¹¸è¿çš„æ˜¯ï¼Œä¸¤è€…éå¸¸ç›¸ä¼¼ï¼ŒLoxä¸ä¼šå¯¹ç­‰å¼ä¸­çš„éšå¼è½¬æ¢ï¼ŒJavaä¹Ÿä¸åšè½¬æ¢ï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘åˆ°nil/nullï¼Œ ä»¥ä¾¿åœ¨å°è¯•å¯¹ nullè°ƒç”¨ isEqual()  å‡½æ•°æ—¶å€™ï¼Œä¸ä¼šå¼•å‘ç©ºæŒ‡é’ˆæŠ¥é”™ï¼Œå…¶ä»–çš„ï¼Œæˆ‘ä»¬éƒ½å¾ˆå¥½ï¼ŒJavaå¯¹Booleanï¼ŒDoubleï¼ŒStringç±»å‹å…·æœ‰ç›¸åŒçš„equals() å‡½æ•°ã€‚</p>
<blockquote>
<p>What do you expect this to evaluate to:</p>
<p>(0 / 0) == (0 / 0)</p>
<p>According to IEEE 754, which specifies the behavior of double-precision numbers, dividing a zero by zero gives you the special NaN (â€œnot a numberâ€) value. Strangely enough, NaN is not equal to itself.</p>
<p>In Java, the == operator on primitive doubles preserves that behavior, but the equals() method on the Double class does not. Lox uses the latter, so doesnâ€™t follow IEEE. These kinds of subtle incompatibilities occupy a dismaying fraction of language implementersâ€™ lives.</p>
<p>ä½ å¸Œæœ›çš„è¯„ä¼°ç»“æœæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ</p>
<p>æ ¹æ® IEEE 754, å®ƒè§„å®šäº†åŒç²¾åº¦æ•°å­—çš„è¡Œä¸ºï¼Œå°† 0/0 å¯ä»¥å¾—åˆ°ç‰¹æ®Šçš„ NaNï¼ˆéæ•°å­—å€¼ï¼‰ï¼Œå¥‡æ€ªçš„æ˜¯ï¼ŒNaNå¹¶ä¸ç­‰äºè‡ªå·±ã€‚</p>
<p>åœ¨Javaä¸­ï¼ŒåŸºäºDoubleç±»å‹çš„ == è¿ç®—ç¬¦ä¿ç•™ç€è¿™ç§è¡Œä¸ºï¼Œä½†æ˜¯ Doubleç±»ä¸Šçš„equals() æ–¹æ³•åˆ™ä¸ä¿ç•™è¿™ç§è¡Œä¸ºï¼ŒLoxä½¿ç”¨åè€…ï¼Œå› æ­¤ä¸éµå®ˆIEEEï¼Œè¿™äº›å¾®å¦™çš„ä¸å…¼å®¹æ€§ï¼Œå æ®äº†è¯­è¨€å®ç°è€…ç”Ÿæ´»ä¸­ä»¤äººæ²®ä¸§çš„ä¸€å°éƒ¨åˆ†ã€‚</p>
</blockquote>
<p>And thatâ€™s it! Thatâ€™s all the code we need to correctly interpret a valid Lox expression. But what about an invalid one? In particular, what happens when a subexpression evaluates to an object of the wrong type for the operation being performed?</p>
<p>å°±è¿™æ ·ï¼è¿™å°±æ˜¯æ­£ç¡®è§£é‡Šæœ‰æ•ˆLoxè¡¨è¾¾å¼æ‰€éœ€çš„å…¨éƒ¨ä»£ç ï¼Œä½†æ˜¯æ— æ•ˆçš„å‘¢ï¼Ÿç‰¹åˆ«æ˜¯ï¼Œå½“å­è¡¨è¾¾å¼çš„è®¡ç®—ç»“æœä¸ºæ‰€æ‰§è¡Œæ“ä½œçš„é”™è¯¯ç±»å‹çš„å¯¹è±¡æ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ</p>
<h2 id="ä¸‰runtime-errors"><a class="header" href="#ä¸‰runtime-errors">ä¸‰ã€Runtime Errors</a></h2>
<p>I was cavalier about jamming casts in whenever a subexpression produces an Object and the operator requires it to be a number or a string. Those casts can fail. Even though the userâ€™s code is erroneous, if we want to make a usable language, we are responsible for handling that error gracefully.</p>
<p>æ¯å½“å­è¡¨è¾¾å¼äº§ç”Ÿä¸€ä¸ªObjectï¼Œä½†æ˜¯è¿ç®—ç¬¦éœ€è¦çš„æ˜¯æ•°å­—æˆ–è€…å­—ç¬¦ä¸²æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šéšæ„çš„ä½¿ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢ã€‚è¿™äº›ç±»å‹è½¬æ¢å¯èƒ½ä¼šå¤±è´¥ï¼Œå³ä½¿ç”¨æˆ·çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼Œä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€é—¨å¯ç”¨çš„è¯­è¨€ï¼Œæˆ‘ä»¬æœ‰è´£ä»»ä¼˜é›…çš„å¤„ç†è¿™ç§é”™è¯¯ã€‚</p>
<blockquote>
<p>We could simply not detect or report a type error at all. This is what C does if you cast a pointer to some type that doesnâ€™t match the data that is actually being pointed to. C gains flexibility and speed by allowing that, but is also famously dangerous. Once you misinterpret bits in memory, all bets are off.</p>
<p>Few modern languages accept unsafe operations like that. Instead, most are memory safe and ensureâ€”through a combination of static and runtime checksâ€”that a program can never incorrectly interpret the value stored in a piece of memory.</p>
<p>æˆ‘ä»¬æ ¹æœ¬æ— æ³•æ£€æµ‹æˆ–è€…æŠ¥å‘Šç±»å‹é”™è¯¯ï¼Œåœ¨Cè¯­è¨€ä¸­ï¼Œå¦‚æœå°†æŒ‡é’ˆè½¬æ¢ä¸ºå®é™…æ•°æ®ä¸ç›¸ç¬¦çš„æŸä¸ªç±»å‹ï¼ŒCè¯­è¨€é€šå¸¸ä¼šï¼Œå…è®¸ç”¨æˆ·è¿™æ ·è½¬æ¢ï¼Œä»¥è·å–é€Ÿåº¦å’Œçµæ´»æ€§ï¼Œä½†æ˜¯è¿™ä¹Ÿæ˜¯æ€»æ‰€å‘¨çŸ¥çš„å±é™©ï¼Œä¸€æ—¦æˆ‘ä»¬é”™è¯¯çš„è½¬æ¢äº†æŒ‡é’ˆç±»å‹ï¼Œå°†å¯èƒ½äº§ç”Ÿä¸¥é‡çš„é”™è¯¯ã€‚</p>
<p>å¾ˆå°‘æœ‰ç°ä»£è¯­è¨€æ¥å—è¿™æ ·çš„ä¸å®‰å…¨æ“ä½œï¼Œç›¸åï¼Œå¤§å¤šæ•°éƒ½æ˜¯å†…å­˜å®‰å…¨çš„ï¼Œå¹¶ä¸”é€šè¿‡é™æ€å’Œè¿è¡Œæ—¶æ£€æŸ¥çš„ç»„åˆï¼Œç¡®ä¿ç¨‹åºä¸ä¼šé”™è¯¯çš„è§£é‡Šå­˜å‚¨åœ¨å†…å­˜ä¸­çš„å€¼ã€‚</p>
</blockquote>
<p>Itâ€™s time for us to talk about runtime errors. I spilled a lot of ink in the previous chapters talking about error handling, but those were all syntax or static errors. Those are detected and reported before any code is executed. Runtime errors are failures that the language semantics demand we detect and report while the program is running (hence the name).</p>
<p>Right now, if an operand is the wrong type for the operation being performed, the Java cast will fail and the JVM will throw a ClassCastException. That unwinds the whole stack and exits the application, vomiting a Java stack trace onto the user. Thatâ€™s probably not what we want. The fact that Lox is implemented in Java should be a detail hidden from the user. Instead, we want them to understand that a Lox runtime error occurred, and give them an error message relevant to our language and their program.</p>
<p>ç°åœ¨æ˜¯æˆ‘ä»¬è®¨è®ºè¿è¡Œæ—¶é”™è¯¯çš„æ—¶å€™äº†ï¼Œæˆ‘ä»¬å·²ç»åœ¨å‰é¢çš„ç« èŠ‚ä¸­è®¨è®ºäº†é”™è¯¯å¤„ç†ï¼Œä½†æ˜¯å®ƒä»¬éƒ½æ˜¯è¯­æ³•å’Œé™æ€é”™è¯¯ï¼Œåœ¨æ‰§è¡Œä»»ä½•ä»£ç ä¹‹å‰ï¼Œè¿™äº›é”™è¯¯éƒ½ä¼šè¢«æ£€æµ‹å¹¶ä¸”æŠ¥å‘Šï¼Œè¿è¡Œæ—¶é”™è¯¯æ˜¯è¯­è¨€è¯­ä¹‰è¦æ±‚æˆ‘ä»¬åœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œæ£€æµ‹å¹¶ä¸”æŠ¥å‘Šæ•…éšœï¼ˆå› æ­¤å¾—åï¼‰</p>
<p>ç°åœ¨ï¼Œå¦‚æœæ“ä½œæ•°çš„ç±»å‹å’Œæ­£åœ¨æ‰§è¡Œçš„æ“ä½œè¿ç®—ä¸ç¬¦åˆï¼ŒJavaçš„å¼ºåˆ¶è½¬æ¢å°†å¤±è´¥ï¼ŒJVMä¼šæŠ›å‡ºç±»å‹è½¬æ¢æŠ¥é”™ï¼Œè¿™å°†è§£å¼€æ•´ä¸ªå †æ ˆï¼Œå¹¶ä¸”é€€å‡ºåº”ç”¨ç¨‹åºï¼Œä»è€Œå‘ç”¨æˆ·æŠ›å‡ºJavaå †æ ˆè·Ÿè¸ªï¼Œä½†æ˜¯ï¼Œè¿™å¯èƒ½ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼ŒLoxè¯­è¨€æ˜¯åœ¨Javaä¸­å®ç°çš„è¿™ä¸€ä¸ªäº‹å®ï¼Œåº”è¯¥æ˜¯å¯¹ç”¨æˆ·éšè—çš„ç»†èŠ‚ã€‚ç›¸åï¼Œæˆ‘ä»¬å¸Œæœ›ä»–ä»¬äº†è§£å‘ç”Ÿäº†è¿è¡Œæ—¶é”™è¯¯ï¼Œå¹¶ä¸”å‘ç”¨æˆ·ï¼Œæä¾›å’Œæˆ‘ä»¬è¯­è¨€å’Œç¨‹åºç›¸å…³çš„é”™è¯¯æ¶ˆæ¯ã€‚</p>
<p>The Java behavior does have one thing going for it, though. It correctly stops executing any code when the error occurs. Letâ€™s say the user enters some expression like:</p>
<pre><code>2 * (3 / -&quot;muffin&quot;)
</code></pre>
<p>You canâ€™t negate a muffin, so we need to report a runtime error at that inner - expression. That in turn means we canâ€™t evaluate the / expression since it has no meaningful right operand. Likewise for the *. So when a runtime error occurs deep in some expression, we need to escape all the way out.</p>
<p>ä¸è¿‡ï¼ŒJavaçš„è¡Œä¸ºç¡®å®æœ‰ä¸€ä¸ªåŸå› ï¼Œå½“å‘ç”Ÿé”™è¯¯æ—¶å€™ï¼Œå®ƒä¼šåœæ­¢æ‰§è¡Œä»»ä½•ä»£ç ï¼Œå‡è®¾ç”¨æˆ·è¾“å…¥ä¸‹é¢çš„è¡¨è¾¾å¼</p>
<p>æˆ‘ä»¬æ— æ³•è®¡ç®— muffin çš„è´Ÿå€¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨å­è¡¨è¾¾å¼è®¡ç®—æ—¶å€™ï¼ŒæŠ¥å‘Šé”™è¯¯ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬ä¹Ÿæ— æ³•è®¡ç®— / ï¼Œå› æ­¤è¯¥æ“ä½œç¬¦çš„å³æ“ä½œæ•°æ²¡æœ‰æ„ä¹‰ï¼ŒåŒæ ·ï¼Œ * è¿ç®—ç¬¦ä¹Ÿä¸€æ ·ã€‚å› æ­¤ï¼Œå½“è¿è¡Œæ—¶é”™è¯¯å‘ç”Ÿåœ¨æ·±å±‚çš„å­è¡¨è¾¾å¼æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šä¸€ç›´å¾€ä¸Šå¿½ç•¥ã€‚</p>
<blockquote>
<p>I donâ€™t know, man, can you negate a muffin?</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/muffin.png?raw=true" alt="muffin" /></p>
</blockquote>
<p>We could print a runtime error and then abort the process and exit the application entirely. That has a certain melodramatic flair. Sort of the programming language interpreter equivalent of a mic drop.</p>
<p>Tempting as that is, we should probably do something a little less cataclysmic. While a runtime error needs to stop evaluating the expression, it shouldnâ€™t kill the interpreter. If a user is running the REPL and has a typo in a line of code, they should still be able to keep the session going and enter more code after that.</p>
<p>æˆ‘ä»¬å¯ä»¥æ‰“å°ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ï¼Œç„¶åç»ˆæ­¢è¿›ç¨‹å¹¶ä¸”é€€å‡ºåº”ç”¨ç¨‹åºï¼Œè¿™æœ‰ä¸€å®šçš„æˆå‰§æ€§ï¼ŒæŸç§è¯­è¨€çš„è§£é‡Šå™¨ï¼Œç›¸å½“äºé™ä¸‹éº¦å…‹é£ã€‚</p>
<p>å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘ä»¬è¿˜æ˜¯åº”è¯¥åšä¸€äº›äº‹æƒ…ï¼Œä¸ä¼šå¼•å‘ç¾éš¾ï¼Œè™½ç„¶ï¼Œè¿è¡Œæ—¶é”™è¯¯éœ€è¦åœæ­¢è®¡ç®—è¡¨è¾¾å¼ï¼Œä½†æ˜¯ï¼Œå®ƒä¸åº”è¯¥åœæ­¢è§£é‡Šå™¨ï¼Œå¦‚æœç”¨æˆ·æ­£åœ¨è¿è¡Œä¸€ä¸ª REPL ç±»å‹çš„ç¨‹åºï¼Œä¸€è¡Œä»£ç ä¸­æœ‰ä¸€ä¸ªé”™è¯¯ï¼Œé‚£ä¹ˆè§£é‡Šå™¨ä¸åº”è¯¥é€€å‡ºï¼Œåº”è¯¥å¯ä»¥ç»§ç»­ä¼šè¯ï¼Œåœ¨ç»ˆç«¯è¾“å…¥æ›´å¤šçš„ä»£ç ã€‚</p>
<h3 id="31-detecting-runtime-errors"><a class="header" href="#31-detecting-runtime-errors">3.1 Detecting runtime errors</a></h3>
<p>æ£€æµ‹è¿è¡Œæ—¶é”™è¯¯</p>
<p>Our tree-walk interpreter evaluates nested expressions using recursive method calls, and we need to unwind out of all of those. Throwing an exception in Java is a fine way to accomplish that. However, instead of using Javaâ€™s own cast failure, weâ€™ll define a Lox-specific one so that we can handle it how we want.</p>
<p>æˆ‘ä»¬çš„æ ‘éå†è§£é‡Šå™¨ï¼Œä½¿ç”¨é€’å½’è°ƒç”¨å®ç°äº†è®¡ç®—åµŒå¥—è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦è§£å¼€æ‰€æœ‰è¿™äº›ã€‚åœ¨Javaä¸­æŠ›å‡ºå¼‚å¸¸ï¼Œæ˜¯å®ç°è¿™ä¸€ç‚¹çš„å¥½æ–¹æ³•ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªç‰¹å®šäºLoxçš„å¤±è´¥ï¼Œè€Œä¸æ˜¯ä½¿ç”¨Javaä¸­é»˜è®¤çš„ç±»å‹è½¬æ¢é”™è¯¯ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§è‡ªå·±æ„æ„¿å¤„ç†æŠ¥é”™ã€‚</p>
<p>Before we do the cast, we check the objectâ€™s type ourselves. So, for unary -, we add:</p>
<p>åœ¨è¿›è¡Œå¼ºåˆ¶ç±»å‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦è‡ªå·±æ£€æŸ¥å¯¹è±¡çš„ç±»å‹ï¼Œå› æ­¤ï¼Œå¯¹äºä¸€å…ƒè¿ç®—ç¬¦</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitUnaryExpr()

      case MINUS:
        checkNumberOperand(expr.operator, right);
        return -(double)right;
		
</code></pre>
<p>The code to check the operand is:</p>
<p>æ£€æŸ¥è¿ç®—æ•°çš„ä»£ç å¦‚ä¸‹ï¼Œ</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitUnaryExpr()

  private void checkNumberOperand(Token operator, Object operand) {
    if (operand instanceof Double) return;
    throw new RuntimeError(operator, &quot;Operand must be a number.&quot;);
  }
  
</code></pre>
<p>When the check fails, it throws one of these:</p>
<p>å½“æ£€æµ‹åˆ°å¤±è´¥ï¼Œæˆ‘ä»¬ä¼šæŠ›å‡ºæŠ¥é”™</p>
<pre><code class="language-java">
// lox/RuntimeError.java, create new file

package com.craftinginterpreters.lox;

class RuntimeError extends RuntimeException {
  final Token token;

  RuntimeError(Token token, String message) {
    super(message);
    this.token = token;
  }
}

</code></pre>
<p>Unlike the Java cast exception, our class tracks the token that identifies where in the userâ€™s code the runtime error came from. As with static errors, this helps the user know where to fix their code.</p>
<p>å’ŒJavaä¸­çš„å¼ºåˆ¶ç±»å‹è½¬æ¢å¼‚å¸¸ä¸ä¸€æ ·ï¼Œæˆ‘ä»¬è‡ªå·±å®ç°çš„ç±»ï¼Œè¿½è¸ªåˆ°ç”¨æˆ·ä»£ç è¿è¡Œæ—¶æŠ¥é”™çš„æ¥æºtokenï¼Œä¸é™æ€é”™è¯¯ä¸€æ ·ï¼Œè¿™æ ·æœ‰åŠ©äºç”¨æˆ·çŸ¥é“å¦‚ä½•ä¿®å¤ä»£ç ã€‚</p>
<blockquote>
<p>I admit the name â€œRuntimeErrorâ€ is confusing since Java defines a RuntimeException class. An annoying thing about building interpreters is your names often collide with ones already taken by the implementation language. Just wait until we support Lox classes.</p>
<p>æˆ‘æ‰¿è®¤ï¼Œæˆ‘ä»¬å®šä¹‰çš„ç±»ï¼Œç±»åæ˜¯RuntimeErrorï¼Œéå¸¸ä»¤äººå›°æƒ‘ï¼Œå› ä¸ºJavaä¸­å®šä¹‰äº†RuntimeException ç±»ï¼Œæ„å»ºè§£é‡Šå™¨çš„ä¸€ä¸ªä»¤äººè®¨åŒçš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬çš„åå­—ç»å¸¸ä¼šå’Œå®ç°è¯­è¨€çš„å·²ç»å­˜åœ¨çš„åå­—ç›¸åŒã€‚éœ€è¦æˆ‘ä»¬è€å¿ƒç­‰å¾…ï¼Œä¸€ç›´åˆ°Loxå®ç°ç±»ã€‚</p>
</blockquote>
<p>We need similar checking for the binary operators. Since I promised you every single line of code needed to implement the interpreters, Iâ€™ll run through them all.</p>
<p>æˆ‘ä»¬è¿˜éœ€è¦å¯¹äºŒå…ƒè¿ç®—ç¬¦è¿›è¡Œç›¸ä¼¼çš„ç±»å‹æ£€æŸ¥ï¼Œæ—¢ç„¶ï¼Œæˆ‘å·²ç»ä¿è¯äº†å®ç°è§£é‡Šå™¨çš„æ¯ä¸€è¡Œä»£ç éƒ½ä¼šå‡ºç°ï¼Œæˆ‘ä¼šæŠŠå®ƒä»¬å†™åœ¨ä¸‹é¢</p>
<pre><code class="language-java">

  @Override
    public Object visitBinaryExpr(Expr.Binary expr) {
        Object left = evaluate(expr.left);
        Object right = evaluate(expr.right);

        switch (expr.operator.type) {
            case GREATER:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &gt; (double) right;
            case GREATER_EQUAL:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &gt;= (double) right;
            case LESS:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &lt; (double) right;
            case LESS_EQUAL:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &lt;= (double) right;
            case MINUS:
                checkNumberOperands(expr.operator, left, right);
                return (double) left - (double) right;
            case PLUS:
                if (left instanceof Double &amp;&amp; right instanceof Double) {
                    return (double) left + (double) right;
                }
                if (left instanceof String &amp;&amp; right instanceof String) {
                    return (String) left + (String) right;
                }
            case SLASH:
                checkNumberOperands(expr.operator, left, right);
                return (double) left / (double) right;
            case STAR:
                checkNumberOperands(expr.operator, left, right);
                return (double) left * (double) right;
            case BANG_EQUAL:
                return !isEqual(left, right);
            case EQUAL_EQUAL:
                return isEqual(left, right);
        }
        return null;
    }


</code></pre>
<pre><code class="language-java">
// lox/Interpreter.java, add after checkNumberOperand()

  private void checkNumberOperands(Token operator,
                                   Object left, Object right) {
    if (left instanceof Double &amp;&amp; right instanceof Double) return;
    
    throw new RuntimeError(operator, &quot;Operands must be numbers.&quot;);
  }


</code></pre>
<blockquote>
<p>Another subtle semantic choice: We evaluate both operands before checking the type of either. Imagine we have a function say() that prints its argument then returns it. Using that, we write:</p>
<p>say(&quot;left&quot;) - say(&quot;right&quot;);</p>
<p>Our interpreter prints â€œleftâ€ and â€œrightâ€ before reporting the runtime error. We could have instead specified that the left operand is checked before even evaluating the right.</p>
<p>å¦å¤–ä¸€ä¸ªå¾®å¦™çš„è¯­ä¹‰é€‰æ‹©ï¼Œæˆ‘ä»¬åœ¨æ£€æŸ¥ä¸¤ä¸ªæ“ä½œæ•°çš„ç±»å‹ä¹‹å‰ï¼Œå¯¹å®ƒä»¬è¿›è¡Œæ±‚å€¼ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªsay() å‡½æ•°ï¼Œå®ƒæ‰“å°å…¶å‚æ•°ï¼Œç„¶åè¿”å›å®ƒï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å®ç°</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨åœ¨æŠ¥å‘Šè¿ç®—æ—¶æŠ¥é”™ä¹‹å‰ï¼Œæ‰“å°å‡ºå·¦ã€å³ï¼Œç›¸åï¼Œæˆ‘ä»¬å¯ä»¥æŒ‡å®šåœ¨è®¡ç®—å³æ“ä½œæ•°ä¹‹å‰ï¼Œæ£€æŸ¥å·¦æ“ä½œæ•°ã€‚</p>
</blockquote>
<p>The last remaining operator, again the odd one out, is addition. Since + is overloaded for numbers and strings, it already has code to check the types. All we need to do is fail if neither of the two success cases match.</p>
<p>å‰©ä¸‹æœ€åä¸€ä¸ªæ“ä½œç¬¦ï¼Œæ˜¯åŠ æ³•ï¼Œç”±äº + å¯¹äºæ•°å­—å’Œå­—ç¬¦ä¸²æ˜¯é‡è½½çš„ï¼Œå› æ­¤ï¼Œå®ƒå·²ç»æœ‰ä»£ç è¿›è¡Œç±»å‹æ£€æŸ¥äº†ï¼Œå¦‚æœä¸¤ä¸ªé‡è½½ç±»å‹éƒ½ä¸ç¬¦åˆï¼Œéœ€è¦æŠ¥é”™</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitBinaryExpr(), replace 1 line

          return (String)left + (String)right;
        }

        throw new RuntimeError(expr.operator,
            &quot;Operands must be two numbers or two strings.&quot;);
      case SLASH:
	  
</code></pre>
<p>That gets us detecting runtime errors deep in the innards of the evaluator. The errors are getting thrown. The next step is to write the code that catches them. For that, we need to wire up the Interpreter class into the main Lox class that drives it.</p>
<p>è¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥æ£€æµ‹åˆ°è®¡ç®—å†…éƒ¨çš„è¿è¡Œæ—¶æŠ¥é”™ï¼Œä¸‹ä¸€æ­¥éœ€è¦ç¼–å†™æ•è·é”™è¯¯çš„ä»£ç ï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å°† Interperterç±»æ·»åŠ åˆ°ä¸»Loxç±»ä¸Šã€‚</p>
<h2 id="å››hooking-up-the-interpreter"><a class="header" href="#å››hooking-up-the-interpreter">å››ã€Hooking Up the Interpreter</a></h2>
<p>è¿æ¥åˆ°è§£é‡Šå™¨</p>
<p>The visit methods are sort of the guts of the Interpreter class, where the real work happens. We need to wrap a skin around them to interface with the rest of the program. The Interpreterâ€™s public API is simply one method.</p>
<p>è®¿é—®æ–¹æ³•æ˜¯è§£é‡Šå™¨ç±»çš„æ ¸å¿ƒï¼Œå› ä¸ºçœŸæ­£çš„å·¥ä½œéƒ½å‘ç”Ÿåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒåŒ…è£¹èµ·æ¥ï¼Œä»¥ä¾¿å’Œç¨‹åºçš„å…¶ä»–éƒ¨åˆ†äº¤äº’ï¼Œè§£é‡Šå™¨çš„å…¬å…±APIåªæ˜¯ä¸€ç§æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

  void interpret(Expr expression) { 
    try {
      Object value = evaluate(expression);
      System.out.println(stringify(value));
    } catch (RuntimeError error) {
      Lox.runtimeError(error);
    }
  }
  
</code></pre>
<p>This takes in a syntax tree for an expression and evaluates it. If that succeeds, evaluate() returns an object for the result value. interpret() converts that to a string and shows it to the user. To convert a Lox value to a string, we rely on:</p>
<p>ä¸Šé¢æ–¹æ³•ï¼Œå°†ä¼šè·å–è¡¨è¾¾å¼çš„è§£ææ ‘ï¼Œå¹¶ä¸”å¯¹å…¶æ±‚å€¼ï¼Œå¦‚æœæ±‚å€¼æˆåŠŸï¼Œevaluate()æ–¹æ³•ï¼Œå°†ä¼šè¿”å›ç»“æœå€¼çš„å¯¹è±¡ï¼Œinterpret() æ–¹æ³•ï¼Œä¼šå°†ç»“æœè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”è¿”å›ç»™ç”¨æˆ·ï¼Œè¦å°†ç»“æœè½¬ä¸ºå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬éœ€è¦:</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after isEqual()

  private String stringify(Object object) {
    if (object == null) return &quot;nil&quot;;

    if (object instanceof Double) {
      String text = object.toString();
      if (text.endsWith(&quot;.0&quot;)) {
        text = text.substring(0, text.length() - 2);
      }
      return text;
    }

    return object.toString();
  }

</code></pre>
<p>This is another of those pieces of code like isTruthy() that crosses the membrane between the userâ€™s view of Lox objects and their internal representation in Java.</p>
<p>Itâ€™s pretty straightforward. Since Lox was designed to be familiar to someone coming from Java, things like Booleans look the same in both languages. The two edge cases are nil, which we represent using Javaâ€™s null, and numbers.</p>
<p>Lox uses double-precision numbers even for integer values. In that case, they should print without a decimal point. Since Java has both floating point and integer types, it wants you to know which one youâ€™re using. It tells you by adding an explicit .0 to integer-valued doubles. We donâ€™t care about that, so we hack it off the end.</p>
<p>è¿™æ˜¯å¦å¤–ä¸€æ®µï¼Œåƒæ˜¯ isTruthy() æ–¹æ³•çš„ä»£ç ï¼Œå®ƒè·¨è¶Šäº†ç”¨æˆ·å¯¹Loxå¯¹è±¡çš„è§†å›¾å’Œå®ƒä»¬åœ¨Javaä¸­çš„å†…éƒ¨è¡¨ç¤ºä¹‹é—´çš„éš”é˜‚ã€‚</p>
<p>è¿™å¾ˆç®€å•ï¼Œå› ä¸ºLoxçš„è®¾è®¡ä¸ºäº†è®©Javaçš„ä½¿ç”¨è€…ç†Ÿæ‚‰ï¼Œæ‰€ä»¥ï¼Œå¸ƒå°”ç±»å‹åœ¨ä¸¤ç§è¯­è¨€ä¸­å‡ ä¹ç›¸åŒï¼Œè¿™ä¸¤ç§è¾¹ç¼˜æƒ…å†µéƒ½æ˜¯nilï¼Œæˆ‘ä»¬ä½¿ç”¨Javaçš„null å’Œæ•°å­—æ¥è¡¨ç¤º</p>
<p>Loxç”šè‡³å¯¹æ•´æ•°ï¼Œä½¿ç”¨åŒç²¾åº¦ç±»å‹è¡¨ç¤ºï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒä»¬åº”è¯¥æ²¡æœ‰å°æ•°ç‚¹ï¼Œç”±äºJavaæ—¢æœ‰æµ®ç‚¹å‹ï¼Œä¹Ÿæœ‰æ•´æ•°å‹ï¼Œæ‰€ä»¥å®ƒå¸Œæœ›ä½ çŸ¥é“ä½¿ç”¨çš„å“ªä¸€ç§ç±»å‹ï¼Œå®ƒé€šè¿‡æ˜¾å¼çš„å°† .0 æ·»åŠ åˆ°æ•´æ•°ï¼Œç”¨åŒç²¾åº¦è¡¨ç¤ºçš„æ–¹æ³•ï¼Œæ¥å‘ŠçŸ¥ã€‚æˆ‘ä»¬ä¸åœ¨ä¹è¿™ä¸€ç‚¹ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ä»å¤´å¼€å§‹ã€‚</p>
<blockquote>
<p>Yet again, we take care of this edge case with numbers to ensure that jlox and clox work the same. Handling weird corners of the language like this will drive you crazy but is an important part of the job.</p>
<p>Users rely on these detailsâ€”either deliberately or inadvertentlyâ€”and if the implementations arenâ€™t consistent, their program will break when they run it on different interpreters.</p>
<p>å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬ç”¨æ•°å­—æ¥å¤„ç†è¾¹ç¼˜çŠ¶å†µï¼Œä»¥ç¡®ä¿jlox å’Œ cloxçš„å¤„ç†æ–¹å¼ç›¸åŒï¼Œåƒè¿™æ ·çš„å¤„ç†ï¼Œè¯­è¨€ä¸­å¥‡æ€ªè§’è½ä¼šè®©ä½ å‘ç–¯ï¼Œä½†è¿™æ˜¯å·¥ä½œçš„é‡è¦ç»„æˆéƒ¨åˆ†</p>
<p>ç”¨æˆ·æœ‰æ„æˆ–è€…æ— æ„çš„ä¾èµ–è¿™äº›ç»†èŠ‚ï¼Œå¦‚æœå®ç°ä¸ä¸€è‡´ï¼Œä»–ä»¬çš„ç¨‹åºå°†åœ¨ä¸åŒçš„è§£é‡Šå™¨ä¸Šï¼Œå‡ºç°ä¸­æ–­ã€‚</p>
</blockquote>
<h3 id="41-reporting-runtime-errors"><a class="header" href="#41-reporting-runtime-errors">4.1 Reporting runtime errors</a></h3>
<p>æŠ¥å‘Šè¿è¡Œæ—¶æŠ¥é”™</p>
<p>If a runtime error is thrown while evaluating the expression, interpret() catches it. This lets us report the error to the user and then gracefully continue. All of our existing error reporting code lives in the Lox class, so we put this method there too:</p>
<p>å¦‚æœåœ¨è®¡ç®—è¡¨è¾¾å¼æ—¶å€™ï¼Œå¼•å‘è¿è¡Œæ—¶æŠ¥é”™ï¼Œinterpert() æ–¹æ³•ï¼Œå°†ä¼šæ•è·åˆ°è¯¥ç±»å‹çš„é”™è¯¯ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç”¨æˆ·æŠ¥å‘Šé”™è¯¯ï¼Œç„¶åï¼Œä¼˜é›…çš„ç»§ç»­è¿è¡Œï¼Œæˆ‘ä»¬ç°åœ¨ï¼Œæ‰€æœ‰çš„æŠ¥é”™ä»£ç éƒ½åœ¨Loxç±»ä¸­ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å°†æ­¤æ–¹æ³•å†™åœ¨é‚£é‡Œï¼š</p>
<pre><code class="language-java">
// lox/Lox.java, add after error()

  static void runtimeError(RuntimeError error) {
    System.err.println(error.getMessage() +
        &quot;\n[line &quot; + error.token.line + &quot;]&quot;);
    hadRuntimeError = true;
  }


</code></pre>
<p>We use the token associated with the RuntimeError to tell the user what line of code was executing when the error occurred. Even better would be to give the user an entire call stack to show how they got to be executing that code. But we donâ€™t have function calls yet, so I guess we donâ€™t have to worry about it.</p>
<p>æˆ‘ä»¬ä½¿ç”¨ä¸ RuntimeError å…³è”çš„tokenï¼Œæ¥å‘Šè¯‰ç”¨æˆ·ï¼Œé”™è¯¯å‘ç”Ÿæ—¶å€™æ­£åœ¨è¿è¡Œçš„ä»£ç è¡Œæ•°ï¼Œæ›´å¥½çš„æ–¹æ³•æ˜¯ç»™ç”¨æˆ·ä¸€ä¸ªå®Œæ•´çš„è°ƒç”¨å †æ ˆï¼Œä»¥æ˜¾ç¤ºä»–ä»¬æ˜¯å¦‚ä½•æ‰§è¡Œä»£ç çš„ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ²¡æœ‰å‡½æ•°è°ƒç”¨ï¼Œæ‰€ä»¥ï¼Œæˆ‘æƒ³è¿˜ä¸éœ€è¦æ‹…å¿ƒã€‚</p>
<p>After showing the error, runtimeError() sets this field:</p>
<p>æ˜¾ç¤ºé”™è¯¯åï¼Œå°†æŠŠå˜é‡ hadRuntimeError è®¾ç½®ä¸ºtrue</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

  static boolean hadError = false;
  static boolean hadRuntimeError = false;

  public static void main(String[] args) throws IOException {
  
</code></pre>
<p>That field plays a small but important role.</p>
<p>è¿™ä¸ªå­—æ®µ hadRuntimeErroræœ‰é‡è¦çš„ä½œç”¨</p>
<pre><code class="language-java">
// lox/Lox.java, in runFile()

    run(new String(bytes, Charset.defaultCharset()));

    // Indicate an error in the exit code.
    if (hadError) System.exit(65);
    if (hadRuntimeError) System.exit(70);
  }
  
</code></pre>
<p>If the user is running a Lox script from a file and a runtime error occurs, we set an exit code when the process quits to let the calling process know. Not everyone cares about shell etiquette, but we do.</p>
<p>å¦‚æœç”¨æˆ·æ­£åœ¨ä»æ–‡ä»¶è¿è¡ŒLox è„šæœ¬ï¼Œå¹¶ä¸”å‘ç”Ÿäº†è¿è¡Œæ—¶æŠ¥é”™ï¼Œæˆ‘ä»¬å°†åœ¨è¿›ç¨‹é€€å‡ºæ—¶å€™ï¼Œè®¾ç½®é€€å‡ºä»£ç ï¼Œè®©è°ƒç”¨è¿›ç¨‹çŸ¥é“ï¼Œä¸æ˜¯æ¯ä¸€ä¸ªäººéƒ½å…³å¿ƒshell é€€å‡ºä¿¡å·ï¼Œä½†æ˜¯æˆ‘ä»¬ç¡®å®å…³å¿ƒã€‚</p>
<blockquote>
<p>If the user is running the REPL, we donâ€™t care about tracking runtime errors. After they are reported, we simply loop around and let them input new code and keep going.</p>
<p>å¦‚æœç”¨æˆ·æ­£åœ¨è¿è¡Œ REPL, æˆ‘ä»¬ä¸å…³å¿ƒè·Ÿè¸ªè¿è¡Œæ—¶æŠ¥é”™ï¼Œåœ¨è¿è¡Œæ—¶æŠ¥é”™æŠ¥å‘Šåï¼Œæˆ‘ä»¬åªéœ€è¦å¾ªç¯ï¼Œè®©ç”¨æˆ·ç»§ç»­è¾“å…¥æ–°ä»£ç å¹¶ä¸”ç»§ç»­è§£é‡Šè¿è¡Œã€‚</p>
</blockquote>
<h3 id="42-running-the-interpreter"><a class="header" href="#42-running-the-interpreter">4.2 Running the interpreter</a></h3>
<p>è¿è¡Œè§£é‡Šå™¨</p>
<p>Now that we have an interpreter, the Lox class can start using it.</p>
<p>ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªè§£é‡Šå™¨ï¼ŒLoxç±»å¯ä»¥ä½¿ç”¨å®ƒäº†</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

public class Lox {
  private static final Interpreter interpreter = new Interpreter();
  static boolean hadError = false;

</code></pre>
<p>We make the field static so that successive calls to run() inside a REPL session reuse the same interpreter. That doesnâ€™t make a difference now, but it will later when the interpreter stores global variables. Those variables should persist throughout the REPL session.</p>
<p>æˆ‘ä»¬å°†å­—æ®µ interpreter è®¾ç½®ä¸ºé™æ€ï¼Œä»¥ä¾¿äºå¯¹ REPLä¼šè¯ä¸­ï¼Œå¯¹äºrun()æ–¹æ³•çš„è¿ç»­è°ƒç”¨ï¼Œä½¿ç”¨ç›¸åŒçš„è§£é‡Šå™¨ï¼Œç°åœ¨ï¼Œè¿™æ ·å¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒï¼Œä½†æ˜¯ç¨åï¼Œå½“è§£é‡Šå™¨å­˜å‚¨äº†å…¨å±€å˜é‡åï¼Œæƒ…å†µå°±ä¼šå‘ç”Ÿå˜åŒ–ï¼Œè¿™äº›å˜é‡åœ¨ REPL ä¼šè¯ä¸­ä¼šå§‹ç»ˆå­˜åœ¨ã€‚</p>
<p>Finally, we remove the line of temporary code from the last chapter for printing the syntax tree and replace it with this:</p>
<p>æœ€åï¼Œæˆ‘ä»¬åˆ é™¤äº†ä¸Šä¸€ç« ï¼Œç”¨äºæ‰“å°è¯­æ³•æ ‘çš„ä¸€è¡Œä¸´æ—¶ä»£ç ï¼Œå¹¶ä¸”æ›¿æ¢ä¸º</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 1 line

    // Stop if there was a syntax error.
    if (hadError) return;

    interpreter.interpret(expression);
  }

</code></pre>
<p>We have an entire language pipeline now: scanning, parsing, and execution. Congratulations, you now have your very own arithmetic calculator.</p>
<p>As you can see, the interpreter is pretty bare bones. But the Interpreter class and the Visitor pattern weâ€™ve set up today form the skeleton that later chapters will stuff full of interesting gutsâ€”variables, functions, etc. Right now, the interpreter doesnâ€™t do very much, but itâ€™s alive!</p>
<p>æˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ä¸ªå®Œæ•´çš„è¯­è¨€ç®¡é“ï¼Œæ‰«æã€è§£æå’Œæ‰§è¡Œï¼Œæ­å–œä½ ï¼Œç°åœ¨æˆ‘ä»¬æœ‰äº†è‡ªå·±çš„ç®—æœ¯è®¡ç®—å™¨</p>
<p>æ­£å¦‚æˆ‘ä»¬éƒ½å¯ä»¥çœ‹åˆ°çš„ï¼Œç°åœ¨çš„è§£é‡Šå™¨æ˜¯éå¸¸ç®€å•çš„ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬ä»Šå¤©æ„é€ çš„è§£é‡Šå™¨ç±»å’Œè®¿é—®è€…æ¨¡å¼ï¼Œæ„æˆäº†ä¸€ä¸ªæ¡†æ¶ï¼Œåœ¨åé¢ï¼Œå°†ä¼šå……æ»¡æœ‰æ„æ€çš„å†…è„â€”â€”å˜é‡ã€å‡½æ•°ã€‚ç°åœ¨ï¼Œè§£é‡Šå™¨åšçš„ä¸å¤šï¼Œä½†æ˜¯çš„ç¡®æœ‰ä½œç”¨ï¼</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/skeleton.png?raw=true" alt="skeleton" /></p>
<h2 id="äº”challenges"><a class="header" href="#äº”challenges">äº”ã€CHALLENGES</a></h2>
<p>ä¹ é¢˜</p>
<ol>
<li>
<p>Allowing comparisons on types other than numbers could be useful. The operators might have a reasonable interpretation for strings. Even comparisons among mixed types, like 3 &lt; &quot;pancake&quot; could be handy to enable things like ordered collections of heterogeneous types. Or it could simply lead to bugs and confusion.</p>
<p>Would you extend Lox to support comparing other types? If so, which pairs of types do you allow and how do you define their ordering? Justify your choices and compare them to other languages.</p>
</li>
<li>
<p>Many languages define + such that if either operand is a string, the other is converted to a string and the results are then concatenated. For example, &quot;scone&quot; + 4 would yield scone4. Extend the code in visitBinaryExpr() to support that.</p>
</li>
<li>
<p>What happens right now if you divide a number by zero? What do you think should happen? Justify your choice. How do other languages you know handle division by zero, and why do they make the choices they do?</p>
<p>Change the implementation in visitBinaryExpr() to detect and report a runtime error for this case.</p>
</li>
</ol>
<h2 id=""><a class="header" href="#"></a></h2>
<ol>
<li>
<p>å…è®¸å¯¹æ•°å­—ä¹‹å¤–çš„ç±»å‹è¿›è¡Œæ¯”è¾ƒï¼Œå¯èƒ½ä¼šéå¸¸æœ‰ç”¨ï¼Œè¿ç®—ç¬¦å¯èƒ½å¯¹å­—ç¬¦ä¸²æœ‰åˆç†çš„è§£é‡Šï¼Œå³ä½¿æ˜¯æ··åˆç±»å‹ä¹‹é—´çš„æ¯”è¾ƒï¼Œä¾‹å¦‚ï¼š3 &lt; &quot;pancake&quot;, ä¹Ÿå¯ä»¥æ–¹ä¾¿çš„å®ç°ï¼Œå¼‚æ„ç±»å‹çš„æœ‰åºé›†åˆï¼Œæˆ–è€…å®ƒå¯èƒ½ä¼šå¯¼è‡´é”™è¯¯å’Œæ··ä¹±ã€‚</p>
<p>ä½ ä¼šæ‰©å±•æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œæ”¯æŒä¸åŒçš„æ•°æ®ç±»å‹å—ï¼Ÿå¦‚æœæ‰©å±•ï¼Œä½ ä¼šæ”¯æŒå¯¹äºå“ªäº›ç±»å‹ï¼Œå¦‚ä½•å®šä¹‰å®ƒä»¬çš„å¤§å°ï¼ŒéªŒè¯ä½ çš„æƒ³æ³•ï¼Œå¹¶ä¸”ä¸å…¶ä»–è¯­æ³•è¿›è¡Œæ¯”è¾ƒã€‚</p>
</li>
<li>
<p>è®¸å¤šè¯­è¨€å®šä¹‰+ è¿ç®—ç¬¦ï¼Œå¦‚æœä¸€ä¸ªæ“ä½œæ•°æ˜¯å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå¦å¤–ä¸€ä¸ªæ“ä½œæ•°ä¹Ÿä¼šè½¬å˜ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åå°†å®ƒä»¬çš„ç»“æœè¿æ¥ï¼Œä¾‹å¦‚: &quot;scone&quot; + 4 å°†å˜ä¸º &quot;scone4&quot;, æ‰©å±•ä»£ç ï¼Œå®ç°è¿™ä¸ªåŠŸèƒ½</p>
</li>
<li>
<p>å¦‚æœé™¤é›¶ï¼Œç°åœ¨Loxä¼šå‘ç”Ÿä»€ä¹ˆï¼Œä½ è®¤ä¸ºåº”è¯¥å‘ç”Ÿä»€ä¹ˆï¼Ÿè¯æ˜ä½ çš„æƒ³æ³•æ˜¯æ­£ç¡®çš„ã€‚å…¶ä»–è¯­è¨€æ˜¯å¦‚ä½•å®ç°é™¤é›¶çš„ï¼Œä¸ºä»€ä¹ˆä»–ä»¬ä¼šè¿™æ ·åšå‘¢ï¼Ÿ</p>
<p>ä¿®æ”¹ visitBinaryExpr()æ–¹æ³•ï¼Œé‡åˆ°é™¤é›¶æƒ…å†µï¼ŒæŠ¥å‘Šä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯</p>
</li>
</ol>
<h2 id="å…­design-note-static-and-dynamic-typing"><a class="header" href="#å…­design-note-static-and-dynamic-typing">å…­ã€DESIGN NOTE: STATIC AND DYNAMIC TYPING</a></h2>
<p>è®¾è®¡è¯´æ˜ï¼šé™æ€å’ŒåŠ¨æ€ç±»å‹</p>
<p>Some languages, like Java, are statically typed which means type errors are detected and reported at compile time before any code is run. Others, like Lox, are dynamically typed and defer checking for type errors until runtime right before an operation is attempted. We tend to consider this a black-and-white choice, but there is actually a continuum between them.</p>
<p>It turns out even most statically typed languages do some type checks at runtime. The type system checks most type rules statically, but inserts runtime checks in the generated code for other operations.</p>
<p>æœ‰äº›è¯­è¨€ï¼Œä¾‹å¦‚Javaï¼Œæ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œè¿™æ„å‘³ç€ï¼Œåœ¨è¿è¡Œä»»ä½•ä»£ç ä¹‹å‰ï¼Œéƒ½ä¼šåœ¨ç¼–è¯‘æ—¶å€™ï¼Œæ£€æµ‹å¹¶ä¸”æŠ¥å‘Šç±»å‹é”™è¯¯ï¼› å…¶ä»–çš„ï¼Œä¾‹å¦‚ï¼šLoxè¯­è¨€ï¼Œæ˜¯åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œå°†æ£€æŸ¥ç±»å‹é”™è¯¯çš„æ—¶é—´æ¨è¿Ÿåˆ°è¿è¡Œæ—¶å€™ï¼Œç„¶åå†å°è¯•æ“ä½œã€‚æˆ‘ä»¬å€¾å‘äºè¿™æ˜¯ä¸€ä¸ªéé»‘å³ç™½çš„é€‰æ‹©ï¼Œä½†æ˜¯ï¼Œå®é™…ä¸Šï¼Œå®ƒä»¬ä¹‹é—´å­˜åœ¨è¿ç»­åœºæ™¯ã€‚</p>
<p>äº‹å®è¯æ˜ï¼Œå³ä½¿æ˜¯ï¼Œå¤§å¤šæ•°çš„é™æ€ç±»å‹è¯­è¨€ï¼Œä¹Ÿä¼šåœ¨è¿è¡Œæ—¶å€™ï¼Œæ‰§è¡Œä¸€äº›ç±»å‹æ£€æµ‹ã€‚ç±»å‹ç³»ç»Ÿä¼šé™æ€æ£€æŸ¥å¤§å¤šæ•°çš„è§„åˆ™ï¼Œä½†æ˜¯ï¼Œç”Ÿæˆçš„ä»£ç ä¸­è¿˜æ˜¯ä¼šæ’å…¥è¿è¡Œæ—¶æ£€æŸ¥ï¼Œä»¥ç”¨äºå…¶ä»–æ“ä½œã€‚</p>
<p>For example, in Java, the static type system assumes a cast expression will always safely succeed. After you cast some value, you can statically treat it as the destination type and not get any compile errors. But downcasts can fail, obviously. The only reason the static checker can presume that casts always succeed without violating the languageâ€™s soundness guarantees, is because the cast is checked at runtime and throws an exception on failure.</p>
<p>ä¾‹å¦‚ï¼šåœ¨Javaä¸­ï¼Œé™æ€ç±»å‹ç³»ç»Ÿï¼Œæ€»æ˜¯å‡è®¾å¼ºåˆ¶è½¬æ¢è¡¨è¾¾å¼ï¼Œä¸€å®šæ‰§è¡ŒæˆåŠŸã€‚åœ¨å¼ºåˆ¶è½¬æ¢æŸä¸ªå€¼åï¼Œå¯ä»¥å°†å…¶é™æ€çš„è§†ä¸ºç›®æ ‡ç±»å‹ï¼Œè€Œä¸ä¼šå‡ºç°ä»»ä½•çš„ç¼–è¯‘æŠ¥é”™ã€‚ä½†æ˜¯ï¼Œæ˜¾ç„¶ï¼Œä¸æ˜¯æ‰€æœ‰çš„ç±»å‹è½¬æ¢éƒ½èƒ½æˆåŠŸã€‚é™æ€æ£€æŸ¥å™¨ï¼Œå¯ä»¥å‡è®¾å¼ºåˆ¶è½¬æ¢æ€»æ˜¯æˆåŠŸï¼Œå¹¶ä¸”ä¸è¿åè¯­è¨€çš„å¯é æ€§çš„å”¯ä¸€åŸå› æ˜¯ï¼Œå¼ºåˆ¶è½¬æ¢åœ¨è¿è¡Œæ—¶å€™è¿˜ä¼šè¢«æ£€æŸ¥ï¼Œå¹¶ä¸”åœ¨è½¬æ¢å¤±è´¥åï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚</p>
<p>A more subtle example is covariant arrays in Java and C#. The static subtyping rules for arrays allow operations that are not sound. Consider:</p>
<p>ä¸€ä¸ªæ›´åŠ å¾®å¦™çš„ä¾‹å­æ˜¯ï¼ŒJava æˆ–è€… C# ä¸­çš„åå˜æ•°ç»„ï¼Œæ•°ç»„çš„é™æ€å­ç±»å‹è§„åˆ™å…è®¸ä¸æ­£ç¡®çš„æ“ä½œï¼Œä¾‹å¦‚ï¼š</p>
<pre><code class="language-java">
Object[] stuff = new Integer[1];
stuff[0] = &quot;not an int!&quot;;


</code></pre>
<p>This code compiles without any errors. The first line upcasts the Integer array and stores it in a variable of type Object array. The second line stores a string in one of its cells. The Object array type statically allows thatâ€”strings are Objectsâ€”but the actual Integer array that stuff refers to at runtime should never have a string in it! To avoid that catastrophe, when you store a value in an array, the JVM does a runtime check to make sure itâ€™s an allowed type. If not, it throws an ArrayStoreException.</p>
<p>Java could have avoided the need to check this at runtime by disallowing the cast on the first line. It could make arrays invariant such that an array of Integers is not an array of Objects. Thatâ€™s statically sound, but it prohibits common and safe patterns of code that only read from arrays. Covariance is safe if you never write to the array. Those patterns were particularly important for usability in Java 1.0 before it supported generics. James Gosling and the other Java designers traded off a little static safety and performanceâ€”those array store checks take timeâ€”in return for some flexibility.</p>
<p>ä¸Šé¢çš„ä»£ç åœ¨ç¼–è¯‘æ—¶å€™ï¼Œä¸ä¼šæŠ¥é”™ã€‚ç¬¬ä¸€è¡Œä»£ç ï¼Œè½¬æ¢Integeræ•°ç»„ï¼Œå¹¶ä¸”ä¿å­˜åœ¨Objectæ•°ç»„ç±»å‹çš„å˜é‡ stuffä¸­ï¼Œç¬¬äºŒè¡Œä»£ç ï¼Œåœ¨å…¶ä¸­çš„ä¸€ä¸ªæ•°ç»„å•å…ƒä¸­ï¼Œä¿å­˜å­—ç¬¦ä¸²ã€‚Objectæ•°ç»„ï¼Œåœ¨ç¼–è¯‘æ—¶å€™ï¼Œå…è®¸å…¶ä¸­çš„å…ƒç´ æ˜¯å­—ç¬¦ä¸²ï¼ˆå­—ç¬¦ä¸²ä¹Ÿæ˜¯Objectï¼‰ï¼Œä½†æ˜¯ï¼Œåœ¨å®é™…è¿è¡Œæ—¶å€™ï¼Œå¼•ç”¨çš„æ•´æ•°æ•°ç»„ä¸­ä¸åº”è¯¥æœ‰å­—ç¬¦ä¸²ã€‚ä¸ºäº†é¿å…è¿™ç§ç¾éš¾çº§é”™è¯¯ï¼Œå½“ä½ åœ¨æ•°ç»„ä¸­å­˜å‚¨æ•°å€¼æ—¶å€™ï¼ŒJVM å°†ä¼šåœ¨è¿è¡Œæ—¶å€™è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œä»¥ç¡®ä¿æ˜¯æ­£ç¡®çš„ç±»å‹ï¼Œå¦‚æœå‡ºç°ä¸å…è®¸çš„ç±»å‹ï¼Œå°†ä¼šæŠ›å‡º ArrayStoreException æŠ¥é”™ã€‚</p>
<p>Java ä¹Ÿå¯ä»¥é€šè¿‡é™æ­¢ç¬¬ä¸€è¡Œä»£ç ä¸­çš„ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œæ¥é¿å…è¿è¡Œæ—¶å€™çš„æ£€æŸ¥ã€‚å®ƒå¯ä»¥ä½¿æ•°ç»„ä¿æŒä¸å˜ï¼Œä»è€Œæ•´æ•°æ•°ç»„ä¸ä¼šå˜ä¸ºå¯¹è±¡æ•°ç»„ã€‚è¿™æ˜¯é™æ€çš„ï¼Œä½†æ˜¯å®ƒç¦æ­¢ï¼Œåªä»æ•°ç»„ä¸­è¯»å–çš„å¸¸è§å®‰å…¨çš„ä»£ç æ¨¡å¼ã€‚å¦‚æœä»ä¸å†™å…¥æ•°ç»„ï¼Œåˆ™åå˜æ•°ç»„æ˜¯å®‰å…¨çš„ã€‚åœ¨Java1.0æ”¯æŒ æ³›å‹ä¹‹å‰ï¼Œè¿™äº›æ¨¡å¼å¯¹äºå¯ç”¨æ€§éå¸¸é‡è¦ã€‚James Gosling å’Œå…¶ä»–çš„Javaè®¾è®¡äººå‘˜ï¼Œäº¤æ¢äº†ä¸€äº›é™æ€å®‰å…¨æ€§å’Œæ€§èƒ½ï¼Œ å› ä¸ºè¿è¡Œæ—¶å€™çš„ç±»å‹æ£€æŸ¥éœ€è¦ä¸€äº›æ—¶é—´ï¼Œä½†æ˜¯æé«˜äº†ä»£ç çš„çµæ´»æ€§ã€‚</p>
<p>There are few modern statically typed languages that donâ€™t make that trade-off somewhere. Even Haskell will let you run code with non-exhaustive matches. If you find yourself designing a statically typed language, keep in mind that you can sometimes give users more flexibility without sacrificing too many of the benefits of static safety by deferring some type checks until runtime.</p>
<p>On the other hand, a key reason users choose statically typed languages is because of the confidence the language gives them that certain kinds of errors can never occur when their program is run. Defer too many type checks until runtime, and you erode that confidence.</p>
<p>å¾ˆå°‘æœ‰ç°ä»£çš„é™æ€ç±»å‹è¯­è¨€ï¼Œåœ¨æŸäº›æ–¹é¢ä¸åšå‡ºè¿™æ ·çš„æƒè¡¡ã€‚ç”šè‡³ï¼ŒHaskellä¹Ÿå…è®¸æˆ‘ä»¬ä½¿ç”¨éç©·å°½åŒ¹é…æ¥è¿è¡Œä»£ç ã€‚å¦‚æœï¼Œä½ åœ¨è®¾è®¡é™æ€è¯­è¨€ã€‚è¯·è®°ä½ï¼Œé€šè¿‡å°†æŸäº›ç±»å‹æ£€æŸ¥æ¨è¿Ÿåˆ°è¿è¡Œæ—¶è¿›è¡Œï¼Œæœ‰æ—¶å€™å¯ä»¥ç»™ç”¨æˆ·æä¾›æ›´é«˜çš„çµæ´»æ€§ï¼Œè€Œä¸”ä¸ä¼šç‰ºç‰²å¤ªå¤šçš„é™æ€å®‰å…¨æ€§èƒ½ã€‚</p>
<p>å¦ä¸€æ–¹é¢ï¼Œç”¨æˆ·é€‰æ‹©é™æ€ç±»å‹è¯­è¨€çš„ä¸€ä¸ªå…³é”®åŸå› æ˜¯ï¼Œè¿™ç§è¯­è¨€è®©ä»–ä»¬ç›¸ä¿¡ï¼Œè¿è¡Œç¨‹åºæ—¶å€™ï¼Œæ°¸è¿œä¸ä¼šå‘ç”Ÿç±»å‹çš„é”™è¯¯ã€‚å¦‚æœå°†è¿‡å¤šçš„ç±»å‹æ£€æŸ¥æ¨è¿Ÿåˆ°è¿è¡Œæ—¶ï¼Œå°†ä¼šå‡å°‘ç”¨æˆ·çš„ä¿¡å¿ƒã€‚</p>

			<div id="bottom"> 
			     <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>

			     <a href="https://info.flagcounter.com/42Wy"><img src="https://s01.flagcounter.com/count/42Wy/bg_FFFFFF/txt_000000/border_CCCCCC/columns_3/maxflags_9/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a>
		       </div>   	 							 
                       <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="../tree/parsing-expression.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                        </a>

                            <a rel="next" href="../tree/statements-and-state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tree/parsing-expression.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../tree/statements-and-state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../giscus.js"></script>


    </body>


</html>
