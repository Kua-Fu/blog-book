<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4717236929129160"
     crossorigin="anonymous"></script>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ç»§æ‰¿ - crafting-interpreters-zh</title>


        <!-- Custom HTML head -->
	<script src="https://static.guance.com/browser-sdk/v2/dataflux-rum.js" type="text/javascript"></script>
	<script>
	window.DATAFLUX_RUM &&
	window.DATAFLUX_RUM.init({
	applicationId: 'thewind_blog',
	datakitOrigin: 'https://www.poetries.cn/rum', 
	env: 'production',
	version: '1.0.0',
	trackInteractions: true,
	traceType: 'ddtrace',
	allowedTracingOrigins: [/https:\/\/.*\.poetries\.cn/, "https://poetries.cn"], 
	})
	</script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MMN1K84KRS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-MMN1K84KRS');
</script>


        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../index.html">å‰è¨€</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">æ¬¢è¿</li><li class="chapter-item "><a href="../welcome/welcome.html"><strong aria-hidden="true">1.</strong> æ¬¢è¿</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../welcome/introduction.html"><strong aria-hidden="true">1.1.</strong> ä»‹ç»</a></li><li class="chapter-item "><a href="../welcome/a-map-of-the-territory.html"><strong aria-hidden="true">1.2.</strong> æ€»è§ˆå›¾</a></li><li class="chapter-item "><a href="../welcome/the-lox-language.html"><strong aria-hidden="true">1.3.</strong> Loxè¯­è¨€</a></li></ol></li><li class="chapter-item "><li class="part-title">è§£ææ ‘</li><li class="chapter-item expanded "><a href="../tree/tree.html"><strong aria-hidden="true">2.</strong> è§£ææ ‘</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tree/scanning.html"><strong aria-hidden="true">2.1.</strong> æ‰«æ</a></li><li class="chapter-item "><a href="../tree/representing-code.html"><strong aria-hidden="true">2.2.</strong> ä»£ç è¡¨ç¤º</a></li><li class="chapter-item "><a href="../tree/parsing-expression.html"><strong aria-hidden="true">2.3.</strong> è§£æè¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="../tree/evaluating-expression.html"><strong aria-hidden="true">2.4.</strong> è®¡ç®—è¡¨è¾¾å¼</a></li><li class="chapter-item "><a href="../tree/statements-and-state.html"><strong aria-hidden="true">2.5.</strong> è¯­å¥å’ŒçŠ¶æ€</a></li><li class="chapter-item "><a href="../tree/control-flow.html"><strong aria-hidden="true">2.6.</strong> æ§åˆ¶æµç¨‹</a></li><li class="chapter-item "><a href="../tree/functions.html"><strong aria-hidden="true">2.7.</strong> å‡½æ•°</a></li><li class="chapter-item "><a href="../tree/resolving-and-binding.html"><strong aria-hidden="true">2.8.</strong> è§£æä¸ç»‘å®š</a></li><li class="chapter-item "><a href="../tree/classes.html"><strong aria-hidden="true">2.9.</strong> ç±»</a></li><li class="chapter-item expanded "><a href="../tree/inheritance.html" class="active"><strong aria-hidden="true">2.10.</strong> ç»§æ‰¿</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">crafting-interpreters-zh</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/Kua-Fu/blog-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>


                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ç»§æ‰¿"><a class="header" href="#ç»§æ‰¿">ç»§æ‰¿</a></h1>
<blockquote>
<p>Once we were blobs in the sea, and then fishes, and then lizards and rats and then monkeys, and hundreds of things in between. This hand was once a fin, this hand once had claws! In my human mouth I have the pointy teeth of a wolf and the chisel teeth of a rabbit and the grinding teeth of a cow! Our blood is as salty as the sea we used to live in! When weâ€™re frightened, the hair on our skin stands up, just like it did when we had fur. We are history! Everything weâ€™ve ever been on the way to becoming us, we still are.</p>
<p align="right"> â€”â€” Terry Pratchett, A Hat Full of Sky</p>
<p>æ›¾ç»æˆ‘ä»¬æ˜¯æµ·æ´‹ä¸­çš„æ³¥å—ï¼Œç„¶åæ˜¯é±¼ï¼Œç„¶åæ˜¯èœ¥èœ´ã€è€é¼ ï¼Œæ¥ç€æ˜¯çŒ´å­ï¼Œè¿˜æœ‰æ•°ç™¾ç§ä¸­é—´å½¢æ€ï¼Œè¿™åŒæ‰‹æ›¾ç»æ˜¯é±¼é³ï¼Œæ›¾ç»æ˜¯çˆªå­ï¼Œåœ¨æˆ‘ä»¬äººç±»çš„å˜´ä¸­ï¼Œæœ‰ç‹¼çš„å°–ç‰™ã€å…”å­çš„å‡¿é½¿ã€ç‰›çš„ç£¨ç‰™ï¼Œæˆ‘ä»¬çš„è¡€æ¶²å’Œæ›¾ç»ç”Ÿæ´»è¿‡çš„æµ·æ´‹ä¸€æ ·å’¸ã€‚å½“æˆ‘ä»¬å®³æ€•æ—¶å€™ï¼Œèº«ä¸Šçš„æ¯›å‘ä¼šæ ‘ç«‹èµ·æ¥ï¼Œå°±åƒæˆ‘ä»¬è¿˜æœ‰çš®æ¯›ä¸€æ ·ï¼Œæˆ‘ä»¬æ˜¯å†å²ï¼Œæ›¾ç»ç»å†çš„ä¸€åˆ‡ï¼Œéƒ½æ˜¯æˆä¸ºç°åœ¨çš„æˆ‘ä»¬çš„è¿‡ç¨‹ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬ä»ç„¶æ˜¯é‚£äº›ç»å†çš„æ€»å’Œã€‚</p>
<p align="right"> â€”â€” Terry Pratchett, A Hat Full of Sky</p>
</blockquote>
<p>Can you believe it? Weâ€™ve reached the last chapter of Part II. Weâ€™re almost done with our first Lox interpreter. The previous chapter was a big ball of intertwined object-orientation features. I couldnâ€™t separate those from each other, but I did manage to untangle one piece. In this chapter, weâ€™ll finish off Loxâ€™s class support by adding inheritance.</p>
<p>Inheritance appears in object-oriented languages all the way back to the first one, Simula. Early on, Kristen Nygaard and Ole-Johan Dahl noticed commonalities across classes in the simulation programs they wrote. Inheritance gave them a way to reuse the code for those similar parts.</p>
<p>ä½ èƒ½ç›¸ä¿¡å—ï¼Ÿæˆ‘ä»¬å·²ç»åˆ°è¾¾ç¬¬äºŒéƒ¨åˆ†çš„æœ€åä¸€ç« ï¼Œæˆ‘ä»¬å³å°†å®Œæˆç¬¬ä¸€ä¸ªè§£é‡Šå™¨ï¼Œä¸Šä¸€ç« æ˜¯ä¸€ä¸ªäº¤ç»‡ç€å¯¹è±¡å¯¼å‘ç‰¹æ€§çš„å¤§çƒï¼Œæˆ‘æ— æ³•å°†å…¶åˆ†å¼€ï¼Œä½†æ˜¯ï¼Œæˆ‘è®¾æ³•è§£å¼€äº†å…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œåœ¨æœ¬ç« ï¼Œæˆ‘ä»¬å°†æ·»åŠ ç»§æ‰¿ç‰¹æ€§æ¥å®ŒæˆLoxè¯­è¨€çš„ç±»çš„æ”¯æŒã€‚</p>
<p>ç»§æ‰¿å‡ºç°åœ¨é¢å‘å¯¹è±¡çš„è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥è¿½æº¯åˆ°ç¬¬ä¸€ä¸ªé¢å‘å¯¹è±¡çš„è¯­è¨€ï¼ŒSimula, æ—©æœŸï¼ŒKristen Nygaardå’ŒOle-Johan Dahlåœ¨ç¼–å†™æ¨¡æ‹Ÿç¨‹åºæ—¶å€™ï¼Œæ³¨æ„åˆ°ç±»ä¹‹é—´çš„å…±æ€§ã€‚ç»§æ‰¿ä¸ºä»–ä»¬æä¾›äº†ä¸€ç§å¤ç”¨è¿™äº›ç›¸ä¼¼éƒ¨åˆ†ä»£ç çš„æ–¹å¼</p>
<blockquote>
<p>You could say all those other languages inherited it from Simula. Hey-ooo! Iâ€™ll, uh, see myself out.</p>
<p>ä½ å¯ä»¥è¯´ï¼Œå…¶ä»–è¯­è¨€çš„ç»§æ‰¿éƒ½å‚è€ƒäº† Simula</p>
</blockquote>
<h2 id="ä¸€superclasses-and-subclasses"><a class="header" href="#ä¸€superclasses-and-subclasses">ä¸€ã€Superclasses and Subclasses</a></h2>
<p>è¶…ç±»å’Œå­ç±»</p>
<p>Given that the concept is â€œinheritanceâ€, you would hope they would pick a consistent metaphor and call them â€œparentâ€ and â€œchildâ€ classes, but that would be too easy. Way back when, C. A. R. Hoare coined the term â€œsubclassâ€ to refer to a record type that refines another type. Simula borrowed that term to refer to a class that inherits from another. I donâ€™t think it was until Smalltalk came along that someone flipped the Latin prefix to get â€œsuperclassâ€ to refer to the other side of the relationship. From C++, you also hear â€œbaseâ€ and â€œderivedâ€ classes. Iâ€™ll mostly stick with â€œsuperclassâ€ and â€œsubclassâ€.</p>
<p>é‰´äºè¿™ä¸ªæ¦‚å¿µæ˜¯ç»§æ‰¿ï¼Œä½ å¸Œæœ›ä»–ä»¬ä¼šé€‰æ‹©ä¸€ä¸ªä¸€è‡´çš„éšå–»ï¼Œç§°ä¹‹ä¸ºçˆ¶ç±»å’Œå­ç±»ï¼Œè¿™æ ·å¤ªå®¹æ˜“äº†ã€‚å¾ˆä¹…ä»¥å‰ï¼ŒC.A.R.Hoare åˆ›é€ äº†æœ¯è¯­&quot;å­ç±»&quot; æ¥æŒ‡ä»£ä¸€ç§ç±»å‹â€”â€”æ”¹è¿›äº†ä¸€ç§ç±»å‹ã€‚Simula å¼•å…¥äº†è¿™ä¸ªæ¦‚å¿µï¼Œè¡¨ç¤ºä»å¦ä¸€ä¸ªç±»ç»§æ‰¿çš„ç±»ã€‚æˆ‘è®¤ä¸ºä¸€ç›´åˆ°Smalltalkå‡ºç°ï¼Œæ‰æœ‰äººç¿»è½¬äº†æ‹‰ä¸å‰ç¼€ï¼Œå¾—åˆ°è¶…ç±»æ¥æŒ‡ä»£å…³ç³»çš„å¦ä¸€ä¾§ï¼Œä»C++ä¸­ï¼Œä½ å¯èƒ½è¿˜ä¼šå¾—åˆ° åŸºç±»å’Œæ´¾ç”Ÿç±»ï¼Œå¤šæ•°åœºæ™¯ï¼Œæˆ‘ä¼šä½¿ç”¨è¶…ç±»å’Œå­ç±»æè¿°</p>
<p>Our first step towards supporting inheritance in Lox is a way to specify a superclass when declaring a class. Thereâ€™s a lot of variety in syntax for this. C++ and C# place a : after the subclassâ€™s name, followed by the superclass name. Java uses extends instead of the colon. Python puts the superclass(es) in parentheses after the class name. Simula puts the superclassâ€™s name before the class keyword.</p>
<p>This late in the game, Iâ€™d rather not add a new reserved word or token to the lexer. We donâ€™t have extends or even :, so weâ€™ll follow Ruby and use a less-than sign (&lt;).</p>
<p>æˆ‘ä»¬åœ¨Loxä¸­æ”¯æŒç»§æ‰¿çš„ç¬¬ä¸€æ­¥æ˜¯ï¼Œåœ¨å£°æ˜ç±»æ—¶å€™ï¼ŒæŒ‡å®šè¶…ç±»çš„æ–¹å¼ã€‚è¿™æ–¹é¢çš„è¯­æ³•æœ‰å¾ˆå¤šç§ï¼Œ</p>
<ul>
<li>
<p>C++ å’Œ C#ï¼Œåœ¨å­ç±»åç§°åé¢æ·»åŠ ä¸€ä¸ªå†’å·ï¼Œç„¶åæ˜¯è¶…ç±»åç§°</p>
<pre><code class="language-C++">class SubclassName : inheritance-access-specifier SuperclassName {
    ......
};
</code></pre>
</li>
<li>
<p>Javaä½¿ç”¨ extends ä»£æ›¿å†’å·</p>
<pre><code class="language-java">
public class ArmoredCar extends Car {

}
</code></pre>
</li>
<li>
<p>Python åœ¨ç±»ååé¢ç”¨æ‹¬å·æ”¾ç½®è¶…ç±»çš„åç§°</p>
<pre><code class="language-python">
class HourlyEmployee(Employee):

</code></pre>
</li>
<li>
<p>Simula åœ¨class å…³é”®å­—ä¹‹å‰æ”¾ç½®è¶…ç±»åç§°</p>
</li>
</ul>
<p>åœ¨æ¸¸æˆçš„æœ€åï¼Œæˆ‘ä»¬å¹¶ä¸æƒ³åœ¨è¯æ³•åˆ†æå™¨ä¸­ï¼Œæ·»åŠ æ–°çš„ä¿ç•™å­—æˆ–è€…æ–°çš„tokenï¼Œæˆ‘ä»¬ä¸ä¼šä½¿ç”¨ extends æˆ–è€…å†’å·ï¼Œæˆ‘ä»¬å°†å‚è€ƒRubyçš„å®ç°æ–¹å¼ï¼Œä½¿ç”¨&lt; è¡¨ç¤ºç»§æ‰¿ã€‚</p>
<pre><code class="language-java">

class Doughnut {
  // General doughnut stuff...
}

class BostonCream &lt; Doughnut {
  // Boston Cream-specific stuff...
}

</code></pre>
<blockquote>
<p>â€œSuper-â€ and â€œsub-â€ mean â€œaboveâ€ and â€œbelowâ€ in Latin, respectively. Picture an inheritance tree like a family tree with the root at the topâ€”subclasses are below their superclasses on the diagram. More generally, â€œsub-â€ refers to things that refine or are contained by some more general concept. In zoology, a subclass is a finer categorization of a larger class of living things.</p>
<p>In set theory, a subset is contained by a larger superset which has all of the elements of the subset and possibly more. Set theory and programming languages meet each other in type theory. There, you have â€œsupertypesâ€ and â€œsubtypesâ€.</p>
<p>In statically typed object-oriented languages, a subclass is also often a subtype of its superclass. Say we have a Doughnut superclass and a BostonCream subclass. Every BostonCream is also an instance of Doughnut, but there may be doughnut objects that are not BostonCreams (like Crullers).</p>
<p>Think of a type as the set of all values of that type. The set of all Doughnut instances contains the set of all BostonCream instances since every BostonCream is also a Doughnut. So BostonCream is a subclass, and a subtype, and its instances are a subset. It all lines up.</p>
<p>super- å’Œ sub- åœ¨æ‹‰ä¸è¯­ä¸­å¯ä»¥è¡¨ç¤º ä¸Šæ–¹å’Œä¸‹æ–¹ã€‚æƒ³è±¡ä¸€ä¸ªç»§æ‰¿æ ‘å°±æ˜¯ä¸€ä¸ªå®¶è°±ï¼Œæ ¹åœ¨é¡¶éƒ¨ï¼Œå­ç±»åœ¨æ ¹çš„ä¸‹æ–¹ã€‚æ›´ä¸€èˆ¬çš„ï¼Œsub-æ˜¯æŒ‡å¯¹æŸä¸ªä¸€èˆ¬æ¦‚å¿µè¿›è¡Œç»†åŒ–æˆ–è€…åŒ…å«çš„äº‹ç‰©ã€‚åœ¨åŠ¨ç‰©å­¦ä¸­ï¼Œå­ç±»æ˜¯å¯¹æ›´å¤§ç±»åˆ«çš„ç”Ÿç‰©çš„ç»†åˆ†ã€‚</p>
<p>åœ¨é›†åˆè®ºä¸­ï¼Œä¸€ä¸ªå­é›†åŒ…å«äºä¸€ä¸ªæ›´å¤§çš„è¶…é›†ä¸­ï¼Œè¯¥è¶…é›†å…·æœ‰å­é›†çš„æ‰€æœ‰å…ƒç´ ï¼Œå¯èƒ½è¿˜æœ‰æ›´å¤šå…ƒç´ ã€‚é›†åˆè®ºå’Œç¼–ç¨‹è¯­è¨€åœ¨ç±»å‹ç†è®ºä¸­ç›¸é‡ã€‚åœ¨é‚£é‡Œï¼Œä½ æœ‰â€œè¶…ç±»å‹â€å’Œâ€œå­ç±»å‹â€ã€‚</p>
<p>åœ¨é™æ€ç±»å‹çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œå­ç±»é€šå¸¸ä¹Ÿæ˜¯å…¶è¶…ç±»çš„å­ç±»å‹ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ª Doughnut è¶…ç±»å’Œä¸€ä¸ª BostonCream å­ç±»ã€‚æ¯ä¸ª BostonCream ä¹Ÿæ˜¯ Doughnut çš„ä¸€ä¸ªå®ä¾‹ï¼Œä½†å¯èƒ½æœ‰ä¸æ˜¯ BostonCream çš„ doughnutå¯¹è±¡ï¼ˆå¦‚ Crullersï¼‰ã€‚</p>
<p>æŠŠä¸€ä¸ªç±»å‹çœ‹ä½œæ‰€æœ‰è¯¥ç±»å‹å€¼çš„é›†åˆã€‚æ‰€æœ‰ Doughnut å®ä¾‹çš„é›†åˆåŒ…å«äº†æ‰€æœ‰ BostonCream å®ä¾‹çš„é›†åˆï¼Œå› ä¸ºæ¯ä¸ª BostonCream ä¹Ÿæ˜¯ Doughnutã€‚å› æ­¤ï¼ŒBostonCream æ˜¯ä¸€ä¸ªå­ç±»å’Œå­ç±»å‹ï¼Œå®ƒçš„å®ä¾‹æ˜¯ä¸€ä¸ªå­é›†ã€‚è¿™ä¸€åˆ‡éƒ½æ˜¯ç›¸äº’å¯¹åº”çš„ã€‚</p>
</blockquote>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/doughnuts.png?raw=true" alt="Doughnut" /></p>
<p>To work this into the grammar, we add a new optional clause in our existing classDecl rule.</p>
<p>ä¸ºäº†å°†å…¶çº³å…¥åˆ°è¯­æ³•è§„åˆ™ä¸­ï¼Œæˆ‘ä»¬åœ¨classDecl ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„åˆ†æ”¯</p>
<pre><code class="language-java">
classDecl      â†’ &quot;class&quot; IDENTIFIER ( &quot;&lt;&quot; IDENTIFIER )?
                 &quot;{&quot; function* &quot;}&quot; ;
				 
</code></pre>
<p>After the class name, you can have a &lt; followed by the superclassâ€™s name. The superclass clause is optional because you donâ€™t have to have a superclass. Unlike some other object-oriented languages like Java, Lox has no root â€œObjectâ€ class that everything inherits from, so when you omit the superclass clause, the class has no superclass, not even an implicit one.</p>
<p>We want to capture this new syntax in the class declarationâ€™s AST node.</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main(), replace 1 line

      &quot;Block      : List&lt;Stmt&gt; statements&quot;,
      &quot;Class      : Token name, Expr.Variable superclass,&quot; +
                  &quot; List&lt;Stmt.Function&gt; methods&quot;,
      &quot;Expression : Expr expression&quot;,


</code></pre>
<p>åœ¨ç±»åä¹‹åï¼Œå¯ä»¥ç´§è·Ÿä¸€ä¸ªå°äºå·ï¼Œç„¶åæ˜¯è¶…ç±»çš„åç§°ï¼Œè¶…ç±»å­å¥æ˜¯å¯é€‰çš„ï¼Œå› ä¸ºæˆ‘ä»¬ä¸æ˜¯å¿…é¡»æŒ‡å®šä¸€ä¸ªè¶…ç±»ï¼Œå’ŒJavaç­‰é¢å‘å¯¹è±¡çš„è¯­è¨€ä¸åŒï¼ŒLoxè¯­è¨€ä¸­æ²¡æœ‰æ ¹ç±» Object,(æ‰€æœ‰ç±»éƒ½ç»§æ‰¿Objectï¼‰ã€‚å› æ­¤ï¼Œå½“çœç•¥äº†è¶…ç±»å­å¥æ—¶å€™ï¼Œè¯¥ç±»æ²¡æœ‰è¶…ç±»ï¼Œç”šè‡³æ²¡æœ‰éšå«çš„è¶…ç±»ã€‚æˆ‘ä»¬å°†åœ¨ç±»å£°æ˜çš„ASTèŠ‚ç‚¹æ•è·è¿™ä¸ªæ–°çš„è¯­æ³•ã€‚</p>
<p>You might be surprised that we store the superclass name as an Expr.Variable, not a Token. The grammar restricts the superclass clause to a single identifier, but at runtime, that identifier is evaluated as a variable access. Wrapping the name in an Expr.Variable early on in the parser gives us an object that the resolver can hang the resolution information off of.</p>
<p>The new parser code follows the grammar directly.</p>
<p>ä½ å¯èƒ½ä¼šæ„Ÿåˆ°æƒŠè®¶ï¼Œæˆ‘ä»¬å°†è¶…ç±»åç§°å­˜å‚¨ä¸ºExpr.Variable, è€Œä¸æ˜¯Tokenï¼Œè¯­æ³•å°†è¶…ç±»å­å¥é™åˆ¶ä¸ºå•ä¸ªæ ‡è¯†ç¬¦ï¼Œä½†æ˜¯åœ¨è¿è¡Œæ—¶ï¼Œè¯¥æ ‡è¯†ç¬¦å°†ä½œä¸ºå˜é‡è®¿é—®è¿›è¡Œè®¡ç®—ï¼Œåœ¨è§£é‡Šå™¨çš„æ—©æœŸå°†è¶…ç±»åç§°åŒ…è£…åœ¨ Expr.Variableä¸­ï¼Œä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªå¯¹è±¡ï¼Œè§£æå™¨å¯ä»¥å°†è§£æä¿¡æ¯ç»‘å®šåœ¨ä¸Šé¢</p>
<p>æ–°çš„è§£æå™¨ä»£ç å°†ç›´æ¥éµå¾ªè¯­æ³•</p>
<pre><code class="language-java">
// lox/Parser.java, in classDeclaration()

  Token name = consume(IDENTIFIER, &quot;Expect class name.&quot;);

    Expr.Variable superclass = null;
    if (match(LESS)) {
      consume(IDENTIFIER, &quot;Expect superclass name.&quot;);
      superclass = new Expr.Variable(previous());
    }

    consume(LEFT_BRACE, &quot;Expect '{' before class body.&quot;);
	
</code></pre>
<p>Once weâ€™ve (possibly) parsed a superclass declaration, we store it in the AST.</p>
<p>ä¸€æ—¦æˆ‘ä»¬è§£æäº†è¶…ç±»å£°æ˜è¯­å¥ï¼Œæˆ‘ä»¬å°†ä¿å­˜è¶…ç±»</p>
<pre><code class="language-java">
// lox/Parser.java, in classDeclaration(), replace 1 line

   consume(RIGHT_BRACE, &quot;Expect '}' after class body.&quot;);

    return new Stmt.Class(name, superclass, methods);
  }


</code></pre>
<p>If we didnâ€™t parse a superclass clause, the superclass expression will be null. Weâ€™ll have to make sure the later passes check for that. The first of those is the resolver.</p>
<p>å¦‚æœæ²¡æœ‰è§£æåˆ°è¶…ç±»å£°æ˜å­å¥ï¼Œè¶…ç±»è¡¨è¾¾å¼å€¼ä¸ºnullï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿åç»­æ­¥éª¤æ£€æŸ¥äº†è¿™ä¸€ç‚¹ï¼Œç¬¬ä¸€æ­¥æ˜¯è§£æå™¨ã€‚</p>
<pre><code class="language-java">
// lox/Resolver.java, in visitClassStmt()

    define(stmt.name);

    if (stmt.superclass != null) {
      resolve(stmt.superclass);
    }

    beginScope();
	
</code></pre>
<p>The class declaration AST node has a new subexpression, so we traverse into and resolve that. Since classes are usually declared at the top level, the superclass name will most likely be a global variable, so this doesnâ€™t usually do anything useful. However, Lox allows class declarations even inside blocks, so itâ€™s possible the superclass name refers to a local variable. In that case, we need to make sure itâ€™s resolved.</p>
<p>Because even well-intentioned programmers sometimes write weird code, thereâ€™s a silly edge case we need to worry about while weâ€™re in here. Take a look at this:</p>
<p>ç±»å£°æ˜AST èŠ‚ç‚¹ï¼Œæœ‰ä¸€ä¸ªæ–°çš„å­è¡¨è¾¾å¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦éå†å¹¶ä¸”è§£æå®ƒï¼Œç”±äºç±»é€šå¸¸åœ¨é¡¶å±‚å£°æ˜ï¼Œå› æ­¤è¶…ç±»åç§°å¾ˆå¯èƒ½æ˜¯å…¨å±€å˜é‡ï¼Œå› æ­¤ï¼Œè¿™é€šå¸¸ä¸ä¼šäº§ç”Ÿä»»ä½•æœ‰ç”¨çš„ç»“æœï¼Œä½†æ˜¯ï¼ŒLoxå…è®¸åœ¨å—å†…å£°æ˜ç±»ï¼Œå› æ­¤ï¼Œè¶…ç±»åç§°å¯èƒ½å¼•ç”¨ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿å®ƒè¢«è§£æã€‚</p>
<p>å› ä¸ºå³ä½¿æ˜¯æœ‰è‰¯å¥½æ„å›¾çš„ç¨‹åºå‘˜ï¼Œæœ‰æ—¶å€™ä¹Ÿä¼šå†™å‡ºå¥‡æ€ªçš„ä»£ç ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦æ‹…å¿ƒä¸€ä¸ªæ„šè ¢çš„è¾¹ç•Œé—®é¢˜ï¼Œ</p>
<pre><code class="language-java">
class Oops &lt; Oops {}
</code></pre>
<p>Thereâ€™s no way this will do anything useful, and if we let the runtime try to run this, it will break the expectation the interpreter has about there not being cycles in the inheritance chain. The safest thing is to detect this case statically and report it as an error.</p>
<p>ä¸Šé¢çš„ä»£ç æ²¡æœ‰å®é™…æ„ä¹‰ï¼Œå¦‚æœåœ¨è¿è¡Œæ—¶å€™ï¼Œå°è¯•è¿è¡Œä¸Šé¢çš„ä»£ç ï¼Œå®ƒä¼šæ‰“ç ´è§£é‡Šå™¨å¯¹ç»§æ‰¿é“¾ä¸­ä¸å­˜åœ¨çš„å¾ªç¯çš„é¢„æœŸï¼Œæœ€å®‰å…¨çš„åšæ³•æ˜¯åœ¨é™æ€æ£€æµ‹æ—¶å€™ï¼Œæ£€æµ‹åˆ°è¿™ç§æƒ…å†µï¼Œå¹¶ä¸”å°†å…¶æŠ¥å‘Šä¸ºé”™è¯¯ã€‚</p>
<pre><code class="language-java">
// lox/Resolver.java, in visitClassStmt()

    define(stmt.name);

    if (stmt.superclass != null &amp;&amp;
        stmt.name.lexeme.equals(stmt.superclass.name.lexeme)) {
      Lox.error(stmt.superclass.name,
          &quot;A class can't inherit from itself.&quot;);
    }

    if (stmt.superclass != null) {
	
</code></pre>
<p>Assuming the code resolves without error, the AST travels to the interpreter.</p>
<p>å‡è®¾ä»£ç åœ¨è§£ææ—¶å€™æ²¡æœ‰æŠ¥é”™ï¼ŒASTå°†è¢«ä¼ é€’åˆ°è§£é‡Šå™¨</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitClassStmt()

  public Void visitClassStmt(Stmt.Class stmt) {
    Object superclass = null;
    if (stmt.superclass != null) {
      superclass = evaluate(stmt.superclass);
      if (!(superclass instanceof LoxClass)) {
        throw new RuntimeError(stmt.superclass.name,
            &quot;Superclass must be a class.&quot;);
      }
    }

    environment.define(stmt.name.lexeme, null);
	
</code></pre>
<p>If the class has a superclass expression, we evaluate it. Since that could potentially evaluate to some other kind of object, we have to check at runtime that the thing we want to be the superclass is actually a class. Bad things would happen if we allowed code like:</p>
<p>å¦‚æœç±»æœ‰ superclass è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬ä¼šå…ˆè®¡ç®—å®ƒï¼Œç”±äºå®ƒå¯èƒ½ä¼šè¢«è®¡ç®—ä¸ºå…¶ä»–ç±»å‹çš„å¯¹è±¡ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨è¿è¡Œæ—¶å€™ï¼Œæ£€æŸ¥æˆ‘ä»¬æƒ³è¦ä½œä¸ºè¶…ç±»çš„ä¸œè¥¿æ˜¯ä¸€ä¸ªç±»ã€‚å¦åˆ™ï¼Œå¦‚æœæˆ‘ä»¬å…è®¸åƒä¸‹é¢è¿™æ ·çš„ä»£ç å­˜åœ¨ï¼Œå°†å‘ç”Ÿç³Ÿç³•çš„äº‹æƒ…</p>
<pre><code class="language-java">
var NotAClass = &quot;I am totally not a class&quot;;

class Subclass &lt; NotAClass {} // ?!

</code></pre>
<p>Assuming that check passes, we continue on. Executing a class declaration turns the syntactic representation of a classâ€”its AST nodeâ€”into its runtime representation, a LoxClass object. We need to plumb the superclass through to that too. We pass the superclass to the constructor.</p>
<p>å‡è®¾ï¼Œæ£€æŸ¥è¶…ç±»é€šè¿‡ï¼Œæˆ‘ä»¬å°†ç»§ç»­è¿›è¡Œã€‚æ‰§è¡Œç±»å£°æ˜å°†ç±»çš„è¯­æ³•è¡¨ç¤ºï¼ˆå³æŠŠASTèŠ‚ç‚¹â€”â€”&gt; è¿è¡Œæ—¶è¡¨ç¤ºï¼Œå³LoxClasså¯¹è±¡ï¼‰ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦å°†è¶…ç±»ä¼ å…¥å…¶ä¸­ï¼Œæˆ‘ä»¬å°†è¶…ç±»ä¼ é€’ç»™æ„é€ å‡½æ•°ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitClassStmt(), replace 1 line

      methods.put(method.name.lexeme, function);
    }

    LoxClass klass = new LoxClass(stmt.name.lexeme,
        (LoxClass)superclass, methods);

    environment.assign(stmt.name, klass);
	
</code></pre>
<p>The constructor stores it in a field.</p>
<pre><code class="language-java">
// lox/LoxClass.java, constructor LoxClass(), replace 1 line

  LoxClass(String name, LoxClass superclass,
           Map&lt;String, LoxFunction&gt; methods) {
    this.superclass = superclass;
    this.name = name;


</code></pre>
<p>Which we declare here:</p>
<pre><code class="language-java">
// lox/LoxClass.java, in class LoxClass

  final String name;
  final LoxClass superclass;
  private final Map&lt;String, LoxFunction&gt; methods;
  
</code></pre>
<p>With that, we can define classes that are subclasses of other classes. Now, what does having a superclass actually do?</p>
<p>æœ‰äº†è¿™ä¸ªï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªæ˜¯å…¶ä»–ç±»çš„å­ç±»ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬æ‹¥æœ‰ä¸€ä¸ªè¶…ç±»ï¼Œå¯ä»¥å®é™…åšä»€ä¹ˆå‘¢ï¼Ÿ</p>
<h2 id="äºŒinheriting-methods"><a class="header" href="#äºŒinheriting-methods">äºŒã€Inheriting Methods</a></h2>
<p>ç»§æ‰¿æ–¹æ³•</p>
<p>Inheriting from another class means that everything thatâ€™s true of the superclass should be true, more or less, of the subclass. In statically typed languages, that carries a lot of implications. The subclass must also be a subtype, and the memory layout is controlled so that you can pass an instance of a subclass to a function expecting a superclass and it can still access the inherited fields correctly.</p>
<p>ä»å¦ä¸€ä¸ªç±»ç»§æ‰¿æ„å‘³ç€è¶…ç±»çš„æ‰€æœ‰ç‰¹æ€§ï¼Œåœ¨å­ç±»ä¸­åº”è¯¥å¤§ä½“ä¸Šä¹Ÿæ˜¯æˆç«‹çš„ã€‚åœ¨é™æ€ç±»å‹è¯­è¨€ä¸­ï¼Œè¿™å¸¦æ¥äº†è®¸å¤šå«ä¹‰ã€‚å­ç±»å¿…é¡»ä¹Ÿæ˜¯è¶…ç±»çš„å­ç±»å‹ï¼Œå¹¶ä¸”å†…å­˜ä¸­å¯ä»¥å°†å­ç±»çš„å®ä¾‹ä¼ é€’ç»™å¸Œæœ›è¶…ç±»çš„å‡½æ•°ï¼Œå¹¶ä¸”ä¾ç„¶å¯ä»¥æ­£ç¡®çš„è®¿é—®ç»§æ‰¿çš„å­—æ®µã€‚</p>
<blockquote>
<p>A fancier name for this hand-wavey guideline is the Liskov substitution principle. Barbara Liskov introduced it in a keynote during the formative period of object-oriented programming.</p>
<p>æ›´æ­£å¼çš„è®²ï¼Œè¿™æ¡å«ç³Šä¸æ¸…çš„æŒ‡å¯¼åŸåˆ™å«åš <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskovæ›¿æ¢åŸåˆ™</a>, <a href="https://en.wikipedia.org/wiki/Barbara_Liskov">Barbara Liskov</a> åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹åˆæœŸçš„ä¸€æ¬¡ä¸»æ—¨æ¼”è®²ä¸­æå‡ºäº†è¿™ä¸€åŸåˆ™ã€‚</p>
</blockquote>
<p>Lox is a dynamically typed language, so our requirements are much simpler. Basically, it means that if you can call some method on an instance of the superclass, you should be able to call that method when given an instance of the subclass. In other words, methods are inherited from the superclass.</p>
<p>This lines up with one of the goals of inheritanceâ€”to give users a way to reuse code across classes. Implementing this in our interpreter is astonishingly easy.</p>
<p>Loxæ˜¯ä¸€ç§åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œå› æ­¤æˆ‘ä»¬çš„è¦æ±‚ç®€å•çš„å¤šï¼ŒåŸºæœ¬ä¸Šï¼Œè¿™æ„å‘³ç€ï¼Œå¦‚æœä½ å¯ä»¥åœ¨è¶…ç±»çš„æŸä¸ªå®ä¾‹ä¸Šè°ƒç”¨æŸä¸ªæ–¹æ³•ï¼Œé‚£ä¹ˆå½“ä½ ç»™å®šäº†è¶…ç±»çš„æŸä¸ªå­ç±»çš„å®ä¾‹æ—¶å€™ï¼Œæˆ‘ä»¬ä¹Ÿåº”è¯¥èƒ½å¤Ÿè°ƒç”¨è¯¥æ–¹æ³•ã€‚æ¢å¥è¯è¯´ï¼Œæ–¹æ³•æ˜¯ä»è¶…ç±»ç»§æ‰¿æ¥çš„</p>
<p>è¿™æ ·çš„è¡¨ç°å’Œç»§æ‰¿çš„ä¸€ä¸ªç›®æ ‡å»åˆâ€”â€”ä¸ºç”¨æˆ·æä¾›äº†ä¸€ç§åœ¨ç±»ä¹‹é—´å¤ç”¨ä»£ç çš„æ–¹å¼ï¼Œåœ¨æˆ‘ä»¬çš„è§£é‡Šå™¨ä¸­å®ç°è¿™ä¸€ç‚¹éå¸¸å®¹æ˜“ã€‚</p>
<pre><code class="language-java">
// lox/LoxClass.java, in findMethod()

      return methods.get(name);
    }

    if (superclass != null) {
      return superclass.findMethod(name);
    }

    return null;
	
</code></pre>
<p>Thatâ€™s literally all there is to it. When we are looking up a method on an instance, if we donâ€™t find it on the instanceâ€™s class, we recurse up through the superclass chain and look there. Give it a try:</p>
<p>ç¡®å®å°±æ˜¯è¿™æ ·ï¼Œå½“æˆ‘ä»¬åœ¨å®ä¾‹ä¸­æŸ¥æ‰¾æ–¹æ³•æ—¶å€™ï¼Œå¦‚æœåœ¨å½“å‰å®ä¾‹çš„ç±»ä¸­æ‰¾ä¸åˆ°å®ƒï¼Œæˆ‘ä»¬ä¼šé€’å½’çš„æŸ¥æ‰¾è¶…ç±»é“¾ï¼Œä¸€å±‚å±‚æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨è¯¥å‡½æ•°</p>
<pre><code class="language-java">

class Doughnut {
  cook() {
    print &quot;Fry until golden brown.&quot;;
  }
}

class BostonCream &lt; Doughnut {}

BostonCream().cook();

</code></pre>
<p>There we go, half of our inheritance features are complete with only three lines of Java code.</p>
<p>å°±è¿™æ ·ï¼Œæˆ‘ä»¬çš„ç»§æ‰¿åŠŸèƒ½å·²ç»å®Œæˆäº†ä¸€åŠï¼Œåªç”¨äº†ä¸‰è¡ŒJavaä»£ç </p>
<h2 id="ä¸‰calling-superclass-methods"><a class="header" href="#ä¸‰calling-superclass-methods">ä¸‰ã€Calling Superclass Methods</a></h2>
<p>è°ƒç”¨è¶…ç±»æ–¹æ³•</p>
<p>In findMethod() we look for a method on the current class before walking up the superclass chain. If a method with the same name exists in both the subclass and the superclass, the subclass one takes precedence or overrides the superclass method. Sort of like how variables in inner scopes shadow outer ones.</p>
<p>Thatâ€™s great if the subclass wants to replace some superclass behavior completely. But, in practice, subclasses often want to refine the superclassâ€™s behavior. They want to do a little work specific to the subclass, but also execute the original superclass behavior too.</p>
<p>However, since the subclass has overridden the method, thereâ€™s no way to refer to the original one. If the subclass method tries to call it by name, it will just recursively hit its own override. We need a way to say â€œCall this method, but look for it directly on my superclass and ignore my overrideâ€. Java uses super for this, and weâ€™ll use that same syntax in Lox. Here is an example:</p>
<p>åœ¨ findMethod() æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬åœ¨éå†è¶…ç±»é“¾ä¹‹å‰ï¼Œä¼˜å…ˆåœ¨å½“å‰çš„å®ä¾‹ä¸­æŸ¥æ‰¾æ–¹æ³•ï¼Œå¦‚æœåœ¨è¶…ç±»å’Œå­ç±»ä¸­éƒ½å­˜åœ¨åŒåçš„å‡½æ•°ï¼Œåˆ™å­ç±»ä¸­çš„æ–¹æ³•å…·æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ï¼Œä¼šè¦†ç›–è¶…ç±»æ–¹æ³•ã€‚è¿™æœ‰ç‚¹åƒæ˜¯ï¼Œå†…éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡è¦†ç›–å¤–éƒ¨åŒåå˜é‡</p>
<p>è¿™å¯¹äºï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦å®Œå…¨æ›¿æ¢ä¸€äº›è¶…ç±»çš„è¡Œä¸ºã€‚ä½†æ˜¯ï¼Œåœ¨å®è·µä¸­ï¼Œæˆ‘ä»¬é€šå¸¸æƒ³è¦æ›¿æ¢éƒ¨åˆ†çš„è¶…ç±»è¡Œä¸ºï¼Œæˆ‘ä»¬æƒ³è¦å­ç±»æ‰§è¡Œéƒ¨åˆ†ç‰¹å®šçš„å·¥ä½œï¼Œä½†æ˜¯ä¹Ÿè¦æ‰§è¡Œè¶…ç±»çš„åŸå§‹è¡Œä¸º</p>
<p>ç„¶è€Œï¼Œå­ç±»å·²ç»è¦†ç›–äº†åŒåçš„æ–¹æ³•ï¼Œæ²¡æœ‰åŠæ³•å†å¼•ç”¨è¶…ç±»çš„æ–¹æ³•äº†ã€‚å¦‚æœå­ç±»æ–¹æ³•æŒ‰ç…§åç§°è°ƒç”¨å®ƒï¼Œå®ƒåªä¼šè°ƒç”¨å­ç±»çš„æ–¹æ³•ã€‚æˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•â€”â€”è°ƒç”¨ä¸€ä¸ªæ–¹æ³•ï¼Œä½†æ˜¯åªæ˜¯è°ƒç”¨è¶…ç±»ä¸­å®šä¹‰çš„æ–¹æ³•ï¼Œå¿½ç•¥å½“å‰å­ç±»çš„åŒåæ–¹æ³•ã€‚Javaä¸­ä½¿ç”¨super å®Œæˆè¿™ç§éœ€æ±‚ï¼ŒLoxä¸­æˆ‘ä»¬å°†ä½¿ç”¨ç›¸åŒçš„æ–¹å¼ã€‚</p>
<pre><code class="language-java">
class Doughnut {
  cook() {
    print &quot;Fry until golden brown.&quot;;
  }
}

class BostonCream &lt; Doughnut {
  cook() {
    super.cook();
    print &quot;Pipe full of custard and coat with chocolate.&quot;;
  }
}

BostonCream().cook();

</code></pre>
<p>If you run this, it should print:</p>
<pre><code>
Fry until golden brown.
Pipe full of custard and coat with chocolate.

</code></pre>
<p>We have a new expression form. The super keyword, followed by a dot and an identifier, looks for a method with that name. Unlike calls on this, the search starts at the superclass.</p>
<p>æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–°çš„è¡¨è¾¾å¼å½¢å¼ï¼Œå…³é”®å­—æ˜¯super, åé¢è·Ÿä¸€ä¸ªç‚¹å’Œä¸€ä¸ªæ ‡è¯†ç¬¦ï¼ŒæŸ¥æ‰¾å…·æœ‰æ›´åç§°çš„æ–¹æ³•ï¼Œä¸thiså…³é”®å­—ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬çš„æœç´¢æ˜¯ä»è¶…ç±»å¼€å§‹</p>
<h3 id="31-syntax"><a class="header" href="#31-syntax">3.1 Syntax</a></h3>
<p>è¯­æ³•</p>
<p>With this, the keyword works sort of like a magic variable, and the expression is that one lone token. But with super, the subsequent . and property name are inseparable parts of the super expression. You canâ€™t have a bare super token all by itself.</p>
<pre><code class="language-java">
print super; // Syntax error.

</code></pre>
<p>å½“æˆ‘ä»¬ä½¿ç”¨thiså…³é”®å­—ï¼Œå®ƒçš„å·¥ä½œæ–¹å¼å¥½åƒæ˜¯ä¸€ä¸ªé­”æ³•å˜é‡ï¼Œè¡¨è¾¾å¼ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªå­¤ç«‹çš„thiså…³é”®å­—ã€‚ä½†æ˜¯superå…³é”®å­—ä½¿ç”¨æ–¹å¼ä¸ä¸€æ ·ï¼Œsuperå’Œ . æ ‡è¯†ç¬¦ä¸‰ä¸ªéƒ¨åˆ†ï¼Œä¸èƒ½åˆ†å¼€ï¼Œä¸€ä¸ªè¡¨è¾¾å¼ä¸èƒ½æ˜¯ä¸€ä¸ªå­¤ç«‹çš„super å…³é”®å­—ã€‚</p>
<p>So the new clause we add to the primary rule in our grammar includes the property access as well.</p>
<p>æ‰€ä»¥ï¼Œæˆ‘ä»¬åœ¨è¯­æ³•è§„åˆ™ä¸­æ·»åŠ äº†æ–°çš„å­å¥ï¼ŒåŒ…å«äº†å±æ€§è®¿é—®</p>
<pre><code>
primary        â†’ &quot;true&quot; | &quot;false&quot; | &quot;nil&quot; | &quot;this&quot;
               | NUMBER | STRING | IDENTIFIER | &quot;(&quot; expression &quot;)&quot;
               | &quot;super&quot; &quot;.&quot; IDENTIFIER ;
			   
</code></pre>
<p>Typically, a super expression is used for a method call, but, as with regular methods, the argument list is not part of the expression. Instead, a super call is a super access followed by a function call. Like other method calls, you can get a handle to a superclass method and invoke it separately.</p>
<p>é€šå¸¸ï¼Œsuperè¡¨è¾¾å¼ç”¨äºæ–¹æ³•è°ƒç”¨ï¼Œä½†æ˜¯ä¸å¸¸è§„æ–¹æ³•ä¸åŒï¼Œå‚æ•°åˆ—è¡¨ä¸æ˜¯è¡¨è¾¾å¼çš„ä¸€éƒ¨åˆ†ã€‚ç›¸åï¼Œsuperè°ƒç”¨æ˜¯ä¸€ä¸ªsuperè®¿é—®ï¼Œåé¢è·Ÿç€ä¸€ä¸ªå‡½æ•°è°ƒç”¨ã€‚åƒå…¶ä»–æ–¹æ³•è°ƒç”¨ä¸€æ ·ï¼Œå¯ä»¥è·å¾—ä¸€ä¸ªè¶…ç±»æ–¹æ³•çš„å¥æŸ„ï¼Œå¹¶ä¸”å•ç‹¬ä½¿ç”¨å®ƒ</p>
<pre><code class="language-java">
var method = super.cook;
method();

</code></pre>
<p>So the super expression itself contains only the token for the super keyword and the name of the method being looked up. The corresponding syntax tree node is thus:</p>
<p>æ‰€ä»¥ï¼Œsuperè¡¨è¾¾å¼ä»…ä»…åŒ…å«super å…³é”®å­—å’Œæ–¹æ³•åã€‚ç›¸åº”çš„è¯­æ³•æ ‘èŠ‚ç‚¹å¦‚ä¸‹æ‰€ç¤º</p>
<p>Following the grammar, the new parsing code goes inside our existing primary() method.</p>
<p>éµå¾ªè¯­æ³•è§„åˆ™ï¼Œæ–°çš„è§£æä»£ç å°†ä¼šæ”¾ç½®åœ¨æˆ‘ä»¬ç°æœ‰çš„primary() æ–¹æ³•ä¸­</p>
<pre><code class="language-java">
// lox/Parser.java, in primary()


      return new Expr.Literal(previous().literal);
    }

    if (match(SUPER)) {
      Token keyword = previous();
      consume(DOT, &quot;Expect '.' after 'super'.&quot;);
      Token method = consume(IDENTIFIER,
          &quot;Expect superclass method name.&quot;);
      return new Expr.Super(keyword, method);
    }

    if (match(THIS)) return new Expr.This(previous());

</code></pre>
<p>A leading super keyword tells us weâ€™ve hit a super expression. After that we consume the expected . and method name.</p>
<p>superå…³é”®å­—å‘Šè¯‰æˆ‘ä»¬é‡åˆ°äº†ä¸€ä¸ªsuperè¡¨è¾¾å¼ï¼Œç„¶åï¼Œæˆ‘ä»¬å°†é¢„æœŸåé¢æœ‰ä¸€ä¸ª . å’Œ ä¸€ä¸ªæ–¹æ³•åç§°</p>
<h3 id="32-semantics"><a class="header" href="#32-semantics">3.2 Semantics</a></h3>
<p>è¯­ä¹‰</p>
<p>Earlier, I said a super expression starts the method lookup from â€œthe superclassâ€, but which superclass? The naÃ¯ve answer is the superclass of this, the object the surrounding method was called on. That coincidentally produces the right behavior in a lot of cases, but thatâ€™s not actually correct. Gaze upon:</p>
<p>å…ˆå‰æˆ‘ä»¬è¯´è¿‡ï¼Œsuper è¡¨è¾¾å¼ä»è¶…ç±»å¼€å§‹è¿›è¡Œæ–¹æ³•çš„æŸ¥æ‰¾ï¼Œä½†æ˜¯æ˜¯ä»å“ªä¸€ä¸ªè¶…ç±»å‘¢ï¼Œç®€å•çš„å›ç­”æ˜¯ï¼šä»å½“å‰ç±»çš„è¶…ç±»å¼€å§‹æŸ¥æ‰¾ï¼Œå³è°ƒç”¨å‘¨å›´æ–¹æ³•çš„å¯¹è±¡ã€‚è¿™åœ¨å¾ˆå¤šåœºæ™¯éƒ½ä¼šè¿›è¡Œæ­£ç¡®çš„æ“ä½œï¼Œä½†æ˜¯ï¼Œå®é™…ä¸Šï¼Œè¿™æ˜¯ä¸æ­£ç¡®çš„ã€‚</p>
<pre><code class="language-java">
class A {
  method() {
    print &quot;A method&quot;;
  }
}

class B &lt; A {
  method() {
    print &quot;B method&quot;;
  }

  test() {
    super.method();
  }
}

class C &lt; B {}

C().test();


</code></pre>
<p>Translate this program to Java, C#, or C++ and it will print â€œA methodâ€, which is what we want Lox to do too. When this program runs, inside the body of test(), this is an instance of C. The superclass of C is B, but that is not where the lookup should start. If it did, we would hit Bâ€™s method().</p>
<p>Instead, lookup should start on the superclass of the class containing the super expression. In this case, since test() is defined inside B, the super expression inside it should start the lookup on Bâ€™s superclassâ€”A.</p>
<p>å°†ä¸Šé¢ç¨‹åºç¿»è¯‘ä¸º Java C# C++ï¼Œ æˆ‘ä»¬å°†å¾—åˆ° &quot;A method&quot;, è¿™ä¹Ÿæ˜¯æˆ‘ä»¬å¸Œæœ›Loxåšçš„ã€‚å½“è¿™ä¸ªç¨‹åºè¿è¡Œæ—¶å€™ï¼Œåœ¨test() å‡½æ•°å†…éƒ¨ï¼Œthis æ˜¯Cçš„ä¸€ä¸ªå®ä¾‹ï¼ŒCçš„è¶…ç±»æ˜¯Bï¼Œä½†æ˜¯ï¼Œè¿™ä¸æ˜¯åº”è¯¥æŸ¥æ‰¾å¼€å§‹çš„åœ°æ–¹ï¼Œå› ä¸ºå¦‚æœæ˜¯ä»æ­¤å¼€å§‹ï¼Œæˆ‘ä»¬å°†ä¼šå¾—åˆ° B method.</p>
<p>ç›¸åï¼ŒæŸ¥æ‰¾åº”è¯¥ä»åŒ…å«superè¡¨è¾¾å¼çš„ç±»çš„è¶…ç±»å¼€å§‹ï¼Œå¦‚æ­¤ï¼Œåœ¨Bä¸­å®šä¹‰çš„test() å‡½æ•°ï¼Œå› æ­¤superè¡¨è¾¾å¼æ‰€è¡¨ç¤ºçš„è¶…ç±»æ˜¯A,æ‰€ä»¥ï¼Œæˆ‘ä»¬åº”è¯¥ä»Aå¼€å§‹æŸ¥æ‰¾ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/classes.png?raw=true" alt="classes" /></p>
<p>The execution flow looks something like this:</p>
<ul>
<li>
<p>We call test() on an instance of C.</p>
</li>
<li>
<p>That enters the test() method inherited from B. That calls super.method().</p>
</li>
<li>
<p>The superclass of B is A, so that chains to method() on A, and the program prints â€œA methodâ€.</p>
</li>
</ul>
<p>æ‰§è¡Œæµç¨‹å¤§æ¦‚æ˜¯</p>
<ul>
<li>
<p>åœ¨Cçš„å®ä¾‹ä¸­ è°ƒç”¨ test()</p>
</li>
<li>
<p>è¿›å…¥Bç±»ä¸­çš„test() æ–¹æ³•ï¼Œç„¶åè°ƒç”¨ super.method()</p>
</li>
<li>
<p>superæŒ‡ä»£çš„ç±»æ˜¯A, å¦‚æœè°ƒç”¨Açš„ method() æ–¹æ³•</p>
</li>
</ul>
<p>Thus, in order to evaluate a super expression, we need access to the superclass of the class definition surrounding the call. Alack and alas, at the point in the interpreter where we are executing a super expression, we donâ€™t have that easily available.</p>
<p>We could add a field to LoxFunction to store a reference to the LoxClass that owns that method. The interpreter would keep a reference to the currently executing LoxFunction so that we could look it up later when we hit a super expression. From there, weâ€™d get the LoxClass of the method, then its superclass.</p>
<p>Thatâ€™s a lot of plumbing. In the last chapter, we had a similar problem when we needed to add support for this. In that case, we used our existing environment and closure mechanism to store a reference to the current object. Could we do something similar for storing the superclass? Well, I probably wouldnâ€™t be talking about it if the answer was no, soâ€‰.â€‰.â€‰. yes.</p>
<p>å› æ­¤ï¼Œä¸ºäº†è·å–åˆ°superè¡¨è¾¾å¼çš„æŒ‡ä»£ï¼Œæˆ‘ä»¬éœ€è¦è®¿é—®è°ƒç”¨å‘¨å›´çš„ç±»å®šä¹‰çš„è¶…ç±»ï¼Œä½†æ˜¯ï¼Œåœ¨è§£é‡Šå™¨æ‰§è¡Œsuper è¡¨è¾¾å¼æ—¶å€™ï¼Œæˆ‘ä»¬å¾ˆéš¾è·å–åˆ°è¿™ä¸ªä¿¡æ¯</p>
<p>æˆ‘ä»¬å¯ä»¥åœ¨LoxFunctionä¸­æ·»åŠ ä¸€ä¸ªå­—æ®µï¼Œå­˜å‚¨ä¸€ä¸ªå¼•ç”¨ï¼Œå¼•ç”¨çš„LoxClass æ‹¥æœ‰è¯¥æ–¹æ³•ã€‚è§£é‡Šå™¨å°†ä¼šä¿ç•™å¯¹å½“å‰æ‰§è¡Œçš„LoxFunction çš„å¼•ç”¨ï¼Œä»¥ä¾¿åœ¨é‡åˆ°superè¡¨è¾¾å¼æ—¶å€™ï¼ŒæŸ¥æ‰¾åˆ°å®ƒã€‚ä»è¿™ä¸ªæ–°å¢çš„å­—æ®µï¼Œæˆ‘ä»¬å°†è·å–è¯¥æ–¹æ³•çš„LoxClassï¼Œç„¶åæ˜¯å®ƒçš„è¶…ç±»</p>
<p>è¿™éœ€è¦æ›´å¤šçš„å·¥ä½œã€‚åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬åœ¨éœ€è¦æ”¯æŒthis æ—¶å€™é‡åˆ°äº†åŒæ ·çš„é—®é¢˜ï¼Œåœ¨é‚£ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä½¿ç”¨ç°æœ‰çš„ç¯å¢ƒï¼Œå’Œé—­åŒ…æœºåˆ¶ï¼Œå­˜å‚¨å½“å‰å¯¹è±¡çš„å¼•ç”¨ã€‚æˆ‘ä»¬æ˜¯å¦å¯ä»¥ç±»ä¼¼çš„å­˜å‚¨è¶…ç±»å‘¢ï¼Ÿå¥½å§ï¼Œè¿™ä¸ªç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼Œå¦‚æœç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œæˆ‘ä¹Ÿä¸ä¼šè°ˆè®ºå®ƒï¼ŒğŸ˜„</p>
<blockquote>
<p>Does anyone even like rhetorical questions?</p>
<p>æœ‰äººå–œæ¬¢ä¿®è¾æ€§é—®é¢˜å—ï¼Ÿ</p>
</blockquote>
<p>One important difference is that we bound this when the method was accessed. The same method can be called on different instances and each needs its own this. With super expressions, the superclass is a fixed property of the class declaration itself. Every time you evaluate some super expression, the superclass is always the same.</p>
<p>That means we can create the environment for the superclass once, when the class definition is executed. Immediately before we define the methods, we make a new environment to bind the classâ€™s superclass to the name super.</p>
<p>ä¸€ä¸ªé‡è¦çš„åŒºåˆ«æ˜¯ï¼Œæˆ‘ä»¬åœ¨è®¿é—®æ–¹æ³•æ—¶å€™ï¼Œç»‘å®šäº†thisï¼Œç›¸åŒçš„æ–¹æ³•å¯ä»¥åœ¨ä¸åŒçš„å®ä¾‹ä¸Šè°ƒç”¨ï¼Œæ‰€ä»¥ï¼Œæ¯ä¸ªå®ä¾‹éƒ½æœ‰è‡ªå·±çš„thisã€‚ä½†æ˜¯ï¼Œå¯¹äºsuperè¡¨è¾¾å¼ï¼Œè¶…ç±»æ˜¯ä¸€ä¸ªç±»å£°æ˜æœ¬èº«çš„å›ºå®šå±æ€§ï¼Œæ¯ä¸ªè·å–æŸä¸ªsuperè¡¨è¾¾å¼æ—¶å€™ï¼Œè¶…ç±»éƒ½æ˜¯ç›¸åŒçš„</p>
<p>è¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ‰§è¡Œç±»çš„å®šä¹‰æ—¶å€™ï¼Œåˆ›å»ºä¸€æ¬¡ç±»çš„è¶…ç±»ç¯å¢ƒï¼Œåœ¨æˆ‘ä»¬å®šä¹‰æ–¹æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ç¯å¢ƒï¼Œå°†ç±»çš„è¶…ç±»ç»‘å®šåˆ°åç§° super</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/superclass.png?raw=true" alt="superclass" /></p>
<p>When we create the LoxFunction runtime representation for each method, that is the environment they will capture in their closure. Later, when a method is invoked and this is bound, the superclass environment becomes the parent for the methodâ€™s environment, like so:</p>
<p>å½“æˆ‘ä»¬ä¸ºæ¯ä¸ªæ–¹æ³•åˆ›å»º LoxFunction çš„è¿è¡Œæ—¶è¡¨ç¤ºæ—¶å€™ï¼Œæˆ‘ä»¬å°†åœ¨å…¶é—­åŒ…ä¸­æ•è·ç¯å¢ƒï¼Œç¨åï¼Œå½“è°ƒç”¨æ–¹æ³•å¹¶ä¸”ç»‘å®šæ—¶å€™ï¼Œè¶…ç±»ç¯å¢ƒæˆä¸ºæ–¹æ³•çš„ç¯å¢ƒçš„è¶…ç¯å¢ƒï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/environments.png?raw=true" alt="environments" /></p>
<p>Thatâ€™s a lot of machinery, but weâ€™ll get through it a step at a time. Before we can get to creating the environment at runtime, we need to handle the corresponding scope chain in the resolver.</p>
<p>è¿™éœ€è¦å¾ˆå¤šæœºåˆ¶ï¼Œæˆ‘ä»¬å°†é€æ¸å®Œå–„ï¼Œåœ¨è¿è¡Œæ—¶åˆ›å»ºç¯å¢ƒä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è§£é‡Šå™¨ä¸­å¤„ç†ç›¸åº”çš„è°ƒç”¨é“¾</p>
<pre><code class="language-java">
// lox/Resolver.java, in visitClassStmt()

      resolve(stmt.superclass);
    }

    if (stmt.superclass != null) {
      beginScope();
      scopes.peek().put(&quot;super&quot;, true);
    }

    beginScope();


</code></pre>
<p>If the class declaration has a superclass, then we create a new scope surrounding all of its methods. In that scope, we define the name â€œsuperâ€. Once weâ€™re done resolving the classâ€™s methods, we discard that scope.</p>
<p>å¦‚æœç±»å£°æ˜æœ‰ä¸€ä¸ªè¶…ç±»ï¼Œæˆ‘ä»¬å°†åœ¨æ‰€æœ‰æ–¹æ³•å‘¨å›´åˆ›å»ºä¸€ä¸ªæ–°çš„ä½œç”¨åŸŸï¼Œåœ¨è¿™ä¸ªä½œç”¨åŸŸä¸­ï¼Œæˆ‘ä»¬å®šä¹‰åç§° &quot;super&quot;, å½“å®Œæˆç±»çš„æ–¹æ³•è§£æä¹‹åï¼Œæˆ‘ä»¬å°†ä¼šä¸¢å¼ƒè¯¥ä½œç”¨åŸŸ</p>
<pre><code class="language-java">
// lox/Resolver.java, in visitClassStmt()

    endScope();

    if (stmt.superclass != null) endScope();

    currentClass = enclosingClass;


</code></pre>
<p>Itâ€™s a minor optimization, but we only create the superclass environment if the class actually has a superclass. Thereâ€™s no point creating it when there isnâ€™t a superclass since thereâ€™d be no superclass to store in it anyway.</p>
<p>With â€œsuperâ€ defined in a scope chain, we are able to resolve the super expression itself.</p>
<p>è¿™æ˜¯ä¸€ä¸ªæ¬¡è¦çš„ä¼˜åŒ–ï¼Œä½†æˆ‘ä»¬åªæœ‰åœ¨ç±»å®é™…ä¸Šæœ‰ä¸€ä¸ªè¶…ç±»æ—¶å€™ï¼Œæ‰ä¼šåˆ›å»ºè¶…ç±»ç¯å¢ƒï¼Œå¦‚æœæ²¡æœ‰è¶…ç±»ï¼Œå°±æ²¡æœ‰æ„ä¹‰åˆ›å»ºå®ƒï¼Œå› ä¸ºå®ƒä¹Ÿæ²¡æœ‰éœ€è¦å­˜å‚¨çš„è¶…ç±»</p>
<p>åœ¨ä½œç”¨åŸŸé“¾ä¸­å®šä¹‰äº†super åï¼Œæˆ‘ä»¬å¯ä»¥è§£æsuper è¡¨è¾¾å¼æœ¬èº«</p>
<pre><code class="language-java">
// lox/Resolver.java, add after visitSetExpr()

  @Override
  public Void visitSuperExpr(Expr.Super expr) {
    resolveLocal(expr, expr.keyword);
    return null;
  }


</code></pre>
<p>We resolve the super token exactly as if it were a variable. The resolution stores the number of hops along the environment chain that the interpreter needs to walk to find the environment where the superclass is stored.</p>
<p>This code is mirrored in the interpreter. When we evaluate a subclass definition, we create a new environment.</p>
<p>æˆ‘ä»¬åƒè§£æå˜é‡ä¸€æ ·ï¼Œè§£æsuper token, è§£æä¼šå­˜å‚¨æ²¿ç€ç¯å¢ƒé“¾éœ€è¦èµ°å¤šå°‘æ­¥ï¼Œæ‰å¯ä»¥æ‰¾åˆ°å­˜å‚¨è¶…ç±»çš„ç¯å¢ƒ</p>
<p>è¿™æ®µä»£ç åœ¨è§£é‡Šå™¨ä¸­ä¹Ÿæœ‰å¯¹åº”ï¼Œå½“æˆ‘ä»¬è¦å¾—åˆ°ä¸€ä¸ªå­ç±»çš„å®šä¹‰ï¼Œæˆ‘ä»¬å°†ä¼šå¾—åˆ°ä¸€ä¸ªæ–°çš„ç¯å¢ƒ</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitClassStmt()

        throw new RuntimeError(stmt.superclass.name,
            &quot;Superclass must be a class.&quot;);
      }
    }

    environment.define(stmt.name.lexeme, null);

    if (stmt.superclass != null) {
      environment = new Environment(environment);
      environment.define(&quot;super&quot;, superclass);
    }

    Map&lt;String, LoxFunction&gt; methods = new HashMap&lt;&gt;();
	
</code></pre>
<p>Inside that environment, we store a reference to the superclassâ€”the actual LoxClass object for the superclass which we have now that we are in the runtime. Then we create the LoxFunctions for each method. Those will capture the current environmentâ€”the one where we just bound â€œsuperâ€â€”as their closure, holding on to the superclass like we need. Once thatâ€™s done, we pop the environment.</p>
<p>åœ¨è¿™ä¸ªç¯å¢ƒä¸­ï¼Œæˆ‘ä»¬å°†å­˜å‚¨å¯¹è¶…ç±»çš„å¼•ç”¨â€”â€”è¶…ç±»çš„å®é™…LoxClass å¯¹è±¡ï¼Œå› ä¸ºæˆ‘ä»¬ç°åœ¨å¤„äºè¿è¡Œæ—¶ã€‚ç„¶åï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªæ–¹æ³•åˆ›å»º LoxFunction,è¿™äº›å‡½æ•°å°†ä¼šæ•è·å½“å‰çš„ç¯å¢ƒâ€”â€”åˆšåˆšç»‘å®šäº†super çš„ç¯å¢ƒâ€”â€”ä½œä¸ºå®ƒä»¬çš„é—­åŒ…ï¼Œä¿ç•™æˆ‘ä»¬éœ€è¦çš„è¶…ç±»ï¼Œå®Œæˆåï¼Œæˆ‘ä»¬å°†å¼¹å‡ºç¯å¢ƒ</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitClassStmt()

    LoxClass klass = new LoxClass(stmt.name.lexeme,
        (LoxClass)superclass, methods);

    if (superclass != null) {
      environment = environment.enclosing;
    }

    environment.assign(stmt.name, klass);
	
</code></pre>
<p>Weâ€™re ready to interpret super expressions themselves. There are a few moving parts, so weâ€™ll build this method up in pieces.</p>
<p>æˆ‘ä»¬å·²ç»å‡†å¤‡å¥½è§£é‡Šsuperè¡¨è¾¾å¼æœ¬èº«äº†ï¼Œè¿™é‡Œæœ‰ä¸€äº›éœ€è¦å¤„ç†çš„ç»†èŠ‚ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å°†é€æ­¥æ„å»ºè¿™ä¸ªæ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitSetExpr()

  @Override
  public Object visitSuperExpr(Expr.Super expr) {
    int distance = locals.get(expr);
    LoxClass superclass = (LoxClass)environment.getAt(
        distance, &quot;super&quot;);
  }
  
</code></pre>
<p>First, the work weâ€™ve been leading up to. We look up the surrounding classâ€™s superclass by looking up â€œsuperâ€ in the proper environment.</p>
<p>When we access a method, we also need to bind this to the object the method is accessed from. In an expression like doughnut.cook, the object is whatever we get from evaluating doughnut. In a super expression like super.cook, the current object is implicitly the same current object that weâ€™re using. In other words, this. Even though we are looking up the method on the superclass, the instance is still this.</p>
<p>Unfortunately, inside the super expression, we donâ€™t have a convenient node for the resolver to hang the number of hops to this on. Fortunately, we do control the layout of the environment chains. The environment where â€œthisâ€ is bound is always right inside the environment where we store â€œsuperâ€.</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®Œæˆå‰é¢çš„å·¥ä½œï¼Œé€šè¿‡åœ¨æ­£ç¡®çš„ç¯å¢ƒä¸­æŸ¥æ‰¾superï¼Œæˆ‘ä»¬æŸ¥æ‰¾å‘¨å›´ç±»çš„è¶…ç±»</p>
<p>å½“æˆ‘ä»¬è®¿é—®æ–¹æ³•æ—¶å€™ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å°† this ç»‘å®šåˆ°è®¿é—®æ–¹æ³•çš„å¯¹è±¡ä¸Šï¼Œåœ¨è¡¨è¾¾å¼ï¼Œdoughnut.cook ï¼Œå¯¹è±¡æ˜¯ä»è·å–åˆ°çš„ doughnut çš„ä»»ä½•å†…å®¹ï¼Œåœ¨superè¡¨è¾¾å¼ï¼Œä¾‹å¦‚: super.cook, å½“å‰å¯¹è±¡ï¼Œéšå¼çš„è¡¨è¾¾æ˜¯å½“å‰å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯thisï¼Œ å³ä½¿æˆ‘ä»¬åœ¨è¶…ç±»ä¸­æŸ¥æ‰¾æ–¹æ³•ï¼Œå®ä¾‹ä»ç„¶æ˜¯this</p>
<p>ä¸å¹¸çš„æ˜¯ï¼Œåœ¨superè¡¨è¾¾å¼çš„å†…éƒ¨ï¼Œæˆ‘ä»¬æ²¡æœ‰ä¸€ä¸ªæ–¹ä¾¿çš„èŠ‚ç‚¹ï¼Œè®©è§£æå™¨æŒ‚èµ·åˆ°this çš„è·³æ•°ï¼Œå¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬æ§åˆ¶äº†ç¯å¢ƒé“¾ï¼Œç»‘å®šthis çš„ç¯å¢ƒæ€»æ˜¯æˆ‘ä»¬å­˜å‚¨çš„superç¯å¢ƒçš„ç›´æ¥å†…éƒ¨</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitSuperExpr()

    LoxClass superclass = (LoxClass)environment.getAt(
        distance, &quot;super&quot;);

    LoxInstance object = (LoxInstance)environment.getAt(
        distance - 1, &quot;this&quot;);
  }
  
</code></pre>
<p>Offsetting the distance by one looks up â€œthisâ€ in that inner environment. I admit this isnâ€™t the most elegant code, but it works.</p>
<p>é€šè¿‡å°†è·ç¦»åç§»ä¸€æ¬¡ï¼Œåœ¨å†…éƒ¨ç¯å¢ƒä¸­æŸ¥æ‰¾åˆ° this,æˆ‘æ‰¿è®¤è¿™ä¸æ˜¯æœ€ä¼˜é›…çš„ä»£ç ï¼Œä½†æ˜¯å®ƒå¯ä»¥æ­£å¸¸å·¥ä½œ</p>
<blockquote>
<p>Writing a book that includes every single line of code for a program means I canâ€™t hide the hacks by leaving them as an â€œexercise for the readerâ€.</p>
<p>ç¼–å†™ä¸€æœ¬ä¹¦ï¼ŒåŒ…å«ç¨‹åºä¸­çš„æ¯ä¸€è¡Œä»£ç ï¼Œæ„å‘³ç€æˆ‘ä¸èƒ½å°†è¿™äº›hackéšè—èµ·æ¥ï¼Œç•™ç»™è¯»è€…å½“ä½œè¯¾åç»ƒä¹ </p>
</blockquote>
<p>Now weâ€™re ready to look up and bind the method, starting at the superclass.</p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»å‡†å¤‡å¥½ä»ï¼Œè¶…ç±»å¼€å§‹æŸ¥æ‰¾å¹¶ä¸”ç»‘å®šæ–¹æ³•äº†</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitSuperExpr()

    LoxInstance object = (LoxInstance)environment.getAt(
        distance - 1, &quot;this&quot;);

    LoxFunction method = superclass.findMethod(expr.method.lexeme);
    return method.bind(object);
  }


</code></pre>
<p>This is almost exactly like the code for looking up a method of a get expression, except that we call findMethod() on the superclass instead of on the class of the current object.</p>
<p>Thatâ€™s basically it. Except, of course, that we might fail to find the method. So we check for that too.</p>
<p>è¿™å‡ ä¹å’ŒæŸ¥æ‰¾getè¡¨è¾¾å¼çš„æ–¹æ³•çš„ä»£ç å®Œå…¨ç›¸åŒï¼Œåªæ˜¯æˆ‘ä»¬åœ¨è¶…ç±»ä¸Šè°ƒç”¨findMethod() è€Œä¸æ˜¯åœ¨å½“å‰ç±»ä¸Š</p>
<p>åŸºæœ¬ä¸Šå°±æ˜¯è¿™æ ·ï¼Œå½“ç„¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯èƒ½æ— æ³•æ‰¾åˆ°è¯¥æ–¹æ³•ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ æ£€æŸ¥</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitSuperExpr()

    LoxFunction method = superclass.findMethod(expr.method.lexeme);

    if (method == null) {
      throw new RuntimeError(expr.method,
          &quot;Undefined property '&quot; + expr.method.lexeme + &quot;'.&quot;);
    }

    return method.bind(object);
  }


</code></pre>
<p>There you have it! Take that BostonCream example earlier and give it a try. Assuming you and I did everything right, it should fry it first, then stuff it with cream.</p>
<p>ç°åœ¨ï¼Œè®©æˆ‘ä»¬æ¥ä½“ä¼šä¸€ä¸‹ä¹‹å‰çš„ BostonCream ç¤ºä¾‹ï¼Œå‡è®¾æˆ‘ä»¬éƒ½æ²¡æœ‰å‡ºé”™ï¼Œæˆ‘ä»¬åº”è¯¥å…ˆç…ç‚¸ï¼Œç„¶åå†å¡«å……å¥¶æ²¹</p>
<h3 id="33-invalid-uses-of-super"><a class="header" href="#33-invalid-uses-of-super">3.3 Invalid uses of super</a></h3>
<p>superçš„éæ³•ä½¿ç”¨</p>
<p>As with previous language features, our implementation does the right thing when the user writes correct code, but we havenâ€™t bulletproofed the intepreter against bad code. In particular, consider:</p>
<p>ä¸å…ˆå‰çš„è¯­è¨€ç‰¹æ€§ä¸€æ ·ï¼Œå½“ç”¨æˆ·ç¼–å†™äº†æ­£ç¡®çš„ä»£ç æ—¶å€™ï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨å¯ä»¥æ­£å¸¸å·¥ä½œã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¯¹äºä¸€äº›é”™è¯¯ä»£ç ï¼Œè¿˜æ˜¯ä¸å¤Ÿç¨³å®šã€‚ç‰¹åˆ«çš„ï¼Œè€ƒè™‘ä¸‹é¢çš„ä»£ç </p>
<pre><code class="language-java">
class Eclair {
  cook() {
    super.cook();
    print &quot;Pipe full of crÃ¨me pÃ¢tissiÃ¨re.&quot;;
  }
}

</code></pre>
<p>This class has a super expression, but no superclass. At runtime, the code for evaluating super expressions assumes that â€œsuperâ€ was successfully resolved and will be found in the environment. Thatâ€™s going to fail here because there is no surrounding environment for the superclass since there is no superclass. The JVM will throw an exception and bring our interpreter to its knees.</p>
<p>Heck, there are even simpler broken uses of super:</p>
<pre><code class="language-java">
super.notEvenInAClass();

</code></pre>
<p>è¿™ä¸ªç±»ä¸­æœ‰ä¸€ä¸ªsuperè¡¨è¾¾å¼ï¼Œä½†æ˜¯æ²¡æœ‰è¶…ç±»ï¼Œåœ¨è¿è¡Œæ—¶å€™ï¼Œè®¡ç®—superè¡¨è¾¾å¼çš„ä»£ç ï¼Œå‡è®¾super å·²ç»æˆåŠŸè§£æï¼Œå¹¶ä¸”å°†åœ¨ç¯å¢ƒä¸­æ‰¾åˆ°å®ƒã€‚å¯»æ‰¾ç»“æœå°†å¤±è´¥ï¼Œå› ä¸ºå‘¨å›´ç¯å¢ƒæ²¡æœ‰è¶…ç±»ï¼ŒJavaè™šæ‹Ÿæœºä¼šç»å¸¸æŠ›å‡ºè¿™æ ·çš„æŠ¥é”™ï¼Œç¨‹åºåœæ­¢è¿è¡Œã€‚</p>
<p>æ›´ç®€å•çš„é”™è¯¯ä½¿ç”¨ super çš„ç”¨ä¾‹</p>
<p>We could handle errors like these at runtime by checking to see if the lookup of â€œsuperâ€ succeeded. But we can tell staticallyâ€”just by looking at the source codeâ€”that Eclair has no superclass and thus no super expression will work inside it. Likewise, in the second example, we know that the super expression is not even inside a method body.</p>
<p>Even though Lox is dynamically typed, that doesnâ€™t mean we want to defer everything to runtime. If the user made a mistake, weâ€™d like to help them find it sooner rather than later. So weâ€™ll report these errors statically, in the resolver.</p>
<p>æˆ‘ä»¬å¯ä»¥é€šè¿‡æ£€æŸ¥ superçš„æŸ¥æ‰¾æ˜¯å¦æˆåŠŸï¼Œåœ¨è¿è¡Œæ—¶å€™ï¼Œå¤„ç†è¿™äº›é”™è¯¯ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é™æ€æ£€æŸ¥åˆ¤æ–­â€”â€”ä»…ä»…é€šè¿‡æŸ¥çœ‹æºä»£ç ï¼ˆEclairç±»æ²¡æœ‰è¶…ç±»ï¼Œå› æ­¤ï¼Œsuperè¡¨è¾¾å¼ä¸èƒ½åœ¨Eclairä¸­è¿è¡Œï¼‰ã€‚åŒæ ·ï¼Œåœ¨ç¬¬äºŒä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œsuperè¡¨è¾¾å¼ç”šè‡³ä¸åœ¨æ–¹æ³•ä½“ä¸­</p>
<p>å³ä½¿Loxæ˜¯åŠ¨æ€ç±»å‹çš„è¯­è¨€ï¼Œè¿™ä¹Ÿå¹¶ä¸ä»£è¡¨ï¼Œæˆ‘ä»¬å¸Œæœ›å°†æ‰€æœ‰çš„äº‹æƒ…éƒ½æ”¾åˆ°è¿è¡Œæ—¶ã€‚å¦‚æœç”¨æˆ·çŠ¯äº†ä¸€ä¸ªé”™è¯¯ï¼Œæˆ‘ä»¬å¸Œæœ›å¸®åŠ©ä»–ä»¬å°½æ—©å‘ç°é”™è¯¯ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†åœ¨è§£æå™¨ä¸­ï¼Œé™æ€æŠ¥å‘Šè¿™äº›é”™è¯¯ã€‚</p>
<p>First, we add a new case to the enum we use to keep track of what kind of class is surrounding the current code being visited.</p>
<pre><code class="language-java">
// lox/Resolver.java, in enum ClassType, add â€œ,â€ to previous line

    NONE,
    CLASS,
    SUBCLASS
  }
  
</code></pre>
<p>Weâ€™ll use that to distinguish when weâ€™re inside a class that has a superclass versus one that doesnâ€™t. When we resolve a class declaration, we set that if the class is a subclass.</p>
<pre><code class="language-java">
// lox/Resolver.java, in visitClassStmt()

    if (stmt.superclass != null) {
      currentClass = ClassType.SUBCLASS;
      resolve(stmt.superclass);
	  
</code></pre>
<p>Then, when we resolve a super expression, we check to see that we are currently inside a scope where thatâ€™s allowed.</p>
<pre><code class="language-java">
// lox/Resolver.java, in visitSuperExpr()

  public Void visitSuperExpr(Expr.Super expr) {
    if (currentClass == ClassType.NONE) {
      Lox.error(expr.keyword,
          &quot;Can't use 'super' outside of a class.&quot;);
    } else if (currentClass != ClassType.SUBCLASS) {
      Lox.error(expr.keyword,
          &quot;Can't use 'super' in a class with no superclass.&quot;);
    }

    resolveLocal(expr, expr.keyword);
	
</code></pre>
<p>If notâ€”oopsie!â€”the user made a mistake.</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬å‘ ç”¨äºè·Ÿè¸ªå½“å‰æ­£åœ¨è®¿é—®çš„ä»£ç çš„å‘¨å›´æ˜¯å“ªç§ç±»å‹çš„ç±»çš„ æšä¸¾ä¸­æ·»åŠ ä¸€ä¸ªæ–°çš„case</p>
<p>æˆ‘ä»¬å°†ä½¿ç”¨è¿™ä¸ªå€¼ï¼Œè¡¨ç¤ºå½“å‰æ˜¯å¦åœ¨ä¸€ä¸ªè¶…ç±»çš„å­ç±»ä¸­ï¼Œå½“æˆ‘ä»¬è§£æç±»çš„å£°æ˜æ—¶å€™ï¼Œå¦‚æœè¯¥ç±»æ˜¯å­ç±»ï¼Œæˆ‘ä»¬ä¼šè®¾ç½®å¯¹åº”çš„æ ‡å¿—</p>
<p>æœ€åï¼Œå½“æˆ‘ä»¬è§£æsuperè¡¨è¾¾å¼æ—¶å€™ï¼Œä¼šæ£€æŸ¥å½“å‰æ˜¯å¦å…è®¸ä½¿ç”¨superè¡¨è¾¾å¼</p>
<p>å¦‚æœå½“å‰ä¸èƒ½ä½¿ç”¨ superè¡¨è¾¾å¼â€”â€”å¯ä»¥ç¡®å®šï¼Œç”¨æˆ·ä½¿ç”¨é”™è¯¯ã€‚</p>
<h2 id="å››conclusion"><a class="header" href="#å››conclusion">å››ã€Conclusion</a></h2>
<p>We made it! That final bit of error handling is the last chunk of code needed to complete our Java implementation of Lox. This is a real accomplishment and one you should be proud of. In the past dozen chapters and a thousand or so lines of code, we have learned and implementedâ€‰.â€‰.â€‰. </p>
<ul>
<li>
<p>tokens and lexing,</p>
</li>
<li>
<p>abstract syntax trees,</p>
</li>
<li>
<p>recursive descent parsing,</p>
</li>
<li>
<p>prefix and infix expressions,</p>
</li>
<li>
<p>runtime representation of objects,</p>
</li>
<li>
<p>interpreting code using the Visitor pattern,</p>
</li>
<li>
<p>lexical scope,</p>
</li>
<li>
<p>environment chains for storing variables,</p>
</li>
<li>
<p>control flow,</p>
</li>
<li>
<p>functions with parameters,</p>
</li>
<li>
<p>closures,</p>
</li>
<li>
<p>static variable resolution and error detection,</p>
</li>
<li>
<p>classes,</p>
</li>
<li>
<p>constructors,</p>
</li>
<li>
<p>fields,</p>
</li>
<li>
<p>methods, </p>
</li>
</ul>
<p>and finally,</p>
<ul>
<li>inheritance.</li>
</ul>
<p>æˆ‘ä»¬åšåˆ°äº†ï¼Œé”™è¯¯å¤„ç†æ˜¯æˆ‘ä»¬ç”¨Java å®ç°Loxçš„æœ€åä¸€éƒ¨åˆ†ä»£ç ã€‚è¿™æ˜¯ä¸€ä¸ªæˆå°±ï¼Œæˆ‘ä»¬åº”è¯¥æ„Ÿåˆ°è‡ªè±ªã€‚åœ¨è¿‡å»çš„åå‡ ç« å’Œä¸€åƒå¤šè¡Œä»£ç ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ å’Œå®ç°äº†</p>
<ul>
<li>
<p>Token å’Œè¯æ³•åˆ†æ</p>
</li>
<li>
<p>æŠ½è±¡è¯­æ³•æ ‘</p>
</li>
<li>
<p>é€’å½’ä¸‹é™è§£æ</p>
</li>
<li>
<p>å‰ç¼€å’Œä¸­ç¼€è¡¨è¾¾å¼</p>
</li>
<li>
<p>å¯¹è±¡çš„è¿è¡Œæ—¶è¡¨ç¤º</p>
</li>
<li>
<p>ä½¿ç”¨è®¿é—®è€…æ¨¡å¼è§£é‡Šä»£ç </p>
</li>
<li>
<p>è¯æ³•ä½œç”¨åŸŸ</p>
</li>
<li>
<p>ç”¨äºå­˜å‚¨å˜é‡çš„ç¯å¢ƒé“¾</p>
</li>
<li>
<p>æ§åˆ¶æµ</p>
</li>
<li>
<p>å¸¦å‚æ•°çš„å‡½æ•°</p>
</li>
<li>
<p>é—­åŒ…</p>
</li>
<li>
<p>é™æ€å˜é‡è§£æå’Œé”™è¯¯æ£€æŸ¥</p>
</li>
<li>
<p>ç±»</p>
</li>
<li>
<p>æ„é€ å‡½æ•°</p>
</li>
<li>
<p>ç±»çš„å­—æ®µ</p>
</li>
<li>
<p>ç±»çš„æ–¹æ³•</p>
</li>
<li>
<p>ç»§æ‰¿</p>
</li>
</ul>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/superhero.png?raw=true" alt="superhero" /></p>
<p>We did all of that from scratch, with no external dependencies or magic tools. Just you and I, our respective text editors, a couple of collection classes in the Java standard library, and the JVM runtime.</p>
<p>This marks the end of Part II, but not the end of the book. Take a break. Maybe write a few fun Lox programs and run them in your interpreter. (You may want to add a few more native methods for things like reading user input.) When youâ€™re refreshed and ready, weâ€™ll embark on our next adventure.</p>
<p>æˆ‘ä»¬ä»å¤´å®Œæˆäº†æ‰€æœ‰å·¥ä½œï¼Œæ²¡æœ‰å¤–éƒ¨ä¾èµ–æˆ–è€…å…¶ä»–ç¥å¥‡å·¥å…·ï¼Œåªæœ‰ä½ å’Œæˆ‘ï¼Œæˆ‘ä»¬çš„ç¼–è¾‘å™¨ï¼ŒJavaæ ‡å‡†åº“ã€Javaé›†åˆç±»ã€JVMè™šæ‹Ÿæœº</p>
<p>è¿™æ ‡å¿—ç€ç¬¬äºŒéƒ¨åˆ†çš„å®Œæˆï¼Œä½†æ˜¯å¹¶ä¸ä»£è¡¨æœ¬ä¹¦çš„å®Œæˆã€‚å¥½å¥½ä¼‘æ¯ä¸€ä¸‹å§ï¼Œä¹Ÿè®¸ç”¨Loxè¯­è¨€å†™ä¸€äº›ç®€å•çš„ç¨‹åºã€‚ï¼ˆä½ å¯èƒ½è¿˜éœ€è¦æ·»åŠ ä¸€äº›åŸç”Ÿæ–¹æ³•æ¥è¯»å–ç”¨æˆ·çš„è¾“å…¥ï¼‰ï¼Œå½“ä½ é‡æ–°ç²¾åŠ›å……æ²›ï¼Œå‡†å¤‡å¥½äº†ï¼Œæˆ‘ä»¬å°†è¸ä¸Šä¸‹ä¸€ä¸ªå†’é™©ã€‚</p>
<h2 id="äº”challenges"><a class="header" href="#äº”challenges">äº”ã€CHALLENGES</a></h2>
<ol>
<li>
<p>Lox supports only single inheritanceâ€”a class may have a single superclass and thatâ€™s the only way to reuse methods across classes. Other languages have explored a variety of ways to more freely reuse and share capabilities across classes: mixins, traits, multiple inheritance, virtual inheritance, extension methods, etc.</p>
<p>If you were to add some feature along these lines to Lox, which would you pick and why? If youâ€™re feeling courageous (and you should be at this point), go ahead and add it.</p>
</li>
<li>
<p>In Lox, as in most other object-oriented languages, when looking up a method, we start at the bottom of the class hierarchy and work our way upâ€”a subclassâ€™s method is preferred over a superclassâ€™s. In order to get to the superclass method from within an overriding method, you use super.</p>
<p>The language BETA takes the opposite approach. When you call a method, it starts at the top of the class hierarchy and works down. A superclass method wins over a subclass method. In order to get to the subclass method, the superclass method can call inner, which is sort of like the inverse of super. It chains to the next method down the hierarchy.</p>
<p>The superclass method controls when and where the subclass is allowed to refine its behavior. If the superclass method doesnâ€™t call inner at all, then the subclass has no way of overriding or modifying the superclassâ€™s behavior.</p>
<p>Take out Loxâ€™s current overriding and super behavior and replace it with BETAâ€™s semantics. In short:</p>
<ul>
<li>
<p>When calling a method on a class, prefer the method highest on the classâ€™s inheritance chain.</p>
</li>
<li>
<p>Inside the body of a method, a call to inner looks for a method with the same name in the nearest subclass along the inheritance chain between the class containing the inner and the class of this. If there is no matching method, the inner call does nothing.</p>
</li>
</ul>
<p>For example:</p>
<pre><code class="language-java">
class Doughnut {
  cook() {
    print &quot;Fry until golden brown.&quot;;
    inner();
    print &quot;Place in a nice box.&quot;;
  }
}

class BostonCream &lt; Doughnut {
  cook() {
    print &quot;Pipe full of custard and coat with chocolate.&quot;;
  }
}

BostonCream().cook();

</code></pre>
<p>This should print:</p>
<pre><code class="language-java">
Fry until golden brown.
Pipe full of custard and coat with chocolate.
Place in a nice box.

</code></pre>
</li>
<li>
<p>In the chapter where I introduced Lox, I challenged you to come up with a couple of features you think the language is missing. Now that you know how to build an interpreter, implement one of those features.</p>
</li>
</ol>
<p> </p>
<ol>
<li>
<p>Loxè¯­è¨€åªæ”¯æŒå•ä¸€ç»§æ‰¿â€”â€”ä¸€ä¸ªç±»æœ€å¤šåªæœ‰ä¸€ä¸ªè¶…ç±»ï¼Œå¹¶ä¸”è¿™æ˜¯åœ¨ç±»ä¹‹é—´å¤ç”¨æ–¹æ³•çš„å”¯ä¸€æ–¹å¼ã€‚ä½†æ˜¯ï¼Œå…¶ä»–è¯­è¨€å·²ç»æ¢ç´¢äº†å„ç§è‡ªç”±å¤ç”¨å’Œå…±äº«ç±»ä¹‹é—´èƒ½åŠ›çš„æ–¹å¼: æ··åˆç±»ã€ç‰¹å¾ã€å¤šé‡ç»§æ‰¿ã€è™šæ‹Ÿç»§æ‰¿ã€æ‰©å±•æ–¹æ³•ç­‰ç­‰</p>
<p>å¦‚æœè¦å‘Loxä¸­æ·»åŠ ç±»ä¼¼åŠŸèƒ½ï¼Œä½ ä¼šé€‰æ‹©å“ªä¸€ä¸ªï¼Œä¸ºä»€ä¹ˆï¼Ÿå¦‚æœä½ æœ‰å‹‡æ°”å»æŒ‘æˆ˜è¿™ä¸ªä»»åŠ¡ï¼Œå°±å»å®ç°å§</p>
</li>
<li>
<p>åœ¨Loxä¸­ï¼Œä¸å¤§å¤šæ•°çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸€æ ·ï¼ŒæŸ¥æ‰¾æ–¹æ³•æ—¶å€™ï¼Œæˆ‘ä»¬ä»ç±»å±‚æ¬¡ç»“æ„çš„åº•éƒ¨å¼€å§‹ï¼Œå‘ä¸ŠæŸ¥æ‰¾ï¼Œå­ç±»çš„æ–¹æ³•ä¼˜å…ˆçº§é«˜äºè¶…ç±»ã€‚ä¸ºäº†è®¿é—®è¶…ç±»çš„æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨superè¯­æ³•</p>
<p>ä½†æ˜¯ï¼Œè¯­è¨€BETAé‡‡ç”¨äº†ç›¸åçš„è®¾è®¡ï¼Œå½“è°ƒç”¨ä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œå®ƒä»ç±»å±‚æ¬¡ç»“æ„çš„é¡¶å±‚å¼€å§‹ï¼Œå‘ä¸‹æŸ¥æ‰¾ã€‚è¶…ç±»æ–¹æ³•ä¼˜å…ˆçº§é«˜äºå­ç±»æ–¹æ³•ï¼Œä¸ºäº†è®¿é—®å­ç±»æ–¹æ³•ï¼Œè¶…ç±»æ–¹æ³•å¯ä»¥è°ƒç”¨ innerï¼Œæœ‰ç‚¹åƒæ˜¯superçš„åå‘ã€‚å®ƒä¼šé“¾æ¥åˆ°å±‚æ¬¡ç»“æ„çš„ä¸‹ä¸€ä¸ªæ–¹æ³•ã€‚</p>
<p>è¶…ç±»æ–¹æ³•æ§åˆ¶å­ç±»åœ¨ä½•æ—¶ä½•åœ°å…è®¸ç»†åŒ–å…¶æ–¹æ³•ã€‚å¦‚æœè¶…ç±»æ–¹æ³•ä¸è°ƒç”¨innerï¼Œåˆ™å­ç±»æ— æ³•è¦†ç›–æˆ–è€…ä¿®æ”¹è¶…ç±»çš„è¡Œä¸ºã€‚</p>
<p>å°†Loxçš„å½“å‰è¦†ç›–å’Œsuperè¡Œä¸ºæ›¿æ¢ä¸ºBETAè¯­è¨€çš„è¯­ä¹‰ï¼Œç®€è€Œè¨€ä¹‹</p>
<ul>
<li>
<p>åœ¨è°ƒç”¨ä¸€ä¸ªç±»çš„æ–¹æ³•æ—¶å€™ï¼Œä¼˜å…ˆé€‰æ‹©ç±»å±‚æ¬¡ç»“æ„ä¸­æœ€é«˜çš„æ–¹æ³•ï¼›</p>
</li>
<li>
<p>åœ¨æ–¹æ³•ä½“å†…ï¼Œè°ƒç”¨innerä¼šåœ¨åŒ…å«innerç±» å’Œ thisç±» çš„ç»§æ‰¿é“¾æŸ¥æ‰¾åŒåæ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰åŒ¹é…çš„æ–¹æ³•ï¼Œinnerè°ƒç”¨ä¸æ‰§è¡Œä»»ä½•æ“ä½œã€‚</p>
</li>
</ul>
</li>
<li>
<p>åœ¨æˆ‘ä»‹ç»Loxçš„é‚£ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº†ä¸€ä¸ªæŒ‘æˆ˜ï¼Œæƒ³è±¡ä¸€äº›æˆ‘ä»¬è®¤ä¸ºè¿˜éœ€è¦å®ç°çš„åŠŸèƒ½ï¼Œç°åœ¨æˆ‘ä»¬éƒ½å·²ç»å®ç°äº†ä¸€ä¸ªå®Œæ•´çš„è§£é‡Šå™¨ï¼Œé‚£å°±é€‰æ‹©ä¸€ä¸ªåŠŸèƒ½å»å®ç°å§</p>
</li>
</ol>

			<div id="bottom"> 
			     <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>

			     <a href="https://info.flagcounter.com/42Wy"><img src="https://s01.flagcounter.com/count/42Wy/bg_FFFFFF/txt_000000/border_CCCCCC/columns_3/maxflags_9/viewers_0/labels_0/pageviews_1/flags_0/percent_0/" alt="Flag Counter" border="0"></a>
		       </div>   	 							 
                       <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <a rel="prev" href="../tree/classes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                        </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tree/classes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../giscus.js"></script>


    </body>


</html>
