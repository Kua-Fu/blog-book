<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>crafting-interpreters-zh</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">欢迎</li><li class="chapter-item expanded "><a href="welcome/welcome.html"><strong aria-hidden="true">1.</strong> 欢迎</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="welcome/introduction.html"><strong aria-hidden="true">1.1.</strong> 介绍</a></li></ol></li><li class="chapter-item expanded "><a href="welcome/a-map-of-the-territory.html"><strong aria-hidden="true">2.</strong> 总览图</a></li><li class="chapter-item expanded "><a href="welcome/the-lox-language.html"><strong aria-hidden="true">3.</strong> Lox语言</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">crafting-interpreters-zh</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基本介绍"><a class="header" href="#基本介绍">基本介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="欢迎"><a class="header" href="#欢迎">欢迎</a></h1>
<p>This may be the beginning of a grand adventure. Programming languages encompass a h
uge space to explore and play in. Plenty of room for your own creations to share with others or just enjoy yourself. Brilliant computer scientists and software engineers have spent entire careers traversing this land without ever reaching the end. If this book is your first entry into the country, welcome.</p>
<p>The pages of this book give you a guided tour through some of the world of languages. But before we strap on our hiking boots and venture out, we should familiarize ourselves with the territory. The chapters in this part introduce you to the basic concepts used by programming languages and how those concepts are organized.</p>
<p>We will also get acquainted with Lox, the languages we'll spend the rest of the book implementing(twice).</p>
<hr />
<p>这将是一次伟大的冒险。程序编程拥有无限的探索和应用空间。你可以与他人分享编程乐趣或者只是自娱自乐。杰出的计算机科学家和软件工程师一直在编程领域探索，终其一生乐在其中。如果你是第一次接触这个领域，那么热烈欢迎你！</p>
<p>本书将和你一起参观语言世界。但是，在我们开始冒险之前，需要先了解要踏足的土地。接下来章节，将向您介绍编程语言中的常用概念和这些基本概念的组织方式。</p>
<p>我们还将介绍一门新的语言 Lox, 本书会带你实现2次 Lox 语言。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<blockquote>
<p>fairy tales are more than true: not because they tell us that dragons exist, but because they tell us that dragons can be beaten. </p>
<p align="right"> —— G.K. Chesterton by way of Neil Gaiman, Coraline </p>
<p>童话绝不仅是真实的: 不仅仅在于它告诉我们龙的存在，更在于它告诉我们勇士可以战胜恶龙。</p>
<p align="right"> —— G.K. Chesterton by way of Neil Gaiman, Coraline </p>
</blockquote>
<p>I'm really excited we're going on this journey together. This is a book on implementing interpreters for programming languages. It's also a book on how to design a language worth implementing. It's the book I wish I'd had when I first started getting into languages, and it's the book I've been writing in my head for nearly a decade.</p>
<p>非常高兴我们可以一起开启新的旅程，</p>
<p>这是一本介绍编程语言解释器的书， 这本书还会介绍如何自己实现一门语言。</p>
<p>这本书在我脑海中已经反复编辑了十年了，多么希望在我刚接触编程语言时候能遇到这种书籍。🐶</p>
<blockquote>
<p>to my friends and family, sorry I've been so absentminded!</p>
<p>对于我的朋友和家人，很抱歉我一直心不在焉。</p>
</blockquote>
<p>In these pages, we will walk step-by-step through two complete interpreters for a full-featured language. I assume this is your first foray into languages, so I'll cover each concept and line of code you need to build a complete, usable, fast language implementation.</p>
<p>In order to cram two full implementations inside one book without it turning into a doorstop, this text is lighter on theory than others. As we build each piece of the system, I will introduce the history and concepts behind it. I'll try to get your familiar with the lingo so that if you ever find yourself at a cocktail party full of PL(parogramming language) researchers, you'll fit in.</p>
<p>接下来，我们将通过实现两个完整的编译器，去实现一个功能齐全的语言。我会假设你第一次接触语言编程，所以我会详细介绍每一个概念和列出详细的代码，而这一切将会构建完整、可用、快速的语言。</p>
<p>为了在一本书中，实现两个编译器，相对于其他的编译语言书籍，我们会更少介绍编译原理，我们不想成为介绍编译理论的拦路虎。在构建编译系统的每一个部分，我将介绍其背后的历史和概念。我将尽可能使用行话，这样即使将来你出现在一个编程语言的鸡尾酒会，也可以快速融入其中。</p>
<blockquote>
<p>Strangely enough, a situation I have found myself in multiple times. You wouldn't believe how much some of them can drink.</p>
<p>奇怪的是，我发现自己多次陷入这种场景。你不应该假想他们都很能喝。</p>
</blockquote>
<p>But we're mostly going to spend our brain juice getting the language up and running. This is not to say theory isn't important. Being able to reason precisely and formally about syntax and semantics is a vital skill when working on a language. But, presonally, I learn best by doing. It's hard for me to wade through paragraphs full of abstract concepts and really absorb them. But if I've coded something, run it, and debugged it, then I get it.</p>
<p>我们将花费精力去开发运行语言，而这并不代表理论不重要。在学习语言时候，掌握语法和语义规则非常重要。但是，个人经验，我总是从实践中获取更多的东西，我通常很难看懂或者真的理解充满抽象概念的段落。但是，但我代码中编码、运行、调试过某个概念，我将能真正掌握它。</p>
<blockquote>
<p>Static type systems in particular require rigorous formal reasoning. Hacking on a type system has the same feel as proving a theorem in mathematics. </p>
<p>静态类型系统，尤其需要严格的形式推理。在类型系统上进行编程，非常像是证明一个数学定理。</p>
</blockquote>
<blockquote>
<p>It turns out this is no coincidence. In the early half of last century, Haskell Curry and William Alvin Howard showed that they are two sides of the same coin: <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">the Curry-Howard isomorphism</a></p>
<p>事实证明，这个感觉并非是巧合。在20世纪上半叶，Haskell Curry 和 William Alvin Howard严格证明了编程语言和数学证明之间的关系，称为<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">柯里-霍华德同构</a></p>
</blockquote>
<p>That's my goal for you. I want you to come away with a solid intuition of how a real language lives and breathes. My hope is that when you read other, more theoretical books later, the concepts there will firmly stick in your mind, adhered to this tangible substrate.</p>
<p>这个本书的一个目标，可以让你更加真切的认识一门语言，可以凭直觉感知一门语言如何编写运行。希望当以后学习更多的编译原理时候，通过现在培养的直觉，可以牢牢记住书中的概念。</p>
<h2 id="一why-learn-this-stuff"><a class="header" href="#一why-learn-this-stuff">一、Why learn this stuff?</a></h2>
<p>为什么要学习这些东西？</p>
<p>Every introduction to every compiler book seems to have this section. I don't know what it is about programming languages that causes such existential doubt. I don't think ornithology books worry about justifying their existence. They assume the reader loves birds and start teaching.</p>
<p>But programming languages are a little different. I suppose it is true that the odds of any of us creating a broadly successful, general-purpose programming language are slim. The designers of the world's widely used languages could fit in a Volkswagen bus, even without putting the pop-top camper up. If joining that elite group was the only reason to learn languages, it would be hard to justify. Fortunately, it isn't.</p>
<p>似乎每本编译器介绍书籍，似乎都包含这个讨论。我不知道，为什么编程语言会出现这样的疑惑。鸟类学研究书籍从来不认为人们会怀疑它是否该存在，他们总是假设读者喜欢鸟，然后开始教学。</p>
<p>但是编程语言总是有点不一样。我认为，我们大部分人，都无法创建一个广泛成功的通用编程语言。世界上最广泛使用的语言设计者可以适应驾驶大众汽车，即使车上没有安装流行的露营设备。如果学习编译器，仅仅是为了加入这个编程精英群体，那么大可不必。幸运的是，事实也并非如此。</p>
<h3 id="11-little-language-are-everywhere"><a class="header" href="#11-little-language-are-everywhere">1.1 Little language are everywhere</a></h3>
<p>For every successful general-purpose language, there are a thousand successful niche ones. We used to call them “little languages”, but inflation in the jargon economy led to the name “domain-specific languages”.These are pidgins tailor-built to a specific task. Think application scripting languages, template engines, markup formats, and configuration files.</p>
<p>Almost every large software project needs a handful of these. When you can, it’s good to reuse an existing one instead of rolling your own.</p>
<p>A random selection of some little languages you might run into.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/little-languages.png?raw=true" alt="A random selection of some little languages you might run into." /></p>
<p>But there’s still a good chance you’ll find yourself needing to whip up a parser or other tool when there isn’t an existing library that fits your needs. Even when you are reusing some existing implementation, you’ll inevitably end up needing to debug and maintain it and poke around in its guts.</p>
<p>对于每一种通用的流行语言，都对应着成千小众语言。我们可以称为这些语言为小众语言，但是在行业术语中，通常人们会使用领域特定语言(DSL)来描述。它们都是为了执行特定任务设计，想象一下，脚本语言、模版引擎、标记格式、配置文件。</p>
<p>几乎每个大型项目中，我们总会使用上图中的部分语言。通常我们会复用已经出现的语言，而不是自己造轮子。但是，当你考虑到文档、调试、编辑器支持、语法高亮和其他类似功能，就需要自己动手了。😄</p>
<p>当没有现有库匹配新需求时候，可能需要开发新的解析器或者一些小工具。即使对于某些正在使用的第三方库，也会需要不断进行调试和维护，并且需要对其深入研究。</p>
<h3 id="12-languages-are-great-exercise"><a class="header" href="#12-languages-are-great-exercise">1.2 Languages are great exercise</a></h3>
<p>语言是好的锻炼</p>
<p>Long distance runners sometimes train with weights strapped to their ankles or at high altitudes where the atmosphere is thin. When they later unburden themselves, the new relative ease of light limbs and oxygen-rich air enables them to run farther and faster.</p>
<p>Implementing a language is a real test of programming skill. The code is complex and performance critical. You must master recursion, dynamic arrays, trees, graphs, and hash tables. You probably use hash tables at least in your day-to-day programming, but do you really understand them?</p>
<p>While I intend to show you that an interpreter isn’t as daunting as you might believe, implementing one well is still a challenge.</p>
<p>长跑运动员会在训练时候，在脚踝上绑上重物，或者在高海拔、空气稀薄地区训练。当他们卸下负重时候，相对轻松的四肢和正常的氧气，使得他们，可以跑得更快更远。</p>
<p>实现一门语言是对编程技能的真正测试。代码会非常复杂，而且性能也很重要。你必须掌握递归算法、动态数组、树、图和哈希表。可能你每日的编程代码中都会使用哈希表，但是你真的理解它吗？好吧，让我们从头开始，我保证你一定可以学会的。</p>
<p>虽然我想向你们展示，编译器并不像我们认为的那么可怕，但是实现一个好的编译器仍然是一个有挑战的任务。当你做到了这一点，你会变得更加强大，并且在日常开发工作中，使用数据结构和算法会更加熟练。</p>
<h3 id="13-one-more-reason"><a class="header" href="#13-one-more-reason">1.3 One more reason</a></h3>
<p>另一个原因</p>
<p>This last reason is hard for me to admit, because it’s so close to my heart. Ever since I learned to program as a kid, I felt there was something magical about languages. When I first tapped out BASIC programs one key at a time I couldn’t conceive how BASIC itself was made.</p>
<p>Later, the mixture of awe and terror on my college friends’ faces when talking about their compilers class was enough to convince me language hackers were a different breed of human—some sort of wizards granted privileged access to arcane arts.</p>
<p>It’s a charming image, but it has a darker side. I didn’t feel like a wizard, so I was left thinking I lacked some inborn quality necessary to join the cabal. Though I’ve been fascinated by languages ever since I doodled made-up keywords in my school notebook, it took me decades to muster the courage to try to really learn them. </p>
<p>When I did finally start cobbling together my own little interpreters, I quickly learned that, of course, there is no magic at all.</p>
<p>There are a few techniques you don’t often encounter outside of languages, and some parts are a little difficult.  But not more difficult than other obstacles you’ve overcome. My hope is that if you’ve felt intimidated by languages and this book helps you overcome that fear, maybe I’ll leave you just a tiny bit braver than you were before.</p>
<p>And, who knows, maybe you will make the next great language. Someone has to.</p>
<p>最后一个原因我本人很难承认，因为它一直深藏我心底。当我小时候学会接触编程，我就觉得编程语言非常神奇。当我第一次一个按键一个按键敲出 BASIC 程序时候，我无法想象 BASIC 内部是如何运行的。</p>
<p>后来，当我的朋友们谈论起编译器课程时候，他们脸上充满了敬畏和恐惧，这加深了我的想法：编译器黑客是另外一种人类，一些巫师才能拥有的天赋。</p>
<p>这是一个迷人的形象，但是它也有黑暗的一面，我不觉得自己是一个巫师，所以我不认为自己拥有巫师的天赋。虽然从我在学校笔记本上，乱写关键词时候，就对于编程语言十分着迷，但是，我花了几十年时间才真正开始学习编译器。编译器的那种神奇之处、不简单的感觉，让我一直徘徊在门外。</p>
<p>当我开始编写自己的编译器时候，很快就明白了，这个领域根本没有魔法。仅仅只是代码，识别代码的也都是普通人。</p>
<p>有一些语言之外的技巧，我们不会经常遇到，但是这一部分有些难度。但是，也不会比你所克服的其他障碍更加棘手。我的希望是，如果你和我一样，对编译器感到恐惧，那么这本书将帮助你克服这个恐惧，也许这之后，你将变得更加勇敢。</p>
<p>最后，你还可能成为下一个伟大语言的创始人，必须有人去做。谁知道呢？</p>
<h2 id="二how-the-book-is-organized"><a class="header" href="#二how-the-book-is-organized">二、How the book is organized</a></h2>
<p>本书的组织方式</p>
<p>This book is broken into three parts. You're reading the first one now. It's a couple of chapters to get you oriented, teach you some of the lingo that language hackers use, and introduce you to Lox, the language we'll be implementing.</p>
<p>Each of the other two parts builds one complete Lox interpreter. Within those parts, each chapter is structured the same way. The chapter takes a single language feature, tachers you the concepts bebind it, and walks you through an implementation.</p>
<p>It took a good bit of trial and error on my part, but I managed to carve up the two interpreters into chapter-sized chunks that build on the previous chapters but require nothing from later ones. From the very first chapter, you'll have a working program you can run and play with. With each passing chapter, it grows increasing full-featured until you eventually have a complete language.</p>
<p>Aside from copious, scintillating English prose, chapters have a few other delightful facets.</p>
<p>这本书将分为三个部分，现在正在阅读的是第一部分。这几章会让你有一些方向感，教你使用黑客常用的术语。然后，会介绍Lox语言，我们将要实现的语言。</p>
<p>其他两个部分，会分别实现一个完整的编译器。在这两个部分，每一章的结构都是相同的，本章节采用单一语言功能，向您介绍背后的概念，并且引导你去实现解析器。</p>
<p>对我来说，需要一些尝试和试错，但我还是把两个编译器分为章节大小的部分，这些章节基于前面几章的基础知识，不需要理解后面几章的内容。从第一章开始，你就拥有了一个可以运行和使用的工作程序。随着更多章节的学习，这个工作程序会越来越全面，直到最终，你会拥有一个完整的编程语言。</p>
<p>除了丰富、华丽的正文外，每个章节还有一些令人愉快的部分。</p>
<h3 id="21-the-code"><a class="header" href="#21-the-code">2.1 The code</a></h3>
<p>We're about crafting interpreters, so this book contains real code. Every single line of code needed is included, and each snippet tells you where to insert it in your ever-growing implementation.</p>
<p>Many other language books and language implementations use tools like <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> and <a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>, so-called <strong>compiler-compilers</strong>, that automatically generate some of the source files for an implementation from some higher-level description. There are pros and cons to tool like those, and strong opinions——some might say religious convictions —— on both sides.</p>
<p>We will abstain from using them here. I want to ensure there are no dark corners where magic and confusion can hide, so we’ll write everything by hand. As you’ll see, it’s not as bad as it sounds, and it means you really will understand each line of code and how both interpreters work.</p>
<p>A book has different constraints from the “real world” and so the coding style here might not always reflect the best way to write maintainable production software. If I seem a little cavalier about, say, omitting private or declaring a global variable, understand I do so to keep the code easier on your eyes. The pages here aren’t as wide as your IDE and every character counts.</p>
<p>Also, the code doesn’t have many comments. That’s because each handful of lines is surrounded by several paragraphs of honest-to-God prose explaining it. When you write a book to accompany your program, you are welcome to omit comments too. Otherwise, you should probably use // a little more than I do.</p>
<p>While the book contains every line of code and teaches what each means, it does not describe the machinery needed to compile and run the interpreter. I assume you can slap together a makefile or a project in your IDE of choice in order to get the code to run. </p>
<p>我们是介绍编译器的，所以本书会包含真是可用的代码。每行代码，每个代码段，都会告诉你它们的作用和在实现的不断完善的编译器中的位置。</p>
<p>许多其他语言书籍和语言实现书籍中，通常会使用 Lex，Yacc等称为编译编译器的编译语言，这些语言，可以从更高级的描述中自动生成源文件。 直接使用这些语言工具，有好处也有弊端，而对于这两个观点，都有很多宗教信仰般的拥趸。</p>
<p>本书中将避免使用编译器语言，我想要确保没有黑暗的角落，隐藏着一些魔法和未知，所以我们将手写所有内容。正如你看到的，这并不像听起来那么糟糕，这意味着你将真正理解每一行代码，并且真的理解这两个编译器是如何工作的。</p>
<p>一本书不同于真实世界的约束，因此本书的编码风格可能并不是编写可维护性生产级别软件的最佳实践。如果我省略了 private 或者 忽略了全局变量声明，请理解我这么做是为了让代码更加容易理解，而不是来源于傲慢。这里的页面没有 IDE 那么宽，但是它们都非常重要。</p>
<p>此外，代码没有太多的注释，这是因为每段代码上下文，都是对其的大段正文说明。当你自己编写一本代码实现的书籍时候，也欢迎你省略其中的注释。当然，你也可以使用更多的 //</p>
<p>虽然这本书包含了编译器的每一行代码，介绍了每一行代码的含义，但是我并没有描述编译和运行代码的具体机器信息。我预想你可以使用自己熟悉的 IDE 创建一个文件或是一个项目。这些具体机器说明很快就会过时，我希望这本书可以像 XO白兰地一样历久弥新，而不是像 backyard hooch（一直保质期不长的蜂蜜酒）一样很快过时。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/yak.png?raw=true" alt="yak" /></p>
<blockquote>
<p>Yacc is a tool that takes in a grammar file and produces a source file for a compiler, so it’s sort of like a “compiler” that outputs a compiler, which is where we get the term “compiler-compiler”.</p>
<p>Yacc wasn’t the first of its ilk, which is why it’s named “Yacc”—Yet Another Compiler-Compiler. A later similar tool is Bison, named as a pun on the pronunciation of Yacc like “yak”.</p>
<p>If you find all of these little self-references and puns charming and fun, you’ll fit right in here. If not, well, maybe the language nerd sense of humor is an acquired taste.</p>
<p>Yacc 是一个工具，可以接收语法文件，然后为编译器生成源文件。所以，它好像是一个可以输出&quot;编译器&quot;的编译器，一般使用术语&quot;编译器编译程序&quot;形容 Yacc</p>
<p>Yacc并不是第一个&quot;编译器编译程序&quot;, 这就是这个程序缩写的来源：另一个编译器编译程序。还有一个相似的工具，称为 Bison（野牛), 命名来源于 Yacc的双关语 yak （牦牛)。</p>
<p>如果你发现，这些小小的自我暗示和双关语，很有魅力和乐趣，你将很快适应这里。如果你对此并不感冒，可能书呆子的幽默感是后天养成的。</p>
</blockquote>
<h3 id="22-snippets"><a class="header" href="#22-snippets">2.2 Snippets</a></h3>
<p>代码段</p>
<p>Since the book contains literally every line of code needed for the implementations, the snippets are quite precise. Also, because I try to keep the program in a runnable state even when major features are missing, sometimes we add temporary code that gets replaced in later snippets.</p>
<p>A snippet with all the bells and whistles looks like this:</p>
<p>In the center, you have the new code to add. It may have a few faded out lines above or below to show where it goes in the existing surrounding code. There is also a little blurb telling you in which file and where to place the snippet. If that blurb says “replace _ lines”, there is some existing code between the faded lines that you need to remove and replace with the new snippet.</p>
<pre><code class="language-java">
	// lox/Scanner.java in scanToken() replace 1 line
	
	default:
        if (isDigit(c)) {
          number();
        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }
        break;
		
</code></pre>
<p>因为本书中包含有所有编译器的实现代码，所以书中涉及的代码段非常准确。此外，因为我试图让程序即使在缺少主要功能的情况下，也可以保持可运行状态。所以，有时候我会添加临时代码，在之后章节会替换这些临时代码。</p>
<p>代码段示例如下:</p>
<p>中间代码是实际要添加的代码，上面和下面的代码表示要添加代码的位置。还有一个小提示，告诉你这段代码添加到哪个文件的哪个函数中。如何小提示上面写了 &quot;替换该行&quot;, 表示新增的代码需要替换之前的代码。</p>
<h3 id="23-asides"><a class="header" href="#23-asides">2.3 Asides</a></h3>
<p>Asides contain biographical sketches, historical background, references to related topics, and suggestions of other areas to explore. There’s nothing that you need to know in them to understand later parts of the book, so you can skip them if you want. I won’t judge you, but I might be a little sad.</p>
<p>Well, some asides do, at least. Most of them are just dumb jokes and amateurish drawings.</p>
<p>旁白包含了传记历史、历史背景、相关主题的参考文献以及推荐的延伸阅读。如果是为了阅读后面章节的内容，你不需要阅读旁白，也就是说你可以直接跳过旁白。我不会批评你，但是我会感到难过 😫。</p>
<p>嗯，还有些旁白不尽如人意，这些旁白大部分都是愚蠢的笑话和业余水平的绘画。</p>
<h3 id="24-challenges"><a class="header" href="#24-challenges">2.4 Challenges</a></h3>
<p>Each chapter ends with a few exercises. Unlike textbook problem sets, which tend to review material you already covered, these are to help you learn more than what’s in the chapter. They force you to step off the guided path and explore on your own. They will make you research other languages, figure out how to implement features, or otherwise get you out of your comfort zone.</p>
<p>Vanquish the challenges and you’ll come away with a broader understanding and possibly a few bumps and scrapes. Or skip them if you want to stay inside the comfy confines of the tour bus. It’s your book.</p>
<p>A word of warning: the challenges often ask you to make changes to the interpreter you’re building. You’ll want to implement those in a copy of your code. The later chapters assume your interpreter is in a pristine (“unchallenged”?) state.</p>
<p>每个章节都以一些练习题结束。但是不同于教科书的习题集，它们通常让你复习已经学过的知识，本书的习题更加倾向于让你学到更多的东西。这些习题会让你离开章节的已有路径，独自探索更多的未知领域。它们会让你去研究其他语言，去寻找如何实现功能，或者让你走出舒适区。</p>
<p>接受习题集的挑战，并且战胜它们，你将会有更加广阔的视野，虽然你可能会遇到一些坎坷和挫折。如果你想要呆在舒服的游览车内，你也可以跳过这些挑战习题，毕竟这是你的书。</p>
<p>一句警告⚠️，这些挑战通常会要求你修改已构建的编译器，建议你在副本项目中实现这些挑战，我们后面的章节基于没有修改的编译器。</p>
<h3 id="25-design-notes"><a class="header" href="#25-design-notes">2.5 Design notes</a></h3>
<p>设计思路</p>
<p>Most “programming language” books are strictly programming language implementation books. They rarely discuss how one might happen to design the language being implemented. Implementation is fun because it is so precisely defined. We programmers seem to have an affinity for things that are black and white, ones and zeroes.</p>
<p>Personally, I think the world needs only so many implementations of FORTRAN 77. At some point, you find yourself designing a new language. Once you start playing that game, then the softer, human side of the equation becomes paramount.  Things like which features are easy to learn, how to balance innovation and familiarity, what syntax is more readable and to whom.</p>
<p>All of that stuff profoundly affects the success of your new language. I want your language to succeed, so in some chapters I end with a “design note”, a little essay on some corner of the human aspect of programming languages. I’m no expert on this—I don’t know if anyone really is—so take these with a large pinch of salt. That should make them tastier food for thought, which is my main aim.</p>
<p>I know a lot of language hackers whose careers are based on this. You slide a language spec under their door, wait a few months, and code and benchmark results come out. Hopefully your new language doesn’t hardcode assumptions about the width of a punched card into its grammar.</p>
<p>大多数的编程语言书籍，都是严格意义上的编写代码实现，他们很少讨论如何设计一门语言、设计一段实现。实现非常有趣，因为它是确定的，而且被精确定义。我们程序员似乎对于确定性的东西，例如：黑与白，1与0，天生有好感。</p>
<p>就我个人而言，我认为世界上只需要 Fortran77 （1976年，美国标准化协会重新对Fortran（x3.9-1966）进行了评估，公布了新的Fortran标准，也就是Fortran 77。Fortran 77是具有结构化特性的编程语言。Fortran77在短时间内获取了巨大的成功，广泛地应用于科学和工程计算，几乎统治了数值计算领域。）中实现的功能。但是在某些时候，你发现自己在设计一门新语言。一旦你开始设计语言这个游戏，那么人性化的一面变得非常重要。需要考虑更加具体的内容，例如：哪些功能更易于学习，如何平衡创新和保留，哪些语法更易于阅读，学习语言的人群是谁？</p>
<p>所有这些都深刻的影响着一门新语言的成功与否。我希望你的新语言可以成功，所以我会在某些章节的结尾，发表一些设计方面的思考，这是一些编程语言中人们设计的最佳实践。我不是设计方面的专家，不知道是否有人真的这么想—在一些编程语言的正文中，添加一些设计方面的内容。这应该会让设计内容称为更加美味的思想食粮，这也是我的主要目标。</p>
<p>我认识很多编程老手，他们的职业就在于此——你将一门语言的规范告知他们，等待几个月，你将会得到这门新语言的代码和基准测试结果。希望你的新语言，不会将穿孔纸的宽度信息，硬编码到语言语法中。</p>
<h2 id="三the-first-interpreter"><a class="header" href="#三the-first-interpreter">三、The First Interpreter</a></h2>
<p>第一个编译器</p>
<p>We’ll write our first interpreter, jlox, in Java. The focus is on concepts. We’ll write the simplest, cleanest code we can to correctly implement the semantics of the language. This will get us comfortable with the basic techniques and also hone our understanding of exactly how the language is supposed to behave.</p>
<p>The book uses Java and C, but readers have ported the code to many other languages. If the languages I picked aren’t your bag, take a look at those.</p>
<p>Java is a great language for this. It’s high level enough that we don’t get overwhelmed by fiddly implementation details, but it’s still pretty explicit. Unlike in scripting languages, there tends to be less complex machinery hiding under the hood, and you’ve got static types to see what data structures you’re working with.</p>
<p>我们将使用JAVA语言实现第一个编译器，jlox，第一个编译器的重点是基本概念，我们将编写最简洁、最基础的代码，实现编译器的语义。这将让我们熟悉基本的技术，让我们能更加准确理解语言行为。</p>
<p>本书将使用 JAVA, C语言，但是读者可能更加熟悉其他的编程语言，如果我使用的语言不是你的菜，可以尝试使用你最熟悉的语言。</p>
<p>JAVA是一门很好的语言，我们不需要关注底层的大量实现细节，因为JAVA是一门高级语言，拥有更多的确定性。和脚本语言不同的是，JAVA与不同机器的关联性并没有那么复杂，通常，你可以使用静态类型去获取查看当前正在使用的结构体。</p>
<p>I also chose Java specifically because it is an object-oriented language.  That paradigm swept the programming world in the ’90s and is now the dominant way of thinking for millions of programmers. Odds are good you’re already used to organizing code into classes and methods, so we’ll keep you in that comfort zone.</p>
<p>While academic language folks sometimes look down on object-oriented languages, the reality is that they are widely used even for language work. GCC and LLVM are written in C++, as are most JavaScript virtual machines. Object-oriented languages are ubiquitous, and the tools and compilers for a language are often written in the same language.</p>
<p>And, finally, Java is hugely popular. That means there’s a good chance you already know it, so there’s less for you to learn to get going in the book. If you aren’t that familiar with Java, don’t freak out. I try to stick to a fairly minimal subset of it.  I use the diamond operator from Java 7 to make things a little more terse,  but that’s about it as far as “advanced” features go. If you know another object-oriented language, like C# or C++, you can muddle through.</p>
<p>By the end of part II, we’ll have a simple, readable implementation. It’s not very fast, but it’s correct. However, we are only able to accomplish that by building on the Java virtual machine’s own runtime facilities. We want to learn how Java itself implements those things.</p>
<p>我们选择Java，还因为它是一门面向对象的语言。这种编程范式在90年代席卷了整个世界，现在也是数百万程序员的主流思维方式。很可能你已经习惯了将代码组织成类和方法，接下来我们也会让你处于舒适区中。</p>
<p>虽然，学术研究语言的人们，有时候看不起面向对象的编程语言，但是实际情况是，即使在他们日常编程工作中，也会广泛使用面向对象语言。GCC/LLVM 还有大多数的 JavaScript 虚拟机都是使用面向对象的C++语言实现的。面向对象语言无处不在，一门语言的编译器和工具，通常会使用相同的语言实现。</p>
<p>最后，Java非常流行。这意味着，这是一个很好机会去使用熟悉这门语言。如果你不熟悉Java，也不用担心，本书中只会使用一小部分功能，我将使用Java7 标准里面的运算符，相对于使用更多的高级用法，这会让编程变得更加简洁。如果你还熟悉其他的面向对象语言，例如: C#, C++, 你也可以尝试使用它们去实现编译器。</p>
<p>在第二部分结束时候，我们将有一个简单易读的编译器实现，它的运行性能不是很高，但是可以保证准确性。但是，我们实现的编译器，是基于Java 语言和 Java 虚拟机底层。我们想要了解 Java本身是如何实现这些功能的。</p>
<p>A compiler reads files in one language, translates them, and outputs files in another language.
You can implement a compiler in any language, including the same language it compiles, a process called self-hosting.</p>
<p>You can’t compile your compiler using itself yet, but if you have another compiler for your language written in some other language, you use that one to compile your compiler once. Now you can use the compiled version of your own compiler to compile future versions of itself, and you can discard the original one compiled from the other compiler. This is called bootstrapping, from the image of pulling yourself up by your own bootstraps.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/bootstrap.png?raw=true" alt="bootstraps" /></p>
<p>编译器读取一种语言的原始文件，翻译它们，然后输出另外一门语言的文件。你可以用任何语言实现编译器，甚至你可以使用相同的语言去实现该语言的编译器，这通常被称为自编译。</p>
<p>一开始，你无法使用相同的语言写成一个编译器，但是如果你已经使用过其他语言实现了新语言的编译器，那么你就可以使用已经实现的编译器，去编译一次，然后你可以获取到使用新语言实现的编译器。接下来，你可以愉快的使用新的编译器，去升级新的编译器版本，也可以扔掉之前的其他语言写成的编译器了。专业术语一般称为自举，图中形象的描述了一个人的自举。</p>
<h2 id="四the-second-interpreter"><a class="header" href="#四the-second-interpreter">四、The Second Interpreter</a></h2>
<p>第二个编译器</p>
<p>So in the next part, we start all over again, but this time in C. C is the perfect language for understanding how an implementation really works, all the way down to the bytes in memory and the code flowing through the CPU.</p>
<p>A big reason that we’re using C is so I can show you things C is particularly good at, but that does mean you’ll need to be pretty comfortable with it. You don’t have to be the reincarnation of Dennis Ritchie, but you shouldn’t be spooked by pointers either.</p>
<p>If you aren’t there yet, pick up an introductory book on C and chew through it, then come back here when you’re done. In return, you’ll come away from this book an even stronger C programmer. That’s useful given how many language implementations are written in C: Lua, CPython, and Ruby’s MRI, to name a few.</p>
<p>In our C interpreter, clox, we are forced to implement for ourselves all the things Java gave us for free. We’ll write our own dynamic array and hash table. We’ll decide how objects are represented in memory, and build a garbage collector to reclaim them.</p>
<blockquote>
<p>I pronounce the name like “sea-locks”, but you can say it “clocks” or even “cloch”, where you pronounce the “x” like the Greeks do if it makes you happy.</p>
<p>我把这个名字读成&quot;sea-locks&quot;, 但是你也可以读成，&quot;clocks&quot; 或者 &quot;cloch&quot;, 如果你开心的话，还可以像希腊人一样读 &quot;x&quot;</p>
</blockquote>
<p>Our Java implementation was focused on being correct. Now that we have that down, we’ll turn to also being fast. Our C interpreter will contain a compiler that translates Lox to an efficient bytecode representation (don’t worry, I’ll get into what that means soon), which it then executes. This is the same technique used by implementations of Lua, Python, Ruby, PHP, and many other successful languages.</p>
<blockquote>
<p>Did you think this was just an interpreter book? It’s a compiler book as well. Two for the price of one!</p>
<p>你认为这只是一本解释器介绍书籍吗，其实它还是一个编译器介绍书籍。这两者没有本质区别。</p>
</blockquote>
<p>We’ll even try our hand at benchmarking and optimization. By the end, we’ll have a robust, accurate, fast interpreter for our language, able to keep up with other professional caliber implementations out there. Not bad for one book and a few thousand lines of code.</p>
<p>在下个部分中，我们将从头开始，但是这一次将使用C语言。C语言可以让我们更好的理解计算机是如何工作的，深入到底层，例如：内存中的字节和 cpu 执行的代码。</p>
<p>我们使用C语言实现编译器，的一个重要原因是，我可以使用C语言一些特别擅长的功能，但是这也意味着你必须非常熟悉C语言。你不需要像创始人 Dennis Ritchie 一样熟悉 C语言，但是你至少不能被指针吓倒。</p>
<p>如果你还不太了解C语言，那么先拿起一本C语言入门书籍仔细阅读后，再回到这里。作为回报，你将变成一个更强大的C语言程序员。你可以先看看有哪些语言是基于C语言实现的：Lua，CPython，Ruby的MRI实现，等等。</p>
<p>在C语言实现的解释器 clox 中，我们将要实现一些 Java中原生存在的结构，例如：我们将实现动态数组和哈希表，我们将设计决定如何在内存中表示对象，并且构建垃圾采集器回收它们。</p>
<p>第一部分，我们用Java语言实现的编译器 jlox主要专注于准确性，现在我们已经实现了准确性，接下来将专注于性能。我们的clox解释器，将实现一个编译器，将lox 编译为有效的字节码（别担心，很快我将解释它是什么），然后执行字节码。这与其他语言的实现使用相同技术，例如：Lua，Python，Ruby，PHP等等。</p>
<p>我们甚至会尝试基准测试和优化。到最后，我们将实现一个强大、准确、快速的语言解释器，能够和其他专业级别的语言媲美，而这对于一本书和几千行代码而言，并不简单。</p>
<h2 id="五-challenges"><a class="header" href="#五-challenges">五、 Challenges</a></h2>
<p>习题</p>
<ol>
<li>
<p>There are at least siz domain-specific languages used in the <a href="https://github.com/munificent/craftinginterpreters">little system I cobbled together</a> to write and publish this book. What are they?</p>
<p>在我编写本书中，至少使用了6种小众语言，请列举中它们？</p>
</li>
<li>
<p>Get a &quot;Hello, world!&quot; program written and running in Java. Set up whatever makefiles or IDE projects you need to get it working. If you have a debugger, get comfortable with it and step through your program as it runs.</p>
<p>使用 Java语言实现一个 &quot;hello, world&quot; 程序，描述一下你使用的IDE 和配置文件，并且在IDE中习惯调试。</p>
</li>
<li>
<p>Do the same thing for C. To get some practice with pointers, define a <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly linked list</a> of heap-allocated strings. Write functions to insert, find, and delete items from it. Test them.</p>
<p>使用C语言实现一个 &quot;hello, world&quot; 程序，为了练习指针，定义一个堆分配字符串的双链表，编写函数插入、查找、删除链表元素。</p>
</li>
</ol>
<h2 id="六design-note-whats-in-a-name"><a class="header" href="#六design-note-whats-in-a-name">六、Design Note: What's in a name?</a></h2>
<p>设计说明：如何命名？</p>
<p>One of the hardest challenges in writing book was coming up with a name for the language it implements. I went through pages of candidates before I found one that worked. As you'll discover on the first day you start building your own language, naming is deviously hard. A good name satisfies a few criteria:</p>
<ol>
<li>
<p>It isn't in use.</p>
<p>You can run into all sorts of trouble, legal and social, if you inadvertently step on someone else’s name.</p>
</li>
<li>
<p>It's easy to pronounce. If things go well, hordes of people will be saying and writing your language’s name. Anything longer than a couple of syllables or a handful of letters will annoy them to no end.</p>
</li>
<li>
<p>It's distinct enough to search for. People will Google your language’s name to learn about it, so you want a word that’s rare enough that most results point to your docs. Though, with the amount of AI search engines are packing today, that’s less of an issue. Still, you won’t be doing your users any favors if you name your language “for”.</p>
</li>
<li>
<p>It doesn't have negative connotations across a number of cultures. This is hard to be on guard for, but it’s worth considering. The designer of Nimrod ended up renaming his language to “Nim” because too many people remember that Bugs Bunny used “Nimrod” as an insult. (Bugs was using it ironically.)</p>
</li>
</ol>
<p>If your potential name makes it through that gauntlet, keep it. Don’t get hung up on trying to find an appellation that captures the quintessence of your language.</p>
<p>本书编写过程中一个挑战是，如何为实现的语言命名。我需要从众多的候选中，找到最合适的。正如你在构建自己语言时候会遇到的一样，命名非常困难，一个好的命名符合下面的标准：</p>
<ol>
<li>
<p>该名字之前没有被使用。如果你不小心使用了他人的命名，可能会有非常多的麻烦，包含法律和社会问题。</p>
</li>
<li>
<p>该名字需要朗朗上口，如果一切顺利的话，会有非常多人书写、说出你的语言名称，而任何拗口的名字，都会给人们带来困惑。</p>
</li>
<li>
<p>该名字需要足够特别，更容易搜索到。人们第一时间会使用搜索引擎了解你的语言，如果你使用一个足够特别的单词命名，那么大家将很容易获取到。尽管，随着搜索引擎拥有更多的AI能力，更容易显示你的语言。但是，如果你把自己的新语言命名为&quot;for&quot;, 那么这通常不能带给使用者任何帮助。</p>
</li>
<li>
<p>该名字在其他文化中没有负面含义。这一点很难防范，但是需要认真考虑。Nimrod 的设计者最终将这个语言命名为 &quot;Nim&quot;, Bugs Bunny曾经故意使用有争议的名称 Nimrod 命名新的语言，人们依然记得。</p>
</li>
</ol>
<p>如果你的候选命名，通过了上面的标准，那么留着它吧。不要试图去找到一个能抓住你的语言精髓的名称。如果说世界上其他已经成功的语言教会了我们什么的话，那就是语言名字和语言精髓没有关联。你所需要的只是一个，独特的名称。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总览图"><a class="header" href="#总览图">总览图</a></h1>
<h2 id="a-map-of-the-territory"><a class="header" href="#a-map-of-the-territory">A Map of the Territory</a></h2>
<blockquote>
<p>you must have a map, no matter how rough. Otherwise you wander all over the place. In The Lord of the Rings I never made anyone go farther than he could on a given day.</p>
<p align="right">—— J.R.R. Tolkien</p>
</blockquote>
<p>领土图</p>
<blockquote>
<p>不管有多么粗糙，你都必须拥有一幅领土地图，否则你将到处游荡。在《指环王》中，我从来都没有让任何人一天内走的更远。</p>
<p align="right">—— J.R.R. Tolkien</p>
</blockquote>
<p>We don’t want to wander all over the place, so before we set off, let’s scan the territory charted by previous language implementers. It will help us understand where we are going and the alternate routes others have taken.</p>
<p>First, let me establish a shorthand.  Much of this book is about a language’s implementation, which is distinct from the language itself in some sort of Platonic ideal form. Things like “stack”, “bytecode”, and “recursive descent”, are nuts and bolts one particular implementation might use. From the user’s perspective, as long as the resulting contraption faithfully follows the language’s specification, it’s all implementation detail.</p>
<p>We’re going to spend a lot of time on those details, so if I have to write “language implementation” every single time I mention them, I’ll wear my fingers off. Instead, I’ll use “language” to refer to either a language or an implementation of it, or both, unless the distinction matters.</p>
<p>我们不想到处瞎逛，所以在出发之前，我们先浏览一下以前的语言实现者绘制的领土图。这将帮助我们理解我们的目标，了解更多的替代路径。</p>
<p>首先，让我们建立一个概览。本书的大部分内容都是如何实现一门语言，这和一门语言本身柏拉图式的理想概念有所不同。 像是栈、字节码、递归下降等东西，是一个特定实现可能会用到的具体细节。 从用户的角度，只要生成的内容还遵循着语言的规范，它就是所有的实现细节。</p>
<p>我们将在这些细节上花费大量时间，因此，如果每次提到这些细节，我都要加上语言实现说明，那么我会累晕的。所以，我将使用语言来表示一门语言或者这门语言的实现，或者两者，除非两者的区别非常重要。</p>
<h2 id="一the-parts-of-a-language"><a class="header" href="#一the-parts-of-a-language">一、The Parts of a Language</a></h2>
<p>语言的组成部分</p>
<p>Engineers have been building programming languages since the Dark Ages of computing. As soon as we could talk to computers, we discovered doing so was too hard, and we enlisted their help. I find it fascinating that even though today’s machines are literally a million times faster and have orders of magnitude more storage, the way we build programming languages is virtually unchanged.</p>
<p>Though the area explored by language designers is vast, the trails they’ve carved through it are few. Not every language takes the exact same path—some take a shortcut or two—but otherwise they are reassuringly similar, from Rear Admiral Grace Hopper’s first COBOL compiler all the way to some hot, new, transpile-to-JavaScript language whose “documentation” consists entirely of a single, poorly edited README in a Git repository somewhere.</p>
<p>自计算的黑暗时代以来，工程师们一直在构建编程语言。当我们可以与电脑交流时候，我们发现这样做太难了，需要电脑的帮助。我发现一个有趣的现象，即使今天的机器运行速度快了数百万倍，存储量也增加了几个数量级，但是我们构建编程语言的方式几乎没有任何改变。</p>
<p>虽然，语言设计者探索的领域非常大，但是他们在其中开辟的道路却非常少。并不是所有的语言都走相同的路径，有些语言的实现，会走一、两条捷径。但是从另一个角度来看，它们都是相似的。从第一个 COBOL编译器到现在最新的可以转换为 JavaScript的语言，在它们 git仓库README文件中的描述都是相似的。</p>
<blockquote>
<p>There are certainly dead ends, sad little cul-de-sacs of CS papers with zero citations and now-forgotten optimizations that only made sense when memory was measured in individual bytes.</p>
<p>毫无疑问，计算机科学论文存在一些死胡同。这些论文现在已经没有人引用，都是在内存需要以一个一个字节来衡量时期的优化使用论文。</p>
</blockquote>
<p>I visualize the network of paths an implementation may choose as climbing a mountain. You start off at the bottom with the program as raw source text, literally just a string of characters. Each phase analyzes the program and transforms it to some higher-level representation where the semantics—what the author wants the computer to do—become more apparent.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/mountain.png?raw=true" alt="a map of the territory" /></p>
<p>Eventually we reach the peak. We have a bird’s-eye view of the user’s program and can see what their code means. We begin our descent down the other side of the mountain. We transform this highest-level representation down to successively lower-level forms to get closer and closer to something we know how to make the CPU actually execute.</p>
<p>我把编译领域图，想象为一幅包含很多路径的爬山图。从底部开始，一开始只是一个文本，实际上只是一个字符串。经过，每个分析阶段，都会生成更加高级的表示，设计者希望计算机执行的语言都更加明确。</p>
<p>最后，我们爬上了山顶。我们鸟瞰全局，可以得到使用者编写的代码含义。我们从山的另一边开始下山，我们将连续将高级别的表示转换为更低级别的表示，以越来越接近计算机 CPU执行的语言。</p>
<p>Let’s trace through each of those trails and points of interest. Our journey begins on the left with the bare text of the user’s source code:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/string.png?raw=true" alt="string" /></p>
<p>接下来，我们将追踪每一条路径、每一个停留点，我们的旅途从左边山脚开始（用户源代码）。</p>
<h3 id="11-scanning"><a class="header" href="#11-scanning">1.1 Scanning</a></h3>
<p>扫描</p>
<p>The first step is scanning, also known as lexing, or (if you’re trying to impress someone) lexical analysis. They all mean pretty much the same thing. I like “lexing” because it sounds like something an evil supervillain would do, but I’ll use “scanning” because it seems to be marginally more commonplace.</p>
<p>A scanner (or lexer) takes in the linear stream of characters and chunks them together into a series of something more akin to “words”. In programming languages, each of these words is called a token. Some tokens are single characters, like ( and ,. Others may be several characters long, like numbers (123), string literals (&quot;hi!&quot;), and identifiers (min).</p>
<p>Some characters in a source file don’t actually mean anything. Whitespace is often insignificant, and comments, by definition, are ignored by the language. The scanner usually discards these, leaving a clean sequence of meaningful tokens.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/tokens.png?raw=true" alt="tokens" /></p>
<p>第一步是扫描，也称为词法，如果你想给别人留下深刻印象，还可以称为词法分析。他们的含义都差不多，我更喜欢词法，因为这听起来像是一个恶作剧，但是接下来我会使用扫描表示这个过程，因为这种说法更加常见。</p>
<p>一个扫描器，接收线性的字符串，将它们分块为一个个单词，在编程语言中，分成的单词称为 token, 一些 token 是单字符，例如: <code>(</code> <code>,</code> 还有一些token长度是多个字符，例如: 数字 <code>123</code> ，字符串 <code>&quot;hi!&quot;</code> , 标识符 <code>min</code></p>
<p>源文件中的某些字符没有实际意义。空白字符，通常没有实际意义，还有注释，根据语言定义，注释会被语言忽略。扫描器通常会忽略这些内容，最终生成一个干净的有意义的token 序列。</p>
<h3 id="12-parsing"><a class="header" href="#12-parsing">1.2 Parsing</a></h3>
<p>解析</p>
<p>The next step is parsing. This is where our syntax gets a grammar—the ability to compose larger expressions and statements out of smaller parts. Did you ever diagram sentences in English class? If so, you’ve done what a parser does, except that English has thousands and thousands of “keywords” and an overflowing cornucopia of ambiguity. Programming languages are much simpler.</p>
<p>A parser takes the flat sequence of tokens and builds a tree structure that mirrors the nested nature of the grammar. These trees have a couple of different names—parse tree or abstract syntax tree—depending on how close to the bare syntactic structure of the source language they are.  In practice, language hackers usually call them syntax trees, ASTs, or often just trees.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/ast.png?raw=true" alt="ast" /></p>
<p>下一步是解析，这就是我们获得语法的地方，语法可以将较小的部分组合成较大的表达式和语句。你在英语课堂上画过句子图吗？如果是这样的话，你已经完成了解析器的工作。除了英语有成千上万个关键词和更多的歧义。相较而言，编程语言就简单太多了。</p>
<p>解析器接收token 序列，然后构建出反应语法嵌套性质的树结构。这些树有一些不同的名称，例如：名称解析树，抽象语法树，命名取决于这些树和源语言的简单语法结构的接近程度。在实践中，语言高手经常称它们为语法树，AST或者通常就称为树。</p>
<p>Parsing has a long, rich history in computer science that is closely tied to the artificial intelligence community. Many of the techniques used today to parse programming languages were originally conceived to parse human languages by AI researchers who were trying to get computers to talk to us.</p>
<p>It turns out human languages were too messy for the rigid grammars those parsers could handle, but they were a perfect fit for the simpler artificial grammars of programming languages. Alas, we flawed humans still manage to use those simple grammars incorrectly, so the parser’s job also includes letting us know when we do by reporting syntax errors.</p>
<p>解析在计算机科学中拥有悠久丰富的历史，与人工智能领域密切相关。今天用于解析编程语言的许多技术最初是由人工智能研究人员构思的，他们最初设想是让计算机与人对话交流。</p>
<p>事实证明，对于解析器所能解析的语法而言，人类的语言太复杂了，但是这些解析器却非常适合编程语言中的人类定义的语法规则。哎，我们这些普通的人，在使用这些简单语法时候，仍然会犯错误，所以，解析器还会报告语法错误，让我们知道。</p>
<h3 id="13-static-analysis"><a class="header" href="#13-static-analysis">1.3 Static analysis</a></h3>
<p>静态分析</p>
<p>The first two stages are pretty similar across all implementations. Now, the individual characteristics of each language start coming into play. At this point, we know the syntactic structure of the code—things like which expressions are nested in which—but we don’t know much more than that.</p>
<p>In an expression like a + b, we know we are adding a and b, but we don’t know what those names refer to. Are they local variables? Global? Where are they defined?</p>
<p>前面两个阶段（扫描、解析）在所有的实现中都是相似的，现在，每种语言的特性开始显现出来了。解析过后，我们知道了代码的语法结构，例如：我们知道了包含了哪些表达式，但是我们了解的还不够多。</p>
<p>在像表达式 a + b中，我们知道表达式是 a与b求和，但是我们并不知道a，b具体表示什么，它们是局部变量吗，是全局变量吗，它们是在哪里定义的呢？</p>
<p>The first bit of analysis that most languages do is called binding or resolution. For each identifier, we find out where that name is defined and wire the two together. This is where scope comes into play—the region of source code where a certain name can be used to refer to a certain declaration.</p>
<p>If the language is statically typed, this is when we type check. Once we know where a and b are declared, we can also figure out their types. Then if those types don’t support being added to each other, we report a type error.</p>
<p>大多数语言的第一点分析叫做，绑定或解析。对于每个标识符，我们需要找到该标识符名称的定义位置，并且将两者连接在一起，这就是作用域发挥作用的地方——源代码的某个区域中，可以使用一个具体名称来引用某个声明。</p>
<p>如果语言是静态语言，这时候，我们还要进行类型判断，一旦我们找到了 a，b的声明位置，我们也可以获取到它们的数据类型。然后，如果这些数据类型不支持加法规则，我们将报告一个类型错误。</p>
<blockquote>
<p>The language we’ll build in this book is dynamically typed, so it will do its type checking later, at runtime.</p>
</blockquote>
<blockquote>
<p>本书中构建的语言是动态语言，所以，类型检查将发生在运行时，而不是当前阶段。</p>
</blockquote>
<p>Take a deep breath. We have attained the summit of the mountain and a sweeping view of the user’s program. All this semantic insight that is visible to us from analysis needs to be stored somewhere. There are a few places we can squirrel it away:</p>
<ul>
<li>
<p>Often, it gets stored right back as attributes on the syntax tree itself—extra fields in the nodes that aren’t initialized during parsing but get filled in later.</p>
</li>
<li>
<p>Other times, we may store data in a lookup table off to the side. Typically, the keys to this table are identifiers—names of variables and declarations. In that case, we call it a symbol table and the values it associates with each key tell us what that identifier refers to.</p>
</li>
<li>
<p>The most powerful bookkeeping tool is to transform the tree into an entirely new data structure that more directly expresses the semantics of the code. That’s the next section.</p>
</li>
</ul>
<p>深呼吸，我们已经登上了山顶，用户程序一览无余。从分析阶段后，获取到的语义附加信息，需要保存在某个地方。有几个地方可以保存这些信息。</p>
<ul>
<li>
<p>通常，它作为属性存储在语法树的其他字段中，这些字段在解析阶段没有初始化，但是在分析阶段会被填充</p>
</li>
<li>
<p>其他时候，我们可以将数据保存在旁边的查找表中。通常情况下，该查找表的key是标识符（变量名称和声明）。这这种情况下，我们称其为符号表，表中key对应的value，表示该标识符对应的实际值是什么</p>
</li>
<li>
<p>更加强大的记录方式是，将语法树转换为一个全新的数据结构，更加直接的表示代码的含义。这是下一节的内容。</p>
</li>
</ul>
<p>Everything up to this point is considered the front end of the implementation. You might guess everything after this is the back end, but no. Back in the days of yore when “front end” and “back end” were coined, compilers were much simpler. Later researchers invented new phases to stuff between the two halves. Rather than discard the old terms, William Wulf and company lumped those new phases into the charming but spatially paradoxical name middle end.</p>
<p>到现在为止，所有内容阶段，都是实现的前端部分。你可能会想象，那么之后的内容是后端了，其实并不是，哈哈😄。当编译器，刚开始有前端、后端概念的时候，那时候的编译器非常简单。后来，研究人员又发明了其他阶段，它们在前端、后端之间。<a href="https://en.wikipedia.org/wiki/William_Wulf">William Wulf</a> 和他们公司并没有抛弃旧的术语，他们把这些新发明的阶段归为有意思的但是有些矛盾的术语，中间端。</p>
<h3 id="14-intermediate-representations"><a class="header" href="#14-intermediate-representations">1.4 Intermediate representations</a></h3>
<p>中间表示法</p>
<p>You can think of the compiler as a pipeline where each stage’s job is to organize the data representing the user’s code in a way that makes the next stage simpler to implement. The front end of the pipeline is specific to the source language the program is written in. The back end is concerned with the final architecture where the program will run.</p>
<p>In the middle, the code may be stored in some intermediate representation (IR) that isn’t tightly tied to either the source or destination forms (hence “intermediate”). Instead, the IR acts as an interface between these two languages.</p>
<p>我们可以将编译器视为一个管道，每个阶段的工作是用一种更易于实现的方式，组织表示用户代码。管道前端，作用于编写程序的源语言，后端与程序运行的最终架构相关。</p>
<p>在中间端，代码可能存储在一些中间表示中，这些表示，与源语言和目标形式都没有紧密关联。相反，这种中间表示，充当源语言和目标语言之间的接口。</p>
<blockquote>
<p>There are a few well-established styles of IRs out there. Hit your search engine of choice and look for “control flow graph”, “static single-assignment”, “continuation-passing style”, and “three-address code”.</p>
</blockquote>
<blockquote>
<p>有一些成熟的中间表示风格，有兴趣的话，可以去研究一下，控制流图、静态单赋值、连续传递样式、三地址代码等等。</p>
</blockquote>
<p>This lets you support multiple source languages and target platforms with less effort. Say you want to implement Pascal, C, and Fortran compilers, and you want to target x86, ARM, and, I dunno, SPARC. Normally, that means you’re signing up to write nine full compilers: Pascal→x86, C→ARM, and every other combination.</p>
<p>A shared intermediate representation reduces that dramatically. You write one front end for each source language that produces the IR. Then one back end for each target architecture. Now you can mix and match those to get every combination.</p>
<p>There’s another big reason we might want to transform the code into a form that makes the semantics more apparent . . . </p>
<p>这种方式，可以让我们更容易支持多种源语言和目标语言的匹配。假设你想要实现，Pascal、C、Fortran语言的编译器，并且这些编译器，可以运行在X86， arm，SPARC等架构上，如果没有使用中间表示，你需要实现9种编译器，例如: Pascal——&gt; x86，C——&gt; arm等等。</p>
<p>使用一种共享的中间表示，可以大大减少这些组合。对于每一种源语言，编写一个前端，将源语言解析为中间表示，对于每个目标架构，针对中间表示，编写一个后端。所以，现在只需要实现 6 中前端、后端组合。</p>
<p>还有一个重要原因，让我们使用中间表示。我们可以利用中间表示，将代码转为一种形式，使得语义更加明显。</p>
<blockquote>
<p>If you’ve ever wondered how GCC supports so many crazy languages and architectures, like Modula-3 on Motorola 68k, now you know. Language front ends target one of a handful of IRs, mainly GIMPLE and RTL. Target back ends like the one for 68k then take those IRs and produce native code.</p>
<p>如果你想要知道 <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>是如何支持这么多语言和架构的，现在你知道原因了。针对前端的少量中间表示，主要是 <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a> 和 <a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">RTL</a>, 不同的目标架构，获取中间表示，生成对应的机器代码。</p>
</blockquote>
<h3 id="15-optimization"><a class="header" href="#15-optimization">1.5 Optimization</a></h3>
<p>优化</p>
<p>Once we understand what the user’s program means, we are free to swap it out with a different program that has the same semantics but implements them more efficiently—we can optimize it.</p>
<p>A simple example is constant folding: if some expression always evaluates to the exact same value, we can do the evaluation at compile time and replace the code for the expression with its result. If the user typed in this:</p>
<pre><code>
pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);

</code></pre>
<p>we could do all of that arithmetic in the compiler and change the code to:</p>
<pre><code>pennyArea = 0.4417860938;
</code></pre>
<p>一旦我们理解了用户程序的含义，我们就可以自由的把用户程序替换为具有相同语义，但是更加高效的实现的另外一种程序。我们可以进行优化。</p>
<p>一个简单示例是常数计算。如果某个表达式的计算结果总是相同，那么我们可以在编译时候计算该表达式，并且使用表达式计算结果代替该表达式，例如，客户输入</p>
<pre><code>pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);
</code></pre>
<p>我们可以在编译时候计算出值，将代码修改为</p>
<pre><code>pennyArea = 0.4417860938;
</code></pre>
<p>Optimization is a huge part of the programming language business.  Many language hackers spend their entire careers here, squeezing every drop of performance they can out of their compilers to get their benchmarks a fraction of a percent faster. It can become a sort of obsession.</p>
<p>We’re mostly going to hop over that rathole in this book. Many successful languages have surprisingly few compile-time optimizations. For example, Lua and CPython generate relatively unoptimized code, and focus most of their performance effort on the runtime.</p>
<p>优化是编程语言的一个重要组成部分，许多语言高手在整个职业生涯都在不断优化，从编译器中榨取每一点性能，最终使得他们的编译器，基准测试结果提高了0.5%，优化是一个不断进行的过程。</p>
<p>本书中，我们会跳过优化这个步骤，有很多成功语言，也很少使用编译时优化。举例，Lua 和 CPython生成相对未优化的代码，将大部分优化放在运行时。</p>
<blockquote>
<p>If you can’t resist poking your foot into that hole, some keywords to get you started are “constant propagation”, “common subexpression elimination”, “loop invariant code motion”, “global value numbering”, “strength reduction”, “scalar replacement of aggregates”, “dead code elimination”, and “loop unrolling”.</p>
<p>如果你忍不住想要探索优化这个领域，那么你可以从一些术语入手，例如: &quot;恒定传播&quot;, &quot;公共子表达式消除&quot;, &quot;循环不变代码&quot;, &quot;全局值编号&quot;, &quot;强度降低&quot;, &quot;聚合标量代替&quot;, &quot;僵尸代码消除&quot;, &quot;循环展开&quot;。</p>
</blockquote>
<h3 id="16-code-generation"><a class="header" href="#16-code-generation">1.6 Code generation</a></h3>
<p>代码生成</p>
<p>We have applied all of the optimizations we can think of to the user’s program. The last step is converting it to a form the machine can actually run. In other words, generating code (or code gen), where “code” here usually refers to the kind of primitive assembly-like instructions a CPU runs and not the kind of “source code” a human might want to read.</p>
<p>Finally, we are in the back end, descending the other side of the mountain. From here on out, our representation of the code becomes more and more primitive, like evolution run in reverse, as we get closer to something our simple-minded machine can understand.</p>
<p>We have a decision to make. Do we generate instructions for a real CPU or a virtual one? If we generate real machine code, we get an executable that the OS can load directly onto the chip. Native code is lightning fast, but generating it is a lot of work. Native code is lightning fast, but generating it is a lot of work. </p>
<p>我们已经将能够想到的所有优化，应用于用户代码中。最后一步是，将代码转换为机器可以实际运行的形式。换句话说，代码生成（或者生成代码），这里的代码是指，CPU直接运行的类似于原始汇编的指令，而不用人们可以直接阅读的源代码。</p>
<p>最后，我们处于后端，从山的另一端往下走。从现在开始，我们对于代码的表示越来越原始，和上山方向相反，我们希望代码变为机器可以直接运行的形式。</p>
<p>我们需要决定，是生成真实的CPU指令，还是生成虚拟的指令。如果我们生成真实的机器代码，我们会得到一个可执行文件，操作系统可以直接加载到芯片中。原生本机代码运行速度非常快，但是，生成真实的 CPU指令需要大量的工作。现在的架构，有成堆的指令集，复杂的管道，和能够塞满747飞机的历史遗留包袱。</p>
<blockquote>
<p>For example, the AAD (“ASCII Adjust AX Before Division”) instruction lets you perform division, which sounds useful. Except that instruction takes, as operands, two binary-coded decimal digits packed into a single 16-bit register. When was the last time you needed BCD on a 16-bit machine</p>
<p>举例，AAD指令可以执行除法运算，这听起来非常有用。除此之外，ADD指令会将两个二进制编码额十进制数字作为操作数压缩到单个16位寄存器上，上一次，你需要BCD，并且在16位机器，是什么时候呢？</p>
</blockquote>
<p>Speaking the chip’s language also means your compiler is tied to a specific architecture. If your compiler targets x86 machine code, it’s not going to run on an ARM device.  All the way back in the ’60s, during the Cambrian explosion of computer architectures, that lack of portability was a real obstacle.</p>
<p>To get around that, hackers like Martin Richards and Niklaus Wirth, of BCPL and Pascal fame, respectively, made their compilers produce virtual machine code. Instead of instructions for some real chip, they produced code for a hypothetical, idealized machine. Wirth called this p-code for portable, but today, we generally call it bytecode because each instruction is often a single byte long.</p>
<p>These synthetic instructions are designed to map a little more closely to the language’s semantics, and not be so tied to the peculiarities of any one computer architecture and its accumulated historical cruft. You can think of it like a dense, binary encoding of the language’s low-level operations.</p>
<p>转换为芯片特定语言，意味着你的编译器和特定架构相关联。如果编译器以x86 机器代码为目标，那么它将无法在arm架构机器上运行。一直追溯到上世纪60年代，在当时的计算机体系结构爆炸时期，缺乏可移植性的编译器是一个真正的缺点。</p>
<p>为了避免这种问题，编程高手，例如：BCPL 语言的发明者<a href="https://en.wikipedia.org/wiki/Martin_Richards_(computer_scientist)">Martin Richards</a> 和 Pascal语言的主要开发者<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a> ,不约而同的，让他们实现的编译器最终生成虚拟机代码。他们为一个假想的、理想化的机器生成代码，而不是为了一些真实的芯片生成指令。<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>称这些代码为P代码，因为可移植单词的缩写，但是今天，我们通常称为字节码，因为每条指令通常只有一个字节长度。</p>
<p>这些合成指令，是为了更加接近代码的语义，而不是因为更加关联那些架构或是其后的历史。我们可以想象字节码是更加底层的二进制编码。</p>
<blockquote>
<p>The basic principle here is that the farther down the pipeline you push the architecture-specific work, the more of the earlier phases you can share across architectures.</p>
<p>基本的原则是，越晚把编译器局限于特定架构上，就可以越多的享受不同架构间代码共用。</p>
</blockquote>
<blockquote>
<p>There is a tension, though. Many optimizations, like register allocation and instruction selection, work best when they know the strengths and capabilities of a specific chip. Figuring out which parts of your compiler can be shared and which should be target-specific is an art.</p>
<p>不过，存在一种均衡，许多优化，例如：寄存器分配和指令选择，当你了解特定芯片的优点和能力时候，使用效果会更好。搞清楚编译器哪些部分可以共享，哪些部分只适用于特定架构，是一门艺术。</p>
</blockquote>
<h3 id="17-virtual-machine"><a class="header" href="#17-virtual-machine">1.7 Virtual machine</a></h3>
<p>虚拟机</p>
<p>If your compiler produces bytecode, your work isn’t over once that’s done. Since there is no chip that speaks that bytecode, it’s your job to translate. Again, you have two options. You can write a little mini-compiler for each target architecture that converts the bytecode to native code for that machine. You still have to do work for each chip you support, but this last stage is pretty simple and you get to reuse the rest of the compiler pipeline across all of the machines you support. You’re basically using your bytecode as an intermediate representation.</p>
<p>Or you can write a virtual machine (VM), a program that emulates a hypothetical chip supporting your virtual architecture at runtime. Running bytecode in a VM is slower than translating it to native code ahead of time because every instruction must be simulated at runtime each time it executes. In return, you get simplicity and portability. Implement your VM in, say, C, and you can run your language on any platform that has a C compiler. This is how the second interpreter we build in this book works.</p>
<p>如果你的编译器，最终产生字节码，那么，你的工作还没有结束。如果你的工作是翻译的话，那么现在没有芯片可以直接执行字节码。同样，现在你有两个选择。</p>
<p>第一个选择是，你可以为每一种目标架构编写一个小型编译器，把字节码转换为架构中机器使用的机器码。我们可以为支持的每一种芯片编写对应的编译器，但是最后这个阶段非常简单，你也可以重复使用编译器之前的代码。我们使用编译器生成的字节码当作中间表示。</p>
<p>或者，我们可以编写一个虚拟机，一个在运行时候，模拟虚构芯片的程序。在虚拟机中运行字节码比直接在本机运行机器码，慢一些，因为虚拟机每次运行指令，都必须模拟实际指令。作为回报，我们获得了简单性和可移植性。假设用C语言实现虚拟机，那么我们可以在任何有C编译器的机器上运行代码。本书第二部分实现的编译器采用该原理。</p>
<blockquote>
<p>The term “virtual machine” also refers to a different kind of abstraction. A system virtual machine emulates an entire hardware platform and operating system in software. This is how you can play Windows games on your Linux machine, and how cloud providers give customers the user experience of controlling their own “server” without needing to physically allocate separate computers for each user.</p>
<p>The kind of VMs we’ll talk about in this book are language virtual machines or process virtual machines if you want to be unambiguous.</p>
<p>术语虚拟机是一种抽象。一个系统级别的虚拟机，会模拟整个硬件平台和操作系统。这就是，你可以在Linux服务器上玩Windows游戏的原因，还有，这也是云服务厂商，为用户分配指定的云服务器，而不需要真实提供对应的机器的原因。</p>
<p>但是，本书中涉及到的虚拟机，只是语言虚拟机或者进程虚拟机，如果你想要一个准确的描述词。</p>
</blockquote>
<h3 id="18-runtime"><a class="header" href="#18-runtime">1.8 Runtime</a></h3>
<p>运行时</p>
<p>We have finally hammered the user’s program into a form that we can execute. The last step is running it. If we compiled it to machine code, we simply tell the operating system to load the executable and off it goes. If we compiled it to bytecode, we need to start up the VM and load the program into that.</p>
<p>In both cases, for all but the basest of low-level languages, we usually need some services that our language provides while the program is running. For example, if the language automatically manages memory, we need a garbage collector going in order to reclaim unused bits. If our language supports “instance of” tests so you can see what kind of object you have, then we need some representation to keep track of the type of each object during execution.</p>
<p>All of this stuff is going at runtime, so it’s called, appropriately, the runtime. In a fully compiled language, the code implementing the runtime gets inserted directly into the resulting executable.  In, say, Go, each compiled application has its own copy of Go’s runtime directly embedded in it. If the language is run inside an interpreter or VM, then the runtime lives there. This is how most implementations of languages like Java, Python, and JavaScript work.</p>
<p>最终，我们终于把用户程序，转换为一种可以执行的形式。最后一步是运行，如果我们最后编译为机器码，我们只需要加载可执行文件，然后运行。如果将其编译为字节码，我们需要启动虚拟机，把编译的字节码加载到虚拟机中。</p>
<p>在两种场景下，除了最基本的低层语言，当程序运行时，我们还需要提供一些其他服务。例如：如果语言是自动管理内存的，那么我们需要一个垃圾收集器，回收不再使用的内存。如果我们实现的语言，支持实例测试，以便于获取对象的实际数据类型，那么我们需要一些功能，跟踪运行时候的对象。</p>
<p>所有这些都发生在程序运行时候，所以，我们称呼这个阶段为运行时。在一个完全编译的语言中，运行时，代码将直接插入到可执行文件中。举例，在go语言中，每个编译的应用程序都有自己的 go运行时副本，直接嵌入其中。如果语言在解释器或者虚拟机中运行，那么运行时就在其中。这也是 Java/Python/JavaScript等语言的运行工作方式。</p>
<h2 id="二shortcuts-and-alternate-routes"><a class="header" href="#二shortcuts-and-alternate-routes">二、Shortcuts and Alternate Routes</a></h2>
<p>快捷方式和备选路径</p>
<p>That’s the long path covering every possible phase you might implement. Many languages do walk the entire route, but there are a few shortcuts and alternate paths.</p>
<p>这一条漫长的路，可能包含你的实现的每一个阶段。许多语言贯穿了整个过程，但是也有一些语言，会包含捷径和其他备选路径。</p>
<h3 id="21-single-pass-compilers"><a class="header" href="#21-single-pass-compilers">2.1 Single-pass compilers</a></h3>
<p>单通道编译器</p>
<p>Some simple compilers interleave parsing, analysis, and code generation so that they produce output code directly in the parser, without ever allocating any syntax trees or other IRs. These single-pass compilers restrict the design of the language. You have no intermediate data structures to store global information about the program, and you don’t revisit any previously parsed part of the code. That means as soon as you see some expression, you need to know enough to correctly compile it.</p>
<p>Pascal and C were designed around this limitation. At the time, memory was so precious that a compiler might not even be able to hold an entire source file in memory, much less the whole program. This is why Pascal’s grammar requires type declarations to appear first in a block. It’s why in C you can’t call a function above the code that defines it unless you have an explicit forward declaration that tells the compiler what it needs to know to generate code for a call to the later function.</p>
<p>一些简单的编译器，会把解析阶段、分析阶段、代码生成阶段混杂在一起，它们直接在解析过程生成代码，而不需要生成语法树或者其他中间表示。这些单通道编译器限制了语言的设计。你没有中间数据结构来存储有关程序的全局信息，也无法重新访问任何之前解析过的代码。这意味着，一旦看到某个表达式，我们需要足够的信息来，正确的编译表达式。</p>
<p>Pascal 和 C语言是围绕上面的限制设计的。当时，内存非常宝贵，编译器甚至无法将整个源文件放入到内存中，更不用说在内存中，保存整个程序了。这就是为什么Pascal语言要求类型声明首先出现在代码块中，这也是为什么在C语言中，除非有一个明确的正向声明，告诉编译器生成调用后面的函数所需要的代码，否则无法在函数定义的位置上面，调用该函数。</p>
<blockquote>
<p>Syntax-directed translation is a structured technique for building these all-at-once compilers. You associate an action with each piece of the grammar, usually one that generates output code. Then, whenever the parser matches that chunk of syntax, it executes the action, building up the target code one rule at a time.</p>
<p>语法定向翻译是一种结构化技术，用于同时构建这些编译器，将每一个动作和每一个语法片段相关联，通常是输出代码的语法片段。然后，每当解析器匹配该语法块时候，它会执行操作，一次建立一个规则的目标代码。</p>
</blockquote>
<h3 id="22-tree-walk-interpreters"><a class="header" href="#22-tree-walk-interpreters">2.2 Tree-walk interpreters</a></h3>
<p>树遍历解释器</p>
<p>Some programming languages begin executing code right after parsing it to an AST (with maybe a bit of static analysis applied). To run the program, the interpreter traverses the syntax tree one branch and leaf at a time, evaluating each node as it goes.</p>
<p>This implementation style is common for student projects and little languages, but is not widely used for general-purpose languages since it tends to be slow. Some people use “interpreter” to mean only these kinds of implementations, but others define that word more generally, so I’ll use the inarguably explicit tree-walk interpreter to refer to these. Our first interpreter rolls this way.</p>
<p>许多的语言，在解析阶段生成了语法树后，就开始执行代码（可能会使用一些静态分析）。为了运行程序，解释器每一次都会遍历语法树的一个分支和叶节点，在每一个节点运行时候，进行评估。</p>
<p>这种实现风格，在学生作业和小的语言中非常常见，但是，由于运行速度比较慢，没有广泛的应用于通用的语言。一些人使用解释器，表示这种类型的实现，但是，另外一些人，使用更加一般的术语描述这种实现方式，本书中我使用树遍历解释器来描述这种实现。我们第一个实现Lox语言采用这种实现风格。</p>
<blockquote>
<p>A notable exception is early versions of Ruby, which were tree walkers. At 1.9, the canonical implementation of Ruby switched from the original MRI (Matz’s Ruby Interpreter) to Koichi Sasada’s YARV (Yet Another Ruby VM). YARV is a bytecode virtual machine.</p>
<p>一个著名的例子是，Ruby语言的早期版本，使用了树遍历风格的实现方式。在1.9版本，Ruby的实现从早期的MRI变更为YARV，YARV是一个字节码虚拟机。</p>
</blockquote>
<h3 id="23-transpilers"><a class="header" href="#23-transpilers">2.3 Transpilers</a></h3>
<p>转换机</p>
<p>Writing a complete back end for a language can be a lot of work. If you have some existing generic IR to target, you could bolt your front end onto that. Otherwise, it seems like you’re stuck. But what if you treated some other source language as if it were an intermediate representation?</p>
<p>Writing a complete back end for a language can be a lot of work. If you have some existing generic IR to target, you could bolt your front end onto that. Otherwise, it seems like you’re stuck. But what if you treated some other source language as if it were an intermediate representation?</p>
<p>You write a front end for your language. Then, in the back end, instead of doing all the work to lower the semantics to some primitive target language, you produce a string of valid source code for some other language that’s about as high level as yours. Then, you use the existing compilation tools for that language as your escape route off the mountain and down to something you can execute.</p>
<p>They used to call this a source-to-source compiler or a transcompiler. After the rise of languages that compile to JavaScript in order to run in the browser, they’ve affected the hipster sobriquet transpiler.</p>
<p>为一种语言编写一个完整的后端，需要很多的工作。如果你有一些现有的通用后端目标，那么你可以把前端设计为通用后端的匹配前端。否则的话，你似乎卡在这里了。但是，如果你把其他的语言视为一种中间表示，那么我们应该如何匹配？</p>
<p>你为自己的语言编写了前端，然后，在后端，你的想法不是，把用户程序的语义变更为底层原始的目标语言，而是把用户语义转换为一个更高级语言的源代码。然后，你可以使用这种高级语言的已经存在的编译器，作为下山的备选路径。</p>
<p>在以前，这种实现方式被称为源代码到源代码编译器或者 转换编译器，当出现了一些语言，为了能在浏览器运行，，最终编译为JavaScript后，大家想到了一个新的名称 转换机 来描述。</p>
<p>While the first transcompiler translated one assembly language to another, today, most transpilers work on higher-level languages. After the viral spread of UNIX to machines various and sundry, there began a long tradition of compilers that produced C as their output language. C compilers were available everywhere UNIX was and produced efficient code, so targeting C was a good way to get your language running on a lot of architectures.</p>
<p>Web browsers are the “machines” of today, and their “machine code” is JavaScript, so these days it seems almost every language out there has a compiler that targets JS since that’s the main way to get your code running in a browser.</p>
<p>The front end—scanner and parser—of a transpiler looks like other compilers. Then, if the source language is only a simple syntactic skin over the target language, it may skip analysis entirely and go straight to outputting the analogous syntax in the destination language.</p>
<p>If the two languages are more semantically different, you’ll see more of the typical phases of a full compiler including analysis and possibly even optimization. Then, when it comes to code generation, instead of outputting some binary language like machine code, you produce a string of grammatically correct source (well, destination) code in the target language.</p>
<p>Either way, you then run that resulting code through the output language’s existing compilation pipeline, and you’re good to go.</p>
<p>虽然第一个转换机，把一种汇编语言转换为另外一种汇编语言，但是现在，我们常常把一门语言转换为更加高级的语言。因为UNIX的风靡，编译器开始了一个传统，那就是把转换机输出语言变为 C语言。C语言编译器，存在于任意的UNIX系统中，支持更多的架构，并且C编译器可以生成更加高效的代码，因此，把C语言作为输出目标，是一个非常好的方向。</p>
<p>现在，web浏览器是一种新型机器，这种新机器的运行代码是JavaScript，所以现在很多语言都有一个针对JS的编译器，最终输出JS代码，这样可以让新的语言运行在浏览器中。<a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">详细清单</a></p>
<p>转换机的前端部分，扫描阶段、解析阶段，和其他的编译器相似，然而，如果新语言只是目标语言的一个简单皮肤，那么编译器可能会完全跳过分析阶段，直接输出目标语言。</p>
<p>但是，如果这两种语言，在语义上非常不相同，那么，你可能会添加一些传统编译器的其他阶段，例如：分析阶段，优化阶段。但是，最终代码生成阶段，我们不会生成传统的机器码或者字节码，而是生成一个语法正确的目标语言字符串。</p>
<p>无论如何，你都可以在编译后，获取到目标语言的源代码，然后通过目标语言的编译器，开始运行新语言。</p>
<blockquote>
<p>The first transcompiler, XLT86, translated 8080 assembly into 8086 assembly. That might seem straightforward, but keep in mind the 8080 was an 8-bit chip and the 8086 a 16-bit chip that could use each register as a pair of 8-bit ones. XLT86 did data flow analysis to track register usage in the source program and then efficiently map it to the register set of the 8086.</p>
<p>It was written by Gary Kildall, a tragic hero of computer science if there ever was one. One of the first people to recognize the promise of microcomputers, he created PL/M and CP/M, the first high-level language and OS for them.</p>
<p>He was a sea captain, business owner, licensed pilot, and motorcyclist. A TV host with the Kris Kristofferson-esque look sported by dashing bearded dudes in the ’80s. He took on Bill Gates and, like many, lost, before meeting his end in a biker bar under mysterious circumstances. He died too young, but sure as hell lived before he did.</p>
<p>第一个转换机，XLT86，把8080 汇编转换为8086汇编，这看起来似乎很简单，但是，请注意，8080是一个8位芯片，而8086是一个16位芯片，可以将8086的寄存器，作为8080的一对寄存器使用，XLT86进行了数据流分析，用于跟踪源程序中的寄存器使用，然后，有效的把这些寄存器，映射为8086的寄存器集。</p>
<p>XLT86 是由Gary KIldall实现的，他是计算机科学领域的一个悲剧人物，作为最早认识到微型计算机前景的人之一，他开发了PL/M 和 CP/M，而CP/M是第一种和操作系统交互的高级语言。</p>
</blockquote>
<blockquote>
<p>JS used to be the only way to execute code in a browser. Thanks to WebAssembly, compilers now have a second, lower-level language they can target that runs on the web.</p>
<p>JS曾经是浏览器中唯一的运行语言，但是现在我们多了一种选择 <a href="https://webassembly.org/">WebAssembly</a>, 编译器现在拥有了第二种可以直接在浏览器运行的语言。</p>
</blockquote>
<h3 id="24-just-in-time-compilation"><a class="header" href="#24-just-in-time-compilation">2.4 Just-in-time compilation</a></h3>
<p>即时编译</p>
<p>This last one is less a shortcut and more a dangerous alpine scramble best reserved for experts. The fastest way to execute code is by compiling it to machine code, but you might not know what architecture your end user’s machine supports. What to do?</p>
<p>You can do the same thing that the HotSpot Java Virtual Machine (JVM), Microsoft’s Common Language Runtime (CLR), and most JavaScript interpreters do. On the end user’s machine, when the program is loaded—either from source in the case of JS, or platform-independent bytecode for the JVM and CLR—you compile it to native code for the architecture their computer supports. Naturally enough, this is called just-in-time compilation. Most hackers just say “JIT”, pronounced like it rhymes with “fit”.</p>
<p>The most sophisticated JITs insert profiling hooks into the generated code to see which regions are most performance critical and what kind of data is flowing through them. Then, over time, they will automatically recompile those hot spots with more advanced optimizations.</p>
<p>最后一个不是捷径，而是危险的高山攀岩，最好留给专家。最快的代码执行速度，肯定是翻译为具体的机器码，但是，编译阶段，你可能不知道用户的机器是什么架构，那么我们应该怎么办呢？</p>
<p>你可以借鉴JVM（Java语言虚拟机），CLR（微软的通用语言运行库），还有大多数JS编译器做的，在用户的机器上，当程序加载时候，无论是从源代码，还是在JVM/CLR中加载字节码，你可以将其编译为本机的机器码。很自然的，这个过程称为即时编译。大多数编程高手称这种实现为JIT，发音类似fit。</p>
<p>最复杂的JIT，会在生成代码中插入一些性能分析代码，查看哪些代码块、哪些数据结构对于运行性能影响最大。然后，随着时间累积，JIT将自动使用更高级的优化方式，重新编译热点代码。</p>
<blockquote>
<p>This is, of course, exactly where the HotSpot JVM gets its name.</p>
<p>当然，这也是JVM的一种实现，HotSpot JVM的名称来源。</p>
</blockquote>
<h2 id="三compilers-and-interpreters"><a class="header" href="#三compilers-and-interpreters">三、Compilers and Interpreters</a></h2>
<p>编译器和解释器</p>
<p>Now that I’ve stuffed your head with a dictionary’s worth of programming language jargon, we can finally address a question that’s plagued coders since time immemorial: What’s the difference between a compiler and an interpreter?</p>
<p>It turns out this is like asking the difference between a fruit and a vegetable. That seems like a binary either-or choice, but actually “fruit” is a botanical term and “vegetable” is culinary. One does not strictly imply the negation of the other. There are fruits that aren’t vegetables (apples) and vegetables that aren’t fruits (carrots), but also edible plants that are both fruits and vegetables, like tomatoes.</p>
<p>现在，我们大脑中已经塞满了各种编译术语，接下来，我们将解决一个自古以来就困扰着程序员的问题，编译器和解释器有什么区别？</p>
<p>实际上，这个问题可以类比为，水果和蔬菜有什么区别？这个答案看起来是一个二选一问题，但是实际上，水果是一个植物学术语，蔬菜则是一个烹饪用语，一个东西是水果并不代表它不可以是蔬菜，现实生活中，我们可以找到某些水果，不是蔬菜，例如：苹果；也可以找到某些蔬菜，不属于水果，例如：胡萝卜；但是，我们也可以找到，某些东西，即是水果，也是蔬菜，例如：西红柿。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/plants.png?raw=true" alt="plants" /></p>
<p>So, back to languages:</p>
<ul>
<li>
<p>Compiling is an implementation technique that involves translating a source language to some other—usually lower-level—form. When you generate bytecode or machine code, you are compiling. When you transpile to another high-level language, you are compiling too.</p>
</li>
<li>
<p>When we say a language implementation “is a compiler”, we mean it translates source code to some other form but doesn’t execute it. The user has to take the resulting output and run it themselves.</p>
</li>
<li>
<p>Conversely, when we say an implementation “is an interpreter”, we mean it takes in source code and executes it immediately. It runs programs “from source”.</p>
</li>
</ul>
<p>那么，返回到语言部分，</p>
<ul>
<li>
<p>编译是一种实现技术，通常是将源语言转换为更加低级别的形式，当你把一门语言编译为字节码或者机器码时候，你使用了编译技术，当你转换为另外一种高级语言时候，你也在使用编译。</p>
</li>
<li>
<p>当我们说实现了一个编译器，我们的意思是，将源语言转换为其他形式，但是并不执行，用户需要获取到编译结果，然后再运行。</p>
</li>
<li>
<p>对应的，当我们说实现了一个解释器，我们的意思是，可以直接执行源代码，看起来，我们好像是直接从源语言运行。</p>
</li>
</ul>
<p>Like apples and oranges, some implementations are clearly compilers and not interpreters. GCC and Clang take your C code and compile it to machine code. An end user runs that executable directly and may never even know which tool was used to compile it. So those are compilers for C.</p>
<p>In older versions of Matz’s canonical implementation of Ruby, the user ran Ruby from source. The implementation parsed it and executed it directly by traversing the syntax tree. No other translation occurred, either internally or in any user-visible form. So this was definitely an interpreter for Ruby.</p>
<blockquote>
<p>Peanuts (which are not even nuts) and cereals like wheat are actually fruit, but I got this drawing wrong. What can I say, I’m a software engineer, not a botanist. I should probably erase the little peanut guy, but he’s so cute that I can’t bear to.</p>
<p>Now pine nuts, on the other hand, are plant-based foods that are neither fruits nor vegetables. At least as far as I can tell.</p>
</blockquote>
<p>像苹果和橘子一样，它们是水果但不是蔬菜，有一些实现，是编译器，而不是解释器。GCC和Clang 接收原始的C语言程序，最终编译为机器码。用户最终运行可执行文件，而不需要知道具体使用了哪个编译器，它们都是C语言编译器。</p>
<p>Ruby的老版本中，用户可以直接从Ruby源码运行。Ruby解释器直接解析源程序，生成语法树，然后，遍历语法树，直接执行，无论处于用户角度，还是实际内部机制，都没有其他的转换过程，我们可以确定这种实现为解释器。</p>
<p>But what of CPython? When you run your Python program using it, the code is parsed and converted to an internal bytecode format, which is then executed inside the VM. From the user’s perspective, this is clearly an interpreter—they run their program from source. But if you look under CPython’s scaly skin, you’ll see that there is definitely some compiling going on.</p>
<p>The answer is that it is both. CPython is an interpreter, and it has a compiler. In practice, most scripting languages work this way, as you can see:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/venn.png?raw=true" alt="venn" /></p>
<p>但是，CPython是什么呢？当我们运行Python程序时候，CPython编译器将Python代码转换为内部的字节码，在Python虚拟机中运行。从用户角度看，这是一个解释器，因为我们可以直接从原始代码运行，但是如果从内部实现角度，还存在着一些编译器。</p>
<p>准确答案是，CPython既是一个解释器，也是一个编译器，实际上，大部分的脚本语言都是这样的</p>
<p>That overlapping region in the center is where our second interpreter lives too, since it internally compiles to bytecode. So while this book is nominally about interpreters, we’ll cover some compilation too.</p>
<p>如上图，我们第二部分实现的Lox解释器，处于中间的重叠部分，因为我们会生成字节码。因此，虽然本书是关于解释器介绍的，但是，我们还是会涉及到编译器的内容。</p>
<blockquote>
<p>The Go tool is even more of a horticultural curiosity. If you run go build, it compiles your Go source code to machine code and stops. If you type go run, it does that, then immediately executes the generated executable.</p>
<p>So go is a compiler (you can use it as a tool to compile code without running it), is an interpreter (you can invoke it to immediately run a program from source), and also has a compiler (when you use it as an interpreter, it is still compiling internally).</p>
<p>go语言的命令更加能说明问题，例如：执行命令 go build，我们能得到一个可执行文件，如果执行命令，go run，程序会马上运行。</p>
<p>所以，go是一个编译器，可以将go程序编译为可执行文件，go也是一个解释器，可以直接运行go程序，但是解释器中还包含一个编译器，当直接运行go程序时候，内部仍有编译步骤。</p>
</blockquote>
<h2 id="四our-journey"><a class="header" href="#四our-journey">四、Our Journey</a></h2>
<p>我们的旅途</p>
<p>That’s a lot to take in all at once. Don’t worry. This isn’t the chapter where you’re expected to understand all of these pieces and parts. I just want you to know that they are out there and roughly how they fit together.</p>
<p>This map should serve you well as you explore the territory beyond the guided path we take in this book. I want to leave you yearning to strike out on your own and wander all over that mountain.</p>
<p>But, for now, it’s time for our own journey to begin. Tighten your bootlaces, cinch up your pack, and come along. From here on out, all you need to focus on is the path in front of you.</p>
<p>本章，我们介绍了很多内容，别担心，你不需要现在就理解所有内容，我们只是，先介绍它们，你需要知道它们是存在的，并且需要知道它们是如何结合在一起的。</p>
<p>本章涉及的地图将很好的陪伴着你，因为它包含有一些内容，本书中不会涉及到。我想要离开你，让你独自去探索、享受爬山的过程。</p>
<p>但是，现在还不是独自探索的时候，让我们一起开启旅程。系紧鞋带，收好背包，跟上来，从现在开始，你需要关注眼前的道路。</p>
<blockquote>
<p>Henceforth, I promise to tone down the whole mountain metaphor thing.</p>
<p>从今往后，我会淡化爬山这件事情。</p>
</blockquote>
<h2 id="五challenges"><a class="header" href="#五challenges">五、CHALLENGES</a></h2>
<p>习题集</p>
<ol>
<li>
<p>Pick an open source implementation of a language you like. Download the source code and poke around in it. Try to find the code that implements the scanner and parser. Are they handwritten, or generated using tools like Lex and Yacc? (.l or .y files usually imply the latter.)</p>
<p>选择一种你熟悉、喜欢的开源语言，下载源码然后浏览一下，尝试找出其中的扫描器、解析器部分，判断它们是自己实现的，还是使用Lex/Yacc等编译器工具实现的，可以查看是否存在 .l, .y 后缀的文件，这通常是工具生成文件。</p>
</li>
<li>
<p>Just-in-time compilation tends to be the fastest way to implement dynamically typed languages, but not all of them use it. What reasons are there to not JIT?</p>
<p>即时编译通常是动态语言最快的实现方式，但是并非所有的语言都利用这种特性，为什么它们不提供即时编译？</p>
</li>
<li>
<p>Most Lisp implementations that compile to C also contain an interpreter that lets them execute Lisp code on the fly as well. Why?</p>
<p>大多数的Lisp实现，在实现一个编译器，编译为C语言的同时，还提供一个解释器，保证可以动态执行Lisp代码，为什么？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lox语言"><a class="header" href="#lox语言">Lox语言</a></h1>
<blockquote>
<p>What nicer thing can you do for somebody than make them breakfast?</p>
<p align="right">—— Anthony Bourdain</p>
<p>还有什么比给别人做早餐更好的事情呢？</p>
</blockquote>
<p>We’ll spend the rest of this book illuminating every dark and sundry corner of the Lox language, but it seems cruel to have you immediately start grinding out code for the interpreter without at least a glimpse of what we’re going to end up with.</p>
<p>At the same time, I don’t want to drag you through reams of language lawyering and specification-ese before you get to touch your text editor. So this will be a gentle, friendly introduction to Lox. It will leave out a lot of details and edge cases. We’ve got plenty of time for those later.</p>
<p>我们将在本书的剩余部分，阐明Lox语言的每一个黑暗和杂乱的角落。但是，如果我们无法看到 Lox 语言的最终样子，就开始编写解释器代码，看起来有一些匆忙。</p>
<p>在你使用文本编辑器之前，我不想过多介绍语言的格式和规范，所以，本章将是一个温和友好的Lox介绍。它会遗漏很多细节和边缘部分，我们在后面有足够的时间去学习。</p>
<blockquote>
<p>A tutorial isn’t very fun if you can’t try the code out yourself. Alas, you don’t have a Lox interpreter yet, since you haven’t built one!</p>
<p>Fear not. You can use mine.</p>
<p>如果一个教程不能自己写代码，那么这个教程就没有吸引力。但是，你还没有一个Lox解释器，因为我们还没有去实现它。</p>
<p>不用担心，你可以先使用我的😄。</p>
</blockquote>
<h2 id="一hello-lox"><a class="header" href="#一hello-lox">一、Hello, Lox</a></h2>
<p>第一个程序</p>
<pre><code class="language-c">
// Your first Lox program!
print &quot;Hello, world!&quot;;

</code></pre>
<p>Here’s your very first taste of Lox:</p>
<p>As that // line comment and the trailing semicolon imply, Lox’s syntax is a member of the C family. (There are no parentheses around the string because print is a built-in statement, and not a library function.)</p>
<p>Now, I won’t claim that C has a great syntax. If we wanted something elegant, we’d probably mimic Pascal or Smalltalk. If we wanted to go full Scandinavian-furniture-minimalism, we’d do a Scheme. Those all have their virtues.</p>
<p>What C-like syntax has instead is something you’ll often find more valuable in a language: familiarity.  I know you are already comfortable with that style because the two languages we’ll be using to implement Lox—Java and C—also inherit it. Using a similar syntax for Lox gives you one less thing to learn.</p>
<p>上面是第一个Lox程序，</p>
<p>正如 // 行注释，行尾；所暗示的，Lox语言，继承了C语言语法。hello, world 字符串周围不需要括号，因为 print是一个内置语句，而不是一个库函数。</p>
<p>现在，我不会说C语言有很好的语法，如果我们想要优雅的东西，可能模仿Pascal、Smalltalk更加合适。如果我们想要完全实现 斯堪的纳维亚家具的极简主义，我们需要先做一个计划。这些都有它们的优势。</p>
<p>相反，我们使用类C语言语法，是因为我们可以从中获得更有价值的东西，熟悉度。我知道，你已经习惯了这种风格，接下来，我们用以实现Lox的两种语言，Java 和C语言，都拥有这种熟悉的风格。Lox语言使用这种风格的语法，可以更加容易入门。</p>
<blockquote>
<p>Your first taste of Lox, the language, that is. I don’t know if you’ve ever had the cured, cold-smoked salmon before. If not, give it a try too.</p>
<p>你第一次品尝Lox语言，就是这样。我不知道你之前有没有尝试过腌制的冷鲑鱼，如果没有，可以尝试一下。</p>
</blockquote>
<blockquote>
<p>I’m surely biased, but I think Lox’s syntax is pretty clean. C’s most egregious grammar problems are around types. Dennis Ritchie had this idea called “declaration reflects use”, where variable declarations mirror the operations you would have to perform on the variable to get to a value of the base type.</p>
<p>Lox doesn’t have static types, so we avoid that.</p>
<p>我是有偏见的，从我的角度，我认为Lox语言语法非常简洁。C语言令人惊讶的语法问题是，类型。Dennis Ritchie 提出一个“声明反映使用”的想法，其中变量声明反映了你对于变量执行的操作，以获得基类型的值。这个想法非常好，但我认为，在实践中的效果并不好。</p>
<p>Lox不是静态类型语言，所以我们避免了这种情况。</p>
</blockquote>
<h2 id="二a-high-level-language"><a class="header" href="#二a-high-level-language">二、A high-level language</a></h2>
<p>高级语言</p>
<p>While this book ended up bigger than I was hoping, it’s still not big enough to fit a huge language like Java in it. In order to fit two complete implementations of Lox in these pages, Lox itself has to be pretty compact.</p>
<p>When I think of languages that are small but useful, what comes to mind are high-level “scripting” languages like JavaScript, Scheme, and Lua. Of those three, Lox looks most like JavaScript, mainly because most C-syntax languages do. As we’ll learn later, Lox’s approach to scoping hews closely to Scheme. The C flavor of Lox we’ll build in Part III is heavily indebted to Lua’s clean, efficient implementation.</p>
<p>虽然本书内容大大超过了一开始的设想，但是还是无法利用一本书来介绍Java 这样的大型语言。为了在接下来去实现 Lox语言两次，Lox本身需要非常紧凑。</p>
<p>当我们提到小而有用的语言时候，通常会想到的是一些脚本语言，例如：JavaScript, Scheme, Lua 等。在这三种脚本语言中，Lox更像是 JavaScript，因为它们都是类C 语法。正如后面将要介绍的，Lox的代码块范围表示，和Scheme 语言相似。在第三部分，我们将实现的C语言为解释器的Lox语言，将更加接近Lua语言的简洁、高效特征。</p>
<p>Lox shares two other aspects with those three languages:</p>
<p>Lox 和脚本语言还有下面3个相同点：</p>
<h3 id="21-dynamic-typing"><a class="header" href="#21-dynamic-typing">2.1 Dynamic typing</a></h3>
<p>动态类型</p>
<p>Lox is dynamically typed. Variables can store values of any type, and a single variable can even store values of different types at different times. If you try to perform an operation on values of the wrong type—say, dividing a number by a string—then the error is detected and reported at runtime.</p>
<p>There are plenty of reasons to like static types, but they don’t outweigh the pragmatic reasons to pick dynamic types for Lox.  A static type system is a ton of work to learn and implement.Skipping it gives you a simpler language and a shorter book. We’ll get our interpreter up and executing bits of code sooner if we defer our type checking to runtime.</p>
<p>Lox是动态类型语言，变量可以存储任何类型的值，单个变量可以在不同时间存储不同类型的数据，如何尝试对于错误类型的值执行操作，例如：数值除以字符串，运行时候会检测，并且报错。</p>
<p>喜欢静态类型有很多理由，但是为了Lox语言更加实用，我们选择了动态类型。静态类型系统需要学习和实现大量工作。跳过静态类型，会让Lox语言实现更加简单。如果在解释器在运行时候，执行类型检查，我们可以更快的执行代码。</p>
<blockquote>
<p>Now that JavaScript has taken over the world and is used to build ginormous applications, it’s hard to think of it as a “little scripting language”. But Brendan Eich hacked the first JS interpreter into Netscape Navigator in ten days to make buttons animate on web pages. JavaScript has grown up since then, but it was once a cute little language.</p>
<p>既然，JavaScript语言已经风靡语言世界，并且用于构建很多的大型项目，我们很难在将它当作一个小众语言。但是，在网景公司，Brendan Eich 仅仅使用了10天时间，就完成了第一个JS编译器，并且实现了网页中的按钮动态展示。JavaScript 从那时开始，不断成长，但是它曾经是一门可爱的小语言。</p>
<p>Because Eich slapped JS together with roughly the same raw materials and time as an episode of MacGyver, it has some weird semantic corners where the duct tape and paper clips show through. Things like variable hoisting, dynamically bound this, holes in arrays, and implicit conversions.</p>
<p>因为Eich使用了与《麦基弗》一集大致相同的原材料和时间制作了JS语言，所以，它存在着一些奇怪的语法，会出现一些胶带和回形针。例如：变量提升，动态绑定，数组中的漏洞和隐式转换。</p>
<p>I had the luxury of taking my time on Lox, so it should be a little cleaner. After all, the two languages we’ll be using to implement Lox are both statically typed.</p>
<p>相比之下，我有更多时间打磨Lox语言，所以，我们会发现，Lox语言会更加简洁。毕竟，我们实现Lox语言的底层语言Java/C都是静态语言。</p>
</blockquote>
<h3 id="22-automatic-memory-management"><a class="header" href="#22-automatic-memory-management">2.2 Automatic memory management</a></h3>
<p>自动内存管理</p>
<p>High-level languages exist to eliminate error-prone, low-level drudgery, and what could be more tedious than manually managing the allocation and freeing of storage? No one rises and greets the morning sun with, “I can’t wait to figure out the correct place to call free() for every byte of memory I allocate today!”</p>
<p>高级语言的出现是为了，消除更加容易出错、低级别、乏味的工作，还有什么比手动管理内存分配与释放，更加繁琐呢？没有人会站起来迎接太阳，我忍不住要为今天分配的每一个字节的内存，找到调用 free() 函数的正确位置。</p>
<p>There are two main techniques for managing memory: reference counting and tracing garbage collection (usually just called garbage collection or GC). Ref counters are much simpler to implement—I think that’s why Perl, PHP, and Python all started out using them. But, over time, the limitations of ref counting become too troublesome. All of those languages eventually ended up adding a full tracing GC, or at least enough of one to clean up object cycles.</p>
<p>Tracing garbage collection has a fearsome reputation. It is a little harrowing working at the level of raw memory. Debugging a GC can sometimes leave you seeing hex dumps in your dreams. But, remember, this book is about dispelling magic and slaying those monsters, so we are going to write our own garbage collector. I think you’ll find the algorithm is quite simple and a lot of fun to implement.</p>
<p>内存管理主要有两种技术：引用计数 和 追踪垃圾回收，通常也称为，垃圾回收，缩写为 GC</p>
<p>引用计数的实现要简单一些，我认为这也是Perl/PHP/Python 语言一开始使用这个技术，实现内存管理的原因。但是，随着时间的变更，引用计数的局限性越来越多。所以，上面的语言，最终都添加了完整的追踪GC 实现，或者有足够的 GC逻辑 周期性清理对象。</p>
<p>追踪垃圾回收具有可怕的名声。在原生内存级别工作，非常痛苦。调试 GC，会让你在梦里都还在想着16进制转储问题。但是，请记住，本书会带着我们一起驱散魔法，杀死怪兽，所以，我们也会编写自己的垃圾回收程序。我猜想，你一定会发现算法非常简单，并且整个程序非常有趣。</p>
<blockquote>
<p>In practice, ref counting and tracing are more ends of a continuum than opposing sides. Most ref counting systems end up doing some tracing to handle cycles, and the write barriers of a generational collector look a bit like retain calls if you squint.</p>
<p>在实践中，引用计数和追踪技术会混合使用，而不是相互对立。大多数的引用计数，都会进行一些周期性的追踪，如果你仔细查看，分代采集器的用法看起来像是保留调用。</p>
<p>For lots more on this, see <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/unified-theory-gc.pdf">“A Unified Theory of Garbage Collection”</a> (PDF).</p>
<p>更多的信息，可以查看 <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/unified-theory-gc.pdf">“垃圾收集的统一理论”</a></p>
</blockquote>
<h2 id="三data-types"><a class="header" href="#三data-types">三、Data Types</a></h2>
<p>数据类型</p>
<p>In Lox’s little universe, the atoms that make up all matter are the built-in data types. There are only a few:</p>
<ol>
<li>
<p><strong>Booleans</strong></p>
<p>You can’t code without logic and you can’t logic without Boolean values. “True” and “false”, the yin and yang of software. Unlike some ancient languages that repurpose an existing type to represent truth and falsehood, Lox has a dedicated Boolean type. </p>
<p>There are two Boolean values, obviously, and a literal for each one.</p>
<pre><code>
true;  // Not false.
false; // Not *not* false.

</code></pre>
<blockquote>
<p>Boolean variables are the only data type in Lox named after a person, George Boole, which is why “Boolean” is capitalized. He died in 1864, nearly a century before digital computers turned his algebra into electricity. I wonder what he’d think to see his name all over billions of lines of Java code.</p>
<p>布尔变量是Lox语言中，唯一使用人名命名的数据类型。Boolean是为了纪念 George Boole, 他于1864年去世，一个世纪后，计算机科学将他发明的布尔代数，转换为计算机表示。我想知道，当他在数十亿Java代码中，看到自己的名字，会有什么感想😄</p>
</blockquote>
</li>
<li>
<p><strong>Numbers</strong></p>
<p>Lox has only one kind of number: double-precision floating point. Since floating-point numbers can also represent a wide range of integers, that covers a lot of territory, while keeping things simple.</p>
<p>Full-featured languages have lots of syntax for numbers—hexadecimal, scientific notation, octal, all sorts of fun stuff. We’ll settle for basic integer and decimal literals.</p>
<pre><code>
1234;  // An integer.
12.34; // A decimal number.

</code></pre>
</li>
<li>
<p><strong>Strings</strong></p>
<p>We’ve already seen one string literal in the first example. Like most languages, they are enclosed in double quotes.</p>
<p>As we’ll see when we get to implementing them, there is quite a lot of complexity hiding in that innocuous sequence of characters.</p>
<pre><code>
&quot;I am a string&quot;;
&quot;&quot;;    // The empty string.
&quot;123&quot;; // This is a string, not a number.

</code></pre>
<blockquote>
<p>Even that word “character” is a trickster. Is it ASCII? Unicode? A code point or a “grapheme cluster”? How are characters encoded? Is each character a fixed size, or can they vary?</p>
<p>即使是单词，字节，也包含了一些隐藏信息，字节是ASCII编码的，还是Unicode编码；一个字节是一个代码点，还是一个图形集簇；字节是如何编码的，是定长编码，还是变长编码？</p>
</blockquote>
</li>
<li>
<p><strong>Nil</strong></p>
<p>There’s one last built-in value who’s never invited to the party but always seems to show up. It represents “no value”. It’s called “null” in many other languages. In Lox we spell it nil.  (When we get to implementing it, that will help distinguish when we’re talking about Lox’s nil versus Java or C’s null.)</p>
<p>There are good arguments for not having a null value in a language since null pointer errors are the scourge of our industry. If we were doing a statically typed language, it would be worth trying to ban it. In a dynamically typed one, though, eliminating it is often more annoying than having it.</p>
</li>
</ol>
<p>在Lox的小宇宙中，构成物质的原子是内置的几种数据类型，详见下面的介绍:</p>
<ol>
<li>
<p>布尔类型</p>
<p>没有逻辑运算，我们无法进行编程，而逻辑运算，需要布尔数据类型。真与假，编程世界中的阴与阳，与一些早先语言复用其他数据类型表示布尔类型不同的是，我们会在Lox语言中定义一个专用的布尔数据类型。</p>
<p>显然，布尔值有两个选择，每个值对应了一个文本</p>
<pre><code>true;  // Not false.
false; // Not *not* false.
</code></pre>
</li>
<li>
<p>数值类型</p>
<p>Lox语言，只有一种数值类型，双精度浮点数。因为浮点数，可以包含大范围的整数，这样做，不但可以包含很多其他数据类型，而且可以保持简洁。</p>
<p>功能齐全的语言，会有很多的数字语法，例如：十六进制表示、科学计数法、八进制表示，以及其他的有趣的东西。但是在Lox语言中，我们将只会满足基本的整数运算和十进制表示。</p>
<pre><code>
1234;  // An integer.
12.34; // A decimal number.

</code></pre>
</li>
<li>
<p>字符串</p>
<p>从上面的第一个示例中，我们可以看到字符串类型 &quot;hello, world!&quot;。 和大多数的语言一样，字符串类型的数据，需要使用双引号括起来。</p>
<p>当我们实现字符串类型时候，将会看到，在这个定义明确的字符序列中，隐藏着许多复杂场景，需要特殊处理。</p>
<pre><code>
&quot;I am a string&quot;;
&quot;&quot;;    // The empty string.
&quot;123&quot;; // This is a string, not a number.

</code></pre>
</li>
<li>
<p>Nil</p>
<p>最后，还有一个数据类型，它似乎从来没有被邀请参加编程聚会，但是你总是能看到它的身影。它，代表了不存在，没有数值。在许多语言中，使用 null 表示它，而在Lox语言中，我们将使用 nil 表示它。当我们实现它时，可以更好的与 Java/C语言中的null 区别开。</p>
<p>在语言中，不使用 nil 存在很多好处，空指针报错是编程行业常见的报错。如果，我们要实现一门静态类型语言，那么我们禁止 nil类型是值得的。但是，如果我们要实现一门动态类型语言，通常，保留 nil类型，拥有更多的好处，相比于禁止该类型。</p>
</li>
</ol>
<h2 id="四expressions"><a class="header" href="#四expressions">四、Expressions</a></h2>
<p>表达式</p>
<p>If built-in data types and their literals are atoms, then expressions must be the molecules. Most of these will be familiar.</p>
<p>如果内置的基础数据类型和它们的文字，是原子，那么表达式就是分子，下面将介绍各种表达式</p>
<h3 id="41-arithmetic"><a class="header" href="#41-arithmetic">4.1 Arithmetic</a></h3>
<p>算术表达式</p>
<p>Lox features the basic arithmetic operators you know and love from C and other languages:</p>
<p>Lox语言具有C语言或者其他语言中，存在的基础算术表达式</p>
<pre><code>
add + me;
subtract - me;
multiply * me;
divide / me;

</code></pre>
<p>The subexpressions on either side of the operator are operands. Because there are two of them, these are called binary operators.(It has nothing to do with the ones-and-zeroes use of “binary”.) </p>
<p>Because the operator is fixed in the middle of the operands, these are also called infix operators (as opposed to prefix operators where the operator comes before the operands, and postfix where it comes after).</p>
<p>One arithmetic operator is actually both an infix and a prefix one. The - operator can also be used to negate a number.</p>
<pre><code>-negateMe;
</code></pre>
<p>All of these operators work on numbers, and it’s an error to pass any other types to them. The exception is the + operator—you can also pass it two strings to concatenate them.</p>
<p>运算符号，两边的子表达式，称为操作数。因为运算符号，有两个操作数，所以称为二元运算符。⚠️这里的二元，和二进制中的0或者1，没有关系。</p>
<p>因为运算符，固定在操作数的中间，所以，我们称之为中缀运算符。（与前缀运算符不同，前缀运算符位于表达式最前面，后缀运算符位于表达式最后。）</p>
<p>一元运算符，实际上可以是中缀运算符，也可以是前缀运算符。例如：- 可以表示负数</p>
<pre><code>-negateMe;
</code></pre>
<p>上面的算术运算符的操作数，只能是数值类型，如果操作数是其他数据类型，表达式计算会报错。但是，有个例外，+运算符可以作用于字符串数据类型，两个字符串的 + 运算，表示连接这两个字符串。</p>
<h3 id="42-comparison-and-equality"><a class="header" href="#42-comparison-and-equality">4.2 Comparison and equality</a></h3>
<p>比较运算符，相等</p>
<p>Moving along, we have a few more operators that always return a Boolean result. We can compare numbers (and only numbers), using Ye Olde Comparison Operators.</p>
<pre><code>less &lt; than;
lessThan &lt;= orEqual;
greater &gt; than;
greaterThan &gt;= orEqual;
</code></pre>
<p>We can test two values of any kind for equality or inequality. Even different types. Values of different types are never equivalent.</p>
<pre><code>1 == 2;         // false.
&quot;cat&quot; != &quot;dog&quot;; // true.
314 == &quot;pi&quot;; // false.
123 == &quot;123&quot;; // false.
</code></pre>
<p>I’m generally against implicit conversions.</p>
<p>接下来，我们将介绍几个返回布尔值的运算符。</p>
<p>我们可以使用 比较运算符，比较并且仅仅比较数值</p>
<p>我们也可以比较两个任意类型的数据，是否相等, 甚至这两个数据，不是相同的类型。不同数据类型的两个数据，肯定是不想等的🤔。</p>
<p>通常，我们不建议使用隐式转换。</p>
<h3 id="43-logical-operators"><a class="header" href="#43-logical-operators">4.3 Logical operators</a></h3>
<ol>
<li>
<p>The not operator, a prefix !, returns false if its operand is true, and vice versa.</p>
<pre><code>
!true;  // false.
!false; // true.

</code></pre>
</li>
<li>
<p>The other two logical operators really are control flow constructs in the guise of expressions. An and expression determines if two values are both true. It returns the left operand if it’s false, or the right operand otherwise.</p>
<pre><code>
true and false; // false.
true and true;  // true.

</code></pre>
</li>
<li>
<p>And an or expression determines if either of two values (or both) are true. It returns the left operand if it is true and the right operand otherwise.</p>
</li>
</ol>
<p>The reason and and or are like control flow structures is that they short-circuit. Not only does and return the left operand if it is false, it doesn’t even evaluate the right one in that case. Conversely (contrapositively?), if the left operand of an or is true, the right is skipped.</p>
<p>逻辑运算</p>
<ol>
<li>
<p>逻辑非运算符，使用 ！表示，如果操作数是true，则添加逻辑非的表达式，值为false，反之亦然。</p>
<pre><code>
!true;  // false.
!false; // true.

</code></pre>
</li>
<li>
<p>另外两个逻辑运算符，与其说是表达式，更加准确的说法是，控制流。</p>
<p>and 逻辑运算符，将确定两个操作数，是否都是true，如果左操作数是false， 则表达式返回左操作数的值；如果左操作数为true，则表达式返回右操作数的值。</p>
<pre><code>
true and false; // false.
true and true;  // true.

</code></pre>
</li>
<li>
<p>or 逻辑运算符，将确定两个操作数，是否包含true，如果左操作数为true，则表达式结果，返回左操作数；如果左操作数为false，表达式将会返回右操作数的值。</p>
<pre><code>
false or false; // false.
true or false;  // true.

</code></pre>
</li>
</ol>
<p>and 和 or 逻辑运算符，本质上是控制流结构的原因是，它们是短路。当逻辑运算符是 and，左操作数值为 false，我们甚至不会去计算右操作数，直接返回左操作数的值。如果逻辑运算符是 or，左操作数值为 true，同样的，我们不会去计算右操作数，直接返回左操作数的值。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
