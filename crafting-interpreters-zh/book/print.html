<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>crafting-interpreters-zh</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">前言</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">欢迎</li><li class="chapter-item expanded "><a href="welcome/welcome.html"><strong aria-hidden="true">1.</strong> 欢迎</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="welcome/introduction.html"><strong aria-hidden="true">1.1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="welcome/a-map-of-the-territory.html"><strong aria-hidden="true">1.2.</strong> 总览图</a></li><li class="chapter-item expanded "><a href="welcome/the-lox-language.html"><strong aria-hidden="true">1.3.</strong> Lox语言</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">解析树</li><li class="chapter-item expanded "><a href="tree/tree.html"><strong aria-hidden="true">2.</strong> 解析树</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tree/scanning.html"><strong aria-hidden="true">2.1.</strong> 扫描</a></li><li class="chapter-item expanded "><a href="tree/representing-code.html"><strong aria-hidden="true">2.2.</strong> 代码表示</a></li><li class="chapter-item expanded "><a href="tree/parsing-expression.html"><strong aria-hidden="true">2.3.</strong> 解析表达式</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">crafting-interpreters-zh</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基本介绍"><a class="header" href="#基本介绍">基本介绍</a></h1>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/header.png?raw=true" alt="header" /></p>
<h2 id="运行解释器"><a class="header" href="#运行解释器">运行解释器</a></h2>
<pre><code>// 1. 源码下载
git clone https://github.com/Kua-Fu/jlox.git

// 2. 编译
gradle build

// 3. 运行
java -cp app/build/classes/java/main com.craftinginterpreters.lox.App 

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="欢迎"><a class="header" href="#欢迎">欢迎</a></h1>
<p>This may be the beginning of a grand adventure. Programming languages encompass a h
uge space to explore and play in. Plenty of room for your own creations to share with others or just enjoy yourself. Brilliant computer scientists and software engineers have spent entire careers traversing this land without ever reaching the end. If this book is your first entry into the country, welcome.</p>
<p>The pages of this book give you a guided tour through some of the world of languages. But before we strap on our hiking boots and venture out, we should familiarize ourselves with the territory. The chapters in this part introduce you to the basic concepts used by programming languages and how those concepts are organized.</p>
<p>We will also get acquainted with Lox, the languages we'll spend the rest of the book implementing(twice).</p>
<hr />
<p>这将是一次伟大的冒险。程序编程拥有无限的探索和应用空间。你可以与他人分享编程乐趣或者只是自娱自乐。杰出的计算机科学家和软件工程师一直在编程领域探索，终其一生乐在其中。如果你是第一次接触这个领域，那么热烈欢迎你！</p>
<p>本书将和你一起参观语言世界。但是，在我们开始冒险之前，需要先了解要踏足的土地。接下来章节，将向您介绍编程语言中的常用概念和这些基本概念的组织方式。</p>
<p>我们还将介绍一门新的语言 Lox, 本书会带你实现2次 Lox 语言。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<blockquote>
<p>fairy tales are more than true: not because they tell us that dragons exist, but because they tell us that dragons can be beaten. </p>
<p align="right"> —— G.K. Chesterton by way of Neil Gaiman, Coraline </p>
<p>童话绝不仅是真实的: 不仅仅在于它告诉我们龙的存在，更在于它告诉我们勇士可以战胜恶龙。</p>
<p align="right"> —— G.K. Chesterton by way of Neil Gaiman, Coraline </p>
</blockquote>
<p>I'm really excited we're going on this journey together. This is a book on implementing interpreters for programming languages. It's also a book on how to design a language worth implementing. It's the book I wish I'd had when I first started getting into languages, and it's the book I've been writing in my head for nearly a decade.</p>
<p>非常高兴我们可以一起开启新的旅程，</p>
<p>这是一本介绍编程语言解释器的书， 这本书还会介绍如何自己实现一门语言。</p>
<p>这本书在我脑海中已经反复编辑了十年了，多么希望在我刚接触编程语言时候能遇到这种书籍。🐶</p>
<blockquote>
<p>to my friends and family, sorry I've been so absentminded!</p>
<p>对于我的朋友和家人，很抱歉我一直心不在焉。</p>
</blockquote>
<p>In these pages, we will walk step-by-step through two complete interpreters for a full-featured language. I assume this is your first foray into languages, so I'll cover each concept and line of code you need to build a complete, usable, fast language implementation.</p>
<p>In order to cram two full implementations inside one book without it turning into a doorstop, this text is lighter on theory than others. As we build each piece of the system, I will introduce the history and concepts behind it. I'll try to get your familiar with the lingo so that if you ever find yourself at a cocktail party full of PL(parogramming language) researchers, you'll fit in.</p>
<p>接下来，我们将通过实现两个完整的编译器，去实现一个功能齐全的语言。我会假设你第一次接触语言编程，所以我会详细介绍每一个概念和列出详细的代码，而这一切将会构建完整、可用、快速的语言。</p>
<p>为了在一本书中，实现两个编译器，相对于其他的编译语言书籍，我们会更少介绍编译原理，我们不想成为介绍编译理论的拦路虎。在构建编译系统的每一个部分，我将介绍其背后的历史和概念。我将尽可能使用行话，这样即使将来你出现在一个编程语言的鸡尾酒会，也可以快速融入其中。</p>
<blockquote>
<p>Strangely enough, a situation I have found myself in multiple times. You wouldn't believe how much some of them can drink.</p>
<p>奇怪的是，我发现自己多次陷入这种场景。你不应该假想他们都很能喝。</p>
</blockquote>
<p>But we're mostly going to spend our brain juice getting the language up and running. This is not to say theory isn't important. Being able to reason precisely and formally about syntax and semantics is a vital skill when working on a language. But, presonally, I learn best by doing. It's hard for me to wade through paragraphs full of abstract concepts and really absorb them. But if I've coded something, run it, and debugged it, then I get it.</p>
<p>我们将花费精力去开发运行语言，而这并不代表理论不重要。在学习语言时候，掌握语法和语义规则非常重要。但是，个人经验，我总是从实践中获取更多的东西，我通常很难看懂或者真的理解充满抽象概念的段落。但是，但我代码中编码、运行、调试过某个概念，我将能真正掌握它。</p>
<blockquote>
<p>Static type systems in particular require rigorous formal reasoning. Hacking on a type system has the same feel as proving a theorem in mathematics. </p>
<p>静态类型系统，尤其需要严格的形式推理。在类型系统上进行编程，非常像是证明一个数学定理。</p>
</blockquote>
<blockquote>
<p>It turns out this is no coincidence. In the early half of last century, Haskell Curry and William Alvin Howard showed that they are two sides of the same coin: <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">the Curry-Howard isomorphism</a></p>
<p>事实证明，这个感觉并非是巧合。在20世纪上半叶，Haskell Curry 和 William Alvin Howard严格证明了编程语言和数学证明之间的关系，称为<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">柯里-霍华德同构</a></p>
</blockquote>
<p>That's my goal for you. I want you to come away with a solid intuition of how a real language lives and breathes. My hope is that when you read other, more theoretical books later, the concepts there will firmly stick in your mind, adhered to this tangible substrate.</p>
<p>这个本书的一个目标，可以让你更加真切的认识一门语言，可以凭直觉感知一门语言如何编写运行。希望当以后学习更多的编译原理时候，通过现在培养的直觉，可以牢牢记住书中的概念。</p>
<h2 id="一why-learn-this-stuff"><a class="header" href="#一why-learn-this-stuff">一、Why learn this stuff?</a></h2>
<p>为什么要学习这些东西？</p>
<p>Every introduction to every compiler book seems to have this section. I don't know what it is about programming languages that causes such existential doubt. I don't think ornithology books worry about justifying their existence. They assume the reader loves birds and start teaching.</p>
<p>But programming languages are a little different. I suppose it is true that the odds of any of us creating a broadly successful, general-purpose programming language are slim. The designers of the world's widely used languages could fit in a Volkswagen bus, even without putting the pop-top camper up. If joining that elite group was the only reason to learn languages, it would be hard to justify. Fortunately, it isn't.</p>
<p>似乎每本编译器介绍书籍，似乎都包含这个讨论。我不知道，为什么编程语言会出现这样的疑惑。鸟类学研究书籍从来不认为人们会怀疑它是否该存在，他们总是假设读者喜欢鸟，然后开始教学。</p>
<p>但是编程语言总是有点不一样。我认为，我们大部分人，都无法创建一个广泛成功的通用编程语言。世界上最广泛使用的语言设计者可以适应驾驶大众汽车，即使车上没有安装流行的露营设备。如果学习编译器，仅仅是为了加入这个编程精英群体，那么大可不必。幸运的是，事实也并非如此。</p>
<h3 id="11-little-language-are-everywhere"><a class="header" href="#11-little-language-are-everywhere">1.1 Little language are everywhere</a></h3>
<p>For every successful general-purpose language, there are a thousand successful niche ones. We used to call them “little languages”, but inflation in the jargon economy led to the name “domain-specific languages”.These are pidgins tailor-built to a specific task. Think application scripting languages, template engines, markup formats, and configuration files.</p>
<p>Almost every large software project needs a handful of these. When you can, it’s good to reuse an existing one instead of rolling your own.</p>
<p>A random selection of some little languages you might run into.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/little-languages.png?raw=true" alt="A random selection of some little languages you might run into." /></p>
<p>But there’s still a good chance you’ll find yourself needing to whip up a parser or other tool when there isn’t an existing library that fits your needs. Even when you are reusing some existing implementation, you’ll inevitably end up needing to debug and maintain it and poke around in its guts.</p>
<p>对于每一种通用的流行语言，都对应着成千小众语言。我们可以称为这些语言为小众语言，但是在行业术语中，通常人们会使用领域特定语言(DSL)来描述。它们都是为了执行特定任务设计，想象一下，脚本语言、模版引擎、标记格式、配置文件。</p>
<p>几乎每个大型项目中，我们总会使用上图中的部分语言。通常我们会复用已经出现的语言，而不是自己造轮子。但是，当你考虑到文档、调试、编辑器支持、语法高亮和其他类似功能，就需要自己动手了。😄</p>
<p>当没有现有库匹配新需求时候，可能需要开发新的解析器或者一些小工具。即使对于某些正在使用的第三方库，也会需要不断进行调试和维护，并且需要对其深入研究。</p>
<h3 id="12-languages-are-great-exercise"><a class="header" href="#12-languages-are-great-exercise">1.2 Languages are great exercise</a></h3>
<p>语言是好的锻炼</p>
<p>Long distance runners sometimes train with weights strapped to their ankles or at high altitudes where the atmosphere is thin. When they later unburden themselves, the new relative ease of light limbs and oxygen-rich air enables them to run farther and faster.</p>
<p>Implementing a language is a real test of programming skill. The code is complex and performance critical. You must master recursion, dynamic arrays, trees, graphs, and hash tables. You probably use hash tables at least in your day-to-day programming, but do you really understand them?</p>
<p>While I intend to show you that an interpreter isn’t as daunting as you might believe, implementing one well is still a challenge.</p>
<p>长跑运动员会在训练时候，在脚踝上绑上重物，或者在高海拔、空气稀薄地区训练。当他们卸下负重时候，相对轻松的四肢和正常的氧气，使得他们，可以跑得更快更远。</p>
<p>实现一门语言是对编程技能的真正测试。代码会非常复杂，而且性能也很重要。你必须掌握递归算法、动态数组、树、图和哈希表。可能你每日的编程代码中都会使用哈希表，但是你真的理解它吗？好吧，让我们从头开始，我保证你一定可以学会的。</p>
<p>虽然我想向你们展示，编译器并不像我们认为的那么可怕，但是实现一个好的编译器仍然是一个有挑战的任务。当你做到了这一点，你会变得更加强大，并且在日常开发工作中，使用数据结构和算法会更加熟练。</p>
<h3 id="13-one-more-reason"><a class="header" href="#13-one-more-reason">1.3 One more reason</a></h3>
<p>另一个原因</p>
<p>This last reason is hard for me to admit, because it’s so close to my heart. Ever since I learned to program as a kid, I felt there was something magical about languages. When I first tapped out BASIC programs one key at a time I couldn’t conceive how BASIC itself was made.</p>
<p>Later, the mixture of awe and terror on my college friends’ faces when talking about their compilers class was enough to convince me language hackers were a different breed of human—some sort of wizards granted privileged access to arcane arts.</p>
<p>It’s a charming image, but it has a darker side. I didn’t feel like a wizard, so I was left thinking I lacked some inborn quality necessary to join the cabal. Though I’ve been fascinated by languages ever since I doodled made-up keywords in my school notebook, it took me decades to muster the courage to try to really learn them. </p>
<p>When I did finally start cobbling together my own little interpreters, I quickly learned that, of course, there is no magic at all.</p>
<p>There are a few techniques you don’t often encounter outside of languages, and some parts are a little difficult.  But not more difficult than other obstacles you’ve overcome. My hope is that if you’ve felt intimidated by languages and this book helps you overcome that fear, maybe I’ll leave you just a tiny bit braver than you were before.</p>
<p>And, who knows, maybe you will make the next great language. Someone has to.</p>
<p>最后一个原因我本人很难承认，因为它一直深藏我心底。当我小时候学会接触编程，我就觉得编程语言非常神奇。当我第一次一个按键一个按键敲出 BASIC 程序时候，我无法想象 BASIC 内部是如何运行的。</p>
<p>后来，当我的朋友们谈论起编译器课程时候，他们脸上充满了敬畏和恐惧，这加深了我的想法：编译器黑客是另外一种人类，一些巫师才能拥有的天赋。</p>
<p>这是一个迷人的形象，但是它也有黑暗的一面，我不觉得自己是一个巫师，所以我不认为自己拥有巫师的天赋。虽然从我在学校笔记本上，乱写关键词时候，就对于编程语言十分着迷，但是，我花了几十年时间才真正开始学习编译器。编译器的那种神奇之处、不简单的感觉，让我一直徘徊在门外。</p>
<p>当我开始编写自己的编译器时候，很快就明白了，这个领域根本没有魔法。仅仅只是代码，识别代码的也都是普通人。</p>
<p>有一些语言之外的技巧，我们不会经常遇到，但是这一部分有些难度。但是，也不会比你所克服的其他障碍更加棘手。我的希望是，如果你和我一样，对编译器感到恐惧，那么这本书将帮助你克服这个恐惧，也许这之后，你将变得更加勇敢。</p>
<p>最后，你还可能成为下一个伟大语言的创始人，必须有人去做。谁知道呢？</p>
<h2 id="二how-the-book-is-organized"><a class="header" href="#二how-the-book-is-organized">二、How the book is organized</a></h2>
<p>本书的组织方式</p>
<p>This book is broken into three parts. You're reading the first one now. It's a couple of chapters to get you oriented, teach you some of the lingo that language hackers use, and introduce you to Lox, the language we'll be implementing.</p>
<p>Each of the other two parts builds one complete Lox interpreter. Within those parts, each chapter is structured the same way. The chapter takes a single language feature, tachers you the concepts bebind it, and walks you through an implementation.</p>
<p>It took a good bit of trial and error on my part, but I managed to carve up the two interpreters into chapter-sized chunks that build on the previous chapters but require nothing from later ones. From the very first chapter, you'll have a working program you can run and play with. With each passing chapter, it grows increasing full-featured until you eventually have a complete language.</p>
<p>Aside from copious, scintillating English prose, chapters have a few other delightful facets.</p>
<p>这本书将分为三个部分，现在正在阅读的是第一部分。这几章会让你有一些方向感，教你使用黑客常用的术语。然后，会介绍Lox语言，我们将要实现的语言。</p>
<p>其他两个部分，会分别实现一个完整的编译器。在这两个部分，每一章的结构都是相同的，本章节采用单一语言功能，向您介绍背后的概念，并且引导你去实现解析器。</p>
<p>对我来说，需要一些尝试和试错，但我还是把两个编译器分为章节大小的部分，这些章节基于前面几章的基础知识，不需要理解后面几章的内容。从第一章开始，你就拥有了一个可以运行和使用的工作程序。随着更多章节的学习，这个工作程序会越来越全面，直到最终，你会拥有一个完整的编程语言。</p>
<p>除了丰富、华丽的正文外，每个章节还有一些令人愉快的部分。</p>
<h3 id="21-the-code"><a class="header" href="#21-the-code">2.1 The code</a></h3>
<p>We're about crafting interpreters, so this book contains real code. Every single line of code needed is included, and each snippet tells you where to insert it in your ever-growing implementation.</p>
<p>Many other language books and language implementations use tools like <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> and <a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>, so-called <strong>compiler-compilers</strong>, that automatically generate some of the source files for an implementation from some higher-level description. There are pros and cons to tool like those, and strong opinions——some might say religious convictions —— on both sides.</p>
<p>We will abstain from using them here. I want to ensure there are no dark corners where magic and confusion can hide, so we’ll write everything by hand. As you’ll see, it’s not as bad as it sounds, and it means you really will understand each line of code and how both interpreters work.</p>
<p>A book has different constraints from the “real world” and so the coding style here might not always reflect the best way to write maintainable production software. If I seem a little cavalier about, say, omitting private or declaring a global variable, understand I do so to keep the code easier on your eyes. The pages here aren’t as wide as your IDE and every character counts.</p>
<p>Also, the code doesn’t have many comments. That’s because each handful of lines is surrounded by several paragraphs of honest-to-God prose explaining it. When you write a book to accompany your program, you are welcome to omit comments too. Otherwise, you should probably use // a little more than I do.</p>
<p>While the book contains every line of code and teaches what each means, it does not describe the machinery needed to compile and run the interpreter. I assume you can slap together a makefile or a project in your IDE of choice in order to get the code to run. </p>
<p>我们是介绍编译器的，所以本书会包含真是可用的代码。每行代码，每个代码段，都会告诉你它们的作用和在实现的不断完善的编译器中的位置。</p>
<p>许多其他语言书籍和语言实现书籍中，通常会使用 Lex，Yacc等称为编译编译器的编译语言，这些语言，可以从更高级的描述中自动生成源文件。 直接使用这些语言工具，有好处也有弊端，而对于这两个观点，都有很多宗教信仰般的拥趸。</p>
<p>本书中将避免使用编译器语言，我想要确保没有黑暗的角落，隐藏着一些魔法和未知，所以我们将手写所有内容。正如你看到的，这并不像听起来那么糟糕，这意味着你将真正理解每一行代码，并且真的理解这两个编译器是如何工作的。</p>
<p>一本书不同于真实世界的约束，因此本书的编码风格可能并不是编写可维护性生产级别软件的最佳实践。如果我省略了 private 或者 忽略了全局变量声明，请理解我这么做是为了让代码更加容易理解，而不是来源于傲慢。这里的页面没有 IDE 那么宽，但是它们都非常重要。</p>
<p>此外，代码没有太多的注释，这是因为每段代码上下文，都是对其的大段正文说明。当你自己编写一本代码实现的书籍时候，也欢迎你省略其中的注释。当然，你也可以使用更多的 //</p>
<p>虽然这本书包含了编译器的每一行代码，介绍了每一行代码的含义，但是我并没有描述编译和运行代码的具体机器信息。我预想你可以使用自己熟悉的 IDE 创建一个文件或是一个项目。这些具体机器说明很快就会过时，我希望这本书可以像 XO白兰地一样历久弥新，而不是像 backyard hooch（一直保质期不长的蜂蜜酒）一样很快过时。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/yak.png?raw=true" alt="yak" /></p>
<blockquote>
<p>Yacc is a tool that takes in a grammar file and produces a source file for a compiler, so it’s sort of like a “compiler” that outputs a compiler, which is where we get the term “compiler-compiler”.</p>
<p>Yacc wasn’t the first of its ilk, which is why it’s named “Yacc”—Yet Another Compiler-Compiler. A later similar tool is Bison, named as a pun on the pronunciation of Yacc like “yak”.</p>
<p>If you find all of these little self-references and puns charming and fun, you’ll fit right in here. If not, well, maybe the language nerd sense of humor is an acquired taste.</p>
<p>Yacc 是一个工具，可以接收语法文件，然后为编译器生成源文件。所以，它好像是一个可以输出&quot;编译器&quot;的编译器，一般使用术语&quot;编译器编译程序&quot;形容 Yacc</p>
<p>Yacc并不是第一个&quot;编译器编译程序&quot;, 这就是这个程序缩写的来源：另一个编译器编译程序。还有一个相似的工具，称为 Bison（野牛), 命名来源于 Yacc的双关语 yak （牦牛)。</p>
<p>如果你发现，这些小小的自我暗示和双关语，很有魅力和乐趣，你将很快适应这里。如果你对此并不感冒，可能书呆子的幽默感是后天养成的。</p>
</blockquote>
<h3 id="22-snippets"><a class="header" href="#22-snippets">2.2 Snippets</a></h3>
<p>代码段</p>
<p>Since the book contains literally every line of code needed for the implementations, the snippets are quite precise. Also, because I try to keep the program in a runnable state even when major features are missing, sometimes we add temporary code that gets replaced in later snippets.</p>
<p>A snippet with all the bells and whistles looks like this:</p>
<p>In the center, you have the new code to add. It may have a few faded out lines above or below to show where it goes in the existing surrounding code. There is also a little blurb telling you in which file and where to place the snippet. If that blurb says “replace _ lines”, there is some existing code between the faded lines that you need to remove and replace with the new snippet.</p>
<pre><code class="language-java">
	// lox/Scanner.java in scanToken() replace 1 line
	
	default:
        if (isDigit(c)) {
          number();
        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }
        break;
		
</code></pre>
<p>因为本书中包含有所有编译器的实现代码，所以书中涉及的代码段非常准确。此外，因为我试图让程序即使在缺少主要功能的情况下，也可以保持可运行状态。所以，有时候我会添加临时代码，在之后章节会替换这些临时代码。</p>
<p>代码段示例如下:</p>
<p>中间代码是实际要添加的代码，上面和下面的代码表示要添加代码的位置。还有一个小提示，告诉你这段代码添加到哪个文件的哪个函数中。如何小提示上面写了 &quot;替换该行&quot;, 表示新增的代码需要替换之前的代码。</p>
<h3 id="23-asides"><a class="header" href="#23-asides">2.3 Asides</a></h3>
<p>Asides contain biographical sketches, historical background, references to related topics, and suggestions of other areas to explore. There’s nothing that you need to know in them to understand later parts of the book, so you can skip them if you want. I won’t judge you, but I might be a little sad.</p>
<p>Well, some asides do, at least. Most of them are just dumb jokes and amateurish drawings.</p>
<p>旁白包含了传记历史、历史背景、相关主题的参考文献以及推荐的延伸阅读。如果是为了阅读后面章节的内容，你不需要阅读旁白，也就是说你可以直接跳过旁白。我不会批评你，但是我会感到难过 😫。</p>
<p>嗯，还有些旁白不尽如人意，这些旁白大部分都是愚蠢的笑话和业余水平的绘画。</p>
<h3 id="24-challenges"><a class="header" href="#24-challenges">2.4 Challenges</a></h3>
<p>Each chapter ends with a few exercises. Unlike textbook problem sets, which tend to review material you already covered, these are to help you learn more than what’s in the chapter. They force you to step off the guided path and explore on your own. They will make you research other languages, figure out how to implement features, or otherwise get you out of your comfort zone.</p>
<p>Vanquish the challenges and you’ll come away with a broader understanding and possibly a few bumps and scrapes. Or skip them if you want to stay inside the comfy confines of the tour bus. It’s your book.</p>
<p>A word of warning: the challenges often ask you to make changes to the interpreter you’re building. You’ll want to implement those in a copy of your code. The later chapters assume your interpreter is in a pristine (“unchallenged”?) state.</p>
<p>每个章节都以一些练习题结束。但是不同于教科书的习题集，它们通常让你复习已经学过的知识，本书的习题更加倾向于让你学到更多的东西。这些习题会让你离开章节的已有路径，独自探索更多的未知领域。它们会让你去研究其他语言，去寻找如何实现功能，或者让你走出舒适区。</p>
<p>接受习题集的挑战，并且战胜它们，你将会有更加广阔的视野，虽然你可能会遇到一些坎坷和挫折。如果你想要呆在舒服的游览车内，你也可以跳过这些挑战习题，毕竟这是你的书。</p>
<p>一句警告⚠️，这些挑战通常会要求你修改已构建的编译器，建议你在副本项目中实现这些挑战，我们后面的章节基于没有修改的编译器。</p>
<h3 id="25-design-notes"><a class="header" href="#25-design-notes">2.5 Design notes</a></h3>
<p>设计思路</p>
<p>Most “programming language” books are strictly programming language implementation books. They rarely discuss how one might happen to design the language being implemented. Implementation is fun because it is so precisely defined. We programmers seem to have an affinity for things that are black and white, ones and zeroes.</p>
<p>Personally, I think the world needs only so many implementations of FORTRAN 77. At some point, you find yourself designing a new language. Once you start playing that game, then the softer, human side of the equation becomes paramount.  Things like which features are easy to learn, how to balance innovation and familiarity, what syntax is more readable and to whom.</p>
<p>All of that stuff profoundly affects the success of your new language. I want your language to succeed, so in some chapters I end with a “design note”, a little essay on some corner of the human aspect of programming languages. I’m no expert on this—I don’t know if anyone really is—so take these with a large pinch of salt. That should make them tastier food for thought, which is my main aim.</p>
<p>I know a lot of language hackers whose careers are based on this. You slide a language spec under their door, wait a few months, and code and benchmark results come out. Hopefully your new language doesn’t hardcode assumptions about the width of a punched card into its grammar.</p>
<p>大多数的编程语言书籍，都是严格意义上的编写代码实现，他们很少讨论如何设计一门语言、设计一段实现。实现非常有趣，因为它是确定的，而且被精确定义。我们程序员似乎对于确定性的东西，例如：黑与白，1与0，天生有好感。</p>
<p>就我个人而言，我认为世界上只需要 Fortran77 （1976年，美国标准化协会重新对Fortran（x3.9-1966）进行了评估，公布了新的Fortran标准，也就是Fortran 77。Fortran 77是具有结构化特性的编程语言。Fortran77在短时间内获取了巨大的成功，广泛地应用于科学和工程计算，几乎统治了数值计算领域。）中实现的功能。但是在某些时候，你发现自己在设计一门新语言。一旦你开始设计语言这个游戏，那么人性化的一面变得非常重要。需要考虑更加具体的内容，例如：哪些功能更易于学习，如何平衡创新和保留，哪些语法更易于阅读，学习语言的人群是谁？</p>
<p>所有这些都深刻的影响着一门新语言的成功与否。我希望你的新语言可以成功，所以我会在某些章节的结尾，发表一些设计方面的思考，这是一些编程语言中人们设计的最佳实践。我不是设计方面的专家，不知道是否有人真的这么想—在一些编程语言的正文中，添加一些设计方面的内容。这应该会让设计内容称为更加美味的思想食粮，这也是我的主要目标。</p>
<p>我认识很多编程老手，他们的职业就在于此——你将一门语言的规范告知他们，等待几个月，你将会得到这门新语言的代码和基准测试结果。希望你的新语言，不会将穿孔纸的宽度信息，硬编码到语言语法中。</p>
<h2 id="三the-first-interpreter"><a class="header" href="#三the-first-interpreter">三、The First Interpreter</a></h2>
<p>第一个编译器</p>
<p>We’ll write our first interpreter, jlox, in Java. The focus is on concepts. We’ll write the simplest, cleanest code we can to correctly implement the semantics of the language. This will get us comfortable with the basic techniques and also hone our understanding of exactly how the language is supposed to behave.</p>
<p>The book uses Java and C, but readers have ported the code to many other languages. If the languages I picked aren’t your bag, take a look at those.</p>
<p>Java is a great language for this. It’s high level enough that we don’t get overwhelmed by fiddly implementation details, but it’s still pretty explicit. Unlike in scripting languages, there tends to be less complex machinery hiding under the hood, and you’ve got static types to see what data structures you’re working with.</p>
<p>我们将使用JAVA语言实现第一个编译器，jlox，第一个编译器的重点是基本概念，我们将编写最简洁、最基础的代码，实现编译器的语义。这将让我们熟悉基本的技术，让我们能更加准确理解语言行为。</p>
<p>本书将使用 JAVA, C语言，但是读者可能更加熟悉其他的编程语言，如果我使用的语言不是你的菜，可以尝试使用你最熟悉的语言。</p>
<p>JAVA是一门很好的语言，我们不需要关注底层的大量实现细节，因为JAVA是一门高级语言，拥有更多的确定性。和脚本语言不同的是，JAVA与不同机器的关联性并没有那么复杂，通常，你可以使用静态类型去获取查看当前正在使用的结构体。</p>
<p>I also chose Java specifically because it is an object-oriented language.  That paradigm swept the programming world in the ’90s and is now the dominant way of thinking for millions of programmers. Odds are good you’re already used to organizing code into classes and methods, so we’ll keep you in that comfort zone.</p>
<p>While academic language folks sometimes look down on object-oriented languages, the reality is that they are widely used even for language work. GCC and LLVM are written in C++, as are most JavaScript virtual machines. Object-oriented languages are ubiquitous, and the tools and compilers for a language are often written in the same language.</p>
<p>And, finally, Java is hugely popular. That means there’s a good chance you already know it, so there’s less for you to learn to get going in the book. If you aren’t that familiar with Java, don’t freak out. I try to stick to a fairly minimal subset of it.  I use the diamond operator from Java 7 to make things a little more terse,  but that’s about it as far as “advanced” features go. If you know another object-oriented language, like C# or C++, you can muddle through.</p>
<p>By the end of part II, we’ll have a simple, readable implementation. It’s not very fast, but it’s correct. However, we are only able to accomplish that by building on the Java virtual machine’s own runtime facilities. We want to learn how Java itself implements those things.</p>
<p>我们选择Java，还因为它是一门面向对象的语言。这种编程范式在90年代席卷了整个世界，现在也是数百万程序员的主流思维方式。很可能你已经习惯了将代码组织成类和方法，接下来我们也会让你处于舒适区中。</p>
<p>虽然，学术研究语言的人们，有时候看不起面向对象的编程语言，但是实际情况是，即使在他们日常编程工作中，也会广泛使用面向对象语言。GCC/LLVM 还有大多数的 JavaScript 虚拟机都是使用面向对象的C++语言实现的。面向对象语言无处不在，一门语言的编译器和工具，通常会使用相同的语言实现。</p>
<p>最后，Java非常流行。这意味着，这是一个很好机会去使用熟悉这门语言。如果你不熟悉Java，也不用担心，本书中只会使用一小部分功能，我将使用Java7 标准里面的运算符，相对于使用更多的高级用法，这会让编程变得更加简洁。如果你还熟悉其他的面向对象语言，例如: C#, C++, 你也可以尝试使用它们去实现编译器。</p>
<p>在第二部分结束时候，我们将有一个简单易读的编译器实现，它的运行性能不是很高，但是可以保证准确性。但是，我们实现的编译器，是基于Java 语言和 Java 虚拟机底层。我们想要了解 Java本身是如何实现这些功能的。</p>
<p>A compiler reads files in one language, translates them, and outputs files in another language.
You can implement a compiler in any language, including the same language it compiles, a process called self-hosting.</p>
<p>You can’t compile your compiler using itself yet, but if you have another compiler for your language written in some other language, you use that one to compile your compiler once. Now you can use the compiled version of your own compiler to compile future versions of itself, and you can discard the original one compiled from the other compiler. This is called bootstrapping, from the image of pulling yourself up by your own bootstraps.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/bootstrap.png?raw=true" alt="bootstraps" /></p>
<p>编译器读取一种语言的原始文件，翻译它们，然后输出另外一门语言的文件。你可以用任何语言实现编译器，甚至你可以使用相同的语言去实现该语言的编译器，这通常被称为自编译。</p>
<p>一开始，你无法使用相同的语言写成一个编译器，但是如果你已经使用过其他语言实现了新语言的编译器，那么你就可以使用已经实现的编译器，去编译一次，然后你可以获取到使用新语言实现的编译器。接下来，你可以愉快的使用新的编译器，去升级新的编译器版本，也可以扔掉之前的其他语言写成的编译器了。专业术语一般称为自举，图中形象的描述了一个人的自举。</p>
<h2 id="四the-second-interpreter"><a class="header" href="#四the-second-interpreter">四、The Second Interpreter</a></h2>
<p>第二个编译器</p>
<p>So in the next part, we start all over again, but this time in C. C is the perfect language for understanding how an implementation really works, all the way down to the bytes in memory and the code flowing through the CPU.</p>
<p>A big reason that we’re using C is so I can show you things C is particularly good at, but that does mean you’ll need to be pretty comfortable with it. You don’t have to be the reincarnation of Dennis Ritchie, but you shouldn’t be spooked by pointers either.</p>
<p>If you aren’t there yet, pick up an introductory book on C and chew through it, then come back here when you’re done. In return, you’ll come away from this book an even stronger C programmer. That’s useful given how many language implementations are written in C: Lua, CPython, and Ruby’s MRI, to name a few.</p>
<p>In our C interpreter, clox, we are forced to implement for ourselves all the things Java gave us for free. We’ll write our own dynamic array and hash table. We’ll decide how objects are represented in memory, and build a garbage collector to reclaim them.</p>
<blockquote>
<p>I pronounce the name like “sea-locks”, but you can say it “clocks” or even “cloch”, where you pronounce the “x” like the Greeks do if it makes you happy.</p>
<p>我把这个名字读成&quot;sea-locks&quot;, 但是你也可以读成，&quot;clocks&quot; 或者 &quot;cloch&quot;, 如果你开心的话，还可以像希腊人一样读 &quot;x&quot;</p>
</blockquote>
<p>Our Java implementation was focused on being correct. Now that we have that down, we’ll turn to also being fast. Our C interpreter will contain a compiler that translates Lox to an efficient bytecode representation (don’t worry, I’ll get into what that means soon), which it then executes. This is the same technique used by implementations of Lua, Python, Ruby, PHP, and many other successful languages.</p>
<blockquote>
<p>Did you think this was just an interpreter book? It’s a compiler book as well. Two for the price of one!</p>
<p>你认为这只是一本解释器介绍书籍吗，其实它还是一个编译器介绍书籍。这两者没有本质区别。</p>
</blockquote>
<p>We’ll even try our hand at benchmarking and optimization. By the end, we’ll have a robust, accurate, fast interpreter for our language, able to keep up with other professional caliber implementations out there. Not bad for one book and a few thousand lines of code.</p>
<p>在下个部分中，我们将从头开始，但是这一次将使用C语言。C语言可以让我们更好的理解计算机是如何工作的，深入到底层，例如：内存中的字节和 cpu 执行的代码。</p>
<p>我们使用C语言实现编译器，的一个重要原因是，我可以使用C语言一些特别擅长的功能，但是这也意味着你必须非常熟悉C语言。你不需要像创始人 Dennis Ritchie 一样熟悉 C语言，但是你至少不能被指针吓倒。</p>
<p>如果你还不太了解C语言，那么先拿起一本C语言入门书籍仔细阅读后，再回到这里。作为回报，你将变成一个更强大的C语言程序员。你可以先看看有哪些语言是基于C语言实现的：Lua，CPython，Ruby的MRI实现，等等。</p>
<p>在C语言实现的解释器 clox 中，我们将要实现一些 Java中原生存在的结构，例如：我们将实现动态数组和哈希表，我们将设计决定如何在内存中表示对象，并且构建垃圾采集器回收它们。</p>
<p>第一部分，我们用Java语言实现的编译器 jlox主要专注于准确性，现在我们已经实现了准确性，接下来将专注于性能。我们的clox解释器，将实现一个编译器，将lox 编译为有效的字节码（别担心，很快我将解释它是什么），然后执行字节码。这与其他语言的实现使用相同技术，例如：Lua，Python，Ruby，PHP等等。</p>
<p>我们甚至会尝试基准测试和优化。到最后，我们将实现一个强大、准确、快速的语言解释器，能够和其他专业级别的语言媲美，而这对于一本书和几千行代码而言，并不简单。</p>
<h2 id="五-challenges"><a class="header" href="#五-challenges">五、 Challenges</a></h2>
<p>习题</p>
<ol>
<li>
<p>There are at least siz domain-specific languages used in the <a href="https://github.com/munificent/craftinginterpreters">little system I cobbled together</a> to write and publish this book. What are they?</p>
<p>在我编写本书中，至少使用了6种小众语言，请列举中它们？</p>
</li>
<li>
<p>Get a &quot;Hello, world!&quot; program written and running in Java. Set up whatever makefiles or IDE projects you need to get it working. If you have a debugger, get comfortable with it and step through your program as it runs.</p>
<p>使用 Java语言实现一个 &quot;hello, world&quot; 程序，描述一下你使用的IDE 和配置文件，并且在IDE中习惯调试。</p>
</li>
<li>
<p>Do the same thing for C. To get some practice with pointers, define a <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly linked list</a> of heap-allocated strings. Write functions to insert, find, and delete items from it. Test them.</p>
<p>使用C语言实现一个 &quot;hello, world&quot; 程序，为了练习指针，定义一个堆分配字符串的双链表，编写函数插入、查找、删除链表元素。</p>
</li>
</ol>
<h2 id="六design-note-whats-in-a-name"><a class="header" href="#六design-note-whats-in-a-name">六、Design Note: What's in a name?</a></h2>
<p>设计说明：如何命名？</p>
<p>One of the hardest challenges in writing book was coming up with a name for the language it implements. I went through pages of candidates before I found one that worked. As you'll discover on the first day you start building your own language, naming is deviously hard. A good name satisfies a few criteria:</p>
<ol>
<li>
<p>It isn't in use.</p>
<p>You can run into all sorts of trouble, legal and social, if you inadvertently step on someone else’s name.</p>
</li>
<li>
<p>It's easy to pronounce. If things go well, hordes of people will be saying and writing your language’s name. Anything longer than a couple of syllables or a handful of letters will annoy them to no end.</p>
</li>
<li>
<p>It's distinct enough to search for. People will Google your language’s name to learn about it, so you want a word that’s rare enough that most results point to your docs. Though, with the amount of AI search engines are packing today, that’s less of an issue. Still, you won’t be doing your users any favors if you name your language “for”.</p>
</li>
<li>
<p>It doesn't have negative connotations across a number of cultures. This is hard to be on guard for, but it’s worth considering. The designer of Nimrod ended up renaming his language to “Nim” because too many people remember that Bugs Bunny used “Nimrod” as an insult. (Bugs was using it ironically.)</p>
</li>
</ol>
<p>If your potential name makes it through that gauntlet, keep it. Don’t get hung up on trying to find an appellation that captures the quintessence of your language.</p>
<p>本书编写过程中一个挑战是，如何为实现的语言命名。我需要从众多的候选中，找到最合适的。正如你在构建自己语言时候会遇到的一样，命名非常困难，一个好的命名符合下面的标准：</p>
<ol>
<li>
<p>该名字之前没有被使用。如果你不小心使用了他人的命名，可能会有非常多的麻烦，包含法律和社会问题。</p>
</li>
<li>
<p>该名字需要朗朗上口，如果一切顺利的话，会有非常多人书写、说出你的语言名称，而任何拗口的名字，都会给人们带来困惑。</p>
</li>
<li>
<p>该名字需要足够特别，更容易搜索到。人们第一时间会使用搜索引擎了解你的语言，如果你使用一个足够特别的单词命名，那么大家将很容易获取到。尽管，随着搜索引擎拥有更多的AI能力，更容易显示你的语言。但是，如果你把自己的新语言命名为&quot;for&quot;, 那么这通常不能带给使用者任何帮助。</p>
</li>
<li>
<p>该名字在其他文化中没有负面含义。这一点很难防范，但是需要认真考虑。Nimrod 的设计者最终将这个语言命名为 &quot;Nim&quot;, Bugs Bunny曾经故意使用有争议的名称 Nimrod 命名新的语言，人们依然记得。</p>
</li>
</ol>
<p>如果你的候选命名，通过了上面的标准，那么留着它吧。不要试图去找到一个能抓住你的语言精髓的名称。如果说世界上其他已经成功的语言教会了我们什么的话，那就是语言名字和语言精髓没有关联。你所需要的只是一个，独特的名称。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="总览图"><a class="header" href="#总览图">总览图</a></h1>
<h2 id="a-map-of-the-territory"><a class="header" href="#a-map-of-the-territory">A Map of the Territory</a></h2>
<blockquote>
<p>you must have a map, no matter how rough. Otherwise you wander all over the place. In The Lord of the Rings I never made anyone go farther than he could on a given day.</p>
<p align="right">—— J.R.R. Tolkien</p>
</blockquote>
<p>领土图</p>
<blockquote>
<p>不管有多么粗糙，你都必须拥有一幅领土地图，否则你将到处游荡。在《指环王》中，我从来都没有让任何人一天内走的更远。</p>
<p align="right">—— J.R.R. Tolkien</p>
</blockquote>
<p>We don’t want to wander all over the place, so before we set off, let’s scan the territory charted by previous language implementers. It will help us understand where we are going and the alternate routes others have taken.</p>
<p>First, let me establish a shorthand.  Much of this book is about a language’s implementation, which is distinct from the language itself in some sort of Platonic ideal form. Things like “stack”, “bytecode”, and “recursive descent”, are nuts and bolts one particular implementation might use. From the user’s perspective, as long as the resulting contraption faithfully follows the language’s specification, it’s all implementation detail.</p>
<p>We’re going to spend a lot of time on those details, so if I have to write “language implementation” every single time I mention them, I’ll wear my fingers off. Instead, I’ll use “language” to refer to either a language or an implementation of it, or both, unless the distinction matters.</p>
<p>我们不想到处瞎逛，所以在出发之前，我们先浏览一下以前的语言实现者绘制的领土图。这将帮助我们理解我们的目标，了解更多的替代路径。</p>
<p>首先，让我们建立一个概览。本书的大部分内容都是如何实现一门语言，这和一门语言本身柏拉图式的理想概念有所不同。 像是栈、字节码、递归下降等东西，是一个特定实现可能会用到的具体细节。 从用户的角度，只要生成的内容还遵循着语言的规范，它就是所有的实现细节。</p>
<p>我们将在这些细节上花费大量时间，因此，如果每次提到这些细节，我都要加上语言实现说明，那么我会累晕的。所以，我将使用语言来表示一门语言或者这门语言的实现，或者两者，除非两者的区别非常重要。</p>
<h2 id="一the-parts-of-a-language"><a class="header" href="#一the-parts-of-a-language">一、The Parts of a Language</a></h2>
<p>语言的组成部分</p>
<p>Engineers have been building programming languages since the Dark Ages of computing. As soon as we could talk to computers, we discovered doing so was too hard, and we enlisted their help. I find it fascinating that even though today’s machines are literally a million times faster and have orders of magnitude more storage, the way we build programming languages is virtually unchanged.</p>
<p>Though the area explored by language designers is vast, the trails they’ve carved through it are few. Not every language takes the exact same path—some take a shortcut or two—but otherwise they are reassuringly similar, from Rear Admiral Grace Hopper’s first COBOL compiler all the way to some hot, new, transpile-to-JavaScript language whose “documentation” consists entirely of a single, poorly edited README in a Git repository somewhere.</p>
<p>自计算的黑暗时代以来，工程师们一直在构建编程语言。当我们可以与电脑交流时候，我们发现这样做太难了，需要电脑的帮助。我发现一个有趣的现象，即使今天的机器运行速度快了数百万倍，存储量也增加了几个数量级，但是我们构建编程语言的方式几乎没有任何改变。</p>
<p>虽然，语言设计者探索的领域非常大，但是他们在其中开辟的道路却非常少。并不是所有的语言都走相同的路径，有些语言的实现，会走一、两条捷径。但是从另一个角度来看，它们都是相似的。从第一个 COBOL编译器到现在最新的可以转换为 JavaScript的语言，在它们 git仓库README文件中的描述都是相似的。</p>
<blockquote>
<p>There are certainly dead ends, sad little cul-de-sacs of CS papers with zero citations and now-forgotten optimizations that only made sense when memory was measured in individual bytes.</p>
<p>毫无疑问，计算机科学论文存在一些死胡同。这些论文现在已经没有人引用，都是在内存需要以一个一个字节来衡量时期的优化使用论文。</p>
</blockquote>
<p>I visualize the network of paths an implementation may choose as climbing a mountain. You start off at the bottom with the program as raw source text, literally just a string of characters. Each phase analyzes the program and transforms it to some higher-level representation where the semantics—what the author wants the computer to do—become more apparent.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/mountain.png?raw=true" alt="a map of the territory" /></p>
<p>Eventually we reach the peak. We have a bird’s-eye view of the user’s program and can see what their code means. We begin our descent down the other side of the mountain. We transform this highest-level representation down to successively lower-level forms to get closer and closer to something we know how to make the CPU actually execute.</p>
<p>我把编译领域图，想象为一幅包含很多路径的爬山图。从底部开始，一开始只是一个文本，实际上只是一个字符串。经过，每个分析阶段，都会生成更加高级的表示，设计者希望计算机执行的语言都更加明确。</p>
<p>最后，我们爬上了山顶。我们鸟瞰全局，可以得到使用者编写的代码含义。我们从山的另一边开始下山，我们将连续将高级别的表示转换为更低级别的表示，以越来越接近计算机 CPU执行的语言。</p>
<p>Let’s trace through each of those trails and points of interest. Our journey begins on the left with the bare text of the user’s source code:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/string.png?raw=true" alt="string" /></p>
<p>接下来，我们将追踪每一条路径、每一个停留点，我们的旅途从左边山脚开始（用户源代码）。</p>
<h3 id="11-scanning"><a class="header" href="#11-scanning">1.1 Scanning</a></h3>
<p>扫描</p>
<p>The first step is scanning, also known as lexing, or (if you’re trying to impress someone) lexical analysis. They all mean pretty much the same thing. I like “lexing” because it sounds like something an evil supervillain would do, but I’ll use “scanning” because it seems to be marginally more commonplace.</p>
<p>A scanner (or lexer) takes in the linear stream of characters and chunks them together into a series of something more akin to “words”. In programming languages, each of these words is called a token. Some tokens are single characters, like ( and ,. Others may be several characters long, like numbers (123), string literals (&quot;hi!&quot;), and identifiers (min).</p>
<p>Some characters in a source file don’t actually mean anything. Whitespace is often insignificant, and comments, by definition, are ignored by the language. The scanner usually discards these, leaving a clean sequence of meaningful tokens.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/tokens.png?raw=true" alt="tokens" /></p>
<p>第一步是扫描，也称为词法，如果你想给别人留下深刻印象，还可以称为词法分析。他们的含义都差不多，我更喜欢词法，因为这听起来像是一个恶作剧，但是接下来我会使用扫描表示这个过程，因为这种说法更加常见。</p>
<p>一个扫描器，接收线性的字符串，将它们分块为一个个单词，在编程语言中，分成的单词称为 token, 一些 token 是单字符，例如: <code>(</code> <code>,</code> 还有一些token长度是多个字符，例如: 数字 <code>123</code> ，字符串 <code>&quot;hi!&quot;</code> , 标识符 <code>min</code></p>
<p>源文件中的某些字符没有实际意义。空白字符，通常没有实际意义，还有注释，根据语言定义，注释会被语言忽略。扫描器通常会忽略这些内容，最终生成一个干净的有意义的token 序列。</p>
<h3 id="12-parsing"><a class="header" href="#12-parsing">1.2 Parsing</a></h3>
<p>解析</p>
<p>The next step is parsing. This is where our syntax gets a grammar—the ability to compose larger expressions and statements out of smaller parts. Did you ever diagram sentences in English class? If so, you’ve done what a parser does, except that English has thousands and thousands of “keywords” and an overflowing cornucopia of ambiguity. Programming languages are much simpler.</p>
<p>A parser takes the flat sequence of tokens and builds a tree structure that mirrors the nested nature of the grammar. These trees have a couple of different names—parse tree or abstract syntax tree—depending on how close to the bare syntactic structure of the source language they are.  In practice, language hackers usually call them syntax trees, ASTs, or often just trees.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/ast.png?raw=true" alt="ast" /></p>
<p>下一步是解析，这就是我们获得语法的地方，语法可以将较小的部分组合成较大的表达式和语句。你在英语课堂上画过句子图吗？如果是这样的话，你已经完成了解析器的工作。除了英语有成千上万个关键词和更多的歧义。相较而言，编程语言就简单太多了。</p>
<p>解析器接收token 序列，然后构建出反应语法嵌套性质的树结构。这些树有一些不同的名称，例如：名称解析树，抽象语法树，命名取决于这些树和源语言的简单语法结构的接近程度。在实践中，语言高手经常称它们为语法树，AST或者通常就称为树。</p>
<p>Parsing has a long, rich history in computer science that is closely tied to the artificial intelligence community. Many of the techniques used today to parse programming languages were originally conceived to parse human languages by AI researchers who were trying to get computers to talk to us.</p>
<p>It turns out human languages were too messy for the rigid grammars those parsers could handle, but they were a perfect fit for the simpler artificial grammars of programming languages. Alas, we flawed humans still manage to use those simple grammars incorrectly, so the parser’s job also includes letting us know when we do by reporting syntax errors.</p>
<p>解析在计算机科学中拥有悠久丰富的历史，与人工智能领域密切相关。今天用于解析编程语言的许多技术最初是由人工智能研究人员构思的，他们最初设想是让计算机与人对话交流。</p>
<p>事实证明，对于解析器所能解析的语法而言，人类的语言太复杂了，但是这些解析器却非常适合编程语言中的人类定义的语法规则。哎，我们这些普通的人，在使用这些简单语法时候，仍然会犯错误，所以，解析器还会报告语法错误，让我们知道。</p>
<h3 id="13-static-analysis"><a class="header" href="#13-static-analysis">1.3 Static analysis</a></h3>
<p>静态分析</p>
<p>The first two stages are pretty similar across all implementations. Now, the individual characteristics of each language start coming into play. At this point, we know the syntactic structure of the code—things like which expressions are nested in which—but we don’t know much more than that.</p>
<p>In an expression like a + b, we know we are adding a and b, but we don’t know what those names refer to. Are they local variables? Global? Where are they defined?</p>
<p>前面两个阶段（扫描、解析）在所有的实现中都是相似的，现在，每种语言的特性开始显现出来了。解析过后，我们知道了代码的语法结构，例如：我们知道了包含了哪些表达式，但是我们了解的还不够多。</p>
<p>在像表达式 a + b中，我们知道表达式是 a与b求和，但是我们并不知道a，b具体表示什么，它们是局部变量吗，是全局变量吗，它们是在哪里定义的呢？</p>
<p>The first bit of analysis that most languages do is called binding or resolution. For each identifier, we find out where that name is defined and wire the two together. This is where scope comes into play—the region of source code where a certain name can be used to refer to a certain declaration.</p>
<p>If the language is statically typed, this is when we type check. Once we know where a and b are declared, we can also figure out their types. Then if those types don’t support being added to each other, we report a type error.</p>
<p>大多数语言的第一点分析叫做，绑定或解析。对于每个标识符，我们需要找到该标识符名称的定义位置，并且将两者连接在一起，这就是作用域发挥作用的地方——源代码的某个区域中，可以使用一个具体名称来引用某个声明。</p>
<p>如果语言是静态语言，这时候，我们还要进行类型判断，一旦我们找到了 a，b的声明位置，我们也可以获取到它们的数据类型。然后，如果这些数据类型不支持加法规则，我们将报告一个类型错误。</p>
<blockquote>
<p>The language we’ll build in this book is dynamically typed, so it will do its type checking later, at runtime.</p>
</blockquote>
<blockquote>
<p>本书中构建的语言是动态语言，所以，类型检查将发生在运行时，而不是当前阶段。</p>
</blockquote>
<p>Take a deep breath. We have attained the summit of the mountain and a sweeping view of the user’s program. All this semantic insight that is visible to us from analysis needs to be stored somewhere. There are a few places we can squirrel it away:</p>
<ul>
<li>
<p>Often, it gets stored right back as attributes on the syntax tree itself—extra fields in the nodes that aren’t initialized during parsing but get filled in later.</p>
</li>
<li>
<p>Other times, we may store data in a lookup table off to the side. Typically, the keys to this table are identifiers—names of variables and declarations. In that case, we call it a symbol table and the values it associates with each key tell us what that identifier refers to.</p>
</li>
<li>
<p>The most powerful bookkeeping tool is to transform the tree into an entirely new data structure that more directly expresses the semantics of the code. That’s the next section.</p>
</li>
</ul>
<p>深呼吸，我们已经登上了山顶，用户程序一览无余。从分析阶段后，获取到的语义附加信息，需要保存在某个地方。有几个地方可以保存这些信息。</p>
<ul>
<li>
<p>通常，它作为属性存储在语法树的其他字段中，这些字段在解析阶段没有初始化，但是在分析阶段会被填充</p>
</li>
<li>
<p>其他时候，我们可以将数据保存在旁边的查找表中。通常情况下，该查找表的key是标识符（变量名称和声明）。这这种情况下，我们称其为符号表，表中key对应的value，表示该标识符对应的实际值是什么</p>
</li>
<li>
<p>更加强大的记录方式是，将语法树转换为一个全新的数据结构，更加直接的表示代码的含义。这是下一节的内容。</p>
</li>
</ul>
<p>Everything up to this point is considered the front end of the implementation. You might guess everything after this is the back end, but no. Back in the days of yore when “front end” and “back end” were coined, compilers were much simpler. Later researchers invented new phases to stuff between the two halves. Rather than discard the old terms, William Wulf and company lumped those new phases into the charming but spatially paradoxical name middle end.</p>
<p>到现在为止，所有内容阶段，都是实现的前端部分。你可能会想象，那么之后的内容是后端了，其实并不是，哈哈😄。当编译器，刚开始有前端、后端概念的时候，那时候的编译器非常简单。后来，研究人员又发明了其他阶段，它们在前端、后端之间。<a href="https://en.wikipedia.org/wiki/William_Wulf">William Wulf</a> 和他们公司并没有抛弃旧的术语，他们把这些新发明的阶段归为有意思的但是有些矛盾的术语，中间端。</p>
<h3 id="14-intermediate-representations"><a class="header" href="#14-intermediate-representations">1.4 Intermediate representations</a></h3>
<p>中间表示法</p>
<p>You can think of the compiler as a pipeline where each stage’s job is to organize the data representing the user’s code in a way that makes the next stage simpler to implement. The front end of the pipeline is specific to the source language the program is written in. The back end is concerned with the final architecture where the program will run.</p>
<p>In the middle, the code may be stored in some intermediate representation (IR) that isn’t tightly tied to either the source or destination forms (hence “intermediate”). Instead, the IR acts as an interface between these two languages.</p>
<p>我们可以将编译器视为一个管道，每个阶段的工作是用一种更易于实现的方式，组织表示用户代码。管道前端，作用于编写程序的源语言，后端与程序运行的最终架构相关。</p>
<p>在中间端，代码可能存储在一些中间表示中，这些表示，与源语言和目标形式都没有紧密关联。相反，这种中间表示，充当源语言和目标语言之间的接口。</p>
<blockquote>
<p>There are a few well-established styles of IRs out there. Hit your search engine of choice and look for “control flow graph”, “static single-assignment”, “continuation-passing style”, and “three-address code”.</p>
</blockquote>
<blockquote>
<p>有一些成熟的中间表示风格，有兴趣的话，可以去研究一下，控制流图、静态单赋值、连续传递样式、三地址代码等等。</p>
</blockquote>
<p>This lets you support multiple source languages and target platforms with less effort. Say you want to implement Pascal, C, and Fortran compilers, and you want to target x86, ARM, and, I dunno, SPARC. Normally, that means you’re signing up to write nine full compilers: Pascal→x86, C→ARM, and every other combination.</p>
<p>A shared intermediate representation reduces that dramatically. You write one front end for each source language that produces the IR. Then one back end for each target architecture. Now you can mix and match those to get every combination.</p>
<p>There’s another big reason we might want to transform the code into a form that makes the semantics more apparent . . . </p>
<p>这种方式，可以让我们更容易支持多种源语言和目标语言的匹配。假设你想要实现，Pascal、C、Fortran语言的编译器，并且这些编译器，可以运行在X86， arm，SPARC等架构上，如果没有使用中间表示，你需要实现9种编译器，例如: Pascal——&gt; x86，C——&gt; arm等等。</p>
<p>使用一种共享的中间表示，可以大大减少这些组合。对于每一种源语言，编写一个前端，将源语言解析为中间表示，对于每个目标架构，针对中间表示，编写一个后端。所以，现在只需要实现 6 中前端、后端组合。</p>
<p>还有一个重要原因，让我们使用中间表示。我们可以利用中间表示，将代码转为一种形式，使得语义更加明显。</p>
<blockquote>
<p>If you’ve ever wondered how GCC supports so many crazy languages and architectures, like Modula-3 on Motorola 68k, now you know. Language front ends target one of a handful of IRs, mainly GIMPLE and RTL. Target back ends like the one for 68k then take those IRs and produce native code.</p>
<p>如果你想要知道 <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>是如何支持这么多语言和架构的，现在你知道原因了。针对前端的少量中间表示，主要是 <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a> 和 <a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">RTL</a>, 不同的目标架构，获取中间表示，生成对应的机器代码。</p>
</blockquote>
<h3 id="15-optimization"><a class="header" href="#15-optimization">1.5 Optimization</a></h3>
<p>优化</p>
<p>Once we understand what the user’s program means, we are free to swap it out with a different program that has the same semantics but implements them more efficiently—we can optimize it.</p>
<p>A simple example is constant folding: if some expression always evaluates to the exact same value, we can do the evaluation at compile time and replace the code for the expression with its result. If the user typed in this:</p>
<pre><code>
pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);

</code></pre>
<p>we could do all of that arithmetic in the compiler and change the code to:</p>
<pre><code>pennyArea = 0.4417860938;
</code></pre>
<p>一旦我们理解了用户程序的含义，我们就可以自由的把用户程序替换为具有相同语义，但是更加高效的实现的另外一种程序。我们可以进行优化。</p>
<p>一个简单示例是常数计算。如果某个表达式的计算结果总是相同，那么我们可以在编译时候计算该表达式，并且使用表达式计算结果代替该表达式，例如，客户输入</p>
<pre><code>pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);
</code></pre>
<p>我们可以在编译时候计算出值，将代码修改为</p>
<pre><code>pennyArea = 0.4417860938;
</code></pre>
<p>Optimization is a huge part of the programming language business.  Many language hackers spend their entire careers here, squeezing every drop of performance they can out of their compilers to get their benchmarks a fraction of a percent faster. It can become a sort of obsession.</p>
<p>We’re mostly going to hop over that rathole in this book. Many successful languages have surprisingly few compile-time optimizations. For example, Lua and CPython generate relatively unoptimized code, and focus most of their performance effort on the runtime.</p>
<p>优化是编程语言的一个重要组成部分，许多语言高手在整个职业生涯都在不断优化，从编译器中榨取每一点性能，最终使得他们的编译器，基准测试结果提高了0.5%，优化是一个不断进行的过程。</p>
<p>本书中，我们会跳过优化这个步骤，有很多成功语言，也很少使用编译时优化。举例，Lua 和 CPython生成相对未优化的代码，将大部分优化放在运行时。</p>
<blockquote>
<p>If you can’t resist poking your foot into that hole, some keywords to get you started are “constant propagation”, “common subexpression elimination”, “loop invariant code motion”, “global value numbering”, “strength reduction”, “scalar replacement of aggregates”, “dead code elimination”, and “loop unrolling”.</p>
<p>如果你忍不住想要探索优化这个领域，那么你可以从一些术语入手，例如: &quot;恒定传播&quot;, &quot;公共子表达式消除&quot;, &quot;循环不变代码&quot;, &quot;全局值编号&quot;, &quot;强度降低&quot;, &quot;聚合标量代替&quot;, &quot;僵尸代码消除&quot;, &quot;循环展开&quot;。</p>
</blockquote>
<h3 id="16-code-generation"><a class="header" href="#16-code-generation">1.6 Code generation</a></h3>
<p>代码生成</p>
<p>We have applied all of the optimizations we can think of to the user’s program. The last step is converting it to a form the machine can actually run. In other words, generating code (or code gen), where “code” here usually refers to the kind of primitive assembly-like instructions a CPU runs and not the kind of “source code” a human might want to read.</p>
<p>Finally, we are in the back end, descending the other side of the mountain. From here on out, our representation of the code becomes more and more primitive, like evolution run in reverse, as we get closer to something our simple-minded machine can understand.</p>
<p>We have a decision to make. Do we generate instructions for a real CPU or a virtual one? If we generate real machine code, we get an executable that the OS can load directly onto the chip. Native code is lightning fast, but generating it is a lot of work. Native code is lightning fast, but generating it is a lot of work. </p>
<p>我们已经将能够想到的所有优化，应用于用户代码中。最后一步是，将代码转换为机器可以实际运行的形式。换句话说，代码生成（或者生成代码），这里的代码是指，CPU直接运行的类似于原始汇编的指令，而不用人们可以直接阅读的源代码。</p>
<p>最后，我们处于后端，从山的另一端往下走。从现在开始，我们对于代码的表示越来越原始，和上山方向相反，我们希望代码变为机器可以直接运行的形式。</p>
<p>我们需要决定，是生成真实的CPU指令，还是生成虚拟的指令。如果我们生成真实的机器代码，我们会得到一个可执行文件，操作系统可以直接加载到芯片中。原生本机代码运行速度非常快，但是，生成真实的 CPU指令需要大量的工作。现在的架构，有成堆的指令集，复杂的管道，和能够塞满747飞机的历史遗留包袱。</p>
<blockquote>
<p>For example, the AAD (“ASCII Adjust AX Before Division”) instruction lets you perform division, which sounds useful. Except that instruction takes, as operands, two binary-coded decimal digits packed into a single 16-bit register. When was the last time you needed BCD on a 16-bit machine</p>
<p>举例，AAD指令可以执行除法运算，这听起来非常有用。除此之外，ADD指令会将两个二进制编码额十进制数字作为操作数压缩到单个16位寄存器上，上一次，你需要BCD，并且在16位机器，是什么时候呢？</p>
</blockquote>
<p>Speaking the chip’s language also means your compiler is tied to a specific architecture. If your compiler targets x86 machine code, it’s not going to run on an ARM device.  All the way back in the ’60s, during the Cambrian explosion of computer architectures, that lack of portability was a real obstacle.</p>
<p>To get around that, hackers like Martin Richards and Niklaus Wirth, of BCPL and Pascal fame, respectively, made their compilers produce virtual machine code. Instead of instructions for some real chip, they produced code for a hypothetical, idealized machine. Wirth called this p-code for portable, but today, we generally call it bytecode because each instruction is often a single byte long.</p>
<p>These synthetic instructions are designed to map a little more closely to the language’s semantics, and not be so tied to the peculiarities of any one computer architecture and its accumulated historical cruft. You can think of it like a dense, binary encoding of the language’s low-level operations.</p>
<p>转换为芯片特定语言，意味着你的编译器和特定架构相关联。如果编译器以x86 机器代码为目标，那么它将无法在arm架构机器上运行。一直追溯到上世纪60年代，在当时的计算机体系结构爆炸时期，缺乏可移植性的编译器是一个真正的缺点。</p>
<p>为了避免这种问题，编程高手，例如：BCPL 语言的发明者<a href="https://en.wikipedia.org/wiki/Martin_Richards_(computer_scientist)">Martin Richards</a> 和 Pascal语言的主要开发者<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a> ,不约而同的，让他们实现的编译器最终生成虚拟机代码。他们为一个假想的、理想化的机器生成代码，而不是为了一些真实的芯片生成指令。<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>称这些代码为P代码，因为可移植单词的缩写，但是今天，我们通常称为字节码，因为每条指令通常只有一个字节长度。</p>
<p>这些合成指令，是为了更加接近代码的语义，而不是因为更加关联那些架构或是其后的历史。我们可以想象字节码是更加底层的二进制编码。</p>
<blockquote>
<p>The basic principle here is that the farther down the pipeline you push the architecture-specific work, the more of the earlier phases you can share across architectures.</p>
<p>基本的原则是，越晚把编译器局限于特定架构上，就可以越多的享受不同架构间代码共用。</p>
</blockquote>
<blockquote>
<p>There is a tension, though. Many optimizations, like register allocation and instruction selection, work best when they know the strengths and capabilities of a specific chip. Figuring out which parts of your compiler can be shared and which should be target-specific is an art.</p>
<p>不过，存在一种均衡，许多优化，例如：寄存器分配和指令选择，当你了解特定芯片的优点和能力时候，使用效果会更好。搞清楚编译器哪些部分可以共享，哪些部分只适用于特定架构，是一门艺术。</p>
</blockquote>
<h3 id="17-virtual-machine"><a class="header" href="#17-virtual-machine">1.7 Virtual machine</a></h3>
<p>虚拟机</p>
<p>If your compiler produces bytecode, your work isn’t over once that’s done. Since there is no chip that speaks that bytecode, it’s your job to translate. Again, you have two options. You can write a little mini-compiler for each target architecture that converts the bytecode to native code for that machine. You still have to do work for each chip you support, but this last stage is pretty simple and you get to reuse the rest of the compiler pipeline across all of the machines you support. You’re basically using your bytecode as an intermediate representation.</p>
<p>Or you can write a virtual machine (VM), a program that emulates a hypothetical chip supporting your virtual architecture at runtime. Running bytecode in a VM is slower than translating it to native code ahead of time because every instruction must be simulated at runtime each time it executes. In return, you get simplicity and portability. Implement your VM in, say, C, and you can run your language on any platform that has a C compiler. This is how the second interpreter we build in this book works.</p>
<p>如果你的编译器，最终产生字节码，那么，你的工作还没有结束。如果你的工作是翻译的话，那么现在没有芯片可以直接执行字节码。同样，现在你有两个选择。</p>
<p>第一个选择是，你可以为每一种目标架构编写一个小型编译器，把字节码转换为架构中机器使用的机器码。我们可以为支持的每一种芯片编写对应的编译器，但是最后这个阶段非常简单，你也可以重复使用编译器之前的代码。我们使用编译器生成的字节码当作中间表示。</p>
<p>或者，我们可以编写一个虚拟机，一个在运行时候，模拟虚构芯片的程序。在虚拟机中运行字节码比直接在本机运行机器码，慢一些，因为虚拟机每次运行指令，都必须模拟实际指令。作为回报，我们获得了简单性和可移植性。假设用C语言实现虚拟机，那么我们可以在任何有C编译器的机器上运行代码。本书第二部分实现的编译器采用该原理。</p>
<blockquote>
<p>The term “virtual machine” also refers to a different kind of abstraction. A system virtual machine emulates an entire hardware platform and operating system in software. This is how you can play Windows games on your Linux machine, and how cloud providers give customers the user experience of controlling their own “server” without needing to physically allocate separate computers for each user.</p>
<p>The kind of VMs we’ll talk about in this book are language virtual machines or process virtual machines if you want to be unambiguous.</p>
<p>术语虚拟机是一种抽象。一个系统级别的虚拟机，会模拟整个硬件平台和操作系统。这就是，你可以在Linux服务器上玩Windows游戏的原因，还有，这也是云服务厂商，为用户分配指定的云服务器，而不需要真实提供对应的机器的原因。</p>
<p>但是，本书中涉及到的虚拟机，只是语言虚拟机或者进程虚拟机，如果你想要一个准确的描述词。</p>
</blockquote>
<h3 id="18-runtime"><a class="header" href="#18-runtime">1.8 Runtime</a></h3>
<p>运行时</p>
<p>We have finally hammered the user’s program into a form that we can execute. The last step is running it. If we compiled it to machine code, we simply tell the operating system to load the executable and off it goes. If we compiled it to bytecode, we need to start up the VM and load the program into that.</p>
<p>In both cases, for all but the basest of low-level languages, we usually need some services that our language provides while the program is running. For example, if the language automatically manages memory, we need a garbage collector going in order to reclaim unused bits. If our language supports “instance of” tests so you can see what kind of object you have, then we need some representation to keep track of the type of each object during execution.</p>
<p>All of this stuff is going at runtime, so it’s called, appropriately, the runtime. In a fully compiled language, the code implementing the runtime gets inserted directly into the resulting executable.  In, say, Go, each compiled application has its own copy of Go’s runtime directly embedded in it. If the language is run inside an interpreter or VM, then the runtime lives there. This is how most implementations of languages like Java, Python, and JavaScript work.</p>
<p>最终，我们终于把用户程序，转换为一种可以执行的形式。最后一步是运行，如果我们最后编译为机器码，我们只需要加载可执行文件，然后运行。如果将其编译为字节码，我们需要启动虚拟机，把编译的字节码加载到虚拟机中。</p>
<p>在两种场景下，除了最基本的低层语言，当程序运行时，我们还需要提供一些其他服务。例如：如果语言是自动管理内存的，那么我们需要一个垃圾收集器，回收不再使用的内存。如果我们实现的语言，支持实例测试，以便于获取对象的实际数据类型，那么我们需要一些功能，跟踪运行时候的对象。</p>
<p>所有这些都发生在程序运行时候，所以，我们称呼这个阶段为运行时。在一个完全编译的语言中，运行时，代码将直接插入到可执行文件中。举例，在go语言中，每个编译的应用程序都有自己的 go运行时副本，直接嵌入其中。如果语言在解释器或者虚拟机中运行，那么运行时就在其中。这也是 Java/Python/JavaScript等语言的运行工作方式。</p>
<h2 id="二shortcuts-and-alternate-routes"><a class="header" href="#二shortcuts-and-alternate-routes">二、Shortcuts and Alternate Routes</a></h2>
<p>快捷方式和备选路径</p>
<p>That’s the long path covering every possible phase you might implement. Many languages do walk the entire route, but there are a few shortcuts and alternate paths.</p>
<p>这一条漫长的路，可能包含你的实现的每一个阶段。许多语言贯穿了整个过程，但是也有一些语言，会包含捷径和其他备选路径。</p>
<h3 id="21-single-pass-compilers"><a class="header" href="#21-single-pass-compilers">2.1 Single-pass compilers</a></h3>
<p>单通道编译器</p>
<p>Some simple compilers interleave parsing, analysis, and code generation so that they produce output code directly in the parser, without ever allocating any syntax trees or other IRs. These single-pass compilers restrict the design of the language. You have no intermediate data structures to store global information about the program, and you don’t revisit any previously parsed part of the code. That means as soon as you see some expression, you need to know enough to correctly compile it.</p>
<p>Pascal and C were designed around this limitation. At the time, memory was so precious that a compiler might not even be able to hold an entire source file in memory, much less the whole program. This is why Pascal’s grammar requires type declarations to appear first in a block. It’s why in C you can’t call a function above the code that defines it unless you have an explicit forward declaration that tells the compiler what it needs to know to generate code for a call to the later function.</p>
<p>一些简单的编译器，会把解析阶段、分析阶段、代码生成阶段混杂在一起，它们直接在解析过程生成代码，而不需要生成语法树或者其他中间表示。这些单通道编译器限制了语言的设计。你没有中间数据结构来存储有关程序的全局信息，也无法重新访问任何之前解析过的代码。这意味着，一旦看到某个表达式，我们需要足够的信息来，正确的编译表达式。</p>
<p>Pascal 和 C语言是围绕上面的限制设计的。当时，内存非常宝贵，编译器甚至无法将整个源文件放入到内存中，更不用说在内存中，保存整个程序了。这就是为什么Pascal语言要求类型声明首先出现在代码块中，这也是为什么在C语言中，除非有一个明确的正向声明，告诉编译器生成调用后面的函数所需要的代码，否则无法在函数定义的位置上面，调用该函数。</p>
<blockquote>
<p>Syntax-directed translation is a structured technique for building these all-at-once compilers. You associate an action with each piece of the grammar, usually one that generates output code. Then, whenever the parser matches that chunk of syntax, it executes the action, building up the target code one rule at a time.</p>
<p>语法定向翻译是一种结构化技术，用于同时构建这些编译器，将每一个动作和每一个语法片段相关联，通常是输出代码的语法片段。然后，每当解析器匹配该语法块时候，它会执行操作，一次建立一个规则的目标代码。</p>
</blockquote>
<h3 id="22-tree-walk-interpreters"><a class="header" href="#22-tree-walk-interpreters">2.2 Tree-walk interpreters</a></h3>
<p>树遍历解释器</p>
<p>Some programming languages begin executing code right after parsing it to an AST (with maybe a bit of static analysis applied). To run the program, the interpreter traverses the syntax tree one branch and leaf at a time, evaluating each node as it goes.</p>
<p>This implementation style is common for student projects and little languages, but is not widely used for general-purpose languages since it tends to be slow. Some people use “interpreter” to mean only these kinds of implementations, but others define that word more generally, so I’ll use the inarguably explicit tree-walk interpreter to refer to these. Our first interpreter rolls this way.</p>
<p>许多的语言，在解析阶段生成了语法树后，就开始执行代码（可能会使用一些静态分析）。为了运行程序，解释器每一次都会遍历语法树的一个分支和叶节点，在每一个节点运行时候，进行评估。</p>
<p>这种实现风格，在学生作业和小的语言中非常常见，但是，由于运行速度比较慢，没有广泛的应用于通用的语言。一些人使用解释器，表示这种类型的实现，但是，另外一些人，使用更加一般的术语描述这种实现方式，本书中我使用树遍历解释器来描述这种实现。我们第一个实现Lox语言采用这种实现风格。</p>
<blockquote>
<p>A notable exception is early versions of Ruby, which were tree walkers. At 1.9, the canonical implementation of Ruby switched from the original MRI (Matz’s Ruby Interpreter) to Koichi Sasada’s YARV (Yet Another Ruby VM). YARV is a bytecode virtual machine.</p>
<p>一个著名的例子是，Ruby语言的早期版本，使用了树遍历风格的实现方式。在1.9版本，Ruby的实现从早期的MRI变更为YARV，YARV是一个字节码虚拟机。</p>
</blockquote>
<h3 id="23-transpilers"><a class="header" href="#23-transpilers">2.3 Transpilers</a></h3>
<p>转换机</p>
<p>Writing a complete back end for a language can be a lot of work. If you have some existing generic IR to target, you could bolt your front end onto that. Otherwise, it seems like you’re stuck. But what if you treated some other source language as if it were an intermediate representation?</p>
<p>Writing a complete back end for a language can be a lot of work. If you have some existing generic IR to target, you could bolt your front end onto that. Otherwise, it seems like you’re stuck. But what if you treated some other source language as if it were an intermediate representation?</p>
<p>You write a front end for your language. Then, in the back end, instead of doing all the work to lower the semantics to some primitive target language, you produce a string of valid source code for some other language that’s about as high level as yours. Then, you use the existing compilation tools for that language as your escape route off the mountain and down to something you can execute.</p>
<p>They used to call this a source-to-source compiler or a transcompiler. After the rise of languages that compile to JavaScript in order to run in the browser, they’ve affected the hipster sobriquet transpiler.</p>
<p>为一种语言编写一个完整的后端，需要很多的工作。如果你有一些现有的通用后端目标，那么你可以把前端设计为通用后端的匹配前端。否则的话，你似乎卡在这里了。但是，如果你把其他的语言视为一种中间表示，那么我们应该如何匹配？</p>
<p>你为自己的语言编写了前端，然后，在后端，你的想法不是，把用户程序的语义变更为底层原始的目标语言，而是把用户语义转换为一个更高级语言的源代码。然后，你可以使用这种高级语言的已经存在的编译器，作为下山的备选路径。</p>
<p>在以前，这种实现方式被称为源代码到源代码编译器或者 转换编译器，当出现了一些语言，为了能在浏览器运行，，最终编译为JavaScript后，大家想到了一个新的名称 转换机 来描述。</p>
<p>While the first transcompiler translated one assembly language to another, today, most transpilers work on higher-level languages. After the viral spread of UNIX to machines various and sundry, there began a long tradition of compilers that produced C as their output language. C compilers were available everywhere UNIX was and produced efficient code, so targeting C was a good way to get your language running on a lot of architectures.</p>
<p>Web browsers are the “machines” of today, and their “machine code” is JavaScript, so these days it seems almost every language out there has a compiler that targets JS since that’s the main way to get your code running in a browser.</p>
<p>The front end—scanner and parser—of a transpiler looks like other compilers. Then, if the source language is only a simple syntactic skin over the target language, it may skip analysis entirely and go straight to outputting the analogous syntax in the destination language.</p>
<p>If the two languages are more semantically different, you’ll see more of the typical phases of a full compiler including analysis and possibly even optimization. Then, when it comes to code generation, instead of outputting some binary language like machine code, you produce a string of grammatically correct source (well, destination) code in the target language.</p>
<p>Either way, you then run that resulting code through the output language’s existing compilation pipeline, and you’re good to go.</p>
<p>虽然第一个转换机，把一种汇编语言转换为另外一种汇编语言，但是现在，我们常常把一门语言转换为更加高级的语言。因为UNIX的风靡，编译器开始了一个传统，那就是把转换机输出语言变为 C语言。C语言编译器，存在于任意的UNIX系统中，支持更多的架构，并且C编译器可以生成更加高效的代码，因此，把C语言作为输出目标，是一个非常好的方向。</p>
<p>现在，web浏览器是一种新型机器，这种新机器的运行代码是JavaScript，所以现在很多语言都有一个针对JS的编译器，最终输出JS代码，这样可以让新的语言运行在浏览器中。<a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">详细清单</a></p>
<p>转换机的前端部分，扫描阶段、解析阶段，和其他的编译器相似，然而，如果新语言只是目标语言的一个简单皮肤，那么编译器可能会完全跳过分析阶段，直接输出目标语言。</p>
<p>但是，如果这两种语言，在语义上非常不相同，那么，你可能会添加一些传统编译器的其他阶段，例如：分析阶段，优化阶段。但是，最终代码生成阶段，我们不会生成传统的机器码或者字节码，而是生成一个语法正确的目标语言字符串。</p>
<p>无论如何，你都可以在编译后，获取到目标语言的源代码，然后通过目标语言的编译器，开始运行新语言。</p>
<blockquote>
<p>The first transcompiler, XLT86, translated 8080 assembly into 8086 assembly. That might seem straightforward, but keep in mind the 8080 was an 8-bit chip and the 8086 a 16-bit chip that could use each register as a pair of 8-bit ones. XLT86 did data flow analysis to track register usage in the source program and then efficiently map it to the register set of the 8086.</p>
<p>It was written by Gary Kildall, a tragic hero of computer science if there ever was one. One of the first people to recognize the promise of microcomputers, he created PL/M and CP/M, the first high-level language and OS for them.</p>
<p>He was a sea captain, business owner, licensed pilot, and motorcyclist. A TV host with the Kris Kristofferson-esque look sported by dashing bearded dudes in the ’80s. He took on Bill Gates and, like many, lost, before meeting his end in a biker bar under mysterious circumstances. He died too young, but sure as hell lived before he did.</p>
<p>第一个转换机，XLT86，把8080 汇编转换为8086汇编，这看起来似乎很简单，但是，请注意，8080是一个8位芯片，而8086是一个16位芯片，可以将8086的寄存器，作为8080的一对寄存器使用，XLT86进行了数据流分析，用于跟踪源程序中的寄存器使用，然后，有效的把这些寄存器，映射为8086的寄存器集。</p>
<p>XLT86 是由Gary KIldall实现的，他是计算机科学领域的一个悲剧人物，作为最早认识到微型计算机前景的人之一，他开发了PL/M 和 CP/M，而CP/M是第一种和操作系统交互的高级语言。</p>
</blockquote>
<blockquote>
<p>JS used to be the only way to execute code in a browser. Thanks to WebAssembly, compilers now have a second, lower-level language they can target that runs on the web.</p>
<p>JS曾经是浏览器中唯一的运行语言，但是现在我们多了一种选择 <a href="https://webassembly.org/">WebAssembly</a>, 编译器现在拥有了第二种可以直接在浏览器运行的语言。</p>
</blockquote>
<h3 id="24-just-in-time-compilation"><a class="header" href="#24-just-in-time-compilation">2.4 Just-in-time compilation</a></h3>
<p>即时编译</p>
<p>This last one is less a shortcut and more a dangerous alpine scramble best reserved for experts. The fastest way to execute code is by compiling it to machine code, but you might not know what architecture your end user’s machine supports. What to do?</p>
<p>You can do the same thing that the HotSpot Java Virtual Machine (JVM), Microsoft’s Common Language Runtime (CLR), and most JavaScript interpreters do. On the end user’s machine, when the program is loaded—either from source in the case of JS, or platform-independent bytecode for the JVM and CLR—you compile it to native code for the architecture their computer supports. Naturally enough, this is called just-in-time compilation. Most hackers just say “JIT”, pronounced like it rhymes with “fit”.</p>
<p>The most sophisticated JITs insert profiling hooks into the generated code to see which regions are most performance critical and what kind of data is flowing through them. Then, over time, they will automatically recompile those hot spots with more advanced optimizations.</p>
<p>最后一个不是捷径，而是危险的高山攀岩，最好留给专家。最快的代码执行速度，肯定是翻译为具体的机器码，但是，编译阶段，你可能不知道用户的机器是什么架构，那么我们应该怎么办呢？</p>
<p>你可以借鉴JVM（Java语言虚拟机），CLR（微软的通用语言运行库），还有大多数JS编译器做的，在用户的机器上，当程序加载时候，无论是从源代码，还是在JVM/CLR中加载字节码，你可以将其编译为本机的机器码。很自然的，这个过程称为即时编译。大多数编程高手称这种实现为JIT，发音类似fit。</p>
<p>最复杂的JIT，会在生成代码中插入一些性能分析代码，查看哪些代码块、哪些数据结构对于运行性能影响最大。然后，随着时间累积，JIT将自动使用更高级的优化方式，重新编译热点代码。</p>
<blockquote>
<p>This is, of course, exactly where the HotSpot JVM gets its name.</p>
<p>当然，这也是JVM的一种实现，HotSpot JVM的名称来源。</p>
</blockquote>
<h2 id="三compilers-and-interpreters"><a class="header" href="#三compilers-and-interpreters">三、Compilers and Interpreters</a></h2>
<p>编译器和解释器</p>
<p>Now that I’ve stuffed your head with a dictionary’s worth of programming language jargon, we can finally address a question that’s plagued coders since time immemorial: What’s the difference between a compiler and an interpreter?</p>
<p>It turns out this is like asking the difference between a fruit and a vegetable. That seems like a binary either-or choice, but actually “fruit” is a botanical term and “vegetable” is culinary. One does not strictly imply the negation of the other. There are fruits that aren’t vegetables (apples) and vegetables that aren’t fruits (carrots), but also edible plants that are both fruits and vegetables, like tomatoes.</p>
<p>现在，我们大脑中已经塞满了各种编译术语，接下来，我们将解决一个自古以来就困扰着程序员的问题，编译器和解释器有什么区别？</p>
<p>实际上，这个问题可以类比为，水果和蔬菜有什么区别？这个答案看起来是一个二选一问题，但是实际上，水果是一个植物学术语，蔬菜则是一个烹饪用语，一个东西是水果并不代表它不可以是蔬菜，现实生活中，我们可以找到某些水果，不是蔬菜，例如：苹果；也可以找到某些蔬菜，不属于水果，例如：胡萝卜；但是，我们也可以找到，某些东西，即是水果，也是蔬菜，例如：西红柿。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/plants.png?raw=true" alt="plants" /></p>
<p>So, back to languages:</p>
<ul>
<li>
<p>Compiling is an implementation technique that involves translating a source language to some other—usually lower-level—form. When you generate bytecode or machine code, you are compiling. When you transpile to another high-level language, you are compiling too.</p>
</li>
<li>
<p>When we say a language implementation “is a compiler”, we mean it translates source code to some other form but doesn’t execute it. The user has to take the resulting output and run it themselves.</p>
</li>
<li>
<p>Conversely, when we say an implementation “is an interpreter”, we mean it takes in source code and executes it immediately. It runs programs “from source”.</p>
</li>
</ul>
<p>那么，返回到语言部分，</p>
<ul>
<li>
<p>编译是一种实现技术，通常是将源语言转换为更加低级别的形式，当你把一门语言编译为字节码或者机器码时候，你使用了编译技术，当你转换为另外一种高级语言时候，你也在使用编译。</p>
</li>
<li>
<p>当我们说实现了一个编译器，我们的意思是，将源语言转换为其他形式，但是并不执行，用户需要获取到编译结果，然后再运行。</p>
</li>
<li>
<p>对应的，当我们说实现了一个解释器，我们的意思是，可以直接执行源代码，看起来，我们好像是直接从源语言运行。</p>
</li>
</ul>
<p>Like apples and oranges, some implementations are clearly compilers and not interpreters. GCC and Clang take your C code and compile it to machine code. An end user runs that executable directly and may never even know which tool was used to compile it. So those are compilers for C.</p>
<p>In older versions of Matz’s canonical implementation of Ruby, the user ran Ruby from source. The implementation parsed it and executed it directly by traversing the syntax tree. No other translation occurred, either internally or in any user-visible form. So this was definitely an interpreter for Ruby.</p>
<blockquote>
<p>Peanuts (which are not even nuts) and cereals like wheat are actually fruit, but I got this drawing wrong. What can I say, I’m a software engineer, not a botanist. I should probably erase the little peanut guy, but he’s so cute that I can’t bear to.</p>
<p>Now pine nuts, on the other hand, are plant-based foods that are neither fruits nor vegetables. At least as far as I can tell.</p>
</blockquote>
<p>像苹果和橘子一样，它们是水果但不是蔬菜，有一些实现，是编译器，而不是解释器。GCC和Clang 接收原始的C语言程序，最终编译为机器码。用户最终运行可执行文件，而不需要知道具体使用了哪个编译器，它们都是C语言编译器。</p>
<p>Ruby的老版本中，用户可以直接从Ruby源码运行。Ruby解释器直接解析源程序，生成语法树，然后，遍历语法树，直接执行，无论处于用户角度，还是实际内部机制，都没有其他的转换过程，我们可以确定这种实现为解释器。</p>
<p>But what of CPython? When you run your Python program using it, the code is parsed and converted to an internal bytecode format, which is then executed inside the VM. From the user’s perspective, this is clearly an interpreter—they run their program from source. But if you look under CPython’s scaly skin, you’ll see that there is definitely some compiling going on.</p>
<p>The answer is that it is both. CPython is an interpreter, and it has a compiler. In practice, most scripting languages work this way, as you can see:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/venn.png?raw=true" alt="venn" /></p>
<p>但是，CPython是什么呢？当我们运行Python程序时候，CPython编译器将Python代码转换为内部的字节码，在Python虚拟机中运行。从用户角度看，这是一个解释器，因为我们可以直接从原始代码运行，但是如果从内部实现角度，还存在着一些编译器。</p>
<p>准确答案是，CPython既是一个解释器，也是一个编译器，实际上，大部分的脚本语言都是这样的</p>
<p>That overlapping region in the center is where our second interpreter lives too, since it internally compiles to bytecode. So while this book is nominally about interpreters, we’ll cover some compilation too.</p>
<p>如上图，我们第二部分实现的Lox解释器，处于中间的重叠部分，因为我们会生成字节码。因此，虽然本书是关于解释器介绍的，但是，我们还是会涉及到编译器的内容。</p>
<blockquote>
<p>The Go tool is even more of a horticultural curiosity. If you run go build, it compiles your Go source code to machine code and stops. If you type go run, it does that, then immediately executes the generated executable.</p>
<p>So go is a compiler (you can use it as a tool to compile code without running it), is an interpreter (you can invoke it to immediately run a program from source), and also has a compiler (when you use it as an interpreter, it is still compiling internally).</p>
<p>go语言的命令更加能说明问题，例如：执行命令 go build，我们能得到一个可执行文件，如果执行命令，go run，程序会马上运行。</p>
<p>所以，go是一个编译器，可以将go程序编译为可执行文件，go也是一个解释器，可以直接运行go程序，但是解释器中还包含一个编译器，当直接运行go程序时候，内部仍有编译步骤。</p>
</blockquote>
<h2 id="四our-journey"><a class="header" href="#四our-journey">四、Our Journey</a></h2>
<p>我们的旅途</p>
<p>That’s a lot to take in all at once. Don’t worry. This isn’t the chapter where you’re expected to understand all of these pieces and parts. I just want you to know that they are out there and roughly how they fit together.</p>
<p>This map should serve you well as you explore the territory beyond the guided path we take in this book. I want to leave you yearning to strike out on your own and wander all over that mountain.</p>
<p>But, for now, it’s time for our own journey to begin. Tighten your bootlaces, cinch up your pack, and come along. From here on out, all you need to focus on is the path in front of you.</p>
<p>本章，我们介绍了很多内容，别担心，你不需要现在就理解所有内容，我们只是，先介绍它们，你需要知道它们是存在的，并且需要知道它们是如何结合在一起的。</p>
<p>本章涉及的地图将很好的陪伴着你，因为它包含有一些内容，本书中不会涉及到。我想要离开你，让你独自去探索、享受爬山的过程。</p>
<p>但是，现在还不是独自探索的时候，让我们一起开启旅程。系紧鞋带，收好背包，跟上来，从现在开始，你需要关注眼前的道路。</p>
<blockquote>
<p>Henceforth, I promise to tone down the whole mountain metaphor thing.</p>
<p>从今往后，我会淡化爬山这件事情。</p>
</blockquote>
<h2 id="五challenges"><a class="header" href="#五challenges">五、CHALLENGES</a></h2>
<p>习题集</p>
<ol>
<li>
<p>Pick an open source implementation of a language you like. Download the source code and poke around in it. Try to find the code that implements the scanner and parser. Are they handwritten, or generated using tools like Lex and Yacc? (.l or .y files usually imply the latter.)</p>
<p>选择一种你熟悉、喜欢的开源语言，下载源码然后浏览一下，尝试找出其中的扫描器、解析器部分，判断它们是自己实现的，还是使用Lex/Yacc等编译器工具实现的，可以查看是否存在 .l, .y 后缀的文件，这通常是工具生成文件。</p>
</li>
<li>
<p>Just-in-time compilation tends to be the fastest way to implement dynamically typed languages, but not all of them use it. What reasons are there to not JIT?</p>
<p>即时编译通常是动态语言最快的实现方式，但是并非所有的语言都利用这种特性，为什么它们不提供即时编译？</p>
</li>
<li>
<p>Most Lisp implementations that compile to C also contain an interpreter that lets them execute Lisp code on the fly as well. Why?</p>
<p>大多数的Lisp实现，在实现一个编译器，编译为C语言的同时，还提供一个解释器，保证可以动态执行Lisp代码，为什么？</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lox语言"><a class="header" href="#lox语言">Lox语言</a></h1>
<blockquote>
<p>What nicer thing can you do for somebody than make them breakfast?</p>
<p align="right">—— Anthony Bourdain</p>
<p>还有什么比给别人做早餐更好的事情呢？</p>
</blockquote>
<p>We’ll spend the rest of this book illuminating every dark and sundry corner of the Lox language, but it seems cruel to have you immediately start grinding out code for the interpreter without at least a glimpse of what we’re going to end up with.</p>
<p>At the same time, I don’t want to drag you through reams of language lawyering and specification-ese before you get to touch your text editor. So this will be a gentle, friendly introduction to Lox. It will leave out a lot of details and edge cases. We’ve got plenty of time for those later.</p>
<p>我们将在本书的剩余部分，阐明Lox语言的每一个黑暗和杂乱的角落。但是，如果我们无法看到 Lox 语言的最终样子，就开始编写解释器代码，看起来有一些匆忙。</p>
<p>在你使用文本编辑器之前，我不想过多介绍语言的格式和规范，所以，本章将是一个温和友好的Lox介绍。它会遗漏很多细节和边缘部分，我们在后面有足够的时间去学习。</p>
<blockquote>
<p>A tutorial isn’t very fun if you can’t try the code out yourself. Alas, you don’t have a Lox interpreter yet, since you haven’t built one!</p>
<p>Fear not. You can use mine.</p>
<p>如果一个教程不能自己写代码，那么这个教程就没有吸引力。但是，你还没有一个Lox解释器，因为我们还没有去实现它。</p>
<p>不用担心，你可以先使用我的😄。</p>
</blockquote>
<h2 id="一hello-lox"><a class="header" href="#一hello-lox">一、Hello, Lox</a></h2>
<p>第一个程序</p>
<pre><code class="language-c">
// Your first Lox program!
print &quot;Hello, world!&quot;;

</code></pre>
<p>Here’s your very first taste of Lox:</p>
<p>As that // line comment and the trailing semicolon imply, Lox’s syntax is a member of the C family. (There are no parentheses around the string because print is a built-in statement, and not a library function.)</p>
<p>Now, I won’t claim that C has a great syntax. If we wanted something elegant, we’d probably mimic Pascal or Smalltalk. If we wanted to go full Scandinavian-furniture-minimalism, we’d do a Scheme. Those all have their virtues.</p>
<p>What C-like syntax has instead is something you’ll often find more valuable in a language: familiarity.  I know you are already comfortable with that style because the two languages we’ll be using to implement Lox—Java and C—also inherit it. Using a similar syntax for Lox gives you one less thing to learn.</p>
<p>上面是第一个Lox程序，</p>
<p>正如 // 行注释，行尾；所暗示的，Lox语言，继承了C语言语法。hello, world 字符串周围不需要括号，因为 print是一个内置语句，而不是一个库函数。</p>
<p>现在，我不会说C语言有很好的语法，如果我们想要优雅的东西，可能模仿Pascal、Smalltalk更加合适。如果我们想要完全实现 斯堪的纳维亚家具的极简主义，我们需要先做一个计划。这些都有它们的优势。</p>
<p>相反，我们使用类C语言语法，是因为我们可以从中获得更有价值的东西，熟悉度。我知道，你已经习惯了这种风格，接下来，我们用以实现Lox的两种语言，Java 和C语言，都拥有这种熟悉的风格。Lox语言使用这种风格的语法，可以更加容易入门。</p>
<blockquote>
<p>Your first taste of Lox, the language, that is. I don’t know if you’ve ever had the cured, cold-smoked salmon before. If not, give it a try too.</p>
<p>你第一次品尝Lox语言，就是这样。我不知道你之前有没有尝试过腌制的冷鲑鱼，如果没有，可以尝试一下。</p>
</blockquote>
<blockquote>
<p>I’m surely biased, but I think Lox’s syntax is pretty clean. C’s most egregious grammar problems are around types. Dennis Ritchie had this idea called “declaration reflects use”, where variable declarations mirror the operations you would have to perform on the variable to get to a value of the base type.</p>
<p>Lox doesn’t have static types, so we avoid that.</p>
<p>我是有偏见的，从我的角度，我认为Lox语言语法非常简洁。C语言令人惊讶的语法问题是，类型。Dennis Ritchie 提出一个“声明反映使用”的想法，其中变量声明反映了你对于变量执行的操作，以获得基类型的值。这个想法非常好，但我认为，在实践中的效果并不好。</p>
<p>Lox不是静态类型语言，所以我们避免了这种情况。</p>
</blockquote>
<h2 id="二a-high-level-language"><a class="header" href="#二a-high-level-language">二、A high-level language</a></h2>
<p>高级语言</p>
<p>While this book ended up bigger than I was hoping, it’s still not big enough to fit a huge language like Java in it. In order to fit two complete implementations of Lox in these pages, Lox itself has to be pretty compact.</p>
<p>When I think of languages that are small but useful, what comes to mind are high-level “scripting” languages like JavaScript, Scheme, and Lua. Of those three, Lox looks most like JavaScript, mainly because most C-syntax languages do. As we’ll learn later, Lox’s approach to scoping hews closely to Scheme. The C flavor of Lox we’ll build in Part III is heavily indebted to Lua’s clean, efficient implementation.</p>
<p>虽然本书内容大大超过了一开始的设想，但是还是无法利用一本书来介绍Java 这样的大型语言。为了在接下来去实现 Lox语言两次，Lox本身需要非常紧凑。</p>
<p>当我们提到小而有用的语言时候，通常会想到的是一些脚本语言，例如：JavaScript, Scheme, Lua 等。在这三种脚本语言中，Lox更像是 JavaScript，因为它们都是类C 语法。正如后面将要介绍的，Lox的代码块范围表示，和Scheme 语言相似。在第三部分，我们将实现的C语言为解释器的Lox语言，将更加接近Lua语言的简洁、高效特征。</p>
<p>Lox shares two other aspects with those three languages:</p>
<p>Lox 和脚本语言还有下面3个相同点：</p>
<h3 id="21-dynamic-typing"><a class="header" href="#21-dynamic-typing">2.1 Dynamic typing</a></h3>
<p>动态类型</p>
<p>Lox is dynamically typed. Variables can store values of any type, and a single variable can even store values of different types at different times. If you try to perform an operation on values of the wrong type—say, dividing a number by a string—then the error is detected and reported at runtime.</p>
<p>There are plenty of reasons to like static types, but they don’t outweigh the pragmatic reasons to pick dynamic types for Lox.  A static type system is a ton of work to learn and implement.Skipping it gives you a simpler language and a shorter book. We’ll get our interpreter up and executing bits of code sooner if we defer our type checking to runtime.</p>
<p>Lox是动态类型语言，变量可以存储任何类型的值，单个变量可以在不同时间存储不同类型的数据，如何尝试对于错误类型的值执行操作，例如：数值除以字符串，运行时候会检测，并且报错。</p>
<p>喜欢静态类型有很多理由，但是为了Lox语言更加实用，我们选择了动态类型。静态类型系统需要学习和实现大量工作。跳过静态类型，会让Lox语言实现更加简单。如果在解释器在运行时候，执行类型检查，我们可以更快的执行代码。</p>
<blockquote>
<p>Now that JavaScript has taken over the world and is used to build ginormous applications, it’s hard to think of it as a “little scripting language”. But Brendan Eich hacked the first JS interpreter into Netscape Navigator in ten days to make buttons animate on web pages. JavaScript has grown up since then, but it was once a cute little language.</p>
<p>既然，JavaScript语言已经风靡语言世界，并且用于构建很多的大型项目，我们很难在将它当作一个小众语言。但是，在网景公司，Brendan Eich 仅仅使用了10天时间，就完成了第一个JS编译器，并且实现了网页中的按钮动态展示。JavaScript 从那时开始，不断成长，但是它曾经是一门可爱的小语言。</p>
<p>Because Eich slapped JS together with roughly the same raw materials and time as an episode of MacGyver, it has some weird semantic corners where the duct tape and paper clips show through. Things like variable hoisting, dynamically bound this, holes in arrays, and implicit conversions.</p>
<p>因为Eich使用了与《麦基弗》一集大致相同的原材料和时间制作了JS语言，所以，它存在着一些奇怪的语法，会出现一些胶带和回形针。例如：变量提升，动态绑定，数组中的漏洞和隐式转换。</p>
<p>I had the luxury of taking my time on Lox, so it should be a little cleaner. After all, the two languages we’ll be using to implement Lox are both statically typed.</p>
<p>相比之下，我有更多时间打磨Lox语言，所以，我们会发现，Lox语言会更加简洁。毕竟，我们实现Lox语言的底层语言Java/C都是静态语言。</p>
</blockquote>
<h3 id="22-automatic-memory-management"><a class="header" href="#22-automatic-memory-management">2.2 Automatic memory management</a></h3>
<p>自动内存管理</p>
<p>High-level languages exist to eliminate error-prone, low-level drudgery, and what could be more tedious than manually managing the allocation and freeing of storage? No one rises and greets the morning sun with, “I can’t wait to figure out the correct place to call free() for every byte of memory I allocate today!”</p>
<p>高级语言的出现是为了，消除更加容易出错、低级别、乏味的工作，还有什么比手动管理内存分配与释放，更加繁琐呢？没有人会站起来迎接太阳，我忍不住要为今天分配的每一个字节的内存，找到调用 free() 函数的正确位置。</p>
<p>There are two main techniques for managing memory: reference counting and tracing garbage collection (usually just called garbage collection or GC). Ref counters are much simpler to implement—I think that’s why Perl, PHP, and Python all started out using them. But, over time, the limitations of ref counting become too troublesome. All of those languages eventually ended up adding a full tracing GC, or at least enough of one to clean up object cycles.</p>
<p>Tracing garbage collection has a fearsome reputation. It is a little harrowing working at the level of raw memory. Debugging a GC can sometimes leave you seeing hex dumps in your dreams. But, remember, this book is about dispelling magic and slaying those monsters, so we are going to write our own garbage collector. I think you’ll find the algorithm is quite simple and a lot of fun to implement.</p>
<p>内存管理主要有两种技术：引用计数 和 追踪垃圾回收，通常也称为，垃圾回收，缩写为 GC</p>
<p>引用计数的实现要简单一些，我认为这也是Perl/PHP/Python 语言一开始使用这个技术，实现内存管理的原因。但是，随着时间的变更，引用计数的局限性越来越多。所以，上面的语言，最终都添加了完整的追踪GC 实现，或者有足够的 GC逻辑 周期性清理对象。</p>
<p>追踪垃圾回收具有可怕的名声。在原生内存级别工作，非常痛苦。调试 GC，会让你在梦里都还在想着16进制转储问题。但是，请记住，本书会带着我们一起驱散魔法，杀死怪兽，所以，我们也会编写自己的垃圾回收程序。我猜想，你一定会发现算法非常简单，并且整个程序非常有趣。</p>
<blockquote>
<p>In practice, ref counting and tracing are more ends of a continuum than opposing sides. Most ref counting systems end up doing some tracing to handle cycles, and the write barriers of a generational collector look a bit like retain calls if you squint.</p>
<p>在实践中，引用计数和追踪技术会混合使用，而不是相互对立。大多数的引用计数，都会进行一些周期性的追踪，如果你仔细查看，分代采集器的用法看起来像是保留调用。</p>
<p>For lots more on this, see <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/unified-theory-gc.pdf">“A Unified Theory of Garbage Collection”</a> (PDF).</p>
<p>更多的信息，可以查看 <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/unified-theory-gc.pdf">“垃圾收集的统一理论”</a></p>
</blockquote>
<h2 id="三data-types"><a class="header" href="#三data-types">三、Data Types</a></h2>
<p>数据类型</p>
<p>In Lox’s little universe, the atoms that make up all matter are the built-in data types. There are only a few:</p>
<ol>
<li>
<p><strong>Booleans</strong></p>
<p>You can’t code without logic and you can’t logic without Boolean values. “True” and “false”, the yin and yang of software. Unlike some ancient languages that repurpose an existing type to represent truth and falsehood, Lox has a dedicated Boolean type. </p>
<p>There are two Boolean values, obviously, and a literal for each one.</p>
<pre><code>
true;  // Not false.
false; // Not *not* false.

</code></pre>
<blockquote>
<p>Boolean variables are the only data type in Lox named after a person, George Boole, which is why “Boolean” is capitalized. He died in 1864, nearly a century before digital computers turned his algebra into electricity. I wonder what he’d think to see his name all over billions of lines of Java code.</p>
<p>布尔变量是Lox语言中，唯一使用人名命名的数据类型。Boolean是为了纪念 George Boole, 他于1864年去世，一个世纪后，计算机科学将他发明的布尔代数，转换为计算机表示。我想知道，当他在数十亿Java代码中，看到自己的名字，会有什么感想😄</p>
</blockquote>
</li>
<li>
<p><strong>Numbers</strong></p>
<p>Lox has only one kind of number: double-precision floating point. Since floating-point numbers can also represent a wide range of integers, that covers a lot of territory, while keeping things simple.</p>
<p>Full-featured languages have lots of syntax for numbers—hexadecimal, scientific notation, octal, all sorts of fun stuff. We’ll settle for basic integer and decimal literals.</p>
<pre><code>
1234;  // An integer.
12.34; // A decimal number.

</code></pre>
</li>
<li>
<p><strong>Strings</strong></p>
<p>We’ve already seen one string literal in the first example. Like most languages, they are enclosed in double quotes.</p>
<p>As we’ll see when we get to implementing them, there is quite a lot of complexity hiding in that innocuous sequence of characters.</p>
<pre><code>
&quot;I am a string&quot;;
&quot;&quot;;    // The empty string.
&quot;123&quot;; // This is a string, not a number.

</code></pre>
<blockquote>
<p>Even that word “character” is a trickster. Is it ASCII? Unicode? A code point or a “grapheme cluster”? How are characters encoded? Is each character a fixed size, or can they vary?</p>
<p>即使是单词，字节，也包含了一些隐藏信息，字节是ASCII编码的，还是Unicode编码；一个字节是一个代码点，还是一个图形集簇；字节是如何编码的，是定长编码，还是变长编码？</p>
</blockquote>
</li>
<li>
<p><strong>Nil</strong></p>
<p>There’s one last built-in value who’s never invited to the party but always seems to show up. It represents “no value”. It’s called “null” in many other languages. In Lox we spell it nil.  (When we get to implementing it, that will help distinguish when we’re talking about Lox’s nil versus Java or C’s null.)</p>
<p>There are good arguments for not having a null value in a language since null pointer errors are the scourge of our industry. If we were doing a statically typed language, it would be worth trying to ban it. In a dynamically typed one, though, eliminating it is often more annoying than having it.</p>
</li>
</ol>
<p>在Lox的小宇宙中，构成物质的原子是内置的几种数据类型，详见下面的介绍:</p>
<ol>
<li>
<p>布尔类型</p>
<p>没有逻辑运算，我们无法进行编程，而逻辑运算，需要布尔数据类型。真与假，编程世界中的阴与阳，与一些早先语言复用其他数据类型表示布尔类型不同的是，我们会在Lox语言中定义一个专用的布尔数据类型。</p>
<p>显然，布尔值有两个选择，每个值对应了一个文本</p>
<pre><code>true;  // Not false.
false; // Not *not* false.
</code></pre>
</li>
<li>
<p>数值类型</p>
<p>Lox语言，只有一种数值类型，双精度浮点数。因为浮点数，可以包含大范围的整数，这样做，不但可以包含很多其他数据类型，而且可以保持简洁。</p>
<p>功能齐全的语言，会有很多的数字语法，例如：十六进制表示、科学计数法、八进制表示，以及其他的有趣的东西。但是在Lox语言中，我们将只会满足基本的整数运算和十进制表示。</p>
<pre><code>
1234;  // An integer.
12.34; // A decimal number.

</code></pre>
</li>
<li>
<p>字符串</p>
<p>从上面的第一个示例中，我们可以看到字符串类型 &quot;hello, world!&quot;。 和大多数的语言一样，字符串类型的数据，需要使用双引号括起来。</p>
<p>当我们实现字符串类型时候，将会看到，在这个定义明确的字符序列中，隐藏着许多复杂场景，需要特殊处理。</p>
<pre><code>
&quot;I am a string&quot;;
&quot;&quot;;    // The empty string.
&quot;123&quot;; // This is a string, not a number.

</code></pre>
</li>
<li>
<p>Nil</p>
<p>最后，还有一个数据类型，它似乎从来没有被邀请参加编程聚会，但是你总是能看到它的身影。它，代表了不存在，没有数值。在许多语言中，使用 null 表示它，而在Lox语言中，我们将使用 nil 表示它。当我们实现它时，可以更好的与 Java/C语言中的null 区别开。</p>
<p>在语言中，不使用 nil 存在很多好处，空指针报错是编程行业常见的报错。如果，我们要实现一门静态类型语言，那么我们禁止 nil类型是值得的。但是，如果我们要实现一门动态类型语言，通常，保留 nil类型，拥有更多的好处，相比于禁止该类型。</p>
</li>
</ol>
<h2 id="四expressions"><a class="header" href="#四expressions">四、Expressions</a></h2>
<p>表达式</p>
<p>If built-in data types and their literals are atoms, then expressions must be the molecules. Most of these will be familiar.</p>
<p>如果内置的基础数据类型和它们的文字，是原子，那么表达式就是分子，下面将介绍各种表达式</p>
<h3 id="41-arithmetic"><a class="header" href="#41-arithmetic">4.1 Arithmetic</a></h3>
<p>算术表达式</p>
<p>Lox features the basic arithmetic operators you know and love from C and other languages:</p>
<p>Lox语言具有C语言或者其他语言中，存在的基础算术表达式</p>
<pre><code>
add + me;
subtract - me;
multiply * me;
divide / me;

</code></pre>
<p>The subexpressions on either side of the operator are operands. Because there are two of them, these are called binary operators.(It has nothing to do with the ones-and-zeroes use of “binary”.) </p>
<p>Because the operator is fixed in the middle of the operands, these are also called infix operators (as opposed to prefix operators where the operator comes before the operands, and postfix where it comes after).</p>
<p>One arithmetic operator is actually both an infix and a prefix one. The - operator can also be used to negate a number.</p>
<pre><code>-negateMe;
</code></pre>
<p>All of these operators work on numbers, and it’s an error to pass any other types to them. The exception is the + operator—you can also pass it two strings to concatenate them.</p>
<p>运算符号，两边的子表达式，称为操作数。因为运算符号，有两个操作数，所以称为二元运算符。⚠️这里的二元，和二进制中的0或者1，没有关系。</p>
<p>因为运算符，固定在操作数的中间，所以，我们称之为中缀运算符。（与前缀运算符不同，前缀运算符位于表达式最前面，后缀运算符位于表达式最后。）</p>
<p>一元运算符，实际上可以是中缀运算符，也可以是前缀运算符。例如：- 可以表示负数</p>
<pre><code>-negateMe;
</code></pre>
<p>上面的算术运算符的操作数，只能是数值类型，如果操作数是其他数据类型，表达式计算会报错。但是，有个例外，+运算符可以作用于字符串数据类型，两个字符串的 + 运算，表示连接这两个字符串。</p>
<blockquote>
<p>There are some operators that have more than two operands and the operators are interleaved between them. The only one in wide usage is the “conditional” or “ternary” operator of C and friends:</p>
<p>condition ? thenArm : elseArm;</p>
<p>Some call these mixfix operators. A few languages let you define your own operators and control how they are positioned—their “fixity”.</p>
<p>有些运算符，可以具有两个以上的操作数，运算符在这些操作数之间。唯一广泛使用的多元运算符是 C语言中的条件（三元）运算符。</p>
<p>condition ? thenArm : elseArm;</p>
</blockquote>
<h3 id="42-comparison-and-equality"><a class="header" href="#42-comparison-and-equality">4.2 Comparison and equality</a></h3>
<p>比较运算符，相等</p>
<p>Moving along, we have a few more operators that always return a Boolean result. We can compare numbers (and only numbers), using Ye Olde Comparison Operators.</p>
<pre><code>less &lt; than;
lessThan &lt;= orEqual;
greater &gt; than;
greaterThan &gt;= orEqual;
</code></pre>
<p>We can test two values of any kind for equality or inequality. Even different types. Values of different types are never equivalent.</p>
<pre><code>1 == 2;         // false.
&quot;cat&quot; != &quot;dog&quot;; // true.
314 == &quot;pi&quot;; // false.
123 == &quot;123&quot;; // false.
</code></pre>
<p>I’m generally against implicit conversions.</p>
<p>接下来，我们将介绍几个返回布尔值的运算符。</p>
<p>我们可以使用 比较运算符，比较并且仅仅比较数值</p>
<p>我们也可以比较两个任意类型的数据，是否相等, 甚至这两个数据，不是相同的类型。不同数据类型的两个数据，肯定是不想等的🤔。</p>
<p>通常，我们不建议使用隐式转换。</p>
<h3 id="43-logical-operators"><a class="header" href="#43-logical-operators">4.3 Logical operators</a></h3>
<ol>
<li>
<p>The not operator, a prefix !, returns false if its operand is true, and vice versa.</p>
<pre><code>
!true;  // false.
!false; // true.

</code></pre>
</li>
<li>
<p>The other two logical operators really are control flow constructs in the guise of expressions. An and expression determines if two values are both true. It returns the left operand if it’s false, or the right operand otherwise.</p>
<pre><code>
true and false; // false.
true and true;  // true.

</code></pre>
</li>
<li>
<p>And an or expression determines if either of two values (or both) are true. It returns the left operand if it is true and the right operand otherwise.</p>
</li>
</ol>
<p>The reason and and or are like control flow structures is that they short-circuit. Not only does and return the left operand if it is false, it doesn’t even evaluate the right one in that case. Conversely (contrapositively?), if the left operand of an or is true, the right is skipped.</p>
<p>逻辑运算</p>
<ol>
<li>
<p>逻辑非运算符，使用 ！表示，如果操作数是true，则添加逻辑非的表达式，值为false，反之亦然。</p>
<pre><code>
!true;  // false.
!false; // true.

</code></pre>
</li>
<li>
<p>另外两个逻辑运算符，与其说是表达式，更加准确的说法是，控制流。</p>
<p>and 逻辑运算符，将确定两个操作数，是否都是true，如果左操作数是false， 则表达式返回左操作数的值；如果左操作数为true，则表达式返回右操作数的值。</p>
<pre><code>
true and false; // false.
true and true;  // true.

</code></pre>
</li>
<li>
<p>or 逻辑运算符，将确定两个操作数，是否包含true，如果左操作数为true，则表达式结果，返回左操作数；如果左操作数为false，表达式将会返回右操作数的值。</p>
<pre><code>
false or false; // false.
true or false;  // true.

</code></pre>
</li>
</ol>
<p>and 和 or 逻辑运算符，本质上是控制流结构的原因是，它们是短路。当逻辑运算符是 and，左操作数值为 false，我们甚至不会去计算右操作数，直接返回左操作数的值。如果逻辑运算符是 or，左操作数值为 true，同样的，我们不会去计算右操作数，直接返回左操作数的值。</p>
<h3 id="44-precedence-and-grouping"><a class="header" href="#44-precedence-and-grouping">4.4 Precedence and grouping</a></h3>
<p>优先级和分组</p>
<p>All of these operators have the same precedence and associativity that you’d expect coming from C. (When we get to parsing, we’ll get way more precise about that.) In cases where the precedence isn’t what you want, you can use () to group stuff.</p>
<pre><code>
var average = (min + max) / 2;

</code></pre>
<p>Since they aren’t very technically interesting, I’ve cut the remainder of the typical operator menagerie out of our little language. </p>
<p>所有这些运算符的优先级和关联性，和C语言中的相同。当我们进入解析过程时候，将会更加理解这一点。如果，优先级不是我们想要的，可以使用 （）对内容进行分组。</p>
<p>因为在技术上不太有趣，在Lox语言中，我删除了一些典型的运算符，例如：位运算，位移，取模，条件运算符等。我不会让你们评分，但是如果你在Lox语言实现中，添加了这些运算符，在我心中，你将会大大加分。</p>
<p>Those are the expression forms (except for a couple related to specific features that we’ll get to later), so let’s move up a level.</p>
<p>上面介绍了表达式形式，除了一些我们下面将要介绍的、与特定功能相关的表达式，让我们继续学习。</p>
<h2 id="五statements"><a class="header" href="#五statements">五、Statements</a></h2>
<p>语句</p>
<p>Now we’re at statements. Where an expression’s main job is to produce a value, a statement’s job is to produce an effect. Since, by definition, statements don’t evaluate to a value, to be useful they have to otherwise change the world in some way—usually modifying some state, reading input, or producing output.</p>
<p>You’ve seen a couple of kinds of statements already. The first one was:</p>
<pre><code>
print &quot;Hello, world!&quot;;

</code></pre>
<p>A print statement evaluates a single expression and displays the result to the user. You’ve also seen some statements like:</p>
<pre><code>
&quot;some expression&quot;;

</code></pre>
<p>An expression followed by a semicolon (;) promotes the expression to statement-hood. This is called (imaginatively enough), an expression statement.</p>
<p>If you want to pack a series of statements where a single one is expected, you can wrap them up in a block.</p>
<pre><code>
{
  print &quot;One statement.&quot;;
  print &quot;Two statements.&quot;;
}

</code></pre>
<p>Blocks also affect scoping, which leads us to the next section . . . </p>
<p>现在，我们开始学习语句。表达式的主要作用是生成值，语句的主要任务是产生效果。因为，语句的结果不是一个具体的值，所以，为了能够有影响，语句的结果必须可以以某种方式改变编程世界，例如：修改某些状态，读取用户输入，产生输出。</p>
<p>你已经看到了几种不同类型的语句，例如:</p>
<pre><code>
print &quot;Hello, world!&quot;;

</code></pre>
<p>一个print语句，计算出单个表达式，并且向用户展示计算结果。</p>
<p>还有一些其他类型的语句，例如：</p>
<pre><code>
&quot;some expression&quot;;

</code></pre>
<p>表达式后面加上 ; 该表达式会变为表达式语句。</p>
<p>如果想将一系列语句，组合为一条语句，可以使用{}, 将这些语句打包为一个块</p>
<pre><code>
{
  print &quot;One statement.&quot;;
  print &quot;Two statements.&quot;;
}

</code></pre>
<p>语法块，还影响生命周期，马上我们将会看到。</p>
<blockquote>
<p>Baking print into the language instead of just making it a core library function is a hack. But it’s a useful hack for us: it means our in-progress interpreter can start producing output before we’ve implemented all of the machinery required to define functions, look them up by name, and call them.</p>
<p>Lox语言中，将print表示为语句，而不是核心函数库中的一个print函数，是一种黑客行为。这对我们来说是一个有用的技巧：这意味着，解释器运行时，我们可以在定义函数之前，实现输出功能。按照名称查找并且调用它们。</p>
</blockquote>
<h2 id="六variables"><a class="header" href="#六variables">六、Variables</a></h2>
<p>变量</p>
<p>You declare variables using var statements. If you omit the initializer, the variable’s value defaults to nil.</p>
<pre><code>
var imAVariable = &quot;here is my value&quot;;
var iAmNil;

</code></pre>
<p>Once declared, you can, naturally, access and assign a variable using its name.</p>
<pre><code>
var breakfast = &quot;bagels&quot;;
print breakfast; // &quot;bagels&quot;.
breakfast = &quot;beignets&quot;;
print breakfast; // &quot;beignets&quot;.

</code></pre>
<p>I won’t get into the rules for variable scope here, because we’re going to spend a surprising amount of time in later chapters mapping every square inch of the rules. In most cases, it works like you would expect coming from C or Java.</p>
<p>可以使用 var语句，声明变量。如果变量省略初始化，该变量的默认值是nil。</p>
<p>一旦声明，我们可以使用变量名，访问和分配变量。</p>
<p>在当前章节，我不会讨论变量的有效使用范围，因为，我们将在后面的章节中，花费很多篇幅讲解变量的使用范围。在多数场景下，Lox语言中，变量的使用范围和 C/Java语言中的规则相同。</p>
<blockquote>
<p>This is one of those cases where not having nil and forcing every variable to be initialized to some value would be more annoying than dealing with nil itself.</p>
<p>这是nil存在的一种好处，如果我们强制要求任意的变量，都必须初始化为具体值，那么，这个强制初始化的过程比我们定一个一个nil类型，更加麻烦。</p>
<p>Can you tell that I tend to work on this book in the morning before I’ve had anything to eat?</p>
<p>你可以看出来我倾向于，在吃早餐之前，开始写一会儿书吗？😂</p>
</blockquote>
<h2 id="七control-flow"><a class="header" href="#七control-flow">七、Control Flow</a></h2>
<p>控制流</p>
<p>It’s hard to write useful programs if you can’t skip some code or execute some more than once. That means control flow. In addition to the logical operators we already covered, Lox lifts three statements straight from C.</p>
<ol>
<li>
<p><strong>if</strong></p>
<p>An if statement executes one of two statements based on some condition.</p>
<pre><code>
if (condition) {
  print &quot;yes&quot;;
} else {
  print &quot;no&quot;;
}

</code></pre>
</li>
<li>
<p><strong>while</strong></p>
<p>A while loop executes the body repeatedly as long as the condition expression evaluates to true.</p>
<pre><code>
var a = 1;
while (a &lt; 10) {
  print a;
  a = a + 1;
}

</code></pre>
</li>
<li>
<p><strong>for</strong></p>
<p>Finally, we have for loops. This loop does the same thing as the previous while loop. Most modern languages also have some sort of for-in or foreach loop for explicitly iterating over various sequence types. In a real language, that’s nicer than the crude C-style for loop we got here. Lox keeps it basic.</p>
<pre><code>
for (var a = 1; a &lt; 10; a = a + 1) {
  print a;
}

</code></pre>
</li>
</ol>
<blockquote>
<p>We already have and and or for branching, and we could use recursion to repeat code, so that’s theoretically sufficient. It would be pretty awkward to program that way in an imperative-styled language, though.</p>
<p>我们已经有了 and 和 or 逻辑运算符，如果在加上递归调用函数，理论上可以实现重复执行代码。但是，这种函数式编程方式，非常难使用。</p>
</blockquote>
<blockquote>
<p>Scheme, on the other hand, has no built-in looping constructs. It does rely on recursion for repetition. Smalltalk has no built-in branching constructs, and relies on dynamic dispatch for selectively executing code.</p>
<p>lisp的方言，scheme, 没有内置的循环语句。它依赖递归执行，实现复用代码。Smalltalk语言，没有内置的分支语句，它依赖动态调度，来选择性的执行代码。</p>
</blockquote>
<blockquote>
<p>I left do while loops out of Lox because they aren’t that common and wouldn’t teach you anything that you won’t already learn from while. Go ahead and add it to your implementation if it makes you happy. It’s your party.</p>
<p>我没有在Lox语言中，引入 do while循环语句，因为，该循环语句，和while语句，效果一致。如果你想在Lox语言中，实现该语句，那么非常欢迎，因为这是你的语言。</p>
</blockquote>
<blockquote>
<p>This is a concession I made because of how the implementation is split across chapters. A for-in loop needs some sort of dynamic dispatch in the iterator protocol to handle different kinds of sequences, but we don’t get that until after we’re done with control flow. We could circle back and add for-in loops later, but I didn’t think doing so would teach you anything super interesting.</p>
<p>这是我做出的让步，我将在后面的章节中，添加 for-in 循环语句。我们需要在迭代器中，根据不同的数据类型，动态调度该数据序列。虽然，我们添加了 for-in语句，但是我并不认为，这个语句非常有趣。</p>
</blockquote>
<p>如果语言不支持，跳过执行某些代码或者重复执行某些代码，那么，我们很难写出有用的程序。而这些，表明我们需要引入控制流。除了上面介绍的逻辑运算符之外，我们还从C语言中直接借用了3种控制流。</p>
<ol>
<li>
<p>if</p>
<p>if语句，根据条件，选择执行其中的一个语句。</p>
<pre><code>
if (condition) {
 print &quot;yes&quot;;
} else {
 print &quot;no&quot;;
}

</code></pre>
</li>
<li>
<p>while</p>
<p>只要while 语句中，表达式执行结果为true，循环语句会一直执行。</p>
<pre><code>
var a = 1;
while (a &lt; 10) {
  print a;
  a = a + 1;
}

</code></pre>
</li>
<li>
<p>for</p>
<p>最后，我们介绍for 循环语句。</p>
<pre><code>
for (var a = 1; a &lt; 10; a = a + 1) {
  print a;
}

</code></pre>
<p>for循环语句，和 while循环语句，效果相同。大多数现代语句，还支持for-in，foreach语句，用于迭代各种序列类型数据。在实际编程中，这种新的语句，比C语言的for语句，更加简洁。但是，我们Lox语言，将保持最原始的for语句。</p>
</li>
</ol>
<h2 id="八-functions"><a class="header" href="#八-functions">八、 Functions</a></h2>
<p>函数</p>
<p>A function call expression looks the same as it does in C.</p>
<pre><code>
makeBreakfast(bacon, eggs, toast);

</code></pre>
<p>You can also call a function without passing anything to it.</p>
<pre><code>
makeBreakfast();

</code></pre>
<p>Unlike in, say, Ruby, the parentheses are mandatory in this case. If you leave them off, the name doesn’t call the function, it just refers to it.</p>
<p>A language isn’t very fun if you can’t define your own functions. In Lox, you do that with fun.</p>
<pre><code>
fun printSum(a, b) {
  print a + b;
}

</code></pre>
<p>函数调用表达式和C语言中一样。</p>
<pre><code>
makeBreakfast(bacon, eggs, toast);

</code></pre>
<p>也可以在不传递任何参数的情况下，调用函数</p>
<pre><code>
makeBreakfast();

</code></pre>
<p>与 Ruby语言不一样，在这种场景，括号是必须的，如果不使用括号，不会实际调用函数，而只会引用函数。</p>
<p>如果一门语言无法自定义函数，那么这门语言也不会非常有意义。在Lox语言中，使用 fun 定义一个函数。</p>
<pre><code>
fun printSum(a, b) {
  print a + b;
}

</code></pre>
<p>Now’s a good time to clarify some terminology. Some people throw around “parameter” and “argument” like they are interchangeable and, to many, they are. We’re going to spend a lot of time splitting the finest of downy hairs around semantics, so let’s sharpen our words. From here on out:</p>
<ul>
<li>
<p>An argument is an actual value you pass to a function when you call it. So a function call has an argument list. Sometimes you hear actual parameter used for these.</p>
</li>
<li>
<p>A parameter is a variable that holds the value of the argument inside the body of the function. Thus, a function declaration has a parameter list. Others call these formal parameters or simply formals.</p>
</li>
</ul>
<p>The body of a function is always a block. Inside it, you can return a value using a return statement.</p>
<pre><code>
fun returnSum(a, b) {
  return a + b;
}

</code></pre>
<p>If execution reaches the end of the block without hitting a return, it implicitly returns nil.</p>
<p>现在是澄清一些术语的好时机。有些人，总会随意的使用 parameter 和 argument 两个术语，很多人会认为这两个术语含义相同，但是其实，它们之间有一些不同之处：</p>
<ul>
<li>
<p>argument 是调用函数时候，传递给函数的实际值，人们一般称为 实参，函数调用时候，会传递一系列的参数列表，称为实参列表</p>
</li>
<li>
<p>parameter 是定义函数时候，保存参数值的变量，人们一般称为 形参，函数定义的时候，会定义一系列的参数列表，称为形参列表。</p>
</li>
</ul>
<p>函数体始终是一个代码块。在函数体中，可以使用return 函数，返回一个值。</p>
<pre><code>
fun returnSum(a, b) {
  return a + b;
}

</code></pre>
<p>如果函数执行到末尾，没有return语句，会隐式的返回 nil</p>
<blockquote>
<p>See, I told you nil would sneak in when we weren’t looking.</p>
<p>看吧，我就说过 nil 总会在我们不注意的时候，偷偷溜进来。</p>
</blockquote>
<blockquote>
<p>I’ve seen languages that use fn, fun, func, and function. I’m still hoping to discover a funct, functi, or functio somewhere.</p>
<p>我已经见过其他语言中，使用fn fun func function 关键字定义函数，我还在期待，有语言使用关键词 funct functi functio</p>
</blockquote>
<blockquote>
<p>Speaking of terminology, some statically typed languages like C make a distinction between declaring a function and defining it. A declaration binds the function’s type to its name so that calls can be type-checked but does not provide a body. A definition declares the function and also fills in the body so that the function can be compiled</p>
<p>说到术语，一些静态类型语言，例如：C语言，在函数声明和函数定义之间有不同之处。函数声明，函数名称关联着参数类型，以便再调用函数时候，检查参数类型，但是不定义函数体。函数定义，在声明函数的同时，还会定义函数体，以便可以编译函数。</p>
</blockquote>
<blockquote>
<p>Since Lox is dynamically typed, this distinction isn’t meaningful. A function declaration fully specifies the function including its body.</p>
<p>因为Lox是一门动态语言，函数声明和函数定义没有区别，函数声明需要指定函数体。</p>
</blockquote>
<h3 id="81-closures"><a class="header" href="#81-closures">8.1 Closures</a></h3>
<p>闭包</p>
<p>Functions are first class in Lox, which just means they are real values that you can get a reference to, store in variables, pass around, etc. This works:</p>
<pre><code>
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints &quot;3&quot;.

</code></pre>
<p>Since function declarations are statements, you can declare local functions inside another function.</p>
<pre><code>
fun outerFunction() {
  fun localFunction() {
    print &quot;I'm local!&quot;;
  }

  localFunction();
}


</code></pre>
<p>函数是Lox语言中的第一类变量，这意味着它们是拥有实际值的变量。我们可以引用/存储/传递这些函数。</p>
<pre><code>
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints &quot;3&quot;.

</code></pre>
<p>因为函数声明是语句，所以，我们可以在函数中，定义内部函数</p>
<pre><code>
fun outerFunction() {
  fun localFunction() {
    print &quot;I'm local!&quot;;
  }

  localFunction();
}


</code></pre>
<p>If you combine local functions, first-class functions, and block scope, you run into this interesting situation:</p>
<pre><code>
fun returnFunction() {
  var outside = &quot;outside&quot;;

  fun inner() {
    print outside;
  }

  return inner;
}

var fn = returnFunction();
fn();

</code></pre>
<p>Here, inner() accesses a local variable declared outside of its body in the surrounding function. Is this kosher? Now that lots of languages have borrowed this feature from Lisp, you probably know the answer is yes.</p>
<p>For that to work, inner() has to “hold on” to references to any surrounding variables that it uses so that they stay around even after the outer function has returned. We call functions that do this closures. These days, the term is often used for any first-class function, though it’s sort of a misnomer if the function doesn’t happen to close over any variables</p>
<p>As you can imagine, implementing these adds some complexity because we can no longer assume variable scope works strictly like a stack where local variables evaporate the moment the function returns. We’re going to have a fun time learning how to make these work correctly and efficiently.</p>
<p>如果将局部函数、一级函数、代码块作用域组合在一起，我们可以发现一些有意思的地方：</p>
<pre><code>
fun returnFunction() {
  var outside = &quot;outside&quot;;

  fun inner() {
    print outside;
  }

  return inner;
}

var fn = returnFunction();
fn();

</code></pre>
<p>可以看到，inner函数，调用了外层函数中的局部变量 outside, 这样会报错吗？很多语言都借鉴了 lisp 语言的这种特性，答案是，我们可以使用外层函数中的局部变量。</p>
<p>为此，inner函数，必须包含对于周围变量的引用，这样即使外部函数已经返回，这些局部变量仍然会保留。我们将实现了这个功能的函数闭包。现如今，这个术语，闭包，经常用于第一类函数，尽管如何函数没有在任何变量上闭合，这个用词有些不太合适。</p>
<p>可以想象，实现这个闭包功能，会增加一些复杂性，因为我们不能假设变量，严格的像堆栈一样工作，当函数返回时候，局部变量就消失了。我们将有一段愉快的时光，学习如何正确有效的工作。</p>
<blockquote>
<p>Peter J. Landin coined the term “closure”. Yes, he invented damn near half the terms in programming languages. Most of them came out of one incredible paper, “The Next 700 Programming Languages”.</p>
<p><a href="https://zh.wikipedia.org/zh-tw/%E5%BD%BC%E5%BE%97%C2%B7%E5%85%B0%E4%B8%81">Peter J. Landin</a> 创造了闭包概念，是的，他几乎发明了一半的编程语言术语，其中大部分都出自那边重要论文 <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/The-Next-700-Programming-Languages.pdf">The Next 700 Programming Languages</a></p>
<p>In order to implement these kind of functions, you need to create a data structure that bundles together the function’s code and the surrounding variables it needs. He called this a “closure” because it closes over and holds on to the variables it needs.</p>
<p>为了实现这些函数，我们需要创建一个数据结构，将函数代码和函数所需要变量绑定在一起。他称这种数据结构为闭包，因为它包围着函数，并且包含了相关变量。</p>
</blockquote>
<h2 id="九classes"><a class="header" href="#九classes">九、Classes</a></h2>
<p>类</p>
<p>Since Lox has dynamic typing, lexical (roughly, “block”) scope, and closures, it’s about halfway to being a functional language. But as you’ll see, it’s also about halfway to being an object-oriented language. Both paradigms have a lot going for them, so I thought it was worth covering some of each.</p>
<p>Since classes have come under fire for not living up to their hype, let me first explain why I put them into Lox and this book. There are really two questions:</p>
<p>因为Lox语言具有动态类型，词法范围、闭包，因此，它已经一部分是函数式语言了，但是，正如我们将看到的，它也同样具有面向语言对象的一部分特性。这两种语言范式分别有很多优点，我们将简单介绍一些：</p>
<p>下面我将解释一下，为什么Lox语言具有面向对象特性：</p>
<h3 id="91-why-might-any-language-want-to-be-object-oriented"><a class="header" href="#91-why-might-any-language-want-to-be-object-oriented">9.1 Why might any language want to be object oriented?</a></h3>
<p>为什么所有语言都想要面向对象特性？</p>
<p>Now that object-oriented languages like Java have sold out and only play arena shows, it’s not cool to like them anymore. Why would anyone make a new language with objects? Isn’t that like releasing music on 8-track?</p>
<p>It is true that the “all inheritance all the time” binge of the ’90s produced some monstrous class hierarchies, but object-oriented programming (OOP) is still pretty rad. Billions of lines of successful code have been written in OOP languages, shipping millions of apps to happy users. Likely a majority of working programmers today are using an object-oriented language. They can’t all be that wrong.</p>
<p>In particular, for a dynamically typed language, objects are pretty handy. We need some way of defining compound data types to bundle blobs of stuff together.</p>
<p>If we can also hang methods off of those, then we avoid the need to prefix all of our functions with the name of the data type they operate on to avoid colliding with similar functions for different types. In, say, Racket, you end up having to name your functions like hash-copy (to copy a hash table) and vector-copy (to copy a vector) so that they don’t step on each other. Methods are scoped to the object, so that problem goes away.</p>
<p>现在，面向对象语言，例如Java，已经普遍被使用，而且已经被接收到主流编程世界了，现在在喜欢它们，也不是很酷的事情了。为什么还有人用对象创造一门新语言，这好像是在8音节上，写出新的歌曲。</p>
<p>诚然，90年代的“一直继承”热潮产生了一些可怕的类层次结构，但是面向对象语言（OOP）仍然非常难实现。现在，面向对象语言，已经应用于数十亿行代码，分布于数百万的应用程序中，今天大多数的程序员都在使用面向对象语言。</p>
<p>特别的，对于动态类型，对象非常方便。我们需要一些方法，将一些复杂的数据类型绑定在一起。</p>
<p>如果我们可以挂起这些方法，那么，我们不需要在所有函数前面加上它们所操作的数据类型的名称，以避免和不同类型的类似函数发生冲突。例如：在Rocket语言中，你需要根据不同的数据类型，分别命名 hash-copy 和 vector-copy 函数，这样它们不会相互重叠。方法的作用域是对象，这样问题，就解决了。</p>
<h3 id="92-why-is-lox-object-oriented"><a class="header" href="#92-why-is-lox-object-oriented">9.2 Why is Lox object oriented?</a></h3>
<p>为什么Lox语言是面向对象的？</p>
<p>I could claim objects are groovy but still out of scope for the book. Most programming language books, especially ones that try to implement a whole language, leave objects out. To me, that means the topic isn’t well covered. With such a widespread paradigm, that omission makes me sad.</p>
<p>Given how many of us spend all day using OOP languages, it seems like the world could use a little documentation on how to make one. As you’ll see, it turns out to be pretty interesting. Not as hard as you might fear, but not as simple as you might presume, either.</p>
<p>我可以说对象是 groovy语言，但是仍然超出了本书的范围。大多数的编程语言书籍，尤其是那些想要实现一门完整语言的书籍，都忽略了面向对象介绍。对我而言，这意味着面向对象这个话题，没有很好的被覆盖。在如此广泛的示例中，这种遗漏让我感到悲伤。</p>
<p>考虑到我们大部分人，每天都在使用面向对象语言，似乎全世界都需要一些关于面向对象语言的介绍。正如你看到的，结果非常有意思，既没有你想象的那么困难，但是也没你想象的那么简单。</p>
<h3 id="93-classes-or-prototypes"><a class="header" href="#93-classes-or-prototypes">9.3 Classes or prototypes</a></h3>
<p>类和原型</p>
<p>When it comes to objects, there are actually two approaches to them, classes and prototypes. Classes came first, and are more common thanks to C++, Java, C#, and friends. Prototypes were a virtually forgotten offshoot until JavaScript accidentally took over the world.</p>
<p>In class-based languages, there are two core concepts: instances and classes. Instances store the state for each object and have a reference to the instance’s class. Classes contain the methods and inheritance chain. To call a method on an instance, there is always a level of indirection. You look up the instance’s class and then you find the method there:</p>
<p>Prototype-based languages merge these two concepts. There are only objects—no classes—and each individual object may contain state and methods. Objects can directly inherit from each other (or “delegate to” in prototypal lingo):</p>
<p>对于对象，实际上有两种方法实现，类和原型。类，更加通用，因为C++， Java，C#，firends等语言。原型几乎是一个被遗忘的分支，直到JavaScript 使用原型实现了面向对象。</p>
<p>在基于类的面向对象语言中，有两个核心概念：实例和类，实例中保存每个对象的状态，而且具有对实例类的引用。类，包含实现方法和继承链。如果通过实例，调用方法，总是存在一定程度上的间接。我们需要先找到实例对应的类，然后找到类的方法。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/class-lookup.png?raw=true" alt="class look-up" /></p>
<p>基于原型的面向对象语言中，融合了实例和类，这两个概念。它们只有对象，没有类，每个单独的对象包含状态和方法。对象可以直接相互继承（或者用原型中的术语，委托给）</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/prototype-lookup.png?raw=true" alt="class look-up" /></p>
<p>This means that in some ways prototypal languages are more fundamental than classes. They are really neat to implement because they’re so simple. Also, they can express lots of unusual patterns that classes steer you away from.</p>
<p>But I’ve looked at a lot of code written in prototypal languages—including  <a href="http://finch.stuffwithstuff.com/index.html">some of my own devising</a>. Do you know what people generally do with all of the power and flexibility of prototypes?  . . . They use them to reinvent classes.</p>
<p>I don’t know why that is, but people naturally seem to prefer a class-based (Classic? Classy?) style. Prototypes are simpler in the language, but they seem to accomplish that only by pushing the complexity onto the user. So, for Lox, we’ll save our users the trouble and bake classes right in.</p>
<p>这意味着某些方面，基于原型的语言，比基于类的语言，更加基础，它们实现起来非常简洁。此外，我们也可以实现很多不寻常的模式，而这些模式，通常基于类的语言都会尽量远离。</p>
<p>但是我看到很多，使用原型语言编写的代码，包括我自己的一些设计。你知道，人们通常如何利用原型的强大功能和灵活性吗？他们使用原型来改造类。</p>
<p>我不知道为什么会这样，人们似乎更加喜欢基于类的风格，尽管基于原型的语言更加容易理解。但是，基于原型的语言，似乎将更多的复杂性转移到用户身上了，因此，对于Lox语言，我们将省去这些麻烦，一开始就使用基于类的面向对象。</p>
<blockquote>
<p>In a statically typed language like C++, method lookup typically happens at compile time based on the static type of the instance, giving you static dispatch. In contrast, dynamic dispatch looks up the class of the actual instance object at runtime. This is how virtual methods in statically typed languages and all methods in a dynamically typed language like Lox work.</p>
<p>在C++ 这样的静态语言中，查找实例方法，一般是在编译阶段进行的，在编译时候，根据实例的静态类型，实现静态调度。相反的，动态调度，是在运行时候，才会去查看实例对应的对象类。 这就是，静态语言中的虚拟方法，和动态语言中的所有方法的工作方式。</p>
</blockquote>
<blockquote>
<p>In practice the line between class-based and prototype-based languages blurs. JavaScript’s “constructor function” notion pushes you pretty hard towards defining class-like objects. Meanwhile, class-based Ruby is perfectly happy to let you attach methods to individual instances.</p>
<p>在实践中，基于类和基于原型的语言之间的界限已经模糊了，JavaScript 的构造函数，让你很难定义一个基于类的对象；同样的，基于类的Ruby，非常乐意让你把方法添加到具体的实例上。</p>
</blockquote>
<h3 id="94-classes-in-lox"><a class="header" href="#94-classes-in-lox">9.4 Classes in Lox</a></h3>
<p>Lox语言中的类</p>
<p>Enough rationale, let’s see what we actually have. Classes encompass a constellation of features in most languages. For Lox, I’ve selected what I think are the brightest stars. You declare a class and its methods like so:</p>
<pre><code>
class Breakfast {
  cook() {
    print &quot;Eggs a-fryin'!&quot;;
  }

  serve(who) {
    print &quot;Enjoy your breakfast, &quot; + who + &quot;.&quot;;
  }
}

</code></pre>
<p>The body of a class contains its methods. They look like function declarations but without the fun keyword. When the class declaration is executed, Lox creates a class object and stores that in a variable named after the class. Just like functions, classes are first class in Lox.</p>
<pre><code>
// Store it in variables.
var someVariable = Breakfast;

// Pass it to functions.
someFunction(Breakfast);

</code></pre>
<p>Next, we need a way to create instances. We could add some sort of new keyword, but to keep things simple, in Lox the class itself is a factory function for instances. Call a class like a function, and it produces a new instance of itself.</p>
<pre><code>
var breakfast = Breakfast();
print breakfast; // &quot;Breakfast instance&quot;.

</code></pre>
<p>有了足够的理由，让我们看看Lox语言是如何实现的。在大多数的语言中，类包含了一系列特征，在Lox中，我选择了我认为的最闪亮的特性，我们可以这样定义一个类和它的方法：</p>
<pre><code>
class Breakfast {
  cook() {
    print &quot;Eggs a-fryin'!&quot;;
  }

  serve(who) {
    print &quot;Enjoy your breakfast, &quot; + who + &quot;.&quot;;
  }
}

</code></pre>
<p>类的主体，包含了它的方法，它们看起来像是函数声明，但是没有fun关键字。当执行类声明时候，Lox创建了一个类对象，并且将它保存在以类命名的变量中。像函数一样，类也是第一类对象。</p>
<pre><code>
// Store it in variables.
var someVariable = Breakfast;

// Pass it to functions.
someFunction(Breakfast);

</code></pre>
<p>接下来，我们需要一种创建实例的方法。我们可以添加一些关键字，但是为了简单起见，在Lox语言中，类本身作为实例的工厂函数。像函数一样调用类，就会产生一个实例。</p>
<pre><code>
var breakfast = Breakfast();
print breakfast; // &quot;Breakfast instance&quot;.

</code></pre>
<blockquote>
<p>Larry Wall, Perl’s inventor/prophet calls this the <a href="http://wiki.c2.com/?WaterbedTheory">“waterbed theory”</a>. Some complexity is essential and cannot be eliminated. If you push it down in one place, it swells up in another.</p>
<p>Larry Wall, Perl语言创始人，称之为水床理论——有些复杂性是无法消除，必不可少的。如果你在一个地方推它，它会在另一个地方膨胀。</p>
<p>Prototypal languages don’t so much eliminate the complexity of classes as they do make the user take that complexity by building their own class-like metaprogramming libraries.</p>
<p>原型语言并没有消除类的复杂性。而是，让用户自己构建元类编程库，来承担复杂性。</p>
</blockquote>
<h3 id="95-instantiation-and-initialization"><a class="header" href="#95-instantiation-and-initialization">9.5 Instantiation and initialization</a></h3>
<p>实例化和初始化</p>
<p>Classes that only have behavior aren’t super useful. The idea behind object-oriented programming is encapsulating behavior and state together. To do that, you need fields. Lox, like other dynamically typed languages, lets you freely add properties onto objects.</p>
<pre><code>
breakfast.meat = &quot;sausage&quot;;
breakfast.bread = &quot;sourdough&quot;;

</code></pre>
<p>Assigning to a field creates it if it doesn’t already exist.</p>
<p>If you want to access a field or method on the current object from within a method, you use good old this.</p>
<pre><code>
class Breakfast {
  serve(who) {
    print &quot;Enjoy your &quot; + this.meat + &quot; and &quot; +
        this.bread + &quot;, &quot; + who + &quot;.&quot;;
  }

  // ...
}

</code></pre>
<p>只有方法的类，不是非常有用，面向对象背后的思想是，将行为和状态封装在一起，为此，需要字段，Lox和其他动态语言一样，允许你在对象上自由添加对象属性。</p>
<pre><code>
breakfast.meat = &quot;sausage&quot;;
breakfast.bread = &quot;sourdough&quot;;

</code></pre>
<p>如果某个字段不存在，则分配给该字段将创建该字段，如果想要从方法中访问，当前对象的字段或者方法，需要使用this关键字</p>
<pre><code>
class Breakfast {
  serve(who) {
    print &quot;Enjoy your &quot; + this.meat + &quot; and &quot; +
        this.bread + &quot;, &quot; + who + &quot;.&quot;;
  }

  // ...
}

</code></pre>
<p>Part of encapsulating data within an object is ensuring the object is in a valid state when it’s created. To do that, you can define an initializer. If your class has a method named init(), it is called automatically when the object is constructed. Any parameters passed to the class are forwarded to its initializer.</p>
<pre><code>
class Breakfast {
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  // ...
}

var baconAndToast = Breakfast(&quot;bacon&quot;, &quot;toast&quot;);
baconAndToast.serve(&quot;Dear Reader&quot;);
// &quot;Enjoy your bacon and toast, Dear Reader.&quot;

</code></pre>
<p>在对象中封装的部分数据，是为了确保对象在创建时候处于有效状态。为此，我们可以创建一个初始化函数，如果类有一个名为init()的方法，那么我们在创建实例时候，自动调用该方法。传递给类的任何参数，都将变为类的初始值。</p>
<pre><code>
class Breakfast {
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  // ...
}

var baconAndToast = Breakfast(&quot;bacon&quot;, &quot;toast&quot;);
baconAndToast.serve(&quot;Dear Reader&quot;);
// &quot;Enjoy your bacon and toast, Dear Reader.&quot;

</code></pre>
<h3 id="96-inheritance"><a class="header" href="#96-inheritance">9.6 Inheritance</a></h3>
<p>继承</p>
<p>Every object-oriented language lets you not only define methods, but reuse them across multiple classes or objects. For that, Lox supports single inheritance. When you declare a class, you can specify a class that it inherits from using a less-than (&lt;) operator.</p>
<pre><code>
class Brunch &lt; Breakfast {
  drink() {
    print &quot;How about a Bloody Mary?&quot;;
  }
}

</code></pre>
<p>Here, Brunch is the derived class or subclass, and Breakfast is the base class or superclass.</p>
<p>每个面向对象语言，都允许你定义方法，并且在其他类或者对象中复用这些方法。Lox语言，同样支持单继承，声明类时候，可以使用运算符 &lt; 表示要继承的类。</p>
<pre><code>
class Brunch &lt; Breakfast {
  drink() {
    print &quot;How about a Bloody Mary?&quot;;
  }
}

</code></pre>
<p>Every method defined in the superclass is also available to its subclasses.</p>
<pre><code>
var benedict = Brunch(&quot;ham&quot;, &quot;English muffin&quot;);
benedict.serve(&quot;Noble Reader&quot;);

</code></pre>
<p>Even the init() method gets inherited. In practice, the subclass usually wants to define its own init() method too. But the original one also needs to be called so that the superclass can maintain its state. We need some way to call a method on our own instance without hitting our own methods.</p>
<p>As in Java, you use super for that.</p>
<pre><code>
class Brunch &lt; Breakfast {
  init(meat, bread, drink) {
    super.init(meat, bread);
    this.drink = drink;
  }
}

</code></pre>
<p>由上面的类声明，我们可以称 Brunch 为派生类或者子类，称 Breakfast 为基类或者超类。</p>
<p>每个基类中定义的方法，在它的派生类中，也可以调用</p>
<pre><code>
var benedict = Brunch(&quot;ham&quot;, &quot;English muffin&quot;);
benedict.serve(&quot;Noble Reader&quot;);

</code></pre>
<p>甚至init() 方法也可以被继承，实际上，子类通常也想要定义自己的init() 方法，但是也需要调用基类，以便于基类更新它的状态信息。我们需要一个方式，只调用超类中的某个方法，但是不调用自身的同名方法。在Java中，我们可以使用super实现。</p>
<pre><code>
class Brunch &lt; Breakfast {
  init(meat, bread, drink) {
    super.init(meat, bread);
    this.drink = drink;
  }
}

</code></pre>
<p>That’s about it for object orientation. I tried to keep the feature set minimal. The structure of the book did force one compromise. Lox is not a pure object-oriented language. In a true OOP language every object is an instance of a class, even primitive values like numbers and Booleans.</p>
<p>Because we don’t implement classes until well after we start working with the built-in types, that would have been hard. So values of primitive types aren’t real objects in the sense of being instances of classes. They don’t have methods or properties. If I were trying to make Lox a real language for real users, I would fix that.</p>
<p>这就是面向对象的方法，我试图保持功能集最小化，本书结构迫使我做出一定的妥协。Lox不是一种纯粹的面向对象语言，在真正的面向对象语言中，每个对象都是一个类的实例，即使是数值和布尔类型这样的原始值，都是一个类的实例。</p>
<p>因为我们在开始使用内置类后，才实现类，所以，实现纯粹的面向对象，比较困难。因此，从类实例的意义上，基本类型的值不是实例。它们没有方法，也没有属性。如果，我想要让Lox变为一门用户可用的真正的语言，我会尝试解决这个问题。</p>
<blockquote>
<p>Why the &lt; operator? I didn’t feel like introducing a new keyword like extends. Lox doesn’t use : for anything else so I didn’t want to reserve that either. Instead, I took a page from Ruby and used &lt;.</p>
<p>为什么要使用 &lt; 表示继承，而不是使用 extends 这样的关键字。同样的，Lox语言也不使用 : 用于任何用途，我从Ruby语言中得到灵感，使用&lt; 表示继承。</p>
<p>If you know any type theory, you’ll notice it’s not a totally arbitrary choice. Every instance of a subclass is an instance of its superclass too, but there may be instances of the superclass that are not instances of the subclass. That means, in the universe of objects, the set of subclass objects is smaller than the superclass’s set, though type nerds usually use &lt;: for that relation.</p>
<p>如果你知道一些类型理论，你会注意到，这不是一个完全武断的决定。子类的每个实例，同时，也是父类的一个实例。可能存在一个实例，是父类的实例，但不是其子类的实例。在对象宇宙中，子类对象集合小于父类对象集合，类型理论的书呆子，会使用 &lt;: 表示这种关系。</p>
<p>Lox is different from C++, Java, and C#, which do not inherit constructors, but similar to Smalltalk and Ruby, which do.</p>
<p>不同于 C++ Java C#, 它们不会继承父类的构造函数，Lox语言，更加类似 Smalltalk Ruby，会继承构造函数。</p>
</blockquote>
<h2 id="十the-standard-library"><a class="header" href="#十the-standard-library">十、The Standard Library</a></h2>
<p>标准库</p>
<p>We’re almost done. That’s the whole language, so all that’s left is the “core” or “standard” library—the set of functionality that is implemented directly in the interpreter and that all user-defined behavior is built on top of.</p>
<p>This is the saddest part of Lox. Its standard library goes beyond minimalism and veers close to outright nihilism. For the sample code in the book, we only need to demonstrate that code is running and doing what it’s supposed to do. For that, we already have the built-in print statement.</p>
<p>Later, when we start optimizing, we’ll write some benchmarks and see how long it takes to execute code. That means we need to track time, so we’ll define one built-in function, clock(), that returns the number of seconds since the program started.</p>
<p>我们差不多完成了Lox语言，这就是整个语言。剩下来的部分是核心库或者称为标准库——直接在解释器中实现的功能，所有用户定义的方法都建立在标准库上面。</p>
<p>这是Lox语言中最悲伤的地方，它的标准库超越了极简主义，转向了完全的虚无主义。对于书中的示例代码，我们只需要证明代码正在运行或者执行它应该执行的操作。为此，我们已经有了内置的print语句。</p>
<p>稍后，当我们优化时候，我们将编写一些基准测试代码，查看执行代码的耗时。这意味着我们需要跟踪时间，因此，我们定义一个内置函数 clock() , 它返回程序启动后的秒数。</p>
<p>And . . . that’s it. I know, right? It’s embarrassing.</p>
<p>If you wanted to turn Lox into an actual useful language, the very first thing you should do is flesh this out. String manipulation, trigonometric functions, file I/O, networking, heck, even reading input from the user would help. But we don’t need any of that for this book, and adding it wouldn’t teach you anything interesting, so I’ve left it out.</p>
<p>Don’t worry, we’ll have plenty of exciting stuff in the language itself to keep us busy.</p>
<p>如果你想把Lox语言变为一门真正有用的语言，第一件事情，就是充实Lox语言。字符串操作，三角函数，文件I/O，网络，检查，甚至读取用户输入都会有所帮助，但是本书将不会涉及。因为加上它们，不会增加任何有意义的地方，所以，我把它们删除了。</p>
<p>别担心，语言本身有很多令人兴奋的东西，让我们忙个不停。</p>
<h2 id="十一challenges"><a class="header" href="#十一challenges">十一、CHALLENGES</a></h2>
<p>习题</p>
<ol>
<li>
<p>Write some sample Lox programs and run them (you can use the implementations of Lox in my repository). Try to come up with edge case behavior I didn’t specify here. Does it do what you expect? Why or why not?</p>
</li>
<li>
<p>This informal introduction leaves a lot unspecified. List several open questions you have about the language’s syntax and semantics. What do you think the answers should be?</p>
</li>
<li>
<p>Lox is a pretty tiny language. What features do you think it is missing that would make it annoying to use for real programs? (Aside from the standard library, of course.)</p>
</li>
<li>
<p>编写一些Lox程序并且运行它们， 尝试给出一些书中没有提及的边缘示例，它是否符合你的期望，并给出原因？</p>
</li>
<li>
<p>本章的简短介绍留下了很多没有明确的地方，列出关于语言的语法和语义的几个开放性问题，你认为答案是什么？</p>
</li>
<li>
<p>Lox是一门很小的语言，你觉得还应该添加哪些新功能，这些功能的缺少，让你在实际应用时候感到恼火（除了标准库之外）</p>
</li>
</ol>
<h2 id="十二design-note-expressions-and-statements"><a class="header" href="#十二design-note-expressions-and-statements">十二、DESIGN NOTE: EXPRESSIONS AND STATEMENTS</a></h2>
<p>设计思想：表达式和语句</p>
<p>Lox has both expressions and statements. Some languages omit the latter. Instead, they treat declarations and control flow constructs as expressions too. These “everything is an expression” languages tend to have functional pedigrees and include most Lisps, SML, Haskell, Ruby, and CoffeeScript.</p>
<p>To do that, for each “statement-like” construct in the language, you need to decide what value it evaluates to. Some of those are easy:</p>
<ul>
<li>
<p>An if expression evaluates to the result of whichever branch is chosen. Likewise, a switch or other multi-way branch evaluates to whichever case is picked.</p>
</li>
<li>
<p>A variable declaration evaluates to the value of the variable.</p>
</li>
<li>
<p>A block evaluates to the result of the last expression in the sequence.</p>
</li>
</ul>
<p>Some get a little stranger. What should a loop evaluate to? A while loop in CoffeeScript evaluates to an array containing each element that the body evaluated to. That can be handy, or a waste of memory if you don’t need the array.</p>
<p>You also have to decide how these statement-like expressions compose with other expressions—you have to fit them into the grammar’s precedence table. For example, Ruby allows:</p>
<p>puts 1 + if true then 2 else 3 end + 4</p>
<p>Lox语言既有表达式，也有语句。有些语言省略了语句，它们会将声明和控制流也当作表达式，这些具有“一切都是表达式“特性的语言，往往具有函数式语言特征，例如：LISP，SML，Haskell，Ruby 和 CoffeeScript</p>
<p>要做到这一点，对于语言中的每一个语句结构，我们需要确定语句的最终值。其中，有些语句很简单：</p>
<ul>
<li>
<p>if 语句的计算结果是所选分支的结果。同样的，switch语句或者其他多路分支，计算结果为根据情况选择的分支的计算结果</p>
</li>
<li>
<p>变量声明语句的结果，为变量的值</p>
</li>
<li>
<p>代码块的计算结果为序列中最后一个表达式的结果</p>
</li>
</ul>
<p>还有一些语句，变得有些奇怪，循环语句的计算结果应该是什么？CoffeeScript 语言的循环语句的计算结果是一个数组，该数组包含了主体计算到的每个元素。这很方便，如果不使用这个数组，会浪费内存。</p>
<p>我们还需要确定一些类似语句的表达式，如何和其他表达式组合使用。我们需要将这些表达式放入语法的优先级表中。例如：Ruby语言中，</p>
<p>puts 1 + if true then 2 else 3 end + 4</p>
<p>这就是你所期待的吗？这就是用户期待的吗？这对于你自己设计语句有什么影响？需要注意，Ruby语言有个显示的关键词 end，表示表达式什么时候完成，如果没有end，+4部分可能被解析为else的一部分。</p>
<p>Turning every statement into an expression forces you to answer a few hairy questions like that. In return, you eliminate some redundancy. C has both blocks for sequencing statements, and the comma operator for sequencing expressions. It has both the if statement and the ?: conditional operator. If everything was an expression in C, you could unify each of those.</p>
<p>Languages that do away with statements usually also feature implicit returns—a function automatically returns whatever value its body evaluates to without need for some explicit return syntax. For small functions and methods, this is really handy. In fact, many languages that do have statements have added syntax like =&gt; to be able to define functions whose body is the result of evaluating a single expression.</p>
<p>将每个语句变为表达式，迫使我们回答上面的棘手问题，作为回报，这样做，消除了一些冗余。C语言中，既有语句，也包含表达式，例如：它既有if语句，也有三元运算符 ?: ，如果C语言中一切都是表达式，那么这两种写法将统一为一种。</p>
<p>不使用语句的语言，通常具有隐式返回特性——函数会自动返回计算结果，而不需要显示返回语句。对于小函数和方法，这样非常方便。事实上，很多存在语句的语言，都实现了=&gt; 这样的语法，定义一个函数，函数体是一个表达式的计算结果</p>
<p>But making all functions work that way can be a little strange. If you aren’t careful, your function will leak a return value even if you only intend it to produce a side effect. In practice, though, users of these languages don’t find it to be a problem.</p>
<p>For Lox, I gave it statements for prosaic reasons. I picked a C-like syntax for familiarity’s sake, and trying to take the existing C statement syntax and interpret it like expressions gets weird pretty fast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解析树"><a class="header" href="#解析树">解析树</a></h1>
<p>A TREE-WALK INTERPRETER</p>
<p>With this part, we begin jlox, the first of our two interpreters. Programming languages are a huge topic with piles of concepts and terminology to cram into your brain all at once. Programming language theory requires a level of mental rigor that you probably haven’t had to summon since your last calculus final. (Fortunately there isn’t too much theory in this book.)</p>
<p>Implementing an interpreter uses a few architectural tricks and design patterns uncommon in other kinds of applications, so we’ll be getting used to the engineering side of things too. Given all of that, we’ll keep the code we have to write as simple and plain as possible.</p>
<p>In less than two thousand lines of clean Java code, we’ll build a complete interpreter for Lox that implements every single feature of the language, exactly as we’ve specified. The first few chapters work front-to-back through the phases of the interpreter—scanning, parsing, and evaluating code. After that, we add language features one at a time, growing a simple calculator into a full-fledged scripting language.</p>
<p>第二部分，我们将从jLox解释器开始，jLox解释器，是我们将要介绍的两个解释器之一。编程语言是一个非常大的话题，有成堆的概念和术语，将一下子塞进你的大脑。编程语言理论，需要一定程度上的严谨性，这可能是你上一次微积分考试后，就没有再经历过的。但幸运的是，本书中，我们将很少涉及严谨的理论研究。</p>
<p>实现一个解释器，使用了其他类型应用程序中，不太使用的，架构技巧和设计模式。因此，我们将熟悉一些软件工程方面的事情，我们将编写尽可能简明的代码。</p>
<p>在不到两千行Java代码中，我们将实现一个Lox语言的完整的解释器，这个解释器，实现了语言的所有特性，正如我们期望的那样。接下来的几章，我们将介绍解释器的扫描、解析、优化阶段，之后，我们将一次直接添加一个特性，把一个简单的计算器，扩展为一个成熟的脚本语言。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="扫描"><a class="header" href="#扫描">扫描</a></h1>
<blockquote>
<p>Take big bites. Anything worth doing is worth overdoing.</p>
<p align="right"> —— Robert A. Heinlein, Time Enough for Love  </p>
<p>大口吃，任何值得做的事情，都值得做的过头。</p>
</blockquote>
<p>The first step in any compiler or interpreter is scanning. The scanner takes in raw source code as a series of characters and groups it into a series of chunks we call tokens. These are the meaningful “words” and “punctuation” that make up the language’s grammar.</p>
<p>Scanning is a good starting point for us too because the code isn’t very hard—pretty much a switch statement with delusions of grandeur. It will help us warm up before we tackle some of the more interesting material later. By the end of this chapter, we’ll have a full-featured, fast scanner that can take any string of Lox source code and produce the tokens that we’ll feed into the parser in the next chapter.</p>
<p>任何编译器或者解释器的，第一个阶段都是扫描。扫描器将源代码当作一系列的字符序列，经过扫描后，会分组为一系列的token，这些token是，构成语言语法的基本单位，例如：英语中的单词和标点符号。</p>
<p>扫描，对于我们来说，是一个好的起点，因为扫描部分代码，并不复杂——是一个有很多 switch语句的代码。扫描部分，是我们后面处理更加有趣阶段的热身。在本章结束时候，我们将拥有一个功能齐全的快速扫描器，它可以根据输入的任意Lox语言源代码，生成我们后面阶段会使用的 token序列。</p>
<h2 id="一the-interpreter-framework"><a class="header" href="#一the-interpreter-framework">一、The Interpreter Framework</a></h2>
<p>解释器架构</p>
<p>Since this is our first real chapter, before we get to actually scanning some code we need to sketch out the basic shape of our interpreter, jlox. Everything starts with a class in Java.</p>
<pre><code class="language-java">
// lox/Lox.java
package com.craftinginterpreters.lox;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

public class Lox {
  public static void main(String[] args) throws IOException {
    if (args.length &gt; 1) {
      System.out.println(&quot;Usage: jlox [script]&quot;);
      System.exit(64); 
    } else if (args.length == 1) {
      runFile(args[0]);
    } else {
      runPrompt();
    }
  }
}

</code></pre>
<p>Stick that in a text file, and go get your IDE or Makefile or whatever set up. I’ll be right here when you’re ready. Good? OK!</p>
<p>Lox is a scripting language, which means it executes directly from source. Our interpreter supports two ways of running code. If you start jlox from the command line and give it a path to a file, it reads the file and executes it.</p>
<pre><code class="language-java">
// lox/Lox.java

public class Lox {
    public static void main(String[] args) throws IOException {
		...
    }

    private static void runFile(String path) throws IOException {
        byte[] bytes = Files.readAllBytes(Paths.get(path));
        run(new String(bytes, Charset.defaultCharset()));
    }
}

</code></pre>
<p>If you want a more intimate conversation with your interpreter, you can also run it interactively. Fire up jlox without any arguments, and it drops you into a prompt where you can enter and execute code one line at a time.</p>
<pre><code class="language-java">
// lox/Lox.java
public class Lox {
    public static void main(String[] args) throws IOException {
		...
    }

    private static void runFile(String path) throws IOException {
		...
    }

    private static void runPrompt() throws IOException {
        InputStreamReader input = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(input);

        for (;;) {
            System.out.print(&quot;&gt; &quot;);
            String line = reader.readLine();
            if (line == null) {
                break;
            }
            run(line);
        }
    }
}
</code></pre>
<p>由于这是我们真正的开始章节，在我们实际扫描Lox代码之前，我们需要先描述 jlox 解释器的基本组成部分，一切从一个Java类开始。</p>
<p>将上面代码保存在文件中，可以选择你自己喜欢的IDE。</p>
<p>Lox语言是一种脚本语言，我的jlox解释器，支持两种运行方式，如果指定一个文件路径，jlox将读取并且运行该文件。</p>
<p>如果你想要与解释器，交互运行，可以运行交互模式。不携带任何参数运行jlox，将会进入交互模式，一次可以运行一行lox代码。</p>
<blockquote>
<p>An interactive prompt is also called a “REPL” (pronounced like “rebel” but with a “p”). The name comes from Lisp where implementing one is as simple as wrapping a loop around a few built-in functions: </p>
<p>(print (eval (read)))</p>
<p>Working outwards from the most nested call, you Read a line of input, Evaluate it, Print the result, then Loop and do it all over again.</p>
<p>交互式提示，也称为 REPL, (Read, Evaluate, Print, Loop) , 这个名称来源于 lisp语言，在lisp中，实现一个交互式，就好像使用内置多个函数和一个循环包装一样简单。</p>
<p>(print (eval (read)))</p>
<p>从最里面的代码开始，先读取一段代码，然后运行，最后打印结果，接下来，开始下一轮循环。</p>
</blockquote>
<p>The readLine() function, as the name so helpfully implies, reads a line of input from the user on the command line and returns the result. To kill an interactive command-line app, you usually type Control-D. Doing so signals an “end-of-file” condition to the program. When that happens readLine() returns null, so we check for that to exit the loop.</p>
<p>Both the prompt and the file runner are thin wrappers around this core function:</p>
<pre><code class="language-java">// lox/Lox.java

public class Lox {
    public static void main(String[] args) throws IOException {
		...
    }

    private static void runFile(String path) throws IOException {
		...
    }

    private static void runPrompt() throws IOException {
		...
    }

    private static void run(String source) {
        Scanner scanner = new Scanner(source);
        List&lt;Token&gt; tokens = scanner.scanTokens();

        for (Token token : tokens) {
            System.out.println(token);
        }
    }
}
</code></pre>
<p>readline() 函数，顾名思义，在命令行，读取用户输入的一行，然后返回运行结果。如果想要终止交互式程序，通常键入 Ctrl-D, 这样做，会向程序发出 文件已经结束信号，当这种情况发生后，readline() 函数，会返回null，我们程序中判断返回值，如果是null，退出循环，即退出交互式程序。</p>
<p>交互式或者从文件中读取，然后运行jlox 的核心函数是 run</p>
<p>It’s not super useful yet since we haven’t written the interpreter, but baby steps, you know? Right now, it prints out the tokens our forthcoming scanner will emit so that we can see if we’re making progress.</p>
<p>因为我们还没有开始编写解释器，所以jlox 还不是非常有用，但是你知道的，接下来，我们将实现扫描仪，run函数将返回扫描仪生成的token 列表，我们可以通过token序列，查看扫描器的运行效果。</p>
<h3 id="11-error-handling"><a class="header" href="#11-error-handling">1.1 Error handling</a></h3>
<p>错误处理</p>
<p>While we’re setting things up, another key piece of infrastructure is error handling. Textbooks sometimes gloss over this because it’s more a practical matter than a formal computer science-y problem. But if you care about making a language that’s actually usable, then handling errors gracefully is vital.</p>
<p>The tools our language provides for dealing with errors make up a large portion of its user interface. When the user’s code is working, they aren’t thinking about our language at all—their headspace is all about their program. It’s usually only when things go wrong that they notice our implementation.</p>
<p>When that happens, it’s up to us to give the user all the information they need to understand what went wrong and guide them gently back to where they are trying to go. Doing that well means thinking about error handling all through the implementation of our interpreter, starting now.</p>
<p>当我们开始运行解释器时候，另外一个需要考虑的基础功能是错误处理。在教科书中，通常不太涉及这个部分，因为错误处理更像是一个实际问题，而不是一个计算机科学的正式问题。但是，如果我们要真正使用一门语言，如果优雅的处理报错，是一个非常重要的部分。</p>
<p>我们语言实现的用于错误处理的工具，构成了用户界面的很大一部分，当用户代码正常运行时候，他们不会关心我们的语言，用户的顶部空间，将展示他们程序运行信息。</p>
<p>当发生错误时候，我们应该提供给用户足够的信息，用于定位哪里出现了问题，并引导用户回到报错的位置。做好这一点意味着从现在开始，在解释器的整个实现过程中，我们都需要考虑报错处理。</p>
<blockquote>
<p>Having said all that, for this interpreter, what we’ll build is pretty bare bones. I’d love to talk about interactive debuggers, static analyzers, and other fun stuff, but there’s only so much ink in the pen.</p>
<p>尽管如此，对于这个解释器来说，我们将构建的错误处理，是非常简单的。我很想谈谈交互式调试器、静态分析器和其他有意思的东西，但是笔里面现在只有这些墨水。</p>
</blockquote>
<pre><code class="language-java">
// lox/Lox.java, add after run()
static void error(int line, String message) {
	report(line, &quot;&quot;, message);
}

private static void report(int line, String where, String message) {
	System.err.println(&quot;[line &quot; + line + &quot;] Error&quot; + where + &quot;: &quot; + message);
	hadError = true;
}
	
</code></pre>
<p>This error() function and its report() helper tells the user some syntax error occurred on a given line. That is really the bare minimum to be able to claim you even have error reporting. Imagine if you accidentally left a dangling comma in some function call and the interpreter printed out:</p>
<pre><code>
Error: Unexpected &quot;,&quot; somewhere in your code. Good luck finding it!

</code></pre>
<p>That’s not very helpful. We need to at least point them to the right line. Even better would be the beginning and end column so they know where in the line. Even better than that is to show the user the offending line, like:</p>
<pre><code>
Error: Unexpected &quot;,&quot; in argument list.

    15 | function(first, second,);
                               ^-- Here.
							   
</code></pre>
<p>error() 函数 和 report() 函数，告诉用户某一行发生了语法错误，这实际上是报错处理的最低要求。想象一下，如果你在代码中添加了一个多余的逗号， 解释器运行结果如下:</p>
<pre><code>
Error: Unexpected &quot;,&quot; somewhere in your code. Good luck finding it!

</code></pre>
<p>这不是非常有帮助，我们至少应该指向正确的报错位置。更好的方式，是设置报错代码的起始位置和结束位置，以便于展示报错位置，更加好的做法是展示报错的原始代码行，例如：</p>
<pre><code>
Error: Unexpected &quot;,&quot; in argument list.

    15 | function(first, second,);
                               ^-- Here.
							   
</code></pre>
<p>I’d love to implement something like that in this book but the honest truth is that it’s a lot of grungy string manipulation code. Very useful for users, but not super fun to read in a book and not very technically interesting. So we’ll stick with just a line number. In your own interpreters, please do as I say and not as I do.</p>
<p>The primary reason we’re sticking this error reporting function in the main Lox class is because of that hadError field. It’s defined here:</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

public class Lox {
  static boolean hadError = false;
  ...
}
</code></pre>
<p>We’ll use this to ensure we don’t try to execute code that has a known error. Also, it lets us exit with a non-zero exit code like a good command line citizen should.</p>
<pre><code class="language-java">
// lox/Lox.java, in runFile()

private static void runFile(String path) throws IOException {
	byte[] bytes = Files.readAllBytes(Paths.get(path));
	run(new String(bytes, Charset.defaultCharset()));

	// Indicate an error in the exit code.
	if (hadError) {
		System.exit(65);
	}
}
	

</code></pre>
<p>We need to reset this flag in the interactive loop. If the user makes a mistake, it shouldn’t kill their entire session.</p>
<pre><code class="language-java">
// lox/Lox.java, in runPrompt()
    private static void runPrompt() throws IOException {
        InputStreamReader input = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(input);

        for (;;) {
            System.out.print(&quot;&gt; &quot;);
            String line = reader.readLine();
            if (line == null) {
                break;
            }
            run(line);
			hadError = false;
        }
    }



</code></pre>
<p>我很想在本书中，实现上面说的报错处理功能，老实说，这是一个非常糟糕的字符串处理代码。对于用户来说，错误处理非常重要，但是，对于我们来说，在技术上实现不是非常有趣。所以，我们将只使用一个行号，当你实现自己的解释器时候，尽量按照我说的去做，而不是按照我做的去做。</p>
<p>我们在Lox主类中，坚持使用report函数的原因是，我们定义了一个字段 hadError</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

public class Lox {
  static boolean hadError = false;
  ...
}
</code></pre>
<p>通过 hadError 字段，我们将确保在出现报错时候，不再执行代码。此外，利用该字段，我们可以退出程序，就像是一个好的命令行工具那样。</p>
<pre><code class="language-java">
// lox/Lox.java, in runFile()

private static void runFile(String path) throws IOException {
	byte[] bytes = Files.readAllBytes(Paths.get(path));
	run(new String(bytes, Charset.defaultCharset()));

	// Indicate an error in the exit code.
	if (hadError) {
		System.exit(65);
	}
}
	

</code></pre>
<p>我们需要在交互式执行时候，重置 hadError信息，如果用户写错了命令，不应该把整个会话断开。</p>
<pre><code class="language-java">
// lox/Lox.java, in runPrompt()
    private static void runPrompt() throws IOException {
        InputStreamReader input = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(input);

        for (;;) {
            System.out.print(&quot;&gt; &quot;);
            String line = reader.readLine();
            if (line == null) {
                break;
            }
            run(line);
			hadError = false;
        }
    }

</code></pre>
<p>The other reason I pulled the error reporting out here instead of stuffing it into the scanner and other phases where the error might occur is to remind you that it’s good engineering practice to separate the code that generates the errors from the code that reports them.</p>
<p>Various phases of the front end will detect errors, but it’s not really their job to know how to present that to a user. In a full-featured language implementation, you will likely have multiple ways errors get displayed: on stderr, in an IDE’s error window, logged to a file, etc. You don’t want that code smeared all over your scanner and parser.</p>
<p>Ideally, we would have an actual abstraction, some kind of “ErrorReporter” interface that gets passed to the scanner and parser so that we can swap out different reporting strategies. For our simple interpreter here, I didn’t do that, but I did at least move the code for error reporting into a different class.</p>
<p>我把error report函数独立出来，而不是把它们写入scanner，或者其他可能发生错误的阶段，是提醒你，将产生错误的代码，和报告错误的代码分开，是一个很好的工程实践。</p>
<p>前端的各个阶段都会检测错误，但是如何将错误呈现给用户，实际上不是它们的工作。在一个全功能的语言实现中，我们可能会实现多种报错展示，例如：在标准错误输出中（stderr），在IDE的报错展示界面，将报错信息写入日志，我们肯定不希望在前端的每个阶段，都实现一次报错处理。</p>
<p>理想状态下，我们将定义一个抽象接口，ErrorReporter ，这样，在不同的编译阶段，例如：在扫描、解析阶段，我们可以使用不同的报错策略。对于我们当前实现的简单的jlox解释器，我将不打算实现，但是至少，我将把报错处理函数，移动到另外一个类中。</p>
<blockquote>
<p>I had exactly that when I first implemented jlox. I ended up tearing it out because it felt over-engineered for the minimal interpreter in this book.</p>
<p>当我一开始实现jlox时候，我的确实现了，一个错误处理接口，但是，接下来，我又把这些代码删除了，因为，对于一个简洁的解释器，我们不应该过度设计错误处理。</p>
</blockquote>
<p>With some rudimentary error handling in place, our application shell is ready. Once we have a Scanner class with a scanTokens() method, we can start running it. Before we get to that, let’s get more precise about what tokens are.</p>
<p>有了基本的报错处理，我们可以进一步开始扫描器，一旦我们定义了一个带有 scanTokens方法的Scanner 类，我们可以考虑运行了。但是，在真正运行扫描器之前，我们还是需要先了解一下 token。</p>
<h2 id="二-lexemes-and-tokens"><a class="header" href="#二-lexemes-and-tokens">二、 Lexemes and Tokens</a></h2>
<p>词素 和 token</p>
<p>Here’s a line of Lox code:</p>
<pre><code class="language-java">
var language = &quot;lox&quot;;

</code></pre>
<p>Here, var is the keyword for declaring a variable. That three-character sequence “v-a-r” means something. But if we yank three letters out of the middle of language, like “g-u-a”, those don’t mean anything on their own.</p>
<p>That’s what lexical analysis is about. Our job is to scan through the list of characters and group them together into the smallest sequences that still represent something. Each of these blobs of characters is called a lexeme. In that example line of code, the lexemes are:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lexemes.png?raw=true" alt="lexeme" /></p>
<p>The lexemes are only the raw substrings of the source code. However, in the process of grouping character sequences into lexemes, we also stumble upon some other useful information. When we take the lexeme and bundle it together with that other data, the result is a token. It includes useful stuff like:</p>
<p>下面是一个Lox代码</p>
<pre><code class="language-java">
var language = &quot;lox&quot;;

</code></pre>
<p>在这里，var 用于声明一个变量，是一个关键字，3个字符 var 意味着什么。但是，如果我们从 language中取出3个字符，gua，这些字母没有实际含义。</p>
<p>这就是词法分析的意义，我们的工作是，扫描字符列表，然后，把它们组合成最小的序列，这些序列仍然代表了某些东西，这些字符序列，称为一个个词素，例如：</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lexemes.png?raw=true" alt="lexeme" /></p>
<p>词素只是源代码的字串，然而，在将字符列表组合成词素列表的过程中，我们还发现了一些其他有用信息。当我们将词素和其他有用信息绑定在一起时候，我们将获取到一个token，有用信息如下。</p>
<h3 id="21-token-type"><a class="header" href="#21-token-type">2.1 Token type</a></h3>
<p>tokne类型</p>
<p>Keywords are part of the shape of the language’s grammar, so the parser often has code like, “If the next token is while then do . . . ” That means the parser wants to know not just that it has a lexeme for some identifier, but that it has a reserved word, and which keyword it is.</p>
<p>The parser could categorize tokens from the raw lexeme by comparing the strings, but that’s slow and kind of ugly. Instead, at the point that we recognize a lexeme, we also remember which kind of lexeme it represents. We have a different type for each keyword, operator, bit of punctuation, and literal type.</p>
<pre><code class="language-java">
// lox/TokenType.java, create new file
package com.craftinginterpreters.lox;

enum TokenType {
  // Single-character tokens.
  LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
  COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,

  // One or two character tokens.
  BANG, BANG_EQUAL,
  EQUAL, EQUAL_EQUAL,
  GREATER, GREATER_EQUAL,
  LESS, LESS_EQUAL,

  // Literals.
  IDENTIFIER, STRING, NUMBER,

  // Keywords.
  AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,
  PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,

  EOF
}

</code></pre>
<p>关键字是语言语法的一部分，因此，解析器通常会有下面的逻辑：如果下一个token是 while，那么..., 这意味着，解析器不仅仅想要知道，它具有某个标识符，还想要知道它包含有一个保留字，用于关键字声明。</p>
<p>解析器可以通过比较字符串，对原始词素进行分类，但是这样既慢，并且非常难实现。相反，在我们识别一个词素的时候，每一个词素都有特定的类型，例如：关键字、运算符、标点符号、文字类型等等。</p>
<pre><code class="language-java">
// lox/TokenType.java, create new file
package com.craftinginterpreters.lox;

enum TokenType {
  // Single-character tokens.
  LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
  COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,

  // One or two character tokens.
  BANG, BANG_EQUAL,
  EQUAL, EQUAL_EQUAL,
  GREATER, GREATER_EQUAL,
  LESS, LESS_EQUAL,

  // Literals.
  IDENTIFIER, STRING, NUMBER,

  // Keywords.
  AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,
  PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,

  EOF
}

</code></pre>
<blockquote>
<p>After all, string comparison ends up looking at individual characters, and isn’t that the scanner’s job?</p>
<p>毕竟，字符串比较会最终比较每一个字符，这个不是扫描器的功能吗？</p>
</blockquote>
<h3 id="22-literal-value"><a class="header" href="#22-literal-value">2.2 Literal value</a></h3>
<p>字符值</p>
<p>There are lexemes for literal values—numbers and strings and the like. Since the scanner has to walk each character in the literal to correctly identify it, it can also convert that textual representation of a value to the living runtime object that will be used by the interpreter later</p>
<p>词素具有实际值，可能是数字，字符串等。由于扫描器需要遍历文本中的每一个字符，因此，扫描器扫描过程中，会将具体的文本值，转化为一个个运行时对象，在接下来的解释阶段，将使用这些对象。</p>
<h3 id="23-location-information"><a class="header" href="#23-location-information">2.3 Location information</a></h3>
<p>位置信息</p>
<p>Back when I was preaching the gospel about error handling, we saw that we need to tell users where errors occurred. Tracking that starts here. In our simple interpreter, we note only which line the token appears on, but more sophisticated implementations include the column and length too.</p>
<p>回到上一章，我宣传错误处理的时候，我们必须告诉用户错误发生的具体位置，而记录位置信息，是从这里开始的。在我们实现的简单的解释器中，我们只会记录行信息，但是，对于更加复杂的解释器，需要记录具体的列和长度信息。</p>
<blockquote>
<p>Some token implementations store the location as two numbers: the offset from the beginning of the source file to the beginning of the lexeme, and the length of the lexeme. The scanner needs to know these anyway, so there’s no overhead to calculate them.</p>
<p>有些token 实现中使用两个数字保存位置信息：从源文件开始到词素开始的偏移量，词素的长度，扫描器需要知道这些位置信息，计算这个位置，不是过度计算。</p>
<p>An offset can be converted to line and column positions later by looking back at the source file and counting the preceding newlines. That sounds slow, and it is. However, you need to do it only when you need to actually display a line and column to the user. Most tokens never appear in an error message. For those, the less time you spend calculating position information ahead of time, the better.</p>
<p>通过偏移量信息（即源文件到词素的偏移量），我们可以通过查看源文件，换算为具体的行、列信息。 注意，换行符的存在。这个过程看起来很慢，实际的确是，但是，我们只是在需要展示实际行、列信息时候，才需要如此计算。但是，大多数 token不会出现在错误信息中，所以，对于这些token，计算它们的位置信息不会消耗很多时间。</p>
</blockquote>
<p>We take all of this data and wrap it in a class.</p>
<pre><code class="language-java">
// lox/Token.java, create new file
package com.craftinginterpreters.lox;

class Token {
  final TokenType type;
  final String lexeme;
  final Object literal;
  final int line; 

  Token(TokenType type, String lexeme, Object literal, int line) {
    this.type = type;
    this.lexeme = lexeme;
    this.literal = literal;
    this.line = line;
  }

  public String toString() {
    return type + &quot; &quot; + lexeme + &quot; &quot; + literal;
  }
}

</code></pre>
<p>我们将token 打包为一个类。</p>
<pre><code class="language-java">
// lox/Token.java, create new file
package com.craftinginterpreters.lox;

class Token {
  final TokenType type;
  final String lexeme;
  final Object literal;
  final int line; 

  Token(TokenType type, String lexeme, Object literal, int line) {
    this.type = type;
    this.lexeme = lexeme;
    this.literal = literal;
    this.line = line;
  }

  public String toString() {
    return type + &quot; &quot; + lexeme + &quot; &quot; + literal;
  }
}

</code></pre>
<p>Now we have an object with enough structure to be useful for all of the later phases of the interpreter.</p>
<p>现在，我们拥有了一个对象，具有足够的结构，可以用于解释器后续阶段。</p>
<h2 id="三-regular-languages-and-expressions"><a class="header" href="#三-regular-languages-and-expressions">三、 Regular Languages and Expressions</a></h2>
<p>Now that we know what we’re trying to produce, let’s, well, produce it. The core of the scanner is a loop. Starting at the first character of the source code, the scanner figures out what lexeme the character belongs to, and consumes it and any following characters that are part of that lexeme. When it reaches the end of that lexeme, it emits a token.</p>
<p>Then it loops back and does it again, starting from the very next character in the source code. It keeps doing that, eating characters and occasionally, uh, excreting tokens, until it reaches the end of the input.</p>
<p>现在，我们知道了想要生产什么，那就让我们去生产吧。扫描器的核心是一个循环，从源代码的第一个字符开始，扫描器识别出该字符所属的词素，然后，继续扫描，一直到词素的结束。然后，扫描器会提交一个token。</p>
<p>然后，扫描器再次从前一个词素结尾开始，它会一直这样，扫描字符，偶尔，到达词素结尾，提交token，一直到源代码的结尾。</p>
<blockquote>
<p>Lexical analygator.</p>
<p>词法分析器</p>
</blockquote>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lexigator.png?raw=true" alt="lexical" /></p>
<p>The part of the loop where we look at a handful of characters to figure out which kind of lexeme it “matches” may sound familiar. If you know regular expressions, you might consider defining a regex for each kind of lexeme and using those to match characters. For example, Lox has the same rules as C for identifiers (variable names and the like). This regex matches one:</p>
<pre><code>
[a-zA-Z_][a-zA-Z_0-9]*

</code></pre>
<p>在扫描器的循环过程中，我们通过几个字符，判断出词素的类型，这看起来很熟悉。如果你知道正则表达式，你可能会为每种类型的词素，定义一个正则表达式，并且使用它来匹配字符。例如：lox语言中，对于标识符的定义（即变量名称）具有和C语言相同的规则，可以用正则表达式表示</p>
<pre><code>
[a-zA-Z_][a-zA-Z_0-9]*

</code></pre>
<p>If you did think of regular expressions, your intuition is a deep one. The rules that determine how a particular language groups characters into lexemes are called its lexical grammar. In Lox, as in most programming languages, the rules of that grammar are simple enough for the language to be classified a regular language. That’s the same “regular” as in regular expressions.</p>
<p>如果你想到了正则表达式，你的直觉是正确深刻的。如何将字符序列分组为词素的规则称为词法规则。在Lox中，和大多数的语言一样，该语法规则非常简单，可以将 lox语言归类为常规语言，这与正则表达式中的正则是一个含义。</p>
<blockquote>
<p>It pains me to gloss over the theory so much, especially when it’s as interesting as I think the Chomsky hierarchy and finite-state machines are. But the honest truth is other books cover this better than I could. Compilers: Principles, Techniques, and Tools (universally known as “the dragon book”) is the canonical reference.</p>
<p>我很痛苦的掩盖了这个理论，特别是当它像我认为的<a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">乔姆斯基谱系 (Chomsky hierarchy)</a>和<a href="https://en.wikipedia.org/wiki/Finite-state_machine">有限状态机 (Finite-state machine)</a>一样有意思。但老实说，其他书比我写得更好一些，<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">编译器：原理、技术和工具</a>，通常被称为龙书，是编译器领域的标准。</p>
</blockquote>
<p>You very precisely can recognize all of the different lexemes for Lox using regexes if you want to, and there’s a pile of interesting theory underlying why that is and what it means. Tools like Lex or Flex are designed expressly to let you do this—throw a handful of regexes at them, and they give you a complete scanner back.</p>
<p>Since our goal is to understand how a scanner does what it does, we won’t be delegating that task. We’re about handcrafted goods.</p>
<p>如果你想的话，你可以非常精确地使用正则表达式来识别Lox的所有不同词素，并且有一堆理论说明，为什么会这样，以及它的含义。像是 Lex Flex就是这样的工具，你可以向它们提供一些正则表达式，它们会生成一个完整的扫描器。</p>
<p>因为我们的目标是了解扫描器内部工作原理，所以我们不会使用Lex这样的工具，我们希望的是纯手工打造的工艺品。</p>
<blockquote>
<p>Lex was created by Mike Lesk and Eric Schmidt. Yes, the same Eric Schmidt who was executive chairman of Google. I’m not saying programming languages are a surefire path to wealth and fame, but we can count at least one mega billionaire among us.</p>
<p>lex是由  Mike Lesk 和 Eric Schmidt 开发的工具，是的，就是 google公司创始人  Eric Schmidt. 我并不是说编程语言可以让人变得富有，但是至少我们当中出现了一个亿万富翁。</p>
</blockquote>
<h2 id="四the-scanner-class"><a class="header" href="#四the-scanner-class">四、The Scanner Class</a></h2>
<p>扫描器类</p>
<p>Without further ado, let’s make ourselves a scanner.</p>
<p>不需要麻烦了，我们将自己实现一个扫描器。</p>
<pre><code class="language-java">
// lox/Scanner.java, create new file

package com.craftinginterpreters.lox;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.craftinginterpreters.lox.TokenType.*; 

class Scanner {
  private final String source;
  private final List&lt;Token&gt; tokens = new ArrayList&lt;&gt;();

  Scanner(String source) {
    this.source = source;
  }
}


</code></pre>
<blockquote>
<p>I know static imports are considered bad style by some, but they save me from having to sprinkle TokenType. all over the scanner and parser. Forgive me, but every character counts in a book.</p>
<p>我知道静态导入，被很多人认为是一种糟糕的写法，但是，静态导入，可以让我们的引用代码，不用再添加 TokenType , 扫描器和解释器，会充满 TokenType, 请原谅我，书中的每一个章节都很重要。</p>
</blockquote>
<p>We store the raw source code as a simple string, and we have a list ready to fill with tokens we’re going to generate. The aforementioned loop that does that looks like this:</p>
<p>我们将源代码存储为一个简单的字符串，我们有一个列表，扫描器提交的token都会写入这个列表。上面提到的扫描器循环，看起来是下面代码。</p>
<pre><code class="language-java">
// lox/Scanner.java, add after Scanner()

  List&lt;Token&gt; scanTokens() {
    while (!isAtEnd()) {
      // We are at the beginning of the next lexeme.
      start = current;
      scanToken();
    }

    tokens.add(new Token(EOF, &quot;&quot;, null, line));
    return tokens;
  }


</code></pre>
<p>The scanner works its way through the source code, adding tokens until it runs out of characters. Then it appends one final “end of file” token. That isn’t strictly needed, but it makes our parser a little cleaner.</p>
<p>This loop depends on a couple of fields to keep track of where the scanner is in the source code.</p>
<p>扫描器通过扫描源代码，添加token，一直到字符序列遍历完成。然后，在最后添加一个“文件结束”的token，这个文件结束 token不是严格必须的，但是它会让我们的解释器更加简洁。</p>
<p>循环阶段，依据几个字段，来追踪扫描器的具体位置信息。</p>
<pre><code class="language-java">
// lox/Scanner.java, in class Scanner
  private final List&lt;Token&gt; tokens = new ArrayList&lt;&gt;();
  private int start = 0;
  private int current = 0;
  private int line = 1;

  Scanner(String source) {

</code></pre>
<p>The start and current fields are offsets that index into the string. The start field points to the first character in the lexeme being scanned, and current points at the character currently being considered. The line field tracks what source line current is on so we can produce tokens that know their location.</p>
<p>Then we have one little helper function that tells us if we’ve consumed all the characters.</p>
<p>start 和 current变量表示词素的位置信息，start字段表示词素的第一个字符的位置，current表示当前扫描到的字符位置，line字段表示当前扫描的行，根据这些字段，我们可以构造token中的位置信息。</p>
<p>我们还定义一个函数 isAtEnd，用于判断是否已经扫描完。</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanTokens()

  private boolean isAtEnd() {
    return current &gt;= source.length();
  }
  
</code></pre>
<h2 id="五recognizing-lexemes"><a class="header" href="#五recognizing-lexemes">五、Recognizing Lexemes</a></h2>
<p>识别词素</p>
<p>In each turn of the loop, we scan a single token. This is the real heart of the scanner. We’ll start simple. Imagine if every lexeme were only a single character long. All you would need to do is consume the next character and pick a token type for it. Several lexemes are only a single character in Lox, so let’s start with those.</p>
<p>在循环过程中，我们会扫描token，这是扫描器的核心功能，我们从简单开始，设想一下，每个token都是一个简单的字符，我们需要做的是，继续判断下一个token，在Lox语言中，有几个词素是简单的一个字符，我们从这些单字符词素开始：</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanTokens()

  private void scanToken() {
    char c = advance();
    switch (c) {
      case '(': addToken(LEFT_PAREN); break;
      case ')': addToken(RIGHT_PAREN); break;
      case '{': addToken(LEFT_BRACE); break;
      case '}': addToken(RIGHT_BRACE); break;
      case ',': addToken(COMMA); break;
      case '.': addToken(DOT); break;
      case '-': addToken(MINUS); break;
      case '+': addToken(PLUS); break;
      case ';': addToken(SEMICOLON); break;
      case '*': addToken(STAR); break; 
    }
  }
  
</code></pre>
<blockquote>
<p>Wondering why / isn’t in here? Don’t worry, we’ll get to it.</p>
<p>为什么 / 符号不在上面的判断中，我们将会马上告诉你。</p>
</blockquote>
<p>Again, we need a couple of helper methods.</p>
<p>The advance() method consumes the next character in the source file and returns it. Where advance() is for input, addToken() is for output. It grabs the text of the current lexeme and creates a new token for it. We’ll use the other overload to handle tokens with literal values soon.</p>
<p>同样的，我们还需要定义几个方法。</p>
<p>advance() 方法获取源文件中的下一个字符，并且返回。 advance() 方法主要用于输入，addToken() 方法用于输出，它会获取当前词素文本，并且创建新的token，下面将很快应用另外一个 addToken() 重载方法</p>
<pre><code class="language-java">
// lox/Scanner.java, add after isAtEnd()

  private char advance() {
    return source.charAt(current++);
  }

  private void addToken(TokenType type) {
    addToken(type, null);
  }

  private void addToken(TokenType type, Object literal) {
    String text = source.substring(start, current);
    tokens.add(new Token(type, text, literal, line));
  }
  
</code></pre>
<h3 id="51-lexical-errors"><a class="header" href="#51-lexical-errors">5.1 Lexical errors</a></h3>
<p>词素错误</p>
<p>Before we get too far in, let’s take a moment to think about errors at the lexical level.  What happens if a user throws a source file containing some characters Lox doesn’t use, like @#^, at our interpreter? Right now, those characters get silently discarded. They aren’t used by the Lox language, but that doesn’t mean the interpreter can pretend they aren’t there. Instead, we report an error.</p>
<p>在我们深入探讨之前，需要花一点时间考虑一下词汇层面的错误。如果客户源文件中包含了，Lox语言中未定义的字符，例如 @#^，我们的jlox解释器将会如何处理？现在，我们的处理方式是，悄悄丢弃这些字符。但是，Lox语言中不使用它们，并不表示它们不存在，我们将报告一个错误。</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()
            case '*':
                addToken(STAR);
                break;
            default:
                Lox.error(line, &quot;Unexpected character.&quot;);
                break;
        }
		
</code></pre>
<p>Note that the erroneous character is still consumed by the earlier call to advance(). That’s important so that we don’t get stuck in an infinite loop.</p>
<p>Note also that we keep scanning. There may be other errors later in the program.  It gives our users a better experience if we detect as many of those as possible in one go. Otherwise, they see one tiny error and fix it, only to have the next error appear, and so on. Syntax error Whac-A-Mole is no fun.</p>
<p>(Don’t worry. Since hadError gets set, we’ll never try to execute any of the code, even though we keep going and scan the rest of it.)</p>
<p>需要⚠️，advance()方法，仍然会消费错误的字符，这一点非常重要，否则，我们将陷入到无限循环中。</p>
<p>还需要注意，我们一直在扫描源文件，扫描过程中，可能会有其他报错。如果我们一次性检测到尽可能多的报错，会给使用者更好的体验。否则，使用者看到一个小错误，并且修复，然后，又会出现下一个小错误，一直这样进行着。</p>
<p>别担心，即使遇到报错，我们继续扫描源文件，也不会真的执行程序，因为 hadError 的存在。</p>
<blockquote>
<p>The code reports each invalid character separately, so this shotguns the user with a blast of errors if they accidentally paste a big blob of weird text. Coalescing a run of invalid characters into a single error would give a nicer user experience.</p>
<p>代码会分别报告每一个非法字符，因此，如果客户意外粘贴了一大块非法的文本，使用者将会收到非常多的报错，将一系列的错误合并为一个错误，将提供更好的用户体验。</p>
</blockquote>
<h3 id="52-operators"><a class="header" href="#52-operators">5.2 Operators</a></h3>
<p>操作符</p>
<p>We have single-character lexemes working, but that doesn’t cover all of Lox’s operators. What about !? It’s a single character, right? Sometimes, yes, but if the very next character is an equals sign, then we should instead create a != lexeme. Note that the ! and = are not two independent operators. You can’t write ! = in Lox and have it behave like an inequality operator. That’s why we need to scan != as a single lexeme. Likewise, &lt;, &gt;, and = can all be followed by = to create the other equality and comparison operators.</p>
<p>我们现在已经考虑到单字符的操作符，但是，这并没有包含lox中的所有操作符。例如：！字符，是一个单字符操作符吗？但是，有时候，紧随着 ！后面的是一个 = ， 此时，我们应该创建一个 != 类型的token，而不是简单的 ！token. ⚠️，! 和 = 不是两个独立的操作符，在lox中，我们不会写 ! = 这种运算符， 一般写法为 != 。这样，我们需要把 !=当作一个单独的词素，相似的，&gt;= &lt;= 也应该视为单独的词素</p>
<p>For all of these, we need to look at the second character.</p>
<p>所以对于这些字符，我们需要继续扫描第二个字符</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

      case '*': addToken(STAR); break; 
      case '!':
        addToken(match('=') ? BANG_EQUAL : BANG);
        break;
      case '=':
        addToken(match('=') ? EQUAL_EQUAL : EQUAL);
        break;
      case '&lt;':
        addToken(match('=') ? LESS_EQUAL : LESS);
        break;
      case '&gt;':
        addToken(match('=') ? GREATER_EQUAL : GREATER);
        break;

      default:
	  
</code></pre>
<p>Those cases use this new method:</p>
<p>上面场景，需要添加新的方法。</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()

  private boolean match(char expected) {
    if (isAtEnd()) return false;
    if (source.charAt(current) != expected) return false;

    current++;
    return true;
  }
</code></pre>
<p>It’s like a conditional advance(). We only consume the current character if it’s what we’re looking for.</p>
<p>Using match(), we recognize these lexemes in two stages. When we reach, for example, !, we jump to its switch case. That means we know the lexeme starts with !. Then we look at the next character to determine if we’re on a != or merely a !.</p>
<p>match() 方法好像是一个有条件的 advance(), 只有当现在的字符是我们期望的，才会消费。</p>
<p>使用match()，我们可以分为两个阶段识别这些词素，当扫描到 ！时候，我们进入判断逻辑，判断下一个字符是不是 =，如果是=，则我们的词素是 !=</p>
<h2 id="六longer-lexemes"><a class="header" href="#六longer-lexemes">六、Longer Lexemes</a></h2>
<p>长词素</p>
<p>We’re still missing one operator: / for division. That character needs a little special handling because comments begin with a slash too.</p>
<p>我们仍然没有考虑到 / 运算符，一般用于表示除法，但是，该字符需要一些特殊处理，因为lox语言中，注释也是 / 字符开始的。</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

        break;
      case '/':
        if (match('/')) {
          // A comment goes until the end of the line.
          while (peek() != '\n' &amp;&amp; !isAtEnd()) advance();
        } else {
          addToken(SLASH);
        }
        break;

      default:
	  
</code></pre>
<p>This is similar to the other two-character operators, except that when we find a second /, we don’t end the token yet. Instead, we keep consuming characters until we reach the end of the line.</p>
<p>This is our general strategy for handling longer lexemes. After we detect the beginning of one, we shunt over to some lexeme-specific code that keeps eating characters until it sees the end.</p>
<p>这类似于其他的两个字符组成的词素，只有当我们找到第二个 /， 才能确定是注释。当我们发现下一个字符依然是 /，我们将不断消耗字符，一直到行尾。</p>
<p>这是我们处理较长词素的一般策略。在我们检测到一个特殊字符后，我们转向一些特定于该词素的代码，而这些代码一直会消费字符，一直到结束。</p>
<p>We’ve got another helper:</p>
<p>这个逻辑，可以变为新函数 peek()</p>
<pre><code class="language-java">
// lox/Scanner.java, add after match()

  private char peek() {
    if (isAtEnd()) return '\0';
    return source.charAt(current);
  }


</code></pre>
<p>It’s sort of like advance(), but doesn’t consume the character. This is called lookahead. Since it only looks at the current unconsumed character, we have one character of lookahead. The smaller this number is, generally, the faster the scanner runs. The rules of the lexical grammar dictate how much lookahead we need. Fortunately, most languages in wide use peek only one or two characters ahead.</p>
<p>peek() 方法和advance() 方法非常相似，但是peek()方法不会消费字符，我们称为前瞻。由于，它只会查看当前没有使用的字符，因此我们称之为前瞻。通常，这个peek() 调用次数越少，我们的扫描器会越快，词法规则，定义了我们可能需要peek() 的次数。幸运的是，大多数语言的只会有1个或者2个字符需要peek()</p>
<blockquote>
<p>Technically, match() is doing lookahead too. advance() and peek() are the fundamental operators and match() combines them.</p>
<p>从技术角度，match() 方法也是一种前瞻。advance() 和 peek() 方法是基础运算单元，match() 方法，可以由它们组合。</p>
</blockquote>
<p>Comments are lexemes, but they aren’t meaningful, and the parser doesn’t want to deal with them. So when we reach the end of the comment, we don’t call addToken(). When we loop back around to start the next lexeme, start gets reset and the comment’s lexeme disappears in a puff of smoke.</p>
<p>While we’re at it, now’s a good time to skip over those other meaningless characters: newlines and whitespace.</p>
<p>注释也是词素，但是它们没有实际意义，解析器也不会处理它们。因此，当我们到达行尾时候，我们不会添加新的token，当我们到达写一个词素时，将更新start，即，我们不会考虑注释部分词素。</p>
<p>同样的，也需要跳过其他没有实际意义的字符，例如：换行符 \n 和 其他空白符</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

        break;

      case ' ':
      case '\r':
      case '\t':
        // Ignore whitespace.
        break;

      case '\n':
        line++;
        break;

      default:
        Lox.error(line, &quot;Unexpected character.&quot;);

</code></pre>
<p>When encountering whitespace, we simply go back to the beginning of the scan loop. That starts a new lexeme after the whitespace character. For newlines, we do the same thing, but we also increment the line counter. (This is why we used peek() to find the newline ending a comment instead of match(). We want that newline to get us here so we can update line.)</p>
<p>当遇到空白字符，我们将回到扫描循环开始。这将在空白字符后，开始扫描下一个词素。对于换行符，我们同样这样，但是还需要增加行计数器。这就是，我们使用peek() 来查找注释行，行尾的换行符，而不是使用match() 方法，我们希望换行符，走到这个case分支，这样我们就可以增加行计数器，所以，我们可以更新行。</p>
<p>Our scanner is getting smarter. It can handle fairly free-form code like:</p>
<p>我们的扫描器越来越智能了，它可以处理这种类型的代码</p>
<pre><code class="language-java">
// this is a comment
(( )){} // grouping stuff
!*+-/=&lt;&gt; &lt;= == // operators

</code></pre>
<h3 id="61-string-literals"><a class="header" href="#61-string-literals">6.1 String literals</a></h3>
<p>字符串常量</p>
<p>Now that we’re comfortable with longer lexemes, we’re ready to tackle literals. We’ll do strings first, since they always begin with a specific character, &quot;.</p>
<p>既然现在，我们已经习惯了较长的词素，我们可以继续处理文字了。我们将首先处理，字符串，它们总是以 &quot; 字符开始。</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()
        break;

      case '&quot;': string(); break;

      default:
</code></pre>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()

  private void string() {
    while (peek() != '&quot;' &amp;&amp; !isAtEnd()) {
      if (peek() == '\n') line++;
      advance();
    }

    if (isAtEnd()) {
      Lox.error(line, &quot;Unterminated string.&quot;);
      return;
    }

    // The closing &quot;.
    advance();

    // Trim the surrounding quotes.
    String value = source.substring(start + 1, current - 1);
    addToken(STRING, value);
  }

</code></pre>
<p>Like with comments, we consume characters until we hit the &quot; that ends the string. We also gracefully handle running out of input before the string is closed and report an error for that.</p>
<p>For no particular reason, Lox supports multi-line strings. There are pros and cons to that, but prohibiting them was a little more complex than allowing them, so I left them in. That does mean we also need to update line when we hit a newline inside a string.</p>
<p>Finally, the last interesting bit is that when we create the token, we also produce the actual string value that will be used later by the interpreter. Here, that conversion only requires a substring() to strip off the surrounding quotes. If Lox supported escape sequences like \n, we’d unescape those here.</p>
<p>和注释一样，我们不断消费字符，直到遇到结尾的 &quot; 字符，如果源文件已经消费完了，但是仍然没有发现字符串结尾 &quot;, 我们将会报告一个错误。</p>
<p>没有什么特殊原因，lox语言支持多行字符串。这样做，各有利弊，但是禁止使用多行字符串，比支持使用更加复杂，所以，我将运行lox使用多行字符串。这意味着，如果字符串中遇到换行符，我们需要更新行计数器。</p>
<p>最后，还有一个有意思的地方，当我们创建token时候，还会包含字符串的实际值，稍后，解释器将会使用字符串的实际值。在这里，还需要一个子字符串函数，去除字符串的 &quot; 字符。如果lox支持转义，例如：\n, 我们在这里将取消转义。</p>
<h2 id="62-number-literals"><a class="header" href="#62-number-literals">6.2 Number literals</a></h2>
<p>数值</p>
<p>All numbers in Lox are floating point at runtime, but both integer and decimal literals are supported. A number literal is a series of digits optionally followed by a . and one or more trailing digits.</p>
<p>lox运行时候，所有的数字都是浮点数，但是，我们支持使用者使用整数 和十进制的数字。数值是一个数字序列，其中可能是整数，也可能是浮点数。</p>
<pre><code>
1234
12.34

</code></pre>
<p>We don’t allow a leading or trailing decimal point, so these are both invalid:</p>
<p>但是我们不允许，小数点之前或者之后，没有实际数字</p>
<pre><code>
.1234
1234.

</code></pre>
<blockquote>
<p>Since we look only for a digit to start a number, that means -123 is not a number literal. Instead, -123, is an expression that applies - to the number literal 123. In practice, the result is the same, though it has one interesting edge case if we were to add method calls on numbers. Consider:</p>
<p><code>print -123.abs();</code></p>
<p>This prints -123 because negation has lower precedence than method calls. We could fix that by making - part of the number literal. But then consider:</p>
<pre><code> var n = 123;
 print -n.abs();

</code></pre>
<p>This still produces -123, so now the language seems inconsistent. No matter what you do, some case ends up weird.</p>
<p>因为我们将数字当作，数值词素的一个开始，这意味着 -123 不是一个数字。对应的，-123 是一个表达式。实际上，表达式的计算结果 和 -123 相同，有一个有趣的边缘场景，如果对于数字进行方法调用，例如:</p>
<p><code>print -123.abs();</code></p>
<p>这将打印出 -123, 因为负数优先级 低于 方法调用，即先执行 abs() 方法，然后才会执行负数运算。我们可以将负数符号，添加到数值中，来解决这个问题。但是，还需要考虑下面场景:</p>
<pre><code>var n = 123;
print -n.abs();
</code></pre>
<p>上面的代码，将仍然打印出 -123，所以现在，lox语言出现了不一致，不管我们怎样修改，都会非常奇怪。</p>
</blockquote>
<p>We could easily support the former, but I left it out to keep things simple. The latter gets weird if we ever want to allow methods on numbers like 123.sqrt()</p>
<p>To recognize the beginning of a number lexeme, we look for any digit. It’s kind of tedious to add cases for every decimal digit, so we’ll stuff it in the default case instead.</p>
<p>对于 <code>.1234</code>这种形式的数值，我们可以很容易兼容它，但是，为了简单，lox将不支持这种写法。但是，如果我们允许 <code>1234.</code> 这种写法，<code>1234.sqrt()</code> 将会变得很令人疑惑。</p>
<p>为了识别数字词素的开头，我们将先发现一个数字，为每一个十进制数字添加大小写非常乏味，所以，我们将它们填充为默认的大小写。</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken(), replace 1 line
      default:
        if (isDigit(c)) {
          number();
        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }
        break;
</code></pre>
<p>This relies on this little utility:</p>
<p>这依赖于新的方法 isDigit()</p>
<pre><code class="language-java">
// lox/Scanner.java, add after peek()

  private boolean isDigit(char c) {
    return c &gt;= '0' &amp;&amp; c &lt;= '9';
  } 

</code></pre>
<blockquote>
<p>The Java standard library provides Character.isDigit(), which seems like a good fit. Alas, that method allows things like Devanagari digits, full-width numbers, and other funny stuff we don’t want.</p>
<p>java 标准库提供了 Character.isDigit() 函数，用于判断数字，看起俩很符合我们的要求。但是，这个函数可以兼容梵文数字，全宽数字，这样子虽然非常有意思，但不是我们想要的数字。</p>
</blockquote>
<p>Once we know we are in a number, we branch to a separate method to consume the rest of the literal, like we do with strings.</p>
<p>一旦我们遇到了数字，我们将不断消费下面的字符，这时候，我们将进入新的独立方法中，就像是我们处理字符串一样。</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()
  private void number() {
    while (isDigit(peek())) advance();

    // Look for a fractional part.
    if (peek() == '.' &amp;&amp; isDigit(peekNext())) {
      // Consume the &quot;.&quot;
      advance();

      while (isDigit(peek())) advance();
    }

    addToken(NUMBER,
        Double.parseDouble(source.substring(start, current)));
  }
  
</code></pre>
<p>We consume as many digits as we find for the integer part of the literal. Then we look for a fractional part, which is a decimal point (.) followed by at least one digit. If we do have a fractional part, again, we consume as many digits as we can find.</p>
<p>Looking past the decimal point requires a second character of lookahead since we don’t want to consume the . until we’re sure there is a digit after it. So we add:</p>
<p>我们将尽可能多的获取数值的整数部分，接下来，我们将寻找小数点部分，它由一个 . 字符开始，后面至少加上一个数字。如果我们有一个分数部分，我们同样将消费尽可能多的数字。</p>
<p>查看小数部分，需要我们前瞻后面的第二个字符，因为，如果小数点后面没有紧随着至少一个数字，我们将不会认为是一个小数部分。</p>
<pre><code class="language-java">
// lox/Scanner.java, add after peek()

  private char peekNext() {
    if (current + 1 &gt;= source.length()) return '\0';
    return source.charAt(current + 1);
  } 
</code></pre>
<blockquote>
<p>I could have made peek() take a parameter for the number of characters ahead to look instead of defining two functions, but that would allow arbitrarily far lookahead. Providing these two functions makes it clearer to a reader of the code that our scanner looks ahead at most two characters.</p>
<p>我本来可以定义一个 peek() 方法，接受一个参数，表示要前瞻的字符数，而不是定义两个函数，但是，这样，我们将允许任意长度的前瞻。提供了peek() 和 peeknext() 两个方法，可以更加明确，我们的扫描器，将最多允许2个字符的前瞻。</p>
</blockquote>
<p>Finally, we convert the lexeme to its numeric value. Our interpreter uses Java’s Double type to represent numbers, so we produce a value of that type. We’re using Java’s own parsing method to convert the lexeme to a real Java double. We could implement that ourselves, but, honestly, unless you’re trying to cram for an upcoming programming interview, it’s not worth your time.</p>
<p>The remaining literals are Booleans and nil, but we handle those as keywords, which gets us to . . . </p>
<p>最后，我们将词素转变为它的数值。我们解释器，使用java double类型表示数字，所以，扫描器这里，我们也将生成一个double数字。我们使用java 的parse方法，将数值变为双精度数字。其实，我们也可以自己实现双精度数字的转换，但是，除非你在准备编程面试，没有必要浪费时间。</p>
<p>剩下来，是布尔类型和 nil，但是我们将这些当作关键字处理，下面我们将探讨这些。</p>
<h2 id="七reserved-words-and-identifiers"><a class="header" href="#七reserved-words-and-identifiers">七、Reserved Words and Identifiers</a></h2>
<p>保留字和标识符</p>
<p>Our scanner is almost done. The only remaining pieces of the lexical grammar to implement are identifiers and their close cousins, the reserved words. You might think we could match keywords like or in the same way we handle multiple-character operators like &lt;=.</p>
<p>我们的扫描仪几乎快完成了。词法中还没有实现的是，标识符和保留字。你可能认为，我们应该像 &lt;= 一样，一个个字符去匹配关键字，例如：我们要匹配 or ，代码如下</p>
<pre><code class="language-java">case 'o':
  if (match('r')) {
    addToken(OR);
  }
  break;
</code></pre>
<p>Consider what would happen if a user named a variable orchid.  The scanner would see the first two letters, or, and immediately emit an or keyword token. This gets us to an important principle called maximal munch. When two lexical grammar rules can both match a chunk of code that the scanner is looking at, whichever one matches the most characters wins.</p>
<p>That rule states that if we can match orchid as an identifier and or as a keyword, then the former wins. This is also why we tacitly assumed, previously, that &lt;= should be scanned as a single &lt;= token and not &lt; followed by =.</p>
<p>考虑一下，当我们命名一个变量 orchid ，如果我们扫描到该变量，将会发生什么？扫描器将会根据前面的两个字符 or, 立即提交一个token， 下面我们将介绍扫描器的一个重要的原则，<a href="https://en.wikipedia.org/wiki/Maximal_munch">最大匹配原则</a>, 当扫描器当前扫描的词素，同时满足两个词法规则，匹配最长字符的词法规则被命中。</p>
<p>例如：orchid，能匹配两个词法规则，可以被当作一个标识符orchid，或被当作一个关键词 or, 根据最大匹配原则，我们选择 orchild 为一个标识符。同样的，这也是，为什么我们把 &lt;= 当作一个完整的词素，而不是把 &lt; 当作一个词素。</p>
<blockquote>
<p>Consider this nasty bit of C code:</p>
<p><code>---a;</code></p>
<p>Is it valid? That depends on how the scanner splits the lexemes. What if the scanner sees it like this:</p>
<p><code>- --a</code></p>
<p>Then it could be parsed. But that would require the scanner to know about the grammatical structure of the surrounding code, which entangles things more than we want. Instead, the maximal munch rule says that it is always scanned like:</p>
<p><code>-- -a</code></p>
<p>It scans it that way even though doing so leads to a syntax error later in the parser.</p>
<p>考虑一下，这个讨厌的c代码</p>
<p><code>---a;</code></p>
<p>这个语句是否合法，这取决于扫描器如何分割这个词素，如果扫描器把这个代码看作 </p>
<p><code>- --a;</code></p>
<p>这样，是可以被解析的，但是，这需要扫描器了解周围代码的语法结构，这会让事情比我们想象的更加复杂。但是，实际上，按照最大匹配原则，它实际上应该是</p>
<p><code>-- -a;</code></p>
<p>扫描器将会如上面这样，扫描代码，即使这样，会导致解析器中的语法错误。</p>
</blockquote>
<p>Maximal munch means we can’t easily detect a reserved word until we’ve reached the end of what might instead be an identifier. After all, a reserved word is an identifier, it’s just one that has been claimed by the language for its own use. That’s where the term reserved word comes from.</p>
<p>最大匹配原则，意味着我们无法简单的判断一个词素是标识符，直到我们扫描到了可以确定是标识符结尾的位置。实际上，保留字也是一个标识符，它只是lox语言为了自己本身使用，而声明的一个标识符。这就是术语，保留字的来源。</p>
<p>So we begin by assuming any lexeme starting with a letter or underscore is an identifier.</p>
<p>所以，我们首先假设任何以字母或者下划线，开始的单词，都是一个标识符</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

      default:
        if (isDigit(c)) {
          number();
        } else if (isAlpha(c)) {
          identifier();
        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }

</code></pre>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()
  private void identifier() {
    while (isAlphaNumeric(peek())) advance();

    addToken(IDENTIFIER);
  }

</code></pre>
<pre><code class="language-java">
// lox/Scanner.java, add after peekNext()

  private boolean isAlpha(char c) {
    return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') ||
           (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ||
            c == '_';
  }

  private boolean isAlphaNumeric(char c) {
    return isAlpha(c) || isDigit(c);
  }
</code></pre>
<p>That gets identifiers working. To handle keywords, we see if the identifier’s lexeme is one of the reserved words. If so, we use a token type specific to that keyword. We define the set of reserved words in a map.</p>
<p>上面的代码将会识别出标识符，为了处理关键字，我们将查看标识符的词素是否是一个保留字，如果是保留字，我们将会定义为特殊类型，下面是一组预定义的保留字。</p>
<pre><code class="language-java">
// lox/Scanner.java, in class Scanner
	private static final Map&lt;String, TokenType&gt; keywords;


    static {
        keywords = new HashMap&lt;&gt;();
        keywords.put(&quot;and&quot;, AND);
        keywords.put(&quot;class&quot;, CLASS);
        keywords.put(&quot;else&quot;, ELSE);
        keywords.put(&quot;false&quot;, FALSE);
        keywords.put(&quot;for&quot;, FOR);
        keywords.put(&quot;fun&quot;, FUN);
        keywords.put(&quot;if&quot;, IF);
        keywords.put(&quot;nil&quot;, NIL);
        keywords.put(&quot;or&quot;, OR);
        keywords.put(&quot;print&quot;, PRINT);
        keywords.put(&quot;return&quot;, RETURN);
        keywords.put(&quot;super&quot;, SUPER);
        keywords.put(&quot;this&quot;, THIS);
        keywords.put(&quot;true&quot;, TRUE);
        keywords.put(&quot;var&quot;, VAR);
        keywords.put(&quot;while&quot;, WHILE);
    }
</code></pre>
<p>Then, after we scan an identifier, we check to see if it matches anything in the map.</p>
<p>然后，我们在确定一个标识符后，可以在判断一下是否是关键字</p>
<pre><code class="language-java">
// lox/Scanner.java, in identifier(), replace 1 line

    private void identifier() {
        while (isAlphaNumberic(peek()))
            advance();
        String text = source.substring(start, current);
        TokenType type = keywords.get(text);
        if (type == null)
            type = IDENTIFIER;
        addToken(type);
    }
  
</code></pre>
<p>If so, we use that keyword’s token type. Otherwise, it’s a regular user-defined identifier.</p>
<p>And with that, we now have a complete scanner for the entire Lox lexical grammar. Fire up the REPL and type in some valid and invalid code. Does it produce the tokens you expect? Try to come up with some interesting edge cases and see if it handles them as it should.</p>
<p>如果标识符是一个关键字，我们提交的token需要为关键字类型。</p>
<p>有了这些，我们现在有了一个完整的扫描器。可以扫描整个lox程序。启动扫描器，输入一些lox代码，执行看看。它是否会输出你想要的token列表，尽可能尝试一些边缘示例，看看我们的扫描器是否可以执行呢？</p>
<h2 id="八挑战习题"><a class="header" href="#八挑战习题">八、挑战习题</a></h2>
<ol>
<li>
<p>The lexical grammars of Python and Haskell are not regular. What does that mean, and why aren’t they?</p>
<p>python 和 Haskell语言词法规则 不是规则的，这是什么意思？它们为什么不是规则的呢？</p>
</li>
<li>
<p>Aside from separating tokens—distinguishing print foo from printfoo—spaces aren’t used for much in most languages. However, in a couple of dark corners, a space does affect how code is parsed in CoffeeScript, Ruby, and the C preprocessor. Where and what effect does it have in each of those languages?</p>
<p>除了区分 <code>print foo</code> 和 <code>printfoo</code> , 空格在大多数的语言中没有太多作用。然而，在很多偏僻的角落，空格会影响 CoffeeScript, Ruby, C预处理器，解析代码。在这些语言中，它们分别有什么影响呢？</p>
</li>
<li>
<p>Our scanner here, like most, discards comments and whitespace since those aren’t needed by the parser. Why might you want to write a scanner that does not discard those? What would it be useful for?</p>
<p>我们的扫描器和大多数的扫描器一样，会丢弃注释和空白字符，因为，解释器不需要它。为什么要编写一个保留注释和空白字符的扫描器呢？它有什么作用呢？</p>
</li>
<li>
<p>Add support to Lox’s scanner for C-style /* ... */ block comments. Make sure to handle newlines in them. Consider allowing them to nest. Is adding support for nesting more work than you expected? Why?</p>
<p>为lox扫描器，添加 /* ... */ 形式的注释语法，确保正确处理其中的换行符。还需要考虑嵌套，添加嵌套支持的工作量是否超过你的预期？为什么？</p>
</li>
</ol>
<h2 id="九design-note-implicit-semicolons"><a class="header" href="#九design-note-implicit-semicolons">九、DESIGN NOTE: IMPLICIT SEMICOLONS</a></h2>
<p>设计思路：隐式分号</p>
<p>Programmers today are spoiled for choice in languages and have gotten picky about syntax. They want their language to look clean and modern. One bit of syntactic lichen that almost every new language scrapes off (and some ancient ones like BASIC never had) is ; as an explicit statement terminator.</p>
<p>Instead, they treat a newline as a statement terminator where it makes sense to do so. The “where it makes sense” part is the challenging bit. While most statements are on their own line, sometimes you need to spread a single statement across a couple of lines. Those intermingled newlines should not be treated as terminators.</p>
<p>今天的程序员被语言的选择宠坏了，对语法变得非常挑剔，他们希望自己使用的语言看起来干净、现代。几乎每一种现代语言都会删除一些语法苔藓（有些古老语言，例如: BASIC, 从未删除）。例如： ; 作为显示的语句终止符</p>
<p>相反，它们都将换行符当作语句终止符号，在合适的时候。其中，合适的时候，是指一个语句只会在一行中。但是，还有一些语句，会分散到多行中。这些语句分散的行中，换行符不应该被当作终止符号。</p>
<p>Most of the obvious cases where the newline should be ignored are easy to detect, but there are a handful of nasty ones:</p>
<ul>
<li>
<p>A return value on the next line:</p>
<pre><code>if (condition) return
&quot;value&quot;
</code></pre>
<p>Is “value” the value being returned, or do we have a return statement with no value followed by an expression statement containing a string literal?</p>
</li>
<li>
<p>A parenthesized expression on the next line:</p>
<pre><code>func
(parenthesized)

</code></pre>
<p>Is this a call to func(parenthesized), or two expression statements, one for func and one for a parenthesized expression?</p>
</li>
<li>
<p>A - on the next line:</p>
<pre><code>
first
-second

</code></pre>
<p>Is this first - second—an infix subtraction—or two expression statements, one for first and one to negate second?</p>
</li>
</ul>
<p>大多数应该忽略换行符的场景，都很容易被发现，但是，也有一些令人讨厌的场景：</p>
<ul>
<li>
<p>返回着在下一行</p>
<pre><code>if (condition) return
&quot;value&quot;
</code></pre>
<p>这是一个return 语句，返回 &quot;value&quot;; 还是一个return语句，没有返回值；紧跟着一个字符串表达式</p>
</li>
<li>
<p>下一行，是括号表达式</p>
<pre><code>func
(parenthesized)

</code></pre>
<p>这是一个函数调用，还是一个func 表达式，紧跟着一个括号表达式</p>
</li>
<li>
<p>负号出现在下一行</p>
<pre><code>first
-second
</code></pre>
<p>这是一个中缀减法表达式，还是两个表达式呢</p>
</li>
</ul>
<p>In all of these, either treating the newline as a separator or not would both produce valid code, but possibly not the code the user wants. Across languages, there is an unsettling variety of rules used to decide which newlines are separators. Here are a couple:</p>
<ul>
<li>
<p>Lua completely ignores newlines, but carefully controls its grammar such that no separator between statements is needed at all in most cases. This is perfectly legit:</p>
<p><code>a = 1 b = 2</code></p>
<p>Lua avoids the return problem by requiring a return statement to be the very last statement in a block. If there is a value after return before the keyword end, it must be for the return. For the other two cases, they allow an explicit ; and expect users to use that. In practice, that almost never happens because there’s no point in a parenthesized or unary negation expression statement.</p>
</li>
<li>
<p>Go handles newlines in the scanner. If a newline appears following one of a handful of token types that are known to potentially end a statement, the newline is treated like a semicolon. Otherwise it is ignored. The Go team provides a canonical code formatter, gofmt, and the ecosystem is fervent about its use, which ensures that idiomatic styled code works well with this simple rule.</p>
</li>
<li>
<p>Python treats all newlines as significant unless an explicit backslash is used at the end of a line to continue it to the next line. However, newlines anywhere inside a pair of brackets ((), [], or {}) are ignored. Idiomatic style strongly prefers the latter.</p>
<p>This rule works well for Python because it is a highly statement-oriented language. In particular, Python’s grammar ensures a statement never appears inside an expression. C does the same, but many other languages which have a “lambda” or function literal syntax do not.</p>
<p>An example in JavaScript:</p>
<pre><code class="language-javascript">console.log(function() {
  statement();
});
</code></pre>
<p>Here, the console.log() expression contains a function literal which in turn contains the statement statement();.</p>
<p>Python would need a different set of rules for implicitly joining lines if you could get back into a statement where newlines should become meaningful while still nested inside brackets.</p>
</li>
<li>
<p>JavaScript’s “automatic semicolon insertion” rule is the real odd one. Where other languages assume most newlines are meaningful and only a few should be ignored in multi-line statements, JS assumes the opposite. It treats all of your newlines as meaningless whitespace unless it encounters a parse error. If it does, it goes back and tries turning the previous newline into a semicolon to get something grammatically valid.</p>
<p>This design note would turn into a design diatribe if I went into complete detail about how that even works, much less all the various ways that JavaScript’s “solution” is a bad idea. It’s a mess. JavaScript is the only language I know where many style guides demand explicit semicolons after every statement even though the language theoretically lets you elide them.</p>
</li>
</ul>
<p>If you’re designing a new language, you almost surely should avoid an explicit statement terminator. Programmers are creatures of fashion like other humans, and semicolons are as passé as ALL CAPS KEYWORDS. Just make sure you pick a set of rules that make sense for your language’s particular grammar and idioms. And don’t do what JavaScript did.</p>
<p>上面的场景中，将换行符当作分隔符，或者不把换行符当作分隔符，都可以产生有效的代码。但是，这样可能产生的不是用户想要的效果。在不同的语言中，有许多特殊规则，指定了哪些换行符是分隔符。</p>
<ul>
<li>
<p>Lua语言中，完全忽略了换行符，但是，需要小心的使用。在大多数场景，没有换行符的语句，可以正常运行，例如：orchid</p>
<p><code>a = 1 b = 2</code></p>
<p>Lua通过将代码块中的最后一条语句定义为return 语句，来避免return问题。</p>
<p>(1) 如果关键词 return 之后，end关键词之前，存在 &quot;value&quot; 字符串，则Lua中表示返回 &quot;value&quot;</p>
<pre><code>return 
&quot;value&quot;
</code></pre>
<p>(2) 其他两种情况，几乎不会发生，因为括号或者一元否定表达式语句，几乎没有意义</p>
</li>
<li>
<p>go语言，会处理扫描仪中的换行符。如果换行符，出现在可能是结束标志后，则换行符被当作隔离符。否则，换行符将被忽略。go开发团队提供了一个代码格式化的程序gofmt，go生态中非常热衷于使用它，这保证了习惯风格的代码和换行符规则可以很好的配合。</p>
</li>
<li>
<p>Python语言将所有的换行符，视为有效的。除了，你在一行的末尾，使用显示的 \ ，表示代码将继续到下一行中。但是，在<code>() [] {} </code>中的换行符将被忽略。python习惯风格也是这样的</p>
<p>在Python中，这些规则很好的运行，因为它是一种高度面向语句的语言。特别的，python的语法规则，保证了表达式中，不会出现语句。C语言也是这样做的，但是很多语言，包含了 <code>lambda</code>函数或者其他函数，可能会在表达式中包含有语句。</p>
<p>例如，javascript中的代码</p>
<pre><code class="language-javascript">console.log(function() {
  statement();
});
</code></pre>
<p>如上，console.log() 函数中，包含了一个匿名函数，函数代码中包含一个语句 statement();</p>
</li>
<li>
<p>javascript语言</p>
</li>
</ul>
<p>如果你正在设计一种语言，你应该避免使用显示分隔符，程序员也会紧跟时尚，分号和所有的大写关键词，都是过时设计。只需要确保，你选择了一套对于新语言特定短语和习语，都有意义的规则。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="representing-code"><a class="header" href="#representing-code">Representing Code</a></h1>
<p>代码表示</p>
<blockquote>
<p>To dwellers in a wood, almost every species of tree has its voice as well as its feature.</p>
<p align="right"> Thomas Hardy, Under the Greenwood Tree</p>
<p>对于森林中的居民来说，几乎每一棵树木都有自己的声音和特征。</p>
</blockquote>
<p>In the last chapter, we took the raw source code as a string and transformed it into a slightly higher-level representation: a series of tokens. The parser we’ll write in the next chapter takes those tokens and transforms them yet again, into an even richer, more complex representation.</p>
<p>Before we can produce that representation, we need to define it.That’s the subject of this chapter. Along the way, we’ll cover some theory around formal grammars, feel the difference between functional and object-oriented programming, go over a couple of design patterns, and do some metaprogramming.</p>
<p>在上一章中，我们通过扫描器，将源代码转换为稍微高级一些的表示：一系列的token。下一章，将要介绍的解释器，会把tokens，转换为更加丰富、复杂的表示。</p>
<p>在我们使用解释器之前，我们需要先定义token，这是本章节的主题。在本章，我们将介绍一些形式语法理论，感受函数式编程和面向对象编程的区别。我们还将讨论一些设计模式，进行一些元编程。</p>
<blockquote>
<p>I was so worried about this being one of the most boring chapters in the book that I kept stuffing more fun ideas into it until I ran out of room.</p>
<p>我一直担心，本章节是此书中最无聊的一章，所以，我一直添加有意思的东西，直到塞满了本章。</p>
</blockquote>
<p>Before we do all that, let’s focus on the main goal—a representation for code. It should be simple for the parser to produce and easy for the interpreter to consume. If you haven’t written a parser or interpreter yet, those requirements aren’t exactly illuminating. Maybe your intuition can help. What is your brain doing when you play the part of a human interpreter? How do you mentally evaluate an arithmetic expression like this:</p>
<pre><code>1 + 2 * 3 - 4
</code></pre>
<p>Because you understand the order of operations—the old “Please Excuse My Dear Aunt Sally” stuff—you know that the multiplication is evaluated before the addition or subtraction. One way to visualize that precedence is using a tree. Leaf nodes are numbers, and interior nodes are operators with branches for each of their operands.</p>
<p>In order to evaluate an arithmetic node, you need to know the numeric values of its subtrees, so you have to evaluate those first. That means working your way from the leaves up to the root—a post-order traversal:</p>
<p>A. Starting with the full tree, evaluate the bottom-most operation, 2 * 3.</p>
<p>B. Now we can evaluate the +.</p>
<p>C. Next, the -.</p>
<p>D. The final answer.</p>
<p>在我们开始做这些之前，让我们先关注主要目标-代码表示。它应该容易被解释器生成，并且解释器更加容易使用它们。但是，如果你还没有编写过解释器或者编译器，那么这些需求你可能不太熟悉。也许，你的直觉将会起作用。当你在扮演人类语言翻译角色时候，你的大脑会如何思考？让我们来看一下下面的示例，你会如何计算下面的算术表达式：</p>
<pre><code>1 + 2 * 3 - 4
</code></pre>
<p>因为我们知道算术运算符的优先级，所以，我们知道乘法会优先加减法，先计算。可视化运算优先级的一种方法是，使用树结构。其中，叶节点是具体的数字，中间层节点是运算符。</p>
<p>In order to evaluate an arithmetic node, you need to know the numeric values of its subtrees, so you have to evaluate those first. That means working your way from the leaves up to the root—a post-order traversal:</p>
<p>为了计算算术节点，我们需要知道它的子树的结果，所以，我们需要先计算这些子树的结果，这意味着，我们需要从叶节点到根节点计算，也就是一个后序遍历。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/tree-evaluate.png?raw=true" alt="tree-travel" /></p>
<p>由上图，可以看到计算步骤</p>
<p>A. 计算最底层的表达式，2 * 3</p>
<p>B. 计算加法表达式</p>
<p>C. 计算减法表达式</p>
<p>D. 得到最终结果</p>
<p>If I gave you an arithmetic expression, you could draw one of these trees pretty easily. Given a tree, you can evaluate it without breaking a sweat. So it intuitively seems like a workable representation of our code is a tree that matches the grammatical structure—the operator nesting—of the language.</p>
<p>如果我们提供了一个算术表达式，那么可以很容易的转变为一棵树，同样的，如果有一棵树，我们也可以容易变为一个表达式。因此，从直觉上，我们可以将代码表示为一棵树，这棵树与我们使用的编程语言的语法结构、运算符，嵌套匹配。</p>
<blockquote>
<p>That’s not to say a tree is the only possible representation of our code. In Part III, we’ll generate bytecode, another representation that isn’t as human friendly but is closer to the machine.</p>
<p>这并不是说，语法树是我们代码的唯一表示方式。在本书的第三部分，我们还将介绍字节码，这是一种更加接近机器的表示，但是对于人类来说，不是那么人性化。</p>
</blockquote>
<p>We need to get more precise about what that grammar is then. Like lexical grammars in the last chapter, there is a long ton of theory around syntactic grammars. We’re going into that theory a little more than we did when scanning because it turns out to be a useful tool throughout much of the interpreter. We start by moving one level up the <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>. </p>
<p>我们需要更加精确去了解，什么是语法。就像上一章的词法规则一样，关于语法规则也有很多理论。我们对这些理论的探讨将更加深入一些，因为这些理论被证明，对于解释器是一个有用的工具。我们首先要学习 <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>. </p>
<h2 id="一context-free-grammars"><a class="header" href="#一context-free-grammars">一、Context-Free Grammars</a></h2>
<p>上下文无关语法</p>
<p>In the last chapter, the formalism we used for defining the lexical grammar—the rules for how characters get grouped into tokens—was called a regular language. That was fine for our scanner, which emits a flat sequence of tokens. But regular languages aren’t powerful enough to handle expressions which can nest arbitrarily deeply.</p>
<p>We need a bigger hammer, and that hammer is a context-free grammar (CFG). It’s the next heaviest tool in the toolbox of formal grammars. A formal grammar takes a set of atomic pieces it calls its “alphabet”. Then it defines a (usually infinite) set of “strings” that are “in” the grammar. Each string is a sequence of “letters” in the alphabet.</p>
<p>I’m using all those quotes because the terms get a little confusing as you move from lexical to syntactic grammars. In our scanner’s grammar, the alphabet consists of individual characters and the strings are the valid lexemes—roughly “words”. In the syntactic grammar we’re talking about now, we’re at a different level of granularity. Now each “letter” in the alphabet is an entire token and a “string” is a sequence of tokens—an entire expression.</p>
<p>Oof. Maybe a table will help:</p>
<table><thead><tr><th>Terminology</th><th>Lexical grammar</th><th>Syntactic grammar</th></tr></thead><tbody>
<tr><td>The “alphabet” is . . .</td><td>Characters</td><td>Tokens</td></tr>
<tr><td>A “string” is . . .</td><td>Lexeme or token</td><td>Expression</td></tr>
<tr><td>It’s implemented by the . . .</td><td>Scanner</td><td>Parser</td></tr>
</tbody></table>
<p>A formal grammar’s job is to specify which strings are valid and which aren’t. If we were defining a grammar for English sentences, “eggs are tasty for breakfast” would be in the grammar, but “tasty breakfast for are eggs” would probably not.</p>
<p>在上一章中，我们定义词汇的规则——将字符分组为token的规则，被称为正则语言。这对于我们实现的扫描器是非常好的，它将输出一个token序列。但是，正则语言的功能不足以处理任何深度嵌套的表达式。</p>
<p>我们需要更强大的工具，这个工具就是CFG 上下文无关语法。CFG上下文无关语法，是<a href="https://en.wikipedia.org/wiki/Formal_grammar">形式文法</a>中第二重要的工具. 形式文法定义了一组原子化的字符表，称为字母表，然后，我们可以定义一组字符串（通常是无限的），每一个字符串都由字母表中的字母组合。</p>
<p>我使用了一些引号标注，是因为当我们从词法规则变更到语法规则时候，其中的术语会变得令人困惑。在词法规则中，字母表是单个字符组成的，字符串是有效的词素（即单词）。但是，在我们当前的语法讨论中，现在的字母表中每一个元素都是一个token，我们处于不同的粒度级别。同样的，这时候，一个字符串表示一组token，即实际上是一个表达式。</p>
<p>它们的区别，详见下表：</p>
<table><thead><tr><th>术语</th><th>词法规则</th><th>语法规则</th></tr></thead><tbody>
<tr><td>字母表</td><td>字符列表</td><td>token列表</td></tr>
<tr><td>字符串</td><td>词素（单词）或者token</td><td>表达式</td></tr>
<tr><td>实现者</td><td>扫描器</td><td>解释器</td></tr>
</tbody></table>
<p>形式文法的目标是指定哪些字符串有效，哪些字符串无效。例如：我们想要给一个英语语句，定义语法规则。&quot;eggs are tasty for breakfast&quot; 是一个合法的英语语句，但是，“tasty breakfast for are eggs”就不是一个合法的英语语句。</p>
<h3 id="11-rules-for-grammars"><a class="header" href="#11-rules-for-grammars">1.1 Rules for grammars</a></h3>
<p>语法规则</p>
<p>How do we write down a grammar that contains an infinite number of valid strings? We obviously can’t list them all out. Instead, we create a finite set of rules. You can think of them as a game that you can “play” in one of two directions.</p>
<p>If you start with the rules, you can use them to generate strings that are in the grammar. Strings created this way are called derivations because each is derived from the rules of the grammar. In each step of the game, you pick a rule and follow what it tells you to do. Most of the lingo around formal grammars comes from playing them in this direction. Rules are called productions because they produce strings in the grammar.</p>
<p>我们如何写出包含无限个字符串的语法？显然，我们不可能罗列出它们。相反，我们可以定义一组有限的规则，我们可以把语法规则想象为一个游戏，可以从两个方向中的一个玩。</p>
<p>如果你从语法规则开始，我们可以使用语法规则生成合法的语句，这些生成的语句，称为派生语句，因为它们都是从语法规则中派生出。在游戏的每一步，你都需要选择一条语法规则，然后，按照规则继续运行。形式文法的，大部分术语都是从这个方向中产生的，语法规则被称为产生式，因为，它们生产字符串。</p>
<p>Each production in a context-free grammar has a head—its name—and a body, which describes what it generates. In its pure form, the body is simply a list of symbols. Symbols come in two delectable flavors:</p>
<blockquote>
<p>Restricting heads to a single symbol is a defining feature of context-free grammars. More powerful formalisms like unrestricted grammars allow a sequence of symbols in the head as well as in the body.</p>
<p>将头限制为单个符号，是上下文无关语法的一个定义特性，更加强大的形式主义，例如: <a href="https://en.wikipedia.org/wiki/Unrestricted_grammar">无限制文法</a>, 允许头部和body中定义一系列符号</p>
</blockquote>
<ul>
<li>
<p>A terminal is a letter from the grammar’s alphabet. You can think of it like a literal value. In the syntactic grammar we’re defining, the terminals are individual lexemes—tokens coming from the scanner like if or 1234.</p>
<p>These are called “terminals”, in the sense of an “end point” because they don’t lead to any further “moves” in the game. You simply produce that one symbol.</p>
</li>
<li>
<p>A nonterminal is a named reference to another rule in the grammar. It means “play that rule and insert whatever it produces here”. In this way, the grammar composes.</p>
</li>
</ul>
<p>There is one last refinement: you may have multiple rules with the same name. When you reach a nonterminal with that name, you are allowed to pick any of the rules for it, whichever floats your boat.</p>
<p>上下文无关语法中的每一个输出，都有一个头（名称），一个主体（描述生成的内容），在纯形式中，主体是一个符号列表。符号主要分为两类：</p>
<ul>
<li>
<p>终止符，是语法字母表中的字母。可以将它想象为文字值。在我们定义的语法规则中，终止符是来自扫描器生成的单个词素或者token，例如：if， 1234，这些被称为终止符，因为它们不会导致规则的进一步前进，它们就是语法规则的终点。只需要生成一个符号</p>
</li>
<li>
<p>非终止符，是对语法规则中的另外一个规则的引用。它的意思是，继续这个规则，将产生的任何东西，插入当前位置，语法就是这样生成的。</p>
</li>
</ul>
<p>还有最后一个改进，你可能会有多个同名规则。当我们遇到该名称的非终止符时候，我们可以选择任意一个规则，无论那个规则使我们继续进行下去。</p>
<p>To make this concrete, we need a way to write down these production rules.People have been trying to crystallize grammar all the way back to Pāṇini’s Ashtadhyayi, which codified Sanskrit grammar a mere couple thousand years ago. Not much progress happened until John Backus and company needed a notation for specifying ALGOL 58 and came up with Backus-Naur form (BNF). Since then, nearly everyone uses some flavor of BNF, tweaked to their own tastes.</p>
<p>I tried to come up with something clean. Each rule is a name, followed by an arrow (→), followed by a sequence of symbols, and finally ending with a semicolon (;). Terminals are quoted strings, and nonterminals are lowercase words.</p>
<p>为了使其具体化，我们需要一种方法来写下这些规则。人们一直尝试着将语法具体化，例如：两千年前的Pāṇini ，编写了梵语语法书  <a href="https://en.wikipedia.org/wiki/P%C4%81%E1%B9%87ini">Aṣṭādhyāyī</a> 。但是，一直到 <a href="https://en.wikipedia.org/wiki/John_Backus">John Backus</a>和他的公司，需要为ALGOL 58 语言指定一种符号，最后被命名为<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">巴科斯范式</a>, 缩写为BNF，从此以后，每一个语言发明者都使用变化的BNF，根据自己的偏好修改。</p>
<p>我尝试着设计出一个简洁的方式，每个规则都是一个名称，后面紧跟着一个箭头 —&gt;，然后在跟随者一串符号，最终用分号结束; </p>
<p>终止符是带引号的字符串，非终止符是小写字符</p>
<blockquote>
<p>Yes, we need to define a syntax to use for the rules that define our syntax. Should we specify that metasyntax too? What notation do we use for it? It’s languages all the way down!</p>
<p>我们需要定义一个语法，使用这些语法规则，我们将定义语言的语法。我们是否也应该指定元语法？我们用什么符号表示它，一直以来都是语言。</p>
</blockquote>
<p>Using that, here’s a grammar for breakfast menus:</p>
<blockquote>
<p>Yes, I really am going to be using breakfast examples throughout this entire book. Sorry.</p>
<p>很抱歉，我一直在书中，使用早餐举例。</p>
</blockquote>
<pre><code>
breakfast  → protein &quot;with&quot; breakfast &quot;on the side&quot; ;
breakfast  → protein ;
breakfast  → bread ;

protein    → crispiness &quot;crispy&quot; &quot;bacon&quot; ;
protein    → &quot;sausage&quot; ;
protein    → cooked &quot;eggs&quot; ;

crispiness → &quot;really&quot; ;
crispiness → &quot;really&quot; crispiness ;

cooked     → &quot;scrambled&quot; ;
cooked     → &quot;poached&quot; ;
cooked     → &quot;fried&quot; ;

bread      → &quot;toast&quot; ;
bread      → &quot;biscuits&quot; ;
bread      → &quot;English muffin&quot; ;

</code></pre>
<p>使用它，我们可以形成早餐的语法规则。</p>
<p>We can use this grammar to generate random breakfasts. Let’s play a round and see how it works. By age-old convention, the game starts with the first rule in the grammar, here breakfast. There are three productions for that, and we randomly pick the first one. Our resulting string looks like:</p>
<p><code>protein &quot;with&quot; breakfast &quot;on the side&quot;</code></p>
<p>We need to expand that first nonterminal, protein, so we pick a production for that. Let’s pick:</p>
<p><code>protein → cooked &quot;eggs&quot; ;</code></p>
<p>Next, we need a production for cooked, and so we pick &quot;poached&quot;. That’s a terminal, so we add that. Now our string looks like:</p>
<p><code>&quot;poached&quot; &quot;eggs&quot; &quot;with&quot; breakfast &quot;on the side&quot;</code></p>
<p>The next non-terminal is breakfast again. The first breakfast production we chose recursively refers back to the breakfast rule. Recursion in the grammar is a good sign that the language being defined is context-free instead of regular. In particular, recursion where the recursive nonterminal has productions on both sides implies that the language is not regular.</p>
<blockquote>
<p>Imagine that we’ve recursively expanded the breakfast rule here several times, like “bacon with bacon with bacon with . . . ” In order to complete the string correctly, we need to add an equal number of “on the side” bits to the end. Tracking the number of required trailing parts is beyond the capabilities of a regular grammar. Regular grammars can express repetition, but they can’t keep count of how many repetitions there are, which is necessary to ensure that the string has the same number of with and on the side parts.</p>
<p>想象一下，我们在这里，递归的扩展了早餐规则好几次，为了正确的产生字符串，我们需要在末尾添加相同数量的位，跟踪所需的尾部部分的数量，超过了常规语法的能力。常规语法，可以表示递归，但是无法计算重复的次数。这对于确保字符串的with 和 on the side 部分，维持相同数量是非常重要的。</p>
</blockquote>
<p>We could keep picking the first production for breakfast over and over again yielding all manner of breakfasts like “bacon with sausage with scrambled eggs with bacon . . . ” We won’t though. This time we’ll pick bread. There are three rules for that, each of which contains only a terminal. We’ll pick “English muffin”.</p>
<p>With that, every nonterminal in the string has been expanded until it finally contains only terminals and we’re left with:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/breakfast.png?raw=true" alt="breakfast" /></p>
<p>Throw in some ham and Hollandaise, and you’ve got eggs Benedict.</p>
<p>我们可以使用这个规则，生成随机的早餐，让我们实际生成一个早餐，看看它是如何生效的。按照古老的惯例，游戏从语法中的第一条规则开始，这里是 breakfast, 对于 breakfast 名称的规则，我们有3个不同的主体，让我们随机选择一个规则，</p>
<p><code>breakfast  → protein &quot;with&quot; breakfast &quot;on the side&quot; ;</code></p>
<p>接下来，我们将扩展第一个非终止符 protein, 同样的，我们将随机选择 protein 名称的规则，我们选择第3个规则</p>
<p><code>protein → cooked &quot;eggs&quot; ;</code></p>
<p>接着，我们将继续扩展非终止符 cooked, 这里我们选择 poached, 而这是一个终止符，所以我们的语法规则到此结束，完整的字符串看起来是</p>
<p><code>&quot;poached&quot; &quot;eggs&quot; &quot;with&quot; breakfast &quot;on the side&quot;</code></p>
<p>下面的一个非终止符是 breakfast , 如果我们选择第一个规则，那么我们将递归的调用 breakfast, 语法中的递归是一个标志，表示语法规则是上下文无关的，而不是正则的。特别情况下，非终止符在规则两边都存在，意味着递归，而不是正则的。</p>
<p>我们可以一直选择breakfast 非终止符的第一个规则，然后，我们将生成源源不断的早餐，但是我们不会这样做的，我们将选择breakfast的第3条规则，bread，下面是我们的早餐</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/breakfast.png?raw=true" alt="breakfast" /></p>
<p>Any time we hit a rule that had multiple productions, we just picked one arbitrarily. It is this flexibility that allows a short number of grammar rules to encode a combinatorially larger set of strings. The fact that a rule can refer to itself—directly or indirectly—kicks it up even more, letting us pack an infinite number of strings into a finite grammar.</p>
<p>任何时候，我们遇到了一个名称，对应着多个规则，我们将选择一个。正是这种灵活性，使得我们可以用有限的语法规则，组合成更多的字符串集合。一个规则中可以递归的调用自己，这样子，我们可以将无限的字符串，表示为有限的语法规则。</p>
<h3 id="12-enhancing-our-notation"><a class="header" href="#12-enhancing-our-notation">1.2 Enhancing our notation</a></h3>
<p>增强我们的符号</p>
<p>Stuffing an infinite set of strings in a handful of rules is pretty fantastic, but let’s take it further. Our notation works, but it’s tedious. So, like any good language designer, we’ll sprinkle a little syntactic sugar on top—some extra convenience notation. In addition to terminals and nonterminals, we’ll allow a few other kinds of expressions in the body of a rule:</p>
<ul>
<li>
<p>Instead of repeating the rule name each time we want to add another production for it, we’ll allow a series of productions separated by a pipe (|).</p>
<p><code>bread → &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;</code></p>
</li>
<li>
<p>Further, we’ll allow parentheses for grouping and then allow | within that to select one from a series of options within the middle of a production.</p>
<p><code>protein → ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;</code></p>
</li>
<li>
<p>Using recursion to support repeated sequences of symbols has a certain appealing purity, but it’s kind of a chore to make a separate named sub-rule each time we want to loop. So, we also use a postfix * to allow the previous symbol or group to be repeated zero or more times.</p>
<p><code>crispiness → &quot;really&quot; &quot;really&quot;* ;</code></p>
</li>
<li>
<p>A postfix + is similar, but requires the preceding production to appear at least once.</p>
<p><code>crispiness → &quot;really&quot;+ ;</code></p>
</li>
<li>
<p>A postfix ? is for an optional production. The thing before it can appear zero or one time, but not more.</p>
<p><code>breakfast → protein ( &quot;with&quot; breakfast &quot;on the side&quot; )? ;</code></p>
</li>
</ul>
<p>With all of those syntactic niceties, our breakfast grammar condenses down to:</p>
<pre><code>
breakfast → protein ( &quot;with&quot; breakfast &quot;on the side&quot; )?
          | bread ;

protein   → &quot;really&quot;+ &quot;crispy&quot; &quot;bacon&quot;
          | &quot;sausage&quot;
          | ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;

bread     → &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;

</code></pre>
<p>在一些规则中，我们填充一组无限的字符串是非常奇妙的，但是，让我们更加深入一些。我们的语法符号生效了，但是十分乏味。所以，像很多有限的语言设计者一样，我们将添加一些语法糖（即添加一些其他符号，更加方便的编写语法规则），除了终止符和非终止符，我们还将在语法规则中，使用下面的符号</p>
<ul>
<li>
<p>我们将添加管道符| 用于分隔规则名称，而不是每一次都重复写入多个相同规则名称</p>
<p><code>bread → &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;</code></p>
</li>
<li>
<p>进一步，我们将允许使用括号进行分组，每一个组中，可以使用管道符 | ，选择其中的一个</p>
<p><code>protein → ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;</code></p>
</li>
<li>
<p>使用递归来支持某个规则的重复使用，是一种好的方式，但是，需要我们每次都定义一个单独的子规则，这有一些麻烦。所以，我们可以通过一个后缀*，表示前面的规则或者组，重复零次或者多次。</p>
<p><code>crispiness → &quot;really&quot; &quot;really&quot;* ;</code></p>
</li>
<li>
<p>相似的后缀，还有+ 表示它之前的规则或者组，至少存在一次</p>
<p><code>crispiness → &quot;really&quot;+ ;</code></p>
</li>
<li>
<p>和 + 相似的后缀为 ? 表示前面的规则或者组可以出现零次或者1次</p>
<p><code>breakfast → protein ( &quot;with&quot; breakfast &quot;on the side&quot; )? ;</code></p>
</li>
</ul>
<p>当我们使用了上面的语法糖后，可以将早餐规则变更为</p>
<pre><code>breakfast → protein ( &quot;with&quot; breakfast &quot;on the side&quot; )?
          | bread ;

protein   → &quot;really&quot;+ &quot;crispy&quot; &quot;bacon&quot;
          | &quot;sausage&quot;
          | ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;

bread     → &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;
</code></pre>
<p>Not too bad, I hope. If you’re used to grep or using regular expressions in your text editor, most of the punctuation should be familiar. The main difference is that symbols here represent entire tokens, not single characters.</p>
<p>We’ll use this notation throughout the rest of the book to precisely describe Lox’s grammar. As you work on programming languages, you’ll find that context-free grammars (using this or EBNF or some other notation) help you crystallize your informal syntax design ideas. They are also a handy medium for communicating with other language hackers about syntax.</p>
<p>The rules and productions we define for Lox are also our guide to the tree data structure we’re going to implement to represent code in memory. Before we can do that, we need an actual grammar for Lox, or at least enough of one for us to get started.</p>
<p>我希望我们的语法糖不会太糟糕，如果你之前使用过 grep 命令或者<a href="https://en.wikipedia.org/wiki/Regular_expression#Standards">正则表达式</a>, 那么其中大部分符号是相同的含义。主要区别是，这里的符号对象是整个token，而不是单个字符</p>
<p>在本书接下来部分，我们将使用这种语法，描述我们的lox语言。当我们使用编程语言时候，会发现上下文无关语法（通常具有BNF，<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a>范式）, 有助于我们具体化语法设计思想。它们也是我们同编程高手交流语法的便捷媒介。</p>
<p>我们定义的lox语言语法和产品，是我们将要实现的语法树结构的指南，表示内存中的代码。在我们可以这样做之前，我们需要一个实际的lox语言语法，或者至少有一些语法开始我们的解析。</p>
<h3 id="13-a-grammar-for-lox-expressions"><a class="header" href="#13-a-grammar-for-lox-expressions">1.3 A Grammar for Lox expressions</a></h3>
<p>lox语言表达式语法</p>
<p>In the previous chapter, we did Lox’s entire lexical grammar in one fell swoop. Every keyword and bit of punctuation is there. The syntactic grammar is larger, and it would be a real bore to grind through the entire thing before we actually get our interpreter up and running.</p>
<p>Instead, we’ll crank through a subset of the language in the next couple of chapters. Once we have that mini-language represented, parsed, and interpreted, then later chapters will progressively add new features to it, including the new syntax. For now, we are going to worry about only a handful of expressions:</p>
<ul>
<li>
<p>Literals. Numbers, strings, Booleans, and nil.</p>
</li>
<li>
<p>Unary expressions. A prefix ! to perform a logical not, and - to negate a number.</p>
</li>
<li>
<p>Binary expressions. The infix arithmetic (+, -, *, /) and logic operators (==, !=, &lt;, &lt;=, &gt;, &gt;=) we know and love.</p>
</li>
<li>
<p>Parentheses. A pair of ( and ) wrapped around an expression.</p>
</li>
</ul>
<p>That gives us enough syntax for expressions like:</p>
<pre><code class="language-C">
1 - (2 * 3) &lt; 4 == false

</code></pre>
<p>上一章中，我们一下子就完成了整个词法规则的介绍，每个关键字和标点符号都在那里。但是，语法规则内容更多，在我们真正启动解释器并且运行之前，对于整个规则的介绍，将是一个真正的麻烦。</p>
<p>相反，我们将在接下来的几章中，快速浏览lox语言的一个子集。一旦我们有了代码表示、解析、编译的迷你语言，随后的章节，将添加新的功能与语法。让我们先从几个表达式入门：</p>
<ul>
<li>
<p>文字，数值、字符串、布尔类型和nil</p>
</li>
<li>
<p>一元表达式，前缀! 表示逻辑非， 前缀-表示负数</p>
</li>
<li>
<p>二元表达式，中缀运算符 + - * / 和 逻辑运算符 == != &lt; &lt;= &gt; &gt;=</p>
</li>
<li>
<p>圆括号，包含一个表达式</p>
</li>
</ul>
<p>下面的表达式，包含上面的语法规则</p>
<pre><code class="language-C">
1 - (2 * 3) &lt; 4 == false

</code></pre>
<p>Using our handy dandy new notation, here’s a grammar for those:</p>
<p>There’s one bit of extra metasyntax here. In addition to quoted strings for terminals that match exact lexemes, we CAPITALIZE terminals that are a single lexeme whose text representation may vary. NUMBER is any number literal, and STRING is any string literal. Later, we’ll do the same for IDENTIFIER.</p>
<p>This grammar is actually ambiguous, which we’ll see when we get to parsing it. But it’s good enough for now.</p>
<p>使用我们之前定义的语法糖，这个语法可以写成：</p>
<pre><code>expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot; ;
grouping       → &quot;(&quot; expression &quot;)&quot; ;
unary          → ( &quot;-&quot; | &quot;!&quot; ) expression ;
binary         → expression operator expression ;
operator       → &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;
               | &quot;+&quot;  | &quot;-&quot;  | &quot;*&quot; | &quot;/&quot; ;
			   
</code></pre>
<p>上面还有一些额外的说明，除了匹配准确的词素，我们当作终止符之外，我们还把大写的字符串当作终止符。NUMBER表示任何的数字，STRING表示任何的字符串。稍后，我们还将介绍 IDENTIFIER</p>
<p>这个语法规则实际上不够明确，但是我们将在遇到它们时候，在探讨，现在我们将继续下面介绍。</p>
<blockquote>
<p>If you’re so inclined, try using this grammar to generate a few expressions like we did with the breakfast grammar before. Do the resulting expressions look right to you? Can you make it generate anything wrong like 1 + / 3?</p>
<p>如果你这么想，试着使用这些语法规则，生成一些表达式，就像我们之前早餐语法那样。这些生成的表达式是正确的吗？它是否会生成像是 1 + / 3 这样的错误？</p>
</blockquote>
<h2 id="二implementing-syntax-trees"><a class="header" href="#二implementing-syntax-trees">二、Implementing Syntax Trees</a></h2>
<p>实现语法树</p>
<p>Finally, we get to write some code. That little expression grammar is our skeleton. Since the grammar is recursive—note how grouping, unary, and binary all refer back to expression—our data structure will form a tree. Since this structure represents the syntax of our language, it’s called a syntax tree.</p>
<p>Our scanner used a single Token class to represent all kinds of lexemes. To distinguish the different kinds—think the number 123 versus the string &quot;123&quot;—we included a simple TokenType enum. Syntax trees are not so homogeneous. Unary expressions have a single operand, binary expressions have two, and literals have none.</p>
<p>We could mush that all together into a single Expression class with an arbitrary list of children. Some compilers do. But I like getting the most out of Java’s type system. So we’ll define a base class for expressions. Then, for each kind of expression—each production under expression—we create a subclass that has fields for the nonterminals specific to that rule. This way, we get a compile error if we, say, try to access the second operand of a unary expression.</p>
<p>最后，我们将编写代码实现语法规则。上面的表达式语法，是我们要实现的骨架。由于语法是递归的，需要注意分组、一元、二元对于表达式是如何实现的，我们的数据结构将形成一棵树，因为这是对语法的描述，我们称之为语法树。</p>
<p>我们的扫描器，使用单个token类型，表示所有类型的词素。为了区分不同的类型，例如：数字123 和 字符串&quot;123&quot;, 我们token类型，包含有一个TokenType属性。语法树不是那么同质化，一元表达式有一个操作数，二元表达式有两个操作数，文字没有操作数。</p>
<p>我们可以将这些都组合为一个表达式类中，其中包含任意的子类列表。有些编译器是这样做的，但是我喜欢充分利用Java类型系统的分类。因此，我们将首先定义表达式基类。然后，对于每种类型的表达式，和表达式下的每一个子类，我们都创建一个子类。这个子类具有特定该规则的非终端符。通过这样做，如果我们尝试访问一元表达式类中的第二个操作数，我们将接收到编译报错。</p>
<p>Something like this:</p>
<pre><code class="language-java">
package com.craftinginterpreters.lox;

abstract class Expr { 
  static class Binary extends Expr {
    Binary(Expr left, Token operator, Expr right) {
      this.left = left;
      this.operator = operator;
      this.right = right;
    }

    final Expr left;
    final Token operator;
    final Expr right;
  }

  // Other expressions...
}

</code></pre>
<blockquote>
<p>In particular, we’re defining an abstract syntax tree (AST). In a parse tree, every single grammar production becomes a node in the tree. An AST elides productions that aren’t needed by later phases.</p>
<p>特别的，我们实现了一个抽象语法树，在解析树中，每个语法生成都是一个节点，AST树省略了后面阶段不需要的部分。</p>
</blockquote>
<blockquote>
<p>Tokens aren’t entirely homogeneous either. Tokens for literals store the value, but other kinds of lexemes don’t need that state. I have seen scanners that use different classes for literals and other kinds of lexemes, but I figured I’d keep things simpler.</p>
<p>token 也不是完全相同的，文字的token，会保存文字的值，其他类型的token可能不需要这个信息。我见过扫描器对文字和其他类型的词汇，使用不同的类，但是我将让事情更加简单。</p>
</blockquote>
<blockquote>
<p>I avoid abbreviations in my code because they trip up a reader who doesn’t know what they stand for. But in compilers I’ve looked at, “Expr” and “Stmt” are so ubiquitous that I may as well start getting you used to them now.</p>
<p>我在代码中将尽量不使用缩写，因为，缩写会让不明白含义的读者感到困惑。但是，我见过的编译器中，使用 Expr 和 Stmt 是如此的普遍，所以我们将从现在开始习惯使用它们。</p>
</blockquote>
<p>Expr is the base class that all expression classes inherit from. As you can see from Binary, the subclasses are nested inside of it. There’s no technical need for this, but it lets us cram all of the classes into a single Java file.</p>
<p>实现代码如上，Expr是所有表达式可以继承的基类。正如我们看到的Binary 子类嵌套在Expr中。这在技术上没有必要，但是如此做，我们可以将所有类塞到一个java源文件中。</p>
<h3 id="21-disoriented-objects"><a class="header" href="#21-disoriented-objects">2.1 Disoriented objects</a></h3>
<p>面向对象的困惑</p>
<p>You’ll note that, much like the Token class, there aren’t any methods here. It’s a dumb structure. Nicely typed, but merely a bag of data. This feels strange in an object-oriented language like Java. Shouldn’t the class do stuff?</p>
<p>The problem is that these tree classes aren’t owned by any single domain. Should they have methods for parsing since that’s where the trees are created? Or interpreting since that’s where they are consumed? Trees span the border between those territories, which means they are really owned by neither.</p>
<p>In fact, these types exist to enable the parser and interpreter to communicate. That lends itself to types that are simply data with no associated behavior. This style is very natural in functional languages like Lisp and ML where all data is separate from behavior, but it feels odd in Java.</p>
<p>Functional programming aficionados right now are jumping up to exclaim “See! Object-oriented languages are a bad fit for an interpreter!” I won’t go that far. You’ll recall that the scanner itself was admirably suited to object-orientation. It had all of the mutable state to keep track of where it was in the source code, a well-defined set of public methods, and a handful of private helpers.</p>
<p>My feeling is that each phase or part of the interpreter works fine in an object-oriented style. It is the data structures that flow between them that are stripped of behavior.</p>
<p>我们注意到，和Token类一样，Expr中没有类方法，这是一个不好的结构，只有一堆数据，在Java这样的面向对象语言中，我们还有补充一些东西。</p>
<p>问题是，这些语法树类不属于单个域。它们是否应该有对应的解析方法，当语法树被创建出来，或者是否应该有编译方法，当它们被编译时候。这些语法树，横跨这些边界，这意味着它们不属于任何一方。</p>
<p>实际上，这些类型的存在是为了让解析器和解释器可以通信。这样的需求，使得这些类只有简单的数据类型，而没有关联行为。这种风格在Lisp，ML这些函数语言中，非常自然，但是，所有数据与行为分离，在Java中非常奇怪。</p>
<p>此时，函数式编程拥护者跳起来大喊：看，面向对象的语言不适合编写解释器。我不会走那么远，你应该记得，面向对象语言非常适合编写扫描器。它拥有可变状态来跟踪源码位置，一组定义良好的公共方法，和一些helper函数。</p>
<p>我的感觉是，解释器的每一个阶段或者每一个部分，都以面向对象的方式运行的非常好。它们直接的数据结构的通信，使得不需要行为。</p>
<h3 id="22-metaprogramming-the-trees"><a class="header" href="#22-metaprogramming-the-trees">2.2 Metaprogramming the trees</a></h3>
<p>语法树中的元编程</p>
<p>Java can express behavior-less classes, but I wouldn’t say that it’s particularly great at it. Eleven lines of code to stuff three fields in an object is pretty tedious, and when we’re all done, we’re going to have 21 of these classes.</p>
<p>I don’t want to waste your time or my ink writing all that down. Really, what is the essence of each subclass? A name, and a list of typed fields. That’s it. We’re smart language hackers, right? Let’s automate.</p>
<p>Java可以定义一个没有方法的类，但是我想说Java不太擅长处理这种类。在一个对象中，使用11行代码，填充3个字段，相当乏味，当我们全部完成后，将发现这样的类有21个</p>
<p>我不想浪费你的时间，或者我的墨水将这些类列举出来。真的，每一个类的本质是什么呢？类名称，类中的类型字段列表。就这样，那么我们可以自动化创建了</p>
<blockquote>
<p>Picture me doing an awkward robot dance when you read that. “AU-TO-MATE.”</p>
<p>当你读到这篇文章时候，想象一下，我在跳舞，跳一个笨拙的机器人舞。</p>
</blockquote>
<p>Instead of tediously handwriting each class definition, field declaration, constructor, and initializer, we’ll hack together a script that does it for us. It has a description of each tree type—its name and fields—and it prints out the Java code needed to define a class with that name and state.</p>
<p>我们将编写一个脚本，生成类，而不是，繁琐的编写每一个类定义，字段声明，构造函数，初始化变量。它将描述每一个定义的语法树类型，包含类名称和类字段列表，打印出类名称和相应的Java定义代码</p>
<p>This script is a tiny Java command-line app that generates a file named “Expr.java”:</p>
<p>这个脚本是一个简单的java代码，生成一个Expr.java 文件</p>
<pre><code class="language-java">
// tool/GenerateAst.java, create new file

package com.craftinginterpreters.tool;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;

public class GenerateAst {
  public static void main(String[] args) throws IOException {
    if (args.length != 1) {
      System.err.println(&quot;Usage: generate_ast &lt;output directory&gt;&quot;);
      System.exit(64);
    }
    String outputDir = args[0];
  }
}

</code></pre>
<blockquote>
<p>I got the idea of scripting the syntax tree classes from Jim Hugunin, creator of Jython and IronPython.</p>
<p>An actual scripting language would be a better fit for this than Java, but I’m trying not to throw too many languages at you.</p>
<p>我从Jython 和 IronPython的发明者 Jim Hugunin那里获取到灵感，有关编写语法树类脚本的想法。</p>
<p>实际上一门真的脚本语言更加适合做这件事，但是，我不想一下子抛出这么多的语言。</p>
</blockquote>
<p>Note that this file is in a different package, .tool instead of .lox. This script isn’t part of the interpreter itself. It’s a tool we, the people hacking on the interpreter, run ourselves to generate the syntax tree classes. When it’s done, we treat “Expr.java” like any other file in the implementation. We are merely automating how that file gets authored.</p>
<p>要注意，这个新的文件位于新的包 tool，而不是之前的lox中。这个脚本不属于解释器的一部分, 它只是一个工具，编程高手用它来，自动生成语法树。该脚本将生成一个 Expr.java文件</p>
<p>To generate the classes, it needs to have some description of each type and its fields.</p>
<p>For brevity’s sake, I jammed the descriptions of the expression types into strings. Each is the name of the class followed by : and the list of fields, separated by commas. Each field has a type and a name.</p>
<p>The first thing defineAst() needs to do is output the base Expr class.</p>
<p>为了生成一个类，对于每个类的类型和字段，我们需要进行一些描述</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main()

    String outputDir = args[0];
    defineAst(outputDir, &quot;Expr&quot;, Arrays.asList(
      &quot;Binary   : Expr left, Token operator, Expr right&quot;,
      &quot;Grouping : Expr expression&quot;,
      &quot;Literal  : Object value&quot;,
      &quot;Unary    : Token operator, Expr right&quot;
    ));
  }


</code></pre>
<p>为了简洁，我们把表达式类型的描述写入到字符串中，每个类中，后面跟上一个: 符号和一些类字段，字段中间使用逗号分隔。每个字段都有一个类型 和 名称。</p>
<p>defineAst() 需要输出Expr类</p>
<pre><code class="language-java">
// tool/GenerateAst.java add after main()

  private static void defineAst(
      String outputDir, String baseName, List&lt;String&gt; types)
      throws IOException {
    String path = outputDir + &quot;/&quot; + baseName + &quot;.java&quot;;
    PrintWriter writer = new PrintWriter(path, &quot;UTF-8&quot;);

    writer.println(&quot;package com.craftinginterpreters.lox;&quot;);
    writer.println();
    writer.println(&quot;import java.util.List;&quot;);
    writer.println();
    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

    writer.println(&quot;}&quot;);
    writer.close();
  }
  
</code></pre>
<p>When we call this, baseName is “Expr”, which is both the name of the class and the name of the file it outputs. We pass this as an argument instead of hardcoding the name because we’ll add a separate family of classes later for statements.</p>
<p>当我们调用这个函数，baseName 是 Expr, 它即是类的名称，也是输出的文件的名称。我们将expr当作一个参数，而不是硬编码，因为稍后，我们将添加一个类家族。</p>
<p>Inside the base class, we define each subclass.</p>
<p>在基类中，我们将定义每一个子类</p>
<pre><code class="language-java">
// tool/GenerateAst.java in defineAst()

 writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

    // The AST classes.
    for (String type : types) {
      String className = type.split(&quot;:&quot;)[0].trim();
      String fields = type.split(&quot;:&quot;)[1].trim(); 
      defineType(writer, baseName, className, fields);
    }
    writer.println(&quot;}&quot;);
	
</code></pre>
<pre><code class="language-java">
// tool/GenerateAst.java add after defineAst()

  private static void defineType(
      PrintWriter writer, String baseName,
      String className, String fieldList) {
    writer.println(&quot;  static class &quot; + className + &quot; extends &quot; +
        baseName + &quot; {&quot;);

    // Constructor.
    writer.println(&quot;    &quot; + className + &quot;(&quot; + fieldList + &quot;) {&quot;);

    // Store parameters in fields.
    String[] fields = fieldList.split(&quot;, &quot;);
    for (String field : fields) {
      String name = field.split(&quot; &quot;)[1];
      writer.println(&quot;      this.&quot; + name + &quot; = &quot; + name + &quot;;&quot;);
    }

    writer.println(&quot;    }&quot;);

    // Fields.
    writer.println();
    for (String field : fields) {
      writer.println(&quot;    final &quot; + field + &quot;;&quot;);
    }

    writer.println(&quot;  }&quot;);
  }
  
</code></pre>
<p>There we go. All of that glorious Java boilerplate is done. It declares each field in the class body. It defines a constructor for the class with parameters for each field and initializes them in the body.</p>
<p>Compile and run this Java program now and it blasts out a new “.java” file containing a few dozen lines of code. That file’s about to get even longer.</p>
<p>我们已经开始构造了，所有java类已经完成了，它声明了类中的每一个字段，它为类定义了一个构造函数，构造函数中包含有每个字段，并且在函数中进行字段初始化。</p>
<p>编译运行这个程序，将会创建一个新的java文件，其中包含几十行代码，java文件将会变得更长。</p>
<blockquote>
<p>This isn’t the world’s most elegant string manipulation code, but that’s fine. It only runs on the exact set of class definitions we give it. Robustness ain’t a priority.</p>
<p>这不是最优雅的字符串操作代码，但是它可以在我们定义的精确的类集合中，生成我们想要的类定义代码，健壮性不是首要任务。</p>
</blockquote>
<h2 id="三working-with-trees"><a class="header" href="#三working-with-trees">三、Working with Trees</a></h2>
<p>使用树</p>
<p>Put on your imagination hat for a moment. Even though we aren’t there yet, consider what the interpreter will do with the syntax trees. Each kind of expression in Lox behaves differently at runtime. That means the interpreter needs to select a different chunk of code to handle each expression type. With tokens, we can simply switch on the TokenType. But we don’t have a “type” enum for the syntax trees, just a separate Java class for each one.</p>
<p>带上想象的帽子一会儿，尽管我们还没有达到，想象一下，解释器如何出来语法树。Lox的每一种表达式在运行时候，行为都不相同。这意味着，解释器需要选择不同的代码块，来处理不同类型的表达式。使用token，我们可以通过tokenType转换。但是，我们没有语法树的枚举，只是对于每一个语法树，有一个独立的java类。</p>
<p>We could write a long chain of type tests:</p>
<p>我们可以编写一长串类型测试</p>
<pre><code class="language-java">
if (expr instanceof Expr.Binary) {
  // ...
} else if (expr instanceof Expr.Grouping) {
  // ...
} else // ...

</code></pre>
<p>But all of those sequential type tests are slow. Expression types whose names are alphabetically later would take longer to execute because they’d fall through more if cases before finding the right type. That’s not my idea of an elegant solution.</p>
<p>We have a family of classes and we need to associate a chunk of behavior with each one. The natural solution in an object-oriented language like Java is to put those behaviors into methods on the classes themselves. We could add an abstract interpret() method on Expr which each subclass would then implement to interpret itself.</p>
<p>但是，所有这些顺序式测试都很慢，如果按照表达式类型名称，按照字母顺序排序，然后执行，可能需要更多时间，因为在找到合适的类型之前，可能包含更多的判断，这不是我们认为的优雅的解决方式。</p>
<p>我们有一个类家族，需要将其中每一个类的行为都关联在一起。在Java这样的面向对象语言中，很自然的解决方式是，将这些类行为放入类方法中。我们可以在每个类中都添加一个抽象的方法，interpret() , Expr基类的每一个子类都实现自身的interpret() 方法。</p>
<blockquote>
<p>This exact thing is literally called the “Interpreter pattern” in Design Patterns: Elements of Reusable Object-Oriented Software, by Erich Gamma, et al.</p>
<p>这个编程模式被称为<a href="https://en.wikipedia.org/wiki/Interpreter_pattern">解释器模式</a>, 在书籍<a href="https://learning.oreilly.com/library/view/design-patterns-elements/0201633612/">《设计模式：可复用面向对象软件的基础》</a> 中 </p>
</blockquote>
<p>This works alright for tiny projects, but it scales poorly. Like I noted before, these tree classes span a few domains. At the very least, both the parser and interpreter will mess with them. As you’ll see later, we need to do name resolution on them. If our language was statically typed, we’d have a type checking pass.</p>
<p>If we added instance methods to the expression classes for every one of those operations, that would smush a bunch of different domains together. That violates separation of concerns and leads to hard-to-maintain code.</p>
<p>这样解决，对于小项目来说很好，它们的规模很小。正如我之前提到的，这些语法树跨域了几个域，至少，解析器和解释器都会使用到语法树。稍后你将看到，我们将进行名称解析。如果我们的语言是静态类型的，我们将有一个类型检查步骤。</p>
<p>如果我们对于每一个操作，都在表达式实例中添加对应的方法，那么将会把一系列的域，混杂在一起。这违反了<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">关注点分离</a>, 会让后面的代码更难维护。</p>
<h3 id="31-the-expression-problem"><a class="header" href="#31-the-expression-problem">3.1 The expression problem</a></h3>
<p>表达式问题</p>
<p>This problem is more fundamental than it may seem at first. We have a handful of types, and a handful of high-level operations like “interpret”. For each pair of type and operation, we need a specific implementation. Picture a table:</p>
<p>这个问题，比最初看起来更加根本，我们有一些类型，还有一些操作，例如: interpret, 对于每一个类型和操作的组合，我们需要一个特定的实现。表格看起来是这样：</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/table.png?raw=true" alt="table" /></p>
<p>Rows are types, and columns are operations. Each cell represents the unique piece of code to implement that operation on that type.</p>
<p>An object-oriented language like Java assumes that all of the code in one row naturally hangs together. It figures all the things you do with a type are likely related to each other, and the language makes it easy to define them together as methods inside the same class.</p>
<p>This makes it easy to extend the table by adding new rows. Simply define a new class. No existing code has to be touched. But imagine if you want to add a new operation—a new column. In Java, that means cracking open each of those existing classes and adding a method to it.</p>
<p>表格中，行是类型，列是操作，每个单元格表示某种类型的某个操作，具体的实现代码。</p>
<p>在Java这样的面向对象语言中，会将一行中的所有操作，自然的放到一起。它认为我们对于每个类型的所有操作都是相互关联的。Java中可以很简单的将这些方法定义到同一个类中</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/rows.png?raw=true" alt="rows" /></p>
<p>这样，我们可以很容易的扩展新的一行，即添加一个新类。无需修改现有代码。但是，想象一下，如果你添加了一个新的操作，即添加了一列。在Java中，这意味着，我们需要在每个类中，添加一个新的方法。</p>
<p>Functional paradigm languages in the ML family flip that around. There, you don’t have classes with methods. Types and functions are totally distinct. To implement an operation for a number of different types, you define a single function. In the body of that function, you use pattern matching—sort of a type-based switch on steroids—to implement the operation for each type all in one place.</p>
<p>This makes it trivial to add new operations—simply define another function that pattern matches on all of the types.</p>
<p><a href="https://craftinginterpreters.com/representing-code.html">ML语言</a>家族中的，函数范型语言正好相反，在那里，你没有类和类方法的概念，类型和函数完全不相同。为了定义某个操作（不同的类型），我们可以定义一个函数，在每个函数中，我们使用类型匹配，根据不同的类型，实现不同的具体操作代码。</p>
<p>这样，我们可以很容易添加一个新的操作，在新操作对应的函数中，我们根据不同类型，定义不同的实现。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/columns.png?raw=true" alt="columns" /></p>
<p>But, conversely, adding a new type is hard. You have to go back and add a new case to all of the pattern matches in all of the existing functions.</p>
<p>但是，如果我们想要添加一个新的类型，会非常麻烦，我们必须在所有的函数中，添加一个模式，匹配新的类型，并且添加对应的代码。</p>
<blockquote>
<p>ML, short for “metalanguage” was created by Robin Milner and friends and forms one of the main branches in the great programming language family tree. Its children include SML, Caml, OCaml, Haskell, and F#. Even Scala, Rust, and Swift bear a strong resemblance.</p>
<p>Much like Lisp, it is one of those languages that is so full of good ideas that language designers today are still rediscovering them over forty years later.</p>
<p>ML, 是元语言的缩写，是由<a href="https://en.wikipedia.org/wiki/Robin_Milner">Robin Milner</a> 和他的朋友们创建，是伟大的编程语言的一个重要分支，受到它影响的语法包括，SML Caml OCaml Haskell F#等等，即使是 Scala, Rust 和 Swift也和它有很多的相似性。</p>
<p>与lisp语言相似，ML是一门充满了想法的语言，以致于语言设计者，在40年后的今天，依然可以发现ML中的新想法。</p>
</blockquote>
<p>Each style has a certain “grain” to it. That’s what the paradigm name literally says—an object-oriented language wants you to orient your code along the rows of types. A functional language instead encourages you to lump each column’s worth of code together into a function.</p>
<p>A bunch of smart language nerds noticed that neither style made it easy to add both rows and columns to the table. They called this difficulty the “expression problem” because—like we are now—they first ran into it when they were trying to figure out the best way to model expression syntax tree nodes in a compiler.</p>
<p>People have thrown all sorts of language features, design patterns, and programming tricks to try to knock that problem down but no perfect language has finished it off yet. In the meantime, the best we can do is try to pick a language whose orientation matches the natural architectural seams in the program we’re writing.</p>
<p>Object-orientation works fine for many parts of our interpreter, but these tree classes rub against the grain of Java. Fortunately, there’s a design pattern we can bring to bear on it.</p>
<p>每一种编程方式，都有自己的风格，这也体现在编程范式名称上，面向对象编程语言，希望我们沿着表格中行方向，函数式编程，鼓励我们沿着列方向编程。</p>
<p>一群聪明的书呆子注意到，上面的两种编程风格，都无法简单的添加一行或者一列。他们将这个困难，称为表达式问题，因为和我们现在一样，他们也是在试图找到一种最好的方法，对表达式语法树进行建模时候，遇到这个问题。</p>
<p>人们已经抛弃了各种语言特性、设计模式、编程技巧，试图去解决这个问题，但是，还没有一种语言可以完美的解决这个问题。所以，当前我们最好的方法是，选择一种语言，它的编程方向，和我们要实现的语法树更加契合。</p>
<p>面向对象语言，对于解释器部分一般更加合适，但是这些语法树，和Java的编程风格有冲突，幸运的是，我们可以引入新的设计模式，利用它，更好的编写语法树的实现。</p>
<blockquote>
<p>Languages with multimethods, like Common Lisp’s CLOS, Dylan, and Julia do support adding both new types and operations easily. What they typically sacrifice is either static type checking, or separate compilation.</p>
<p>具有多方法的语言，例如: Common Lisp, 确实支持轻松添加新的类型和操作，但是，它们通常会缺少静态类型的检查或者单独编译。</p>
</blockquote>
<h3 id="32-the-visitor-pattern"><a class="header" href="#32-the-visitor-pattern">3.2 The Visitor pattern</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Visitor_pattern">访问者模式</a></p>
<p>The Visitor pattern is the most widely misunderstood pattern in all of Design Patterns, which is really saying something when you look at the software architecture excesses of the past couple of decades.</p>
<p>The trouble starts with terminology. The pattern isn’t about “visiting”, and the “accept” method in it doesn’t conjure up any helpful imagery either. Many think the pattern has to do with traversing trees, which isn’t the case at all. We are going to use it on a set of classes that are tree-like, but that’s a coincidence. As you’ll see, the pattern works as well on a single object.</p>
<p>The Visitor pattern is really about approximating the functional style within an OOP language. It lets us add new columns to that table easily. We can define all of the behavior for a new operation on a set of types in one place, without having to touch the types themselves. It does this the same way we solve almost every problem in computer science: by adding a layer of indirection.</p>
<p>当你查看过去几十年的软件架构历史，访问者模式是最容易被误解的模式</p>
<p>问题从术语开始，该模式与访问无关，其中的接受方法，也不会产生任何有用的图像。许多人认为这种模式和遍历语法树有关，但事实并不是这样。我们接下来，将在一组树类，使用访问者模式，但是这只是巧合。正如，你将看到，该模式也适用于单个对象。</p>
<p>访问者模式，在面向对象语言中，类似于函数式。它，可以让我们轻松的添加一列。我们可以在一个地方，定义一组类型上的新操作的所有行为，而不需要接触具体的类型。这与我们解决计算中的几乎所有问题的思想一样——添加一层抽象，间接寻址。</p>
<blockquote>
<p>A beignet (pronounced “ben-yay”, with equal emphasis on both syllables) is a deep-fried pastry in the same family as doughnuts. When the French colonized North America in the 1700s, they brought beignets with them. Today, in the US, they are most strongly associated with the cuisine of New Orleans.</p>
<p>My preferred way to consume them is fresh out of the fryer at Café du Monde, piled high in powdered sugar, and washed down with a cup of café au lait while I watch tourists staggering around trying to shake off their hangover from the previous night’s revelry</p>
<p>beignet是一种油炸糕点，和甜甜圈是同一类型糕点。</p>
</blockquote>
<p>Before we apply it to our auto-generated Expr classes, let’s walk through a simpler example. Say we have two kinds of pastries: beignets and crullers.</p>
<p>在我们应用该模式于我们的Expr类之前，我们先进行一个简单示例。假设我们有两类糕点：甜饼和煎饼</p>
<pre><code class="language-java">

  abstract class Pastry {
  }

  class Beignet extends Pastry {
  }

  class Cruller extends Pastry {
  }
  
  
</code></pre>
<p>We want to be able to define new pastry operations—cooking them, eating them, decorating them, etc.—without having to add a new method to each class every time. Here’s how we do it. First, we define a separate interface.</p>
<p>我们想要定义新的糕点操作，烹饪、食用、装饰它们，而不需要向每个类中添加方法，下面是我们的做法。首先，我们定义一个单独的接口</p>
<pre><code class="language-java">


  interface PastryVisitor {
    void visitBeignet(Beignet beignet); 
    void visitCruller(Cruller cruller);
  }
  
  
</code></pre>
<blockquote>
<p>In Design Patterns, both of these methods are confusingly named visit(), and they rely on overloading to distinguish them. This leads some readers to think that the correct visit method is chosen at runtime based on its parameter type. That isn’t the case. Unlike overriding, overloading is statically dispatched at compile time.</p>
<p>Using distinct names for each method makes the dispatch more obvious, and also shows you how to apply this pattern in languages that don’t support overloading.</p>
<p>在设计模式中，所有方法名称都相同，visit(), 它们非常容易混淆，我们需要使用重载来区分它们。这导致一些读者认为，visit()方法的区分是在运行时候根据参数类型不同，执行不同的方法，但是，实际上，与重写不同，重载是在静态编译阶段区分的。</p>
<p>对于每个方法使用不同的名称 visitBeignet/visitCruller 可以让分派更加明显。并且，还可以展示在不支持重载的语言中，如何实现访问者模式。</p>
</blockquote>
<p>Each operation that can be performed on pastries is a new class that implements that interface. It has a concrete method for each type of pastry. That keeps the code for the operation on both types all nestled snugly together in one class.</p>
<p>Given some pastry, how do we route it to the correct method on the visitor based on its type? Polymorphism to the rescue! We add this method to Pastry:</p>
<p>可以在糕点上执行的每个操作都是一个实现该接口的新类。每个糕点，都有具体的制作方法，这样，两个类型的相同操作代码将写入一个类中</p>
<p>给定一些糕点，我们如何根据其类型将它们发送到访问者的正确方法？我们将使用多态，每个子类都将实现</p>
<pre><code class="language-java">

 abstract class Pastry {
    abstract void accept(PastryVisitor visitor);
  }
  
</code></pre>
<pre><code class="language-java">
 class Beignet extends Pastry {
    @Override
    void accept(PastryVisitor visitor) {
      visitor.visitBeignet(this);
    }
  }
  
</code></pre>
<pre><code class="language-java">

  class Cruller extends Pastry {
    @Override
    void accept(PastryVisitor visitor) {
      visitor.visitCruller(this);
    }
  }
  
</code></pre>
<p>To perform an operation on a pastry, we call its accept() method and pass in the visitor for the operation we want to execute. The pastry—the specific subclass’s overriding implementation of accept()—turns around and calls the appropriate visit method on the visitor and passes itself to it.</p>
<p>That’s the heart of the trick right there. It lets us use polymorphic dispatch on the pastry classes to select the appropriate method on the visitor class. In the table, each pastry class is a row, but if you look at all of the methods for a single visitor, they form a column.</p>
<p>We added one accept() method to each class, and we can use it for as many visitors as we want without ever having to touch the pastry classes again. It’s a clever pattern.</p>
<p>要在糕点上执行操作，我们调用它的accept() 方法，并且传参是 要执行操作的访问者。糕点的子类，重写 accept() 方法，它会对应不同的访问者，调用不同的访问方法，并将自身当作传参。</p>
<p>这就是关键所在，它允许我们在糕点类上使用多态，选择访问者类上的特定方法，在下面的表格中，每个具体的糕点类都是一行，但是，当你查看单个访问者的所有方法，它们将会是一列</p>
<p>我们为每一个糕点子类，添加了一个accept方法，我们可以根据需要，为任意多的访问者使用不同的accept方法，而无须修改糕点类，这是一个好的模式。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/visitor.png?raw=true" alt="visitor" /></p>
<h3 id="33-visitors-for-expressions"><a class="header" href="#33-visitors-for-expressions">3.3 Visitors for expressions</a></h3>
<p>表达式访问者模式</p>
<p>OK, let’s weave it into our expression classes. We’ll also refine the pattern a little. In the pastry example, the visit and accept() methods don’t return anything. In practice, visitors often want to define operations that produce values. But what return type should accept() have? We can’t assume every visitor class wants to produce the same type, so we’ll use generics to let each implementation fill in a return type.</p>
<p>好的，接下来，让我们在表达式类中，使用访问者模式，我们还将对访问者模式进行一些改进，在糕点示例中，vistor() 和 accept() 方法，没有具体的返回值。实际上，vistor期望定义可以产生值的操作，但是,accept() 方法，应该有什么类型的返回值呢？我们不能假设，每一个visitor都返回相同的类型，所以，我们将使用泛型，让每一个具体实现，去填充类型</p>
<blockquote>
<p>Another common refinement is an additional “context” parameter that is passed to the visit methods and then sent back through as a parameter to accept(). That lets operations take an additional parameter. The visitors we’ll define in the book don’t need that, so I omitted it.</p>
<p>另一个常见的细化是通过一个参数context, 该参数传递给visit(), 然后，在作为一个参数，发送回accept()， 这允许操作使用附加参数，我们在本书中定义的访问者不需要该参数，所以，我们省略了context的介绍。</p>
</blockquote>
<p>First, we define the visitor interface. Again, we nest it inside the base class so that we can keep everything in one file.</p>
<p>首先，我们定义访问者接口，同样的，我们将其嵌套在基类中，以便我们将所有内容保存在一个文件中。</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in defineAst()

    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

    defineVisitor(writer, baseName, types);

    // The AST classes.


</code></pre>
<pre><code class="language-java">
// tool/GenerateAst.java, add after defineAst()
  private static void defineVisitor(
      PrintWriter writer, String baseName, List&lt;String&gt; types) {
    writer.println(&quot;  interface Visitor&lt;R&gt; {&quot;);

    for (String type : types) {
      String typeName = type.split(&quot;:&quot;)[0].trim();
      writer.println(&quot;    R visit&quot; + typeName + baseName + &quot;(&quot; +
          typeName + &quot; &quot; + baseName.toLowerCase() + &quot;);&quot;);
    }

    writer.println(&quot;  }&quot;);
  }
  
</code></pre>
<p>Here, we iterate through all of the subclasses and declare a visit method for each one. When we define new expression types later, this will automatically include them.</p>
<p>Inside the base class, we define the abstract accept() method.</p>
<p>在这里，我们遍历每一个子类，并且为每一个子类，声明了一个访问方法，当我们定义新的表达式类时候，这将自动包括它们</p>
<p>在基类中，我们将定义抽象类 accept() 方法</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in defineAst()

      defineType(writer, baseName, className, fields);
    }

    // The base accept() method.
    writer.println();
    writer.println(&quot;  abstract &lt;R&gt; R accept(Visitor&lt;R&gt; visitor);&quot;);

    writer.println(&quot;}&quot;);


</code></pre>
<p>Finally, each subclass implements that and calls the right visit method for its own type.</p>
<p>最后，每一个子类中都实现了accept() 方法，每个具体的accept() 方法将会调用正确的visit方法</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in defineType()

    writer.println(&quot;    }&quot;);

    // Visitor pattern.
    writer.println();
    writer.println(&quot;    @Override&quot;);
    writer.println(&quot;    &lt;R&gt; R accept(Visitor&lt;R&gt; visitor) {&quot;);
    writer.println(&quot;      return visitor.visit&quot; +
        className + baseName + &quot;(this);&quot;);
    writer.println(&quot;    }&quot;);

    // Fields.


</code></pre>
<p>There we go. Now we can define operations on expressions without having to muck with the classes or our generator script. Compile and run this generator script to output an updated “Expr.java” file. It contains a generated Visitor interface and a set of expression node classes that support the Visitor pattern using it.</p>
<p>Before we end this rambling chapter, let’s implement that Visitor interface and see the pattern in action.</p>
<p>我们继续开始，现在，我们可以在表达式上定义操作，而不需要处理类和生成类脚本， 编译运行这个脚本，更新Expr.java 文件，它包含一个生成Visitor接口，和一系列表达式节点类，支持Visitor模式。</p>
<p>在我们结束这漫无边际的一章之前，让我们实现Visitor接口，并且实际使用访问者模式。</p>
<h2 id="四a-not-very-pretty-printer"><a class="header" href="#四a-not-very-pretty-printer">四、A (Not Very) Pretty Printer</a></h2>
<p>When we debug our parser and interpreter, it’s often useful to look at a parsed syntax tree and make sure it has the structure we expect. We could inspect it in the debugger, but that can be a chore.</p>
<p>Instead, we’d like some code that, given a syntax tree, produces an unambiguous string representation of it. Converting a tree to a string is sort of the opposite of a parser, and is often called “pretty printing” when the goal is to produce a string of text that is valid syntax in the source language.</p>
<p>That’s not our goal here. We want the string to very explicitly show the nesting structure of the tree. A printer that returned 1 + 2 * 3 isn’t super helpful if what we’re trying to debug is whether operator precedence is handled correctly. We want to know if the + or * is at the top of the tree.</p>
<p>当我们调试解析器和解释器时候，查看已经解析的语法树，并且确保它们拥有我们期望的结构，通常非常重要，我们可以在调试阶段检查。但是，这也是一项繁重的任务</p>
<p>相反，我们更喜欢一些输出，在给定语法树场景，输出明确的字符串，表示这个语法树。将树返回为一个字符串，过程和解析器正好相反，这通常称为完美输出，如果我们输出的字符串是一个合法的原始语言的字符串</p>
<p>但是，这不是我们的目标，我们希望字符串，可以非常明确的显示语法树结构，如果我们想要调试运算符优先级是否正确被处理，那么我们直接输出 1 +  2*3 , 不会有很大的作用。我们想要知道，+ 还是 * 在语法树的顶部。</p>
<p>To that end, the string representation we produce isn’t going to be Lox syntax. Instead, it will look a lot like, well, Lisp. Each expression is explicitly parenthesized, and all of its subexpressions and tokens are contained in that.</p>
<p>为此，我们输出的字符串不是符合lox语法的字符串，相反，它看起来更像是 lisp语言，每个表达式都显示的用括号括起来，其中包含所有的子表达式和token</p>
<p>Given a syntax tree like:</p>
<p>给定下面的语法树，</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/expression.png?raw=true" alt="expression" /></p>
<p>It produces:</p>
<p>它对应的输出字符串是</p>
<p><code>(* (- 123) (group 45.67))</code></p>
<p>Not exactly “pretty”, but it does show the nesting and grouping explicitly. To implement this, we define a new class.</p>
<p>虽然，不是非常完美，但是它，的确显示了嵌套和分组结构，为了实现这个输出，我们定义一个新的类</p>
<pre><code class="language-java">
// lox/AstPrinter.java, create new file

package com.craftinginterpreters.lox;

class AstPrinter implements Expr.Visitor&lt;String&gt; {
  String print(Expr expr) {
    return expr.accept(this);
  }
}


</code></pre>
<p>As you can see, it implements the visitor interface. That means we need visit methods for each of the expression types we have so far.</p>
<p>如我们所见，它实现了访问者模式的接口，这意味着我们需要对每个表达式类型实现访问方法，</p>
<pre><code class="language-java">
// lox/AstPrinter.java, add after print()

    return expr.accept(this);
  }

  @Override
  public String visitBinaryExpr(Expr.Binary expr) {
    return parenthesize(expr.operator.lexeme,
                        expr.left, expr.right);
  }

  @Override
  public String visitGroupingExpr(Expr.Grouping expr) {
    return parenthesize(&quot;group&quot;, expr.expression);
  }

  @Override
  public String visitLiteralExpr(Expr.Literal expr) {
    if (expr.value == null) return &quot;nil&quot;;
    return expr.value.toString();
  }

  @Override
  public String visitUnaryExpr(Expr.Unary expr) {
    return parenthesize(expr.operator.lexeme, expr.right);
  }
}

</code></pre>
<p>Literal expressions are easy—they convert the value to a string with a little check to handle Java’s null standing in for Lox’s nil. The other expressions have subexpressions, so they use this parenthesize() helper method:</p>
<p>文字表达式的访问者接口很容易实现——它们将值转换为字符串，只需要稍微检查一下，是否是Java 中的null值，如果是，需要转为lox语言中的nil；其他的表达式，含有子表达式，因此，我们还需要借助这个括号处理帮助函数</p>
<pre><code class="language-java">
// lox/AstPrinter.java, add after visitUnaryExpr()

  private String parenthesize(String name, Expr... exprs) {
    StringBuilder builder = new StringBuilder();

    builder.append(&quot;(&quot;).append(name);
    for (Expr expr : exprs) {
      builder.append(&quot; &quot;);
      builder.append(expr.accept(this));
    }
    builder.append(&quot;)&quot;);

    return builder.toString();
  }


</code></pre>
<p>It takes a name and a list of subexpressions and wraps them all up in parentheses, yielding a string like:</p>
<p>它接受一个名称和一串子表达式，并且将它们都是用括号括起来，生成如下的字符串</p>
<pre><code>
(+ 1 2)

</code></pre>
<p>Note that it calls accept() on each subexpression and passes in itself. This is the recursive step that lets us print an entire tree.</p>
<p>需要注意的是，每个子表达式都会调用accept() 方法，并且将自身传参，这样，我们可以递归调用，打印出语法树。</p>
<blockquote>
<p>This recursion is also why people think the Visitor pattern itself has to do with trees.</p>
<p>这种递归，也让人们更加认为，访问者模式和语法树是有关的。</p>
</blockquote>
<p>We don’t have a parser yet, so it’s hard to see this in action. For now, we’ll hack together a little main() method that manually instantiates a tree and prints it.</p>
<p>我们还没有解析器，所以很难看到具体的实际应用。但是，我们将先实现一个demo main函数，手动实例化语法树，并且打印</p>
<pre><code class="language-java">// lox/AstPrinter.java, add after parenthesize()

  public static void main(String[] args) {
    Expr expression = new Expr.Binary(
        new Expr.Unary(
            new Token(TokenType.MINUS, &quot;-&quot;, null, 1),
            new Expr.Literal(123)),
        new Token(TokenType.STAR, &quot;*&quot;, null, 1),
        new Expr.Grouping(
            new Expr.Literal(45.67)));

    System.out.println(new AstPrinter().print(expression));
  }


</code></pre>
<p>If we did everything right, it prints:</p>
<p>接下来，我们运行，将会输出</p>
<p><code>(* (- 123) (group 45.67))</code></p>
<p>You can go ahead and delete this method. We won’t need it. Also, as we add new syntax tree types, I won’t bother showing the necessary visit methods for them in AstPrinter. If you want to (and you want the Java compiler to not yell at you), go ahead and add them yourself. It will come in handy in the next chapter when we start parsing Lox code into syntax trees. Or, if you don’t care to maintain AstPrinter, feel free to delete it. We won’t need it again.</p>
<p>我们可以继续下去，删除当前demo，我们不需要它。此外，当我们添加新的表达式类型时候，我不会费心在AstPrinter中实现它们的访问方法，如果你想要添加（并且希望Java编译器不会报错），那么你可以自己添加对应的vistor方法，当我们将Lox代码解析为语法树时候，它将在接下来发挥作用。或者，如果你不想维护AstPrinter, 可以随时删除它，我们不再需要它。</p>
<h2 id="五challenges-1"><a class="header" href="#五challenges-1">五、CHALLENGES</a></h2>
<p>习题</p>
<ol>
<li>
<p>Earlier, I said that the |, *, and + forms we added to our grammar metasyntax were just syntactic sugar. Take this grammar:</p>
<p>早先，我讲了我们的元语法中，只是将 | * + 当作一些语法糖，</p>
<pre><code>
expr → expr ( &quot;(&quot; ( expr ( &quot;,&quot; expr )* )? &quot;)&quot; | &quot;.&quot; IDENTIFIER )+
  | IDENTIFIER
  | NUMBER


</code></pre>
<p>请生成同样的语法规则，不使用语法糖，上面这段语法规则，是描述了什么表达式？</p>
</li>
<li>
<p>The Visitor pattern lets you emulate the functional style in an object-oriented language. Devise a complementary pattern for a functional language. It should let you bundle all of the operations on one type together and let you define new types easily.</p>
<p>(SML or Haskell would be ideal for this exercise, but Scheme or another Lisp works as well.)</p>
<p>访问者模式允许我们在面向对象语言中使用模拟函数式编程风格。请，为函数式语言设计一个模式，它允许我们将所有的操作写入到一起，并且允许我们轻松的定义新的类型</p>
<p>SML 和 Haskell 是这个练习的理想语言，但是 Scheme 和 Lisp 也可以</p>
</li>
<li>
<p>In reverse Polish notation (RPN), the operands to an arithmetic operator are both placed before the operator, so 1 + 2 becomes 1 2 +. Evaluation proceeds from left to right. Numbers are pushed onto an implicit stack. An arithmetic operator pops the top two numbers, performs the operation, and pushes the result. Thus, this:</p>
<p>(1 + 2) * (4 - 3) in RPN becomes: 1 2 + 4 3 - *</p>
<p>Define a visitor class for our syntax tree classes that takes an expression, converts it to RPN, and returns the resulting string.</p>
<p>在逆波兰表示法中RPN，算术运算符的操作数放到操作符之前，例如：1 + 2将变为 1 2 + , 执行时候，从左到右。将操作数放入堆栈中，遇到操作符后，将弹出对应的操作数，执行运算，将结果重新放入堆栈</p>
<p>例如: </p>
<p>(1 + 2) * (4 - 3)  使用逆波兰表示法 1 2 + 4 3 - *</p>
<p>定义一个访问者类，针对不同的表达式类型，输出其逆波兰表示法。</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="解析表达式"><a class="header" href="#解析表达式">解析表达式</a></h1>
<blockquote>
<p>Grammar, which knows how to control even kings.</p>
<p>语法，知道如何控制国王。</p>
<p align="right">—— Molière </p>
</blockquote>
<p>This chapter marks the first major milestone of the book. Many of us have cobbled together a mishmash of regular expressions and substring operations to extract some sense out of a pile of text. The code was probably riddled with bugs and a beast to maintain. Writing a real parser—one with decent error handling, a coherent internal structure, and the ability to robustly chew through a sophisticated syntax—is considered a rare, impressive skill. In this chapter, you will attain it.</p>
<p>这一章是本书的一个重要里程碑，我们中的许多人都拼凑了一堆正则表达式和子字符串处理方法，以便在一堆文本中获取意义。代码可能存在漏洞，需要不断维护。编写一个真正的解析器——具有良好的错误处理能力，连贯的内部结构，对复杂语法的良好处理能力，被认为是一种罕见的、令人印象深刻的能力。在本章，我们将实现这个目标。</p>
<blockquote>
<p>“Parse” comes to English from the Old French “pars” for “part of speech”. It means to take a text and map each word to the grammar of the language. We use it here in the same sense, except that our language is a little more modern than Old French.</p>
<p>Like many rites of passage, you’ll probably find it looks a little smaller, a little less daunting when it’s behind you than when it loomed ahead.</p>
<p>parse 单词是从古法语中来的，它表示我们取一段文字，将每一个单词映射到语言的语法中，我们在这里使用的是，相同的含义，但是，我们要实现的语言更加现代一些，相比于古法语。</p>
<p>像是很多成人仪式一样，你可能会发现，这个看起来有点小，比它隐约出现在你的面前时候，令人更少一些畏惧。</p>
</blockquote>
<p>It’s easier than you think, partially because we front-loaded a lot of the hard work in the last chapter. You already know your way around a formal grammar. You’re familiar with syntax trees, and we have some Java classes to represent them. The only remaining piece is parsing—transmogrifying a sequence of tokens into one of those syntax trees.</p>
<p>Some CS textbooks make a big deal out of parsers. In the ’60s, computer scientists—understandably tired of programming in assembly language—started designing more sophisticated, human-friendly languages like Fortran and ALGOL. Alas, they weren’t very machine-friendly for the primitive computers of the time.</p>
<p>这个解析过程，比你想要的要简单一些，因为我们在上一章中，提前完成了很多艰苦的工作。你已经熟悉了正则语法，而且我们使用了很多的Java类来表示这些表达式。剩下的解析部分——将一系列的token解析为语法树。</p>
<p>有一些编程教科书，对解析器部分做了很大的改动。上世纪60年代初，计算机科学家对于汇编编程感到厌倦，这是可以理解的，于是，他们开始设计更加高级、人性化的语言，例如：Fortran ,Algol等等，虽然对于当时的原始计算机，这些语言不是很友好。</p>
<blockquote>
<p>Imagine how harrowing assembly programming on those old machines must have been that they considered Fortran to be an improvement.</p>
<p>想象一下，在那些老机器上，进行汇编语言编程是一件多么痛苦的事情，所以，计算机科学家们，认为使用Fortran语言编程，是一种改进。</p>
</blockquote>
<p>These pioneers designed languages that they honestly weren’t even sure how to write compilers for, and then did groundbreaking work inventing parsing and compiling techniques that could handle these new, big languages on those old, tiny machines.</p>
<p>Classic compiler books read like fawning hagiographies of these heroes and their tools. The cover of Compilers: Principles, Techniques, and Tools literally has a dragon labeled “complexity of compiler design” being slain by a knight bearing a sword and shield branded “LALR parser generator” and “syntax directed translation”. They laid it on thick.</p>
<p>A little self-congratulation is well-deserved, but the truth is you don’t need to know most of that stuff to bang out a high quality parser for a modern machine. As always, I encourage you to broaden your education and take it in later, but this book omits the trophy case.</p>
<p>这些计算机领域的先驱者们，设计了他们甚至还不知道如何编写编译器的语言，他们接着发明了解析、编译技术，在老旧的机器上处理新的语言。</p>
<p>经典的编译器书籍，读起来像是，这些先驱及其发明工具的传记。《编译器：原理、技术和工具》的封面是一条龙，龙身上写着编译器设计的复杂性，被一个手持盾牌和宝剑的骑士杀死。骑上盾牌上写着：LALR解析器生成器，语法向导翻译，这个非常重要。</p>
<p>有一些自鸣得意是理所当然的，但事实是，我们不需要了解其中的大部分内容，就可以为现代机器，设计出高质量的解析器。向之前一样，我鼓励你扩大学习范围，然后深入研究，本书省略奖杯案例。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/compiler-dragon.png?raw=true" alt="compiler-dragon" /></p>
<h2 id="一ambiguity-and-the-parsing-game"><a class="header" href="#一ambiguity-and-the-parsing-game">一、Ambiguity and the Parsing Game</a></h2>
<p>歧义和解析博弈</p>
<p>In the last chapter, I said you can “play” a context-free grammar like a game in order to generate strings. Parsers play that game in reverse. Given a string—a series of tokens—we map those tokens to terminals in the grammar to figure out which rules could have generated that string.</p>
<p>The “could have” part is interesting. It’s entirely possible to create a grammar that is ambiguous, where different choices of productions can lead to the same string. When you’re using the grammar to generate strings, that doesn’t matter much. Once you have the string, who cares how you got to it?</p>
<p>在上一章中，我们可以像玩游戏一样，通过上下文无关语法，生成一系列字符串，本章中，解析器将反其道而行之。给定一个字符串（一系列token）我们将这些token 映射到语法规则中，确定哪些规则，可以生成这样的字符串。</p>
<p>”可能有“ 部分（找出合适语法规则的过程）非常有意思，我们完全可以创建一个存在歧义的语法规则，不同的选择，却可以生成相同的字符串，当我们确定了语法规则后，这个过程将不再重要，一旦我们有了字符串，没有人会在乎我们是如何生成它的。</p>
<p>When parsing, ambiguity means the parser may misunderstand the user’s code. As we parse, we aren’t just determining if the string is valid Lox code, we’re also tracking which rules match which parts of it so that we know what part of the language each token belongs to. Here’s the Lox expression grammar we put together in the last chapter:</p>
<p>当解析时候，歧义意味着解析器可能会误解用户的代码。在解析时候，我们不仅仅要确定，字符串是否是，有效的lox语言代码，还需要跟踪哪些语法规则和字符串的哪些部分匹配，便于我们获取token属于具体的哪个部分，下面是我们之前总结的lox语法规则</p>
<pre><code>
expression     → literal
               | unary
               | binary
               | grouping ;

literal        → NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot; ;
grouping       → &quot;(&quot; expression &quot;)&quot; ;
unary          → ( &quot;-&quot; | &quot;!&quot; ) expression ;
binary         → expression operator expression ;
operator       → &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;
               | &quot;+&quot;  | &quot;-&quot;  | &quot;*&quot; | &quot;/&quot; ;
			   
</code></pre>
<p>This is a valid string in that grammar:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/tokens.png?raw=true" alt="tokens" /></p>
<p>But there are two ways we could have generated it. One way is:</p>
<ol>
<li>
<p>Starting at expression, pick binary.</p>
</li>
<li>
<p>For the left-hand expression, pick NUMBER, and use 6.</p>
</li>
<li>
<p>For the operator, pick &quot;/&quot;.</p>
</li>
<li>
<p>For the right-hand expression, pick binary again.</p>
</li>
<li>
<p>In that nested binary expression, pick 3 - 1.</p>
</li>
</ol>
<p>Another is:</p>
<ol>
<li>
<p>Starting at expression, pick binary.</p>
</li>
<li>
<p>For the left-hand expression, pick binary again.</p>
</li>
<li>
<p>In that nested binary expression, pick 6 / 3.</p>
</li>
<li>
<p>Back at the outer binary, for the operator, pick &quot;-&quot;.</p>
</li>
<li>
<p>For the right-hand expression, pick NUMBER, and use 1.</p>
</li>
</ol>
<p>Those produce the same strings, but not the same syntax trees:</p>
<p>下面一个合法的lox代码，但是我们可以使用两种方式生成, 生成的语法树如下: </p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/syntax-trees.png?raw=true" alt="syntax-trees" /></p>
<p>In other words, the grammar allows seeing the expression as (6 / 3) - 1 or 6 / (3 - 1). The binary rule lets operands nest any which way you want. That in turn affects the result of evaluating the parsed tree. The way mathematicians have addressed this ambiguity since blackboards were first invented is by defining rules for precedence and associativity.</p>
<ul>
<li>
<p>Precedence </p>
<p>determines which operator is evaluated first in an expression containing a mixture of different operators. Precedence rules tell us that we evaluate the / before the - in the above example. Operators with higher precedence are evaluated before operators with lower precedence. Equivalently, higher precedence operators are said to “bind tighter”.</p>
</li>
<li>
<p>Associativity </p>
<p>determines which operator is evaluated first in a series of the same operator. When an operator is left-associative (think “left-to-right”), operators on the left evaluate before those on the right. Since - is left-associative, this expression:</p>
<p>Assignment, on the other hand, is right-associative. This:</p>
</li>
</ul>
<p>换句话说，语法规则，可以将 </p>
<p><code>6/3-1</code> 视为 <code>(6/3)-1</code>  或者 <code>6/(3-1)</code></p>
<p>二叉树允许我们按照任意的方式嵌套，而这又会反过来影响，我们的解析过程，自从黑板被发明出来，数学家解决这个歧义的方式是：定义优先级，关联性规则。</p>
<ul>
<li>
<p>优先级</p>
<p>优先级确定了包含不同运算符的表达式中，我们首先计算哪个运算符。优先级规则告知我们，/ 优先于 -， 优先级高的运算符先计算；等价的，优先级较高的运算符，可以称为绑定更紧。</p>
</li>
<li>
<p>关联性</p>
<p>关联性决定了在一些相同优先级的运算符中，如何计算。当一个操作符是左关联的（即从左往右计算），左边的运算符的会先被计算，如果是左关联，下面的表达式一致</p>
</li>
</ul>
<pre><code>
5-3-1

</code></pre>
<pre><code>
(5-3)-1

</code></pre>
<p>赋值操作是右关联的，即下面的表达式一致</p>
<pre><code>a = b = c

</code></pre>
<pre><code>a = (b = c)

</code></pre>
<blockquote>
<p>While not common these days, some languages specify that certain pairs of operators have no relative precedence. That makes it a syntax error to mix those operators in an expression without using explicit grouping.</p>
<p>Likewise, some operators are non-associative. That means it’s an error to use that operator more than once in a sequence. For example, Perl’s range operator isn’t associative, so a .. b is OK, but a .. b .. c is an error.</p>
<p>虽然现在不常见，但是有一些语言，没有指定运算符的相对优先级，如果在一个表达式中包含不同的运算符，并且没有使用显示的分组，解析器会报错，语法错误。</p>
<p>同样，有一些运算符是非关联的。这意味着，在一个序列中，多次使用该运算符是错误的，举例: Perl语言中范围运算符是非关联的，即 
a...b 是合法的，但是 a...b...c 是非法的</p>
</blockquote>
<p>Without well-defined precedence and associativity, an expression that uses multiple operators is ambiguous—it can be parsed into different syntax trees, which could in turn evaluate to different results. We’ll fix that in Lox by applying the same precedence rules as C, going from lowest to highest.</p>
<p>如果没有定义运算符的优先级和关联性，那么使用多个运算符的表达式可能会引起歧义。这样的表达式，会生成不同的语法树，执行这些不同的语法树，会产生不同的结果。我们将在Lox语言中，定义和C语言，相同的运算符优先级。下面的优先级，从低到高</p>
<table><thead><tr><th>Name</th><th>Operators</th><th>Associates</th></tr></thead><tbody>
<tr><td>Equality</td><td>== !=</td><td>Left</td></tr>
<tr><td>Comparison</td><td>&gt; &gt;= &lt; &lt;=</td><td>Left</td></tr>
<tr><td>Term</td><td>+ -</td><td>Left</td></tr>
<tr><td>Factor</td><td>* /</td><td>Left</td></tr>
<tr><td>Unary</td><td>! -</td><td>Right</td></tr>
</tbody></table>
<p>Right now, the grammar stuffs all expression types into a single expression rule. That same rule is used as the non-terminal for operands, which lets the grammar accept any kind of expression as a subexpression, regardless of whether the precedence rules allow it.</p>
<p>现在，语法规则将所有的表达式类型，填充到单个表达式规则中。相同的规则，可以被当作操作数的非终止符，这使得语法可以接受任何类型的表达式当作子表达式，而不管优先级是否允许。</p>
<p>We fix that by stratifying the grammar. We define a separate rule for each precedence level.</p>
<p>我们通过语法分层来解决这个问题，我们为每个优先级定义了专门的规则。</p>
<pre><code>
expression     → ...
equality       → ...
comparison     → ...
term           → ...
factor         → ...
unary          → ...
primary        → ...

</code></pre>
<blockquote>
<p>Instead of baking precedence right into the grammar rules, some parser generators let you keep the same ambiguous-but-simple grammar and then add in a little explicit operator precedence metadata on the side in order to disambiguate.</p>
<p>有一些解析生成器，没有将优先级正确的添加到语法规则中，而是让你保持相同的模糊但是简单的语法，然后在旁边添加一些显式的运算符优先级元数据，用于消除歧义。</p>
</blockquote>
<p>Each rule here only matches expressions at its precedence level or higher. For example, unary matches a unary expression like !negated or a primary expression like 1234. And term can match 1 + 2 but also 3 * 4 / 5. The final primary rule covers the highest-precedence forms—literals and parenthesized expressions.</p>
<p>We just need to fill in the productions for each of those rules. We’ll do the easy ones first. The top expression rule matches any expression at any precedence level. Since equality has the lowest precedence, if we match that, then it covers everything.</p>
<p>上面的规则，只会匹配相同或更高优先级的表达式，例如：</p>
<p>一元 类型表达式可以匹配一个相同优先级的表达式 !unary 或者 像 1234 这样的主表达式</p>
<p>术语表达式可以匹配 1+2  或者 3*4/5 这样的表达式</p>
<p>最后的规则，即定义了主规则拥有最高的优先级，主规则匹配的类型为文字表达式和括号表达式</p>
<p>我们这需要填充每一个规则，让我们先从最简单的开始。顶级表达式可以匹配任何优先级的表达式，因为相等是最低优先级的表达式，如果我们匹配到它，我们将覆盖所有</p>
<pre><code>
expression     → equality

</code></pre>
<blockquote>
<p>We could eliminate expression and simply use equality in the other rules that contain expressions, but using expression makes those other rules read a little better.</p>
<p>Also, in later chapters when we expand the grammar to include assignment and logical operators, we’ll only need to change the production for expression instead of touching every rule that contains an expression.</p>
<p>我们可以取消相等表达式，在其他语法规则中，包含等式，但是，使用等式表达式，可以让其他语法规则更加容易理解。</p>
<p>此外，在后面的章节中，我们会扩展语法，包含赋值、逻辑运算符，我们只需要修改等式表达式的定义，不需要修改每一条其他语法规则。</p>
</blockquote>
<p>Over at the other end of the precedence table, a primary expression contains all the literals and grouping expressions.</p>
<p>在优先级表格的另外一边，主表达式包含文本和括号表达式</p>
<pre><code>
primary        → NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
               | &quot;(&quot; expression &quot;)&quot; ;

</code></pre>
<p>A unary expression starts with a unary operator followed by the operand. Since unary operators can nest—!!true is a valid if weird expression—the operand can itself be a unary operator. A recursive rule handles that nicely.</p>
<p>一元表达式是以一元运算符开始，后面跟随操作数。因为一元运算符可以嵌套 - ！</p>
<p>例如: !true 是一个奇怪但是有效的表达式，</p>
<p>我们使用递归规则可以很好的处理</p>
<pre><code>
unary          → ( &quot;!&quot; | &quot;-&quot; ) unary ;

</code></pre>
<p>But this rule has a problem. It never terminates.</p>
<p>Remember, each rule needs to match expressions at that precedence level or higher, so we also need to let this match a primary expression.</p>
<p>但是一元表达式规则，有个问题，它可能永远不会终止。请记住，每一个规则匹配优先级相同或者更高的表达式，因此，我们还需要匹配主表达式</p>
<pre><code class="language-C">
unary          → ( &quot;!&quot; | &quot;-&quot; ) unary
               | primary ;

</code></pre>
<p>That works.</p>
<p>上面的规则生效了。</p>
<p>The remaining rules are all binary operators. We’ll start with the rule for multiplication and division. Here’s a first try:</p>
<p>其余规则都是二元运算符，我们首先从乘法和除法开始，下面是第一次尝试</p>
<pre><code class="language-c">
factor         → factor ( &quot;/&quot; | &quot;*&quot; ) unary
               | unary ;
			   
</code></pre>
<p>The rule recurses to match the left operand. That enables the rule to match a series of multiplication and division expressions like 1 * 2 / 3. Putting the recursive production on the left side and unary on the right makes the rule left-associative and unambiguous.</p>
<p>All of this is correct, but the fact that the first symbol in the body of the rule is the same as the head of the rule means this production is left-recursive. Some parsing techniques, including the one we’re going to use, have trouble with left recursion. (Recursion elsewhere, like we have in unary and the indirect recursion for grouping in primary are not a problem.)</p>
<p>该规则会以左关联，递归调用，这样，这条语法规则，将会产生一系列的乘法除法表达式，例如：1*2/3</p>
<p>我们将递归放在左侧，一元运算规则放在右侧，是为了使得该规则左关联，以确保规则是明确没有歧义的</p>
<p>所有这一切都是正确的，当规则正文中的第一个符号和规则标题相同的时候，意味着这个规则是左递归的，有一些解析技术，包括我们将要使用的技术，在解析左递归方面存在一些问题。其他地方的递归，例如：一元中的递归，以及在主表达式中用于分组的间接递归都不是问题</p>
<blockquote>
<p>In principle, it doesn’t matter whether you treat multiplication as left- or right-associative—you get the same result either way. Alas, in the real world with limited precision, roundoff and overflow mean that associativity can affect the result of a sequence of multiplications. Consider:</p>
<p><code>print 0.1 * (0.2 * 0.3);</code></p>
<p><code>print (0.1 * 0.2) * 0.3;</code></p>
<p>In languages like Lox that use <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754</a> double-precision floating-point numbers, the first evaluates to 0.006, while the second yields <code>0.006000000000000001</code>.</p>
<p>Sometimes that tiny difference matters. This is a good place to learn more.</p>
<p>原则上，无论我们将乘法，设置为左关联/右关联，结果都是相同的，但实际上，在现实世界中，数值型计算会有溢出和舍入，例如:</p>
<p>在Lox语言中，我们遵守 IEEE 754双精度规则，第一个表达式计算结果是 0.006, 第二个表达式计算结果是 0.006000000000000001</p>
<p>有时候，这个微小的差别非常重要，需要注意</p>
</blockquote>
<p>There are many grammars you can define that match the same language. The choice for how to model a particular language is partially a matter of taste and partially a pragmatic one. This rule is correct, but not optimal for how we intend to parse it. Instead of a left recursive rule, we’ll use a different one.</p>
<p>我们可以定义许多语法，和同一个语言相匹配。如果为一门语言建模，一部分取决于编程品味，一部分取决于应用。这个规则是正确的，但是，对于我们如何解析它来说不是最佳的，我们将使用新的规则，而不是使用左递归规则</p>
<pre><code class="language-c">
factor         → unary ( ( &quot;/&quot; | &quot;*&quot; ) unary )* ;

</code></pre>
<p>We define a factor expression as a flat sequence of multiplications and divisions. This matches the same syntax as the previous rule, but better mirrors the code we’ll write to parse Lox. We use the same structure for all of the other binary operator precedence levels, giving us this complete expression grammar:</p>
<p>我们将因子表达式定义为乘法和除法混合的平面的序列。这个规则和前面的规则，匹配相同的语法，但是，更好的反映了我们将要编写的解析Lox的代码。我们对所有的其他二元运算符优先级，使用相同结构，从而，我们将获得完整的表达式语法</p>
<pre><code class="language-C">
expression -&gt; equality;

equality -&gt; comparison (( &quot;!=&quot; | &quot;==&quot; ) comparison )* ;

comparison -&gt; term ( ( &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; ) term)* ;

term           → factor ( ( &quot;-&quot; | &quot;+&quot; ) factor )* ;

factor         → unary ( ( &quot;/&quot; | &quot;*&quot; ) unary )* ;

unary          → ( &quot;!&quot; | &quot;-&quot; ) unary
	           | primary ;
			   
primary        → NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
	           | &quot;(&quot; expression &quot;)&quot; ;
			   
</code></pre>
<p>This grammar is more complex than the one we had before, but in return we have eliminated the previous one’s ambiguity. It’s just what we need to make a parser.</p>
<p>上面的语法规则，比我们之前的语法规则更加复杂，但是作为回报，我们消除了之前的歧义，这就是我们想要的解析器。</p>
<h2 id="二recursive-descent-parsing"><a class="header" href="#二recursive-descent-parsing">二、Recursive Descent Parsing</a></h2>
<p>递归下降分析</p>
<p>There is a whole pack of parsing techniques whose names are mostly combinations of “L” and “R”—LL(k), LR(1), LALR—along with more exotic beasts like parser combinators, Earley parsers, the shunting yard algorithm, and packrat parsing. For our first interpreter, one technique is more than sufficient: recursive descent.</p>
<p>Recursive descent is the simplest way to build a parser, and doesn’t require using complex parser generator tools like Yacc, Bison or ANTLR. All you need is straightforward handwritten code. Don’t be fooled by its simplicity, though. Recursive descent parsers are fast, robust, and can support sophisticated error handling. In fact, GCC, V8 (the JavaScript VM in Chrome), Roslyn (the C# compiler written in C#) and many other heavyweight production language implementations use recursive descent. It rocks.</p>
<p>Recursive descent is considered a top-down parser because it starts from the top or outermost grammar rule (here expression) and works its way down into the nested subexpressions before finally reaching the leaves of the syntax tree. This is in contrast with bottom-up parsers like LR that start with primary expressions and compose them into larger and larger chunks of syntax.</p>
<p>有一整套的解析技术，其名称大多是L R 的组合——<a href="https://en.wikipedia.org/wiki/LL_parser">LL(k)</a> , <a href="https://en.wikipedia.org/wiki/LR_parser">LR(1)</a> , <a href="https://en.wikipedia.org/wiki/LALR_parser">LALR</a>, 此外，还有一些更奇特的组合，<a href="https://en.wikipedia.org/wiki/Parser_combinator">语法分析组合子 parser combinators</a>, <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parser</a>, <a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">调度场算法 the shunting yard algorithm</a>, <a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95">解析表达文法 packrat parsing</a>。 但是对于我们的第一个解析器，使用一种技巧就足够了: 递归下降分析</p>
<p>递归下降是构造解析器的最简单方法，而且我们不需要使用 yacc, Bison, ANTLR 这样的生成器工具。我们需要的仅仅是简单的手写代码，但是，不要被它的简单所迷惑。递归下降的解析器，速度快，代码健壮，可以支持复杂的错误处理。事实上，很多重量级的解析器，都是用递归下降分析，例如：GCC， V8（chrome中JavaScript的VM），Roslyn（C#编写的C#编译器）</p>
<p>递归下降被认为是一种自顶向下的解析器，因为它是从最上面或者最外面的语法规则（上文中的 expression规则）开始，一直向下到嵌套的子表达式，最后到达，语法树的叶子节点，这与自底向上的解析器，形成对比。例如：自底向上的解析器LR，会从最底层的 primary开始，然后，一直组合子表达式，语法块越来越大。</p>
<blockquote>
<p>It’s called “recursive descent” because it walks down the grammar. Confusingly, we also use direction metaphorically when talking about “high” and “low” precedence, but the orientation is reversed. In a top-down parser, you reach the lowest-precedence expressions first because they may in turn contain subexpressions of higher precedence.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/direction.png?raw=true" alt="direction" /></p>
<p>CS people really need to get together and straighten out their metaphors. Don’t even get me started on which direction a stack grows or why trees have their roots on top.</p>
<p>这种解析技术，被称为递归下降，因为它遵循这语法，令人困惑的是，当我们谈论优先级的高低时候，我们也会使用方向来比喻，但是方向相反。在自上而下的解析器中，我们将首先到达优先级最低的表达式，因为优先级低的表达式中，可能包含着优先级较高的子表达式</p>
<p>计算机科学领域，真的需要统一一下表述。甚至，不要让我一开始在了解语法树方向时候，就困惑，为什么树根在最上面。</p>
</blockquote>
<p>A recursive descent parser is a literal translation of the grammar’s rules straight into imperative code. Each rule becomes a function. The body of the rule translates to code roughly like:</p>
<table><thead><tr><th>Grammar notation</th><th>Code representation</th></tr></thead><tbody>
<tr><td>Terminal</td><td>Code to match and consume a token</td></tr>
<tr><td>Nonterminal</td><td>Call to that rule’s function</td></tr>
<tr><td></td><td></td></tr>
<tr><td>* or +</td><td>while or for loop</td></tr>
<tr><td>?</td><td>if statement</td></tr>
</tbody></table>
<p>The descent is described as “recursive” because when a grammar rule refers to itself—directly or indirectly—that translates to a recursive function call.</p>
<p>递归下降解析器是将语法规则直接翻译为命令式代码的直译，每个规则都成为一个函数，规则的转换可以参考：</p>
<p>下降将被描述为“递归”，因为当语法规则直接或者间接的引用自身时候，它会转化为递归函数调用</p>
<h3 id="21-the-parser-class"><a class="header" href="#21-the-parser-class">2.1 The parser class</a></h3>
<p>解析类</p>
<p>Each grammar rule becomes a method inside this new class:</p>
<p>每个语法规则都会变为解析类中的一个方法</p>
<pre><code class="language-java">
// lox/Parser.java, create new file


package com.craftinginterpreters.lox;

import java.util.List;

import static com.craftinginterpreters.lox.TokenType.*;

class Parser {
  private final List&lt;Token&gt; tokens;
  private int current = 0;

  Parser(List&lt;Token&gt; tokens) {
    this.tokens = tokens;
  }
}

</code></pre>
<p>Like the scanner, the parser consumes a flat input sequence, only now we’re reading tokens instead of characters. We store the list of tokens and use current to point to the next token eagerly waiting to be parsed.</p>
<p>和扫描器一样，解析器使用输入的序列，只不过我们从扫描器的字符序列，变为了解析器的token序列，在类中，我们会存储 token序列，并且使用 current, 表示下一个等待解析的token</p>
<p>We’re going to run straight through the expression grammar now and translate each rule to Java code. The first rule, expression, simply expands to the equality rule, so that’s straightforward.</p>
<p>现在，我们将直接运行表达式语法，并将每个语法规则转为Java 代码，第一条规则，表达式，简单的扩展为等式规则，所以这个非常简单</p>
<pre><code class="language-java">
// lox/Parser.java, add after Parser()

  private Expr expression() {
    return equality();
  }
  
</code></pre>
<p>Each method for parsing a grammar rule produces a syntax tree for that rule and returns it to the caller. When the body of the rule contains a nonterminal—a reference to another rule—we call that other rule’s method.</p>
<p>The rule for equality is a little more complex.</p>
<p>每一个语法规则解析方法，都为该语法规则生成一个语法树，并且将语法树，返回给调用者，当规则中包含有一个非终止符时候——对另一个规则的引用，我们将调用另外一个规则。</p>
<blockquote>
<p>This is why left recursion is problematic for recursive descent. The function for a left-recursive rule immediately calls itself, which calls itself again, and so on, until the parser hits a stack overflow and dies.</p>
<p>这就是为什么左递归，对于递归下降是有问题的原因，左递归语法规则，将会立即调用自身，然后一直无限循环，直到解析器遇到堆栈溢出，程序崩溃</p>
</blockquote>
<p>下面等式的规则有些复杂</p>
<pre><code>
equality       → comparison ( ( &quot;!=&quot; | &quot;==&quot; ) comparison )* ;

</code></pre>
<p>In Java, that becomes:</p>
<p>使用 Java实现，变为：</p>
<pre><code class="language-java">
// lox/Parser.java, add after expression()

  private Expr equality() {
    Expr expr = comparison();

    while (match(BANG_EQUAL, EQUAL_EQUAL)) {
      Token operator = previous();
      Expr right = comparison();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }


</code></pre>
<p>Let’s step through it. The first comparison nonterminal in the body translates to the first call to comparison() in the method. We take that result and store it in a local variable.</p>
<p>Then, the ( ... )* loop in the rule maps to a while loop. We need to know when to exit that loop. We can see that inside the rule, we must first find either a != or == token. So, if we don’t see one of those, we must be done with the sequence of equality operators. We express that check using a handy match() method.</p>
<p>让我们逐一了解，语法规则中的 comparison 非终止符，将变为解析类中的一个方法—— comparison(), 我们将调用 comparison() ，并且返回结果，存储在局部变量中。</p>
<p>接下来，语法规则中的 ( ... ) * 循环将变为Java代码中的 while 循环，我们需要知道什么时候，退出循环，从语法规则中，可以发现，我们需要先找到一个 != 或者  == 的 token, 所以，如果我们看不到 == 或者 != , 我们必须对等式运算符序列进行处理，我们将简单的使用一个match() 函数，实现该检查</p>
<pre><code class="language-java">
// lox/Parser.java, add after equality()

  private boolean match(TokenType... types) {
    for (TokenType type : types) {
      if (check(type)) {
        advance();
        return true;
      }
    }

    return false;
  }
  
</code></pre>
<p>This checks to see if the current token has any of the given types. If so, it consumes the token and returns true. Otherwise, it returns false and leaves the current token alone. The match() method is defined in terms of two more fundamental operations.</p>
<p>The check() method returns true if the current token is of the given type. Unlike match(), it never consumes the token, it only looks at it.</p>
<p>The advance() method consumes the current token and returns it, similar to how our scanner’s corresponding method crawled through characters.</p>
<p>These methods bottom out on the last handful of primitive operations.</p>
<p>这个match()函数，将检查当前的token，是否是参数中的token类型，如果当前token满足给定的类型，将返回 true, 否则，将返回false，并且保留在当前的位置，match() 函数中，将会调用其他两个函数 check() , advance()</p>
<p>如果当前的token符合给定的 token类型，check() 方法将返回true， 与match() 方法不一样，check()方法，不会前移token（及发现满足条件后，current前移一位），只会检查token类型</p>
<p>advance() 方法使用current位置的token，并且返回，类似于我们在扫描器中，对应的字符级别的 advance() 方法</p>
<p>advance() 方法，将会使用到下面的基本方法</p>
<pre><code class="language-java">
// lox/Parser.java, add after match()

  private boolean check(TokenType type) {
    if (isAtEnd()) return false;
    return peek().type == type;
  }


</code></pre>
<pre><code class="language-java">
// lox/Parser.java, add after check()

  private Token advance() {
    if (!isAtEnd()) current++;
    return previous();
  }


</code></pre>
<pre><code class="language-java">
// lox/Parser.java, add after advance()

  private boolean isAtEnd() {
    return peek().type == EOF;
  }

  private Token peek() {
    return tokens.get(current);
  }

  private Token previous() {
    return tokens.get(current - 1);
  }


</code></pre>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/parse-fun.png?raw=true" alt="func" /></p>
<p>isAtEnd() checks if we’ve run out of tokens to parse. peek() returns the current token we have yet to consume, and previous() returns the most recently consumed token. The latter makes it easier to use match() and then access the just-matched token.</p>
<p>isAtEnd() 方法，检查token是否已经使用完，peek(） 返回current位置的token，previous() 返回最近使用的token，previous() 方法，让 match() 函数更加容易，访问匹配的token</p>
<p>That’s most of the parsing infrastructure we need. Where were we? Right, so if we are inside the while loop in equality(), then we know we have found a != or == operator and must be parsing an equality expression.</p>
<p>We grab the matched operator token so we can track which kind of equality expression we have. Then we call comparison() again to parse the right-hand operand. We combine the operator and its two operands into a new Expr.Binary syntax tree node, and then loop around. For each iteration, we store the resulting expression back in the same expr local variable. As we zip through a sequence of equality expressions, that creates a left-associative nested tree of binary operator nodes.</p>
<p>这就是我们需要使用的大部分的，解析基础结构，我们在哪里？如果我们在 equality() 方法的while循环中，那么我们需要找到 != 或者 == 运算符，并且必须解析等式表达式。</p>
<p>我们将获取匹配到的运算符token（ == 或者 != ), 以便跟踪我们拥有哪种等式表达式，然后，我们将再次调用 comparison() 方法，来解析右边的操作数，我们将两个操作数和运算符，组合为一个新的二元表达式语法树，然后，循环，对于每一次迭代，我们都将结果保存在相同的expr 局部变量中，</p>
<p>当我们创建一系列的等式表达式时候，我们将创建一个二元运算符节点的左关联嵌套树。</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/sequence.png?raw=true" alt="sequence" /></p>
<blockquote>
<p>Parsing a == b == c == d == e. For each iteration, we create a new binary expression using the previous one as the left operand.</p>
<p>解析 a == b == c == d == e, 我们每一次都会使用前一个计算结果，当作后面的二元表达式的左值，例如：我们先计算 a == b，将结果当作 x == c 中的 x</p>
</blockquote>
<p>The parser falls out of the loop once it hits a token that’s not an equality operator. Finally, it returns the expression. Note that if the parser never encounters an equality operator, then it never enters the loop. In that case, the equality() method effectively calls and returns comparison(). In that way, this method matches an equality operator or anything of higher precedence.</p>
<p>一旦解析器碰到不是等式运算符的token， 它就会退出循环，最后，解析器会返回表达式，需要注意的是，如果解析器没有遇到等式运算符，它永远不会进入循环，在这种情况下，equaility() 函数，调用会返回 comparison(). 通过上面的方式，此方法将会匹配相等运算符，或者任何优先级较高的运算符。</p>
<p>Moving on to the next rule . . . </p>
<pre><code>
comparison     → term ( ( &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; ) term )* ;

</code></pre>
<p>Translated to Java:</p>
<pre><code class="language-java">
// lox/Parser.java add after equality()

  private Expr comparison() {
    Expr expr = term();

    while (match(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL)) {
      Token operator = previous();
      Expr right = term();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }
  
</code></pre>
<p>The grammar rule is virtually identical to equality and so is the corresponding code. The only differences are the token types for the operators we match, and the method we call for the operands—now term() instead of comparison(). The remaining two binary operator rules follow the same pattern.</p>
<p>继续进行下个语法规则</p>
<p>语法规则实际等同于相等表达式，相应的代码也是如此，唯一的区别是我们匹配的运算符token的类型，以及，我们为了操作数调用的方法是 term() 而不是 comparison() , 另外的两个二元运算符规则，遵循相同的模式</p>
<blockquote>
<p>If you wanted to do some clever Java 8, you could create a helper method for parsing a left-associative series of binary operators given a list of token types, and an operand method handle to simplify this redundant code.</p>
<p>如果不想一直这样构造函数，可以通过一个helper函数，生成对应的解析方法</p>
</blockquote>
<p>In order of precedence, first addition and subtraction:</p>
<p>按照运算优先级，首先考虑加法和减法运算</p>
<pre><code class="language-java">
// lox/Parser.java add after comparison()

  private Expr term() {
    Expr expr = factor();

    while (match(MINUS, PLUS)) {
      Token operator = previous();
      Expr right = factor();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }
  
</code></pre>
<p>And finally, multiplication and division:</p>
<p>最后，考虑乘法和除法</p>
<pre><code class="language-java">
//lox/Parser.java add after term()

 private Expr factor() {
    Expr expr = unary();

    while (match(SLASH, STAR)) {
      Token operator = previous();
      Expr right = unary();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }
  
</code></pre>
<p>That’s all of the binary operators, parsed with the correct precedence and associativity. We’re crawling up the precedence hierarchy and now we’ve reached the unary operators.</p>
<p>这就是所有的二元运算符，以正确的优先级和关联性解析，我们正在往优先级更高的运算符进行解析，下一步，我们将解析一元运算符</p>
<pre><code>
unary          → ( &quot;!&quot; | &quot;-&quot; ) unary
               | primary ;
			   
</code></pre>
<p>The code for this is a little different.</p>
<p>代码看起来有点不一样</p>
<pre><code class="language-java">
// lox/Parser.java, add after factor()

  private Expr unary() {
    if (match(BANG, MINUS)) {
      Token operator = previous();
      Expr right = unary();
      return new Expr.Unary(operator, right);
    }

    return primary();
  }
  
</code></pre>
<p>Again, we look at the current token to see how to parse. If it’s a ! or -, we must have a unary expression. In that case, we grab the token and then recursively call unary() again to parse the operand. Wrap that all up in a unary expression syntax tree and we’re done.</p>
<p>我们查看当前的 token，判断如何解析； 如果当前的 token 是 ！或者 - 等一元运算符，我们将获得一个一元表达式，在这种情况下，我们通过 previous() 获取操作符，还需要通过再次调用 unary() 获取一元运算符的右值，即操作数。然后，我们将获取到一个一元运算符语法树。</p>
<blockquote>
<p>The fact that the parser looks ahead at upcoming tokens to decide how to parse puts recursive descent into the category of predictive parsers.</p>
<p>事实上，解析器会提前查看当前位置的token，决定如何接下来的解析流程，递归下降由此被归类为，预测解析器的范畴。</p>
</blockquote>
<p>Otherwise, we must have reached the highest level of precedence, primary expressions.</p>
<p>接下来，我们将进入主表达式的解析方法，主表达式是优先级最高的表达式</p>
<pre><code>
primary        → NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
               | &quot;(&quot; expression &quot;)&quot; ;
			   
</code></pre>
<p>Most of the cases for the rule are single terminals, so parsing is straightforward.</p>
<p>这个表达式的大多数情况，是一个单终结符，因此解析方法很简单。</p>
<pre><code class="language-java">
// lox/Parser.java, add after unary()

 private Expr primary() {
    if (match(FALSE)) return new Expr.Literal(false);
    if (match(TRUE)) return new Expr.Literal(true);
    if (match(NIL)) return new Expr.Literal(null);

    if (match(NUMBER, STRING)) {
      return new Expr.Literal(previous().literal);
    }

    if (match(LEFT_PAREN)) {
      Expr expr = expression();
      consume(RIGHT_PAREN, &quot;Expect ')' after expression.&quot;);
      return new Expr.Grouping(expr);
    }
  }
  
</code></pre>
<p>The interesting branch is the one for handling parentheses. After we match an opening ( and parse the expression inside it, we must find a ) token. If we don’t, that’s an error.</p>
<p>有趣的分支是处理括号的分支，在匹配到一个左括号后，我们必须找到一个对应的括号，如果没有找到对应的括号，解析将报错。</p>
<h2 id="三syntax-errors"><a class="header" href="#三syntax-errors">三、Syntax Errors</a></h2>
<p>语法错误</p>
<p>A parser really has two jobs:</p>
<ol>
<li>
<p>Given a valid sequence of tokens, produce a corresponding syntax tree.</p>
</li>
<li>
<p>Given an invalid sequence of tokens, detect any errors and tell the user about their mistakes.</p>
</li>
</ol>
<p>解析器实际上有两项任务，</p>
<ol>
<li>
<p>给定一个合法有效 token 序列，生成一个语法树</p>
</li>
<li>
<p>给定一个非法的 token 序列，检测错误，并且通知用户详细错误</p>
</li>
</ol>
<p>Don’t underestimate how important the second job is! In modern IDEs and editors, the parser is constantly reparsing code—often while the user is still editing it—in order to syntax highlight and support things like auto-complete. That means it will encounter code in incomplete, half-wrong states all the time.</p>
<p>When the user doesn’t realize the syntax is wrong, it is up to the parser to help guide them back onto the right path.  The way it reports errors is a large part of your language’s user interface. Good syntax error handling is hard. By definition, the code isn’t in a well-defined state, so there’s no infallible way to know what the user meant to write. The parser can’t read your mind.</p>
<p>不要低估第二个任务的重要性，解析器经常在用户在用户仍在编辑代码时候，同步分析代码，用于支持代码高亮和自动补全功能。这意味着，分析的代码将始终处于不完整、半错误状态的代码。</p>
<p>当用户还没有注意到语法错误时候，解析器将帮助他们返回正确的语法，语法错误的提示，是IDE 用户界面的很大一部分，通常很好的处理报错是一项艰难的任务，根据定义，代码没有处于定义良好的状态，因此，我们没有可靠的方式，获知用户将要输入什么，毕竟，解析器无法获知用户的思想。</p>
<blockquote>
<p>Not yet at least. With the way things are going in machine learning these days, who knows what the future will bring?</p>
<p>至少现在还没有，随着机器学习的发展，我们并不知道未来会变成什么样？🐶</p>
</blockquote>
<p>There are a couple of hard requirements for when the parser runs into a syntax error. A parser must:</p>
<ul>
<li>
<p><strong>Detect and report the error.</strong></p>
<p>If it doesn’t detect the error and passes the resulting malformed syntax tree on to the interpreter, all manner of horrors may be summoned.</p>
</li>
<li>
<p><strong>Avoid crashing or hanging.</strong></p>
<p>Syntax errors are a fact of life, and language tools have to be robust in the face of them. Segfaulting or getting stuck in an infinite loop isn’t allowed. While the source may not be valid code, it’s still a valid input to the parser because users use the parser to learn what syntax is allowed.</p>
</li>
</ul>
<p>当解析器遇到语法错误时候，有几个硬性要求，</p>
<ul>
<li>
<p>检测并且报告错误，</p>
<p>如果没有及时检测到错误，并且报告错误，而是将错误格式的语法树返回给解析器，那么可能引发各种各样的报错。</p>
</li>
<li>
<p>避免程序挂起或者崩溃</p>
<p>语法错误是生活中的一个事实，面对这些错误，语言解析器必须是健壮的，不能出现 <a href="https://zh.wikipedia.org/zh-cn/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4">存储器段错误</a> 或者无限循环。虽然，源代码不是有效的代码，但是它仍然是解析器的有效输入，因为用户通过解析器了解到哪些语法是允许的。</p>
</li>
</ul>
<p>Those are the table stakes if you want to get in the parser game at all, but you really want to raise the ante beyond that. A decent parser should:</p>
<ul>
<li>
<p>**Be fast. **</p>
<p>Computers are thousands of times faster than they were when parser technology was first invented. The days of needing to optimize your parser so that it could get through an entire source file during a coffee break are over. But programmer expectations have risen as quickly, if not faster. They expect their editors to reparse files in milliseconds after every keystroke.</p>
</li>
<li>
<p>**Report as many distinct errors as there are. **</p>
<p>Aborting after the first error is easy to implement, but it’s annoying for users if every time they fix what they think is the one error in a file, a new one appears. They want to see them all.</p>
</li>
<li>
<p><strong>Minimize cascaded errors.</strong></p>
<p>Once a single error is found, the parser no longer really knows what’s going on. It tries to get itself back on track and keep going, but if it gets confused, it may report a slew of ghost errors that don’t indicate other real problems in the code. When the first error is fixed, those phantoms disappear, because they reflect only the parser’s own confusion. Cascaded errors are annoying because they can scare the user into thinking their code is in a worse state than it is.</p>
</li>
</ul>
<p>The last two points are in tension. We want to report as many separate errors as we can, but we don’t want to report ones that are merely side effects of an earlier one.</p>
<p>上面两点是入局解析器游戏的基本条件，但是，如果你想提高自己的筹码，一个更好的解析器应该:</p>
<ul>
<li>
<p>编译更快 </p>
<p>计算机的运行速度，比解析器技术，首次发明的时候，快了数千倍。需要优化解析器编译速度，需要喝完一整杯咖啡才能编译完成的日子，已经过去了。但是，程序员的期望值也在不断变高，他们希望在毫秒内重新编译源码。</p>
</li>
<li>
<p>报告尽可能多的明显错误</p>
<p>在发现第一个错误时候，马上终止解析器，很容易实现，但是，如果用户每次只能发现代码中的一个错误，一次次的重新修改，会给用户很不好的体验，他们希望一次发现所有的明显错误。</p>
</li>
<li>
<p>最小化级联错误</p>
<p>一旦发现了一个错误，解析器不再真的知道，发生了什么。解析器试图让解析回到正轨，并且继续解析，但是如果它无法前进，可能会发现大量的关联错误，这些错误并不表示，这些错误处是真正的问题所在。当第一个错误被发现并且修复后，大量的关联错误将会消失，因为它们不是真的错误。级联错误非常烦人，因为，客户通常会认为，自己的代码状态比实际情况差多了。</p>
</li>
</ul>
<p>后面的两点要求，有一定的竞争关系。我们既希望，报告尽可能多的明显错误，但是，我们也希望，报告尽可能少的关联错误。</p>
<p>The way a parser responds to an error and keeps going to look for later errors is called error recovery. This was a hot research topic in the ’60s. Back then, you’d hand a stack of punch cards to the secretary and come back the next day to see if the compiler succeeded. With an iteration loop that slow, you really wanted to find every single error in your code in one pass.</p>
<p>Today, when parsers complete before you’ve even finished typing, it’s less of an issue. Simple, fast error recovery is fine.</p>
<p>解析器响应错误，并且继续查找后续错误的方式，称为错误恢复。这是60年代的热门研究课题。在那个年代，你会把一叠穿孔卡纸，交给相关人员，然后，在第二天，去查看编译器是否执行成功。由于迭代循环如何缓慢，我们希望在一次编译中发现尽可能完整的错误。</p>
<p>今天，解析器通常在你还没有编辑完成，就已经完成解析，问题不是很大，简单、快速的错误恢复更好。</p>
<h3 id="31-panic-mode-error-recovery"><a class="header" href="#31-panic-mode-error-recovery">3.1 Panic mode error recovery</a></h3>
<p>恐慌模式错误恢复</p>
<blockquote>
<p>You know you want to push it.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/panic.png?raw=true" alt="panic" /></p>
<p>你想要按下它 😄</p>
</blockquote>
<p>Of all the recovery techniques devised in yesteryear, the one that best stood the test of time is called—somewhat alarmingly—panic mode. As soon as the parser detects an error, it enters panic mode. It knows at least one token doesn’t make sense given its current state in the middle of some stack of grammar productions.</p>
<p>Before it can get back to parsing, it needs to get its state and the sequence of forthcoming tokens aligned such that the next token does match the rule being parsed. This process is called synchronization.</p>
<p>To do that, we select some rule in the grammar that will mark the synchronization point. The parser fixes its parsing state by jumping out of any nested productions until it gets back to that rule. Then it synchronizes the token stream by discarding tokens until it reaches one that can appear at that point in the rule.</p>
<p>Any additional real syntax errors hiding in those discarded tokens aren’t reported, but it also means that any mistaken cascaded errors that are side effects of the initial error aren’t falsely reported either, which is a decent trade-off.</p>
<p>The traditional place in the grammar to synchronize is between statements. We don’t have those yet, so we won’t actually synchronize in this chapter, but we’ll get the machinery in place for later.</p>
<p>在过去发明的所有错误恢复技术中，最禁得起时间考验的是恐慌模式的错误恢复技术。一旦解析器检测到错误，它将进入到恐慌模式，它知道至少有一个 token，没有实际意义，当我们需要获取语法生成的堆栈中的当前状态。</p>
<p>在返回解析之前，它需要获取其状态，并且和即将解析的 token序列对齐，以便下一个token 和当前的解析规则匹配，这个过程称之为同步。</p>
<p>为此，我们在语法中，选择一些规则，来标记同步点。解析器，肯能会跳出一些嵌套循环，用于恢复其解析状态，直到返回该解析规则。然后，解析器通过丢弃token，来同步token 流，直到它到达可以出现在规则中的那个点。</p>
<p>隐藏在这些被丢弃的token中的，任何其他真实的错误都不会被报告，这也意外着，任何错误的级联错误（初始错误的副作用）也不会被错误报告，这是一个不错的权衡。</p>
<p>语法中的传统同步位置，是语句之间。我们还没有涉及到，所以我们将不会在本章中实现同步，但是后面章节会实现。</p>
<h3 id="32-entering-panic-mode"><a class="header" href="#32-entering-panic-mode">3.2 Entering panic mode</a></h3>
<p>进入恐慌模式</p>
<p>Back before we went on this side trip around error recovery, we were writing the code to parse a parenthesized expression. After parsing the expression, the parser looks for the closing ) by calling consume(). Here, finally, is that method:</p>
<p>在我们讨论错误恢复之前，我们的解析器正在，编写代码解析带括号的表达式。解析表达式以后，我们通过调用 consume()方法，来查找后面的 ），最后的方法如下：</p>
<pre><code class="language-java">
// lox/Parser.java, add after match()

  private Token consume(TokenType type, String message) {
    if (check(type)) return advance();

    throw error(peek(), message);
  }
  
</code></pre>
<p>It’s similar to match() in that it checks to see if the next token is of the expected type. If so, it consumes the token and everything is groovy. If some other token is there, then we’ve hit an error. We report it by calling this:</p>
<p>consume() 方法和match() 方法类似，它们都会检查当前 token 是否是预期的类型，如果是合适的类型，consume() 方法会消耗一个位置，一切都会正常运行。如果不是合适的类型，将会产生一个错误</p>
<pre><code class="language-java">
// lox/Parser.java, add after previous()

  private ParseError error(Token token, String message) {
    Lox.error(token, message);
    return new ParseError();
  }
  
</code></pre>
<p>First, that shows the error to the user by calling:</p>
<p>首先，我们通过调用下面方法，向用户报告错误</p>
<pre><code class="language-java">
// lox/Lox.java, add after report()

  static void error(Token token, String message) {
    if (token.type == TokenType.EOF) {
      report(token.line, &quot; at end&quot;, message);
    } else {
      report(token.line, &quot; at '&quot; + token.lexeme + &quot;'&quot;, message);
    }
  }
  
</code></pre>
<p>This reports an error at a given token. It shows the token’s location and the token itself. This will come in handy later since we use tokens throughout the interpreter to track locations in code.</p>
<p>这个方法，将报告给定token 的具体错误，它将会报告token 的位置和token 的字符值，这将在以后派上用场，因为我们在这个解释器中，使用token来定位追踪代码的位置</p>
<p>After we report the error, the user knows about their mistake, but what does the parser do next? Back in error(), we create and return a ParseError, an instance of this new class:</p>
<p>在我们报告了错误后，用户知道了他们代码中的错误，但是，接下来，解析器将如何运行呢？回到error() 方法，我们将创建并且返回一个新的类实例，ParseError()</p>
<pre><code class="language-java">
// lox/Parser.java, nest inside class Parser


class Parser {
  private static class ParseError extends RuntimeException {}

  private final List&lt;Token&gt; tokens;
  
</code></pre>
<p>This is a simple sentinel class we use to unwind the parser.  The error() method returns the error instead of throwing it because we want to let the calling method inside the parser decide whether to unwind or not.  Some parse errors occur in places where the parser isn’t likely to get into a weird state and we don’t need to synchronize. In those places, we simply report the error and keep on truckin’.</p>
<p>For example, Lox limits the number of arguments you can pass to a function. If you pass too many, the parser needs to report that error, but it can and should simply keep on parsing the extra arguments instead of freaking out and going into panic mode.</p>
<p>这是一个简单的哨兵类，用于展开解析器。error() 方法将返回错误，而不是抛出错误，因为，我们希望让解析器内部的调用方法决定是否展开。有一些解析错误，发生在解析器不太可能进入奇怪状态，并且也不需要我们同步的地方，在这些地方，我们只需要报告错误，并且继续运行。</p>
<p>举例，如果Lox 限制了函数可以传参的个数，如果你传递了太多的参数，解析器需要报告该错误，但是，解析器，接下来应该解析额外的参数，而不是马上进入恐慌模式</p>
<blockquote>
<p>Another way to handle common syntax errors is with error productions. You augment the grammar with a rule that successfully matches the erroneous syntax. The parser safely parses it but then reports it as an error instead of producing a syntax tree.</p>
<p>For example, some languages have a unary + operator, like +123, but Lox does not. Instead of getting confused when the parser stumbles onto a + at the beginning of an expression, we could extend the unary rule to allow it.</p>
<pre><code>unary → ( &quot;!&quot; | &quot;-&quot; | &quot;+&quot; ) unary
     | primary ;
</code></pre>
<p>This lets the parser consume + without going into panic mode or leaving the parser in a weird state.</p>
<p>Error productions work well because you, the parser author, know how the code is wrong and what the user was likely trying to do. That means you can give a more helpful message to get the user back on track, like, “Unary ‘+’ expressions are not supported.” Mature parsers tend to accumulate error productions like barnacles since they help users fix common mistakes.</p>
<p>另外一种处理常见语法错误的报错是，我们可以使用成功匹配错误语法的规则来扩充语法，解析器安全的解析它，但是随后，我们将其报告为错误，而不是生成语法树。</p>
<p>举个例子，有些语言，支持一个一元运算符 +，例如： +123， 但是Lox语言没有。所以，当解析器在表达式的开始，遇到一个+时候，我们可以扩充语法规则，添加一个新的一元运算符，而不是解析报错。</p>
<p>这样，解析器可以正常解析+，不会进入到恐慌模式，或者解析器出现奇怪的状态。</p>
<p>错误生成工作的很好，因为作为解析器的作者，我们知道代码是如何产生错误的，以及用户可能想要做什么。这意味着，你可能给出更加有用的信息，让用户更好的修改错误，例如：不支持一元运算符 +， 成熟的解析器，倾向于像藤壶一样积累错误，因为，它可以让用户更好的修复常见错误。</p>
</blockquote>
<p>In our case, though, the syntax error is nasty enough that we want to panic and synchronize. Discarding tokens is pretty easy, but how do we synchronize the parser’s own state?</p>
<p>然而，在我们的例子中，语法错误非常严重，以至于我们想要进入恐慌模式，并且同步。丢弃token非常简单，但是我们如何同步解析器自己的状态呢？</p>
<h3 id="33-synchronizing-a-recursive-descent-parser"><a class="header" href="#33-synchronizing-a-recursive-descent-parser">3.3 Synchronizing a recursive descent parser</a></h3>
<p>同步递归下降解析器</p>
<p>With recursive descent, the parser’s state—which rules it is in the middle of recognizing—is not stored explicitly in fields. Instead, we use Java’s own call stack to track what the parser is doing. Each rule in the middle of being parsed is a call frame on the stack. In order to reset that state, we need to clear out those call frames.</p>
<p>The natural way to do that in Java is exceptions. When we want to synchronize, we throw that ParseError object. Higher up in the method for the grammar rule we are synchronizing to, we’ll catch it. Since we synchronize on statement boundaries, we’ll catch the exception there. After the exception is caught, the parser is in the right state. All that’s left is to synchronize the tokens.</p>
<p>通过递归下降，解析器在识别过程中的状态不会显示存储在字段中，相反，我们将使用Java自己的堆栈来跟踪解析器，正在做什么。正在解析的每一个规则，都是堆栈上的调用帧。为了重置该状态，我们需要清除这些调用帧。</p>
<p>在Java中，这样做的自然是使用 Exception，当我们想要同步时候，我们将抛出 ParseError对象。在我们想要同步的语法规则，对应的方法的上层，我们将会捕捉到 ParseError对象。因为我们在语句的边界处同步，所以，我们将会在那里，捕获到异常。捕获到异常后，解析器将进入正常的状态，剩下的就是同步token。</p>
<p>We want to discard tokens until we’re right at the beginning of the next statement. That boundary is pretty easy to spot—it’s one of the main reasons we picked it. After a semicolon, we’re probably finished with a statement. Most statements start with a keyword—for, if, return, var, etc. When the next token is any of those, we’re probably about to start a statement.</p>
<p>我们希望在解析下一条语句之前，丢弃token。这个边界非常容易被发现，这也是我们使用它的主要原因。分号之后，我们可能完成了一个语句。大多数的语法，以 <code>for if return var </code>等token开始，如果下一个解析的token是其中之一，那么，很可能我们将开始一个语句。</p>
<blockquote>
<p>I say “probably” because we could hit a semicolon separating clauses in a for loop. Our synchronization isn’t perfect, but that’s OK. We’ve already reported the first error precisely, so everything after that is kind of “best effort”.</p>
<p>我说可能，是因为，我们可以在for 循环中，使用分号，分隔字句，我们的同步并不完美，耽没有关系，我们已经准确的报告了第一个错误。所以，之后的都是尽力而为。</p>
</blockquote>
<p>This method encapsulates that logic:</p>
<p>下面的方法封装了该逻辑。</p>
<pre><code class="language-java">
  private void synchronize() {
    advance();

    while (!isAtEnd()) {
      if (previous().type == SEMICOLON) return;

      switch (peek().type) {
        case CLASS:
        case FUN:
        case VAR:
        case FOR:
        case IF:
        case WHILE:
        case PRINT:
        case RETURN:
          return;
      }

      advance();
    }
  }

</code></pre>
<p>It discards tokens until it thinks it has found a statement boundary. After catching a ParseError, we’ll call this and then we are hopefully back in sync. When it works well, we have discarded tokens that would have likely caused cascaded errors anyway, and now we can parse the rest of the file starting at the next statement.</p>
<p>Alas, we don’t get to see this method in action, since we don’t have statements yet. We’ll get to that in a couple of chapters. For now, if an error occurs, we’ll panic and unwind all the way to the top and stop parsing. Since we can parse only a single expression anyway, that’s no big loss.</p>
<p>一直到我们找到了语句边界，我们才会丢掉token，在捕获到 ParseError对象后，我们将调用此函数，然后，我们有希望能恢复同步。当它可以正常工作的时候，我们丢弃了可能会导致级联错误的token，现在，我们可以从下一条语句，开始解析文件的剩余部分。</p>
<p>但是，我们还是没有看到这种方法的实际应用，因为我们还没有语句。我们将在下面的章节中，接着讨论。现在，如果遇到解析错误，我们将会立即进入恐慌模式，并且一直展开到顶端，停止解析。因为，当前我们最多只会解析一个表达式语句，所以，我们并没有什么大的损失。</p>
<h3 id="34-wiring-up-the-parser"><a class="header" href="#34-wiring-up-the-parser">3.4 Wiring up the Parser</a></h3>
<p>连接解析器</p>
<p>We are mostly done parsing expressions now. There is one other place where we need to add a little error handling. As the parser descends through the parsing methods for each grammar rule, it eventually hits primary(). If none of the cases in there match, it means we are sitting on a token that can’t start an expression. We need to handle that error too.</p>
<p>我们现在基本上，完成了解析表达式，但是，还有一个地方需要添加错误处理。当解析器通过每一个语法规则对应的方法，递归下降时候，它最终将到达 primary() 方法。如果primary() 中所有的情况都无法匹配，这意味着我们处于一个无法解析的token，我们同样需要处理这种错误。</p>
<pre><code class="language-java">
// lox/Parser.java, in primary()

    private Expr primary() {
        if (match(FALSE))
            return new Expr.Literal(false);
        if (match(TRUE))
            return new Expr.Literal(true);
        if (match(NIL))
            return new Expr.Literal(null);

        if (match(NUMBER, STRING)) {
            return new Expr.Literal(previous().literal);
        }
        if (match(LEFT_PAREN)) {
            Expr expr = expression();
            consume(RIGHT_PAREN, &quot;Expect ')' after expression.&quot;);
            return new Expr.Grouping(expr);
        }

        throw error(peek(), &quot;Expect expression.&quot;);
    }
	
</code></pre>
<p>With that, all that remains in the parser is to define an initial method to kick it off. That method is called, naturally enough, parse().</p>
<p>现在，解析器中剩下的就是，定义一个启动方法，这个方法自然被命名为 parse().</p>
<pre><code class="language-java">
// lox/Parser.java, add after Parser()

  Expr parse() {
    try {
      return expression();
    } catch (ParseError error) {
      return null;
    }
  }
  
</code></pre>
<p>We’ll revisit this method later when we add statements to the language. For now, it parses a single expression and returns it. We also have some temporary code to exit out of panic mode. Syntax error recovery is the parser’s job, so we don’t want the ParseError exception to escape into the rest of the interpreter.</p>
<p>When a syntax error does occur, this method returns null. That’s OK. The parser promises not to crash or hang on invalid syntax, but it doesn’t promise to return a usable syntax tree if an error is found. As soon as the parser reports an error, hadError gets set, and subsequent phases are skipped.</p>
<p>Finally, we can hook up our brand new parser to the main Lox class and try it out. We still don’t have an interpreter, so for now, we’ll parse to a syntax tree and then use the AstPrinter class from the last chapter to display it.</p>
<p>当我们在语言中添加了语句后，我们还将重新讨论这个方法。现在，它只是解析表达式并且返回。我们还有一些临时代码，可以退出恐慌模式。语法错误恢复是解析器的工作，因此我们不希望ParseError 对象逃逸到，解释器的其他部分。</p>
<p>当出现语法错误时候，parse() 方法返回 null，没关系，解析器，承诺当遇到语法错误时候，不会引发崩溃或者挂起，但是，如果发现了语法错误，它不会返回一个语法树。一旦解析器报错，就会设置 hadError, 并且会跳过后续阶段。</p>
<p>最后，我们将把全新的解析器，连接到主Lox类上，进行尝试。我们仍然没有完成解释器，现在，我们的解析结果是语法树，然后，我们将使用上一章中的 AstPrinter 类，展示语法树。</p>
<p>Delete the old code to print the scanned tokens and replace it with this:</p>
<p>删除打印token 的旧代码，替换为新的解析器</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 5 lines


    List&lt;Token&gt; tokens = scanner.scanTokens();
    Parser parser = new Parser(tokens);
    Expr expression = parser.parse();

    // Stop if there was a syntax error.
    if (hadError) return;

    System.out.println(new AstPrinter().print(expression));
  }
  
</code></pre>
<p>Congratulations, you have crossed the threshold! That really is all there is to handwriting a parser. We’ll extend the grammar in later chapters with assignment, statements, and other stuff, but none of that is any more complex than the binary operators we tackled here.</p>
<p>恭喜🎉，你已经跨过了门槛，这就是编写解析器的全部内容。我们将在后面的章节中，用赋值、语句，其他的东西，来扩展语法。但是，这些都没有本章讨论的二元运算符，更加复杂。</p>
<blockquote>
<p>It is possible to define a more complex grammar than Lox’s that’s difficult to parse using recursive descent. Predictive parsing gets tricky when you may need to look ahead a large number of tokens to figure out what you’re sitting on.</p>
<p>In practice, most languages are designed to avoid that. Even in cases where they aren’t, you can usually hack around it without too much pain. If you can parse C++ using recursive descent—which many C++ compilers do—you can parse anything.</p>
<p>有可能定一个比Lox更加复杂的语法，使用递归下降技术很难解析，当你可能需要提前查看大量的token，用来确定你的所在位置时候，预测性解析变得很棘手。</p>
<p>实际上，大多数的语言都是为了避免这种场景。即使无法避免的时候，我们也可以绕过它，而不会太痛苦。如果你可以用递归下降技术解析C++，像许多C++解析器那样做的，那么，你将可以解析任意的语言。</p>
</blockquote>
<p>Fire up the interpreter and type in some expressions. See how it handles precedence and associativity correctly? Not bad for less than 200 lines of code.</p>
<p>启动解释器，并且输出一些表达式，看看我们的解释器，是如何处理优先级和级联的，对一个少于200行的代码的解释器来说，还算是不错了。</p>
<h2 id="四习题"><a class="header" href="#四习题">四、习题</a></h2>
<ol>
<li>
<p>In C, a block is a statement form that allows you to pack a series of statements where a single one is expected. The comma operator is an analogous syntax for expressions. A comma-separated series of expressions can be given where a single expression is expected (except inside a function call’s argument list). At runtime, the comma operator evaluates the left operand and discards the result. Then it evaluates and returns the right operand.</p>
<p>Add support for comma expressions. Give them the same precedence and associativity as in C. Write the grammar, and then implement the necessary parsing code.</p>
</li>
<li>
<p>Likewise, add support for the C-style conditional or “ternary” operator ?:. What precedence level is allowed between the ? and :? Is the whole operator left-associative or right-associative?</p>
</li>
<li>
<p>Add error productions to handle each binary operator appearing without a left-hand operand. In other words, detect a binary operator appearing at the beginning of an expression. Report that as an error, but also parse and discard a right-hand operand with the appropriate precedence.</p>
</li>
</ol>
<hr />
<ol>
<li>
<p>在C语言中，代码块也是一种语句形式，它允许我们将多行代码打包到一个只需要一个语句的地方，<a href="https://en.wikipedia.org/wiki/Comma_operator">逗号运算符</a>是表达式的类似语法，例如: <code>int a=1, b=2, c=3, i=0;</code>, 在需要单个表达式的地方（函数调用的参数列表除外），可以给出逗号分隔的表达式系列。在运行时候，逗号运算符，计算左操作数，然后丢弃结果，然后计算并且返回右操作数。</p>
<p>添加对于逗号表达式的支持，然后赋予它和C 语言中相同的优先级和关联性。编写语法，然后实现，对应的解析方法。</p>
</li>
<li>
<p>同样的，添加对于三元运算符 <code>?:</code>的支持， ? 和 : 之间是什么样的关联性呢？整个三元运算符是左关联还是右关联的呢？</p>
</li>
<li>
<p>添加错误处理，处理每一个二元运算符，没有出现左操作数。换句话，就是，检查每一个出现在表达式开始的二元运算符，将其报告为错误，但是还要继续分析并且丢弃具有适当优先级的右操作数。</p>
</li>
</ol>
<h2 id="五design-note-logic-versus-history"><a class="header" href="#五design-note-logic-versus-history">五、DESIGN NOTE: LOGIC VERSUS HISTORY</a></h2>
<p>设计说明：逻辑和历史</p>
<p>Let’s say we decide to add bitwise &amp; and | operators to Lox. Where should we put them in the precedence hierarchy? C—and most languages that follow in C’s footsteps—place them below ==. This is widely considered a mistake because it means common operations like testing a flag require parentheses.</p>
<p>假设我们决定添加位运算符，&amp; 和 ｜， 我们应该把它们放在优先级中的哪个位置呢？C语言和大部分紧随C脚步的语言中，位运算都在 == 运算符之下，这被广泛认为是一个错误，因为，如果位运算符优先级低于 ==，下面的测试表达式需要添加括号</p>
<pre><code>
if (flags &amp; FLAG_MASK == SOME_FLAG) { ... } // Wrong.
if ((flags &amp; FLAG_MASK) == SOME_FLAG) { ... } // Right.

</code></pre>
<p>Should we fix this for Lox and put bitwise operators higher up the precedence table than C does? There are two strategies we can take.</p>
<p>You almost never want to use the result of an == expression as the operand to a bitwise operator. By making bitwise bind tighter, users don’t need to parenthesize as often. So if we do that, and users assume the precedence is chosen logically to minimize parentheses, they’re likely to infer it correctly.</p>
<p>This kind of internal consistency makes the language easier to learn because there are fewer edge cases and exceptions users have to stumble into and then correct. That’s good, because before users can use our language, they have to load all of that syntax and semantics into their heads. A simpler, more rational language makes sense.</p>
<p>But, for many users there is an even faster shortcut to getting our language’s ideas into their wetware—use concepts they already know. Many newcomers to our language will be coming from some other language or languages. If our language uses some of the same syntax or semantics as those, there is much less for the user to learn (and unlearn).</p>
<p>This is particularly helpful with syntax. You may not remember it well today, but way back when you learned your very first programming language, code probably looked alien and unapproachable. Only through painstaking effort did you learn to read and accept it. If you design a novel syntax for your new language, you force users to start that process all over again.</p>
<p>Taking advantage of what users already know is one of the most powerful tools you can use to ease adoption of your language. It’s almost impossible to overestimate how valuable this is. But it faces you with a nasty problem: What happens when the thing the users all know kind of sucks? C’s bitwise operator precedence is a mistake that doesn’t make sense. But it’s a familiar mistake that millions have already gotten used to and learned to live with.</p>
<p>我们是否应该在Lox语言中，修复这个错误，将位运算符优先级设置更高，而不是C语言中的优先级，我们可以采取两种策略：</p>
<p>因为，我们几乎不会想将 == 表达式的结果当作位运算符的操作数，通过设置更高的位运算符优先级，用户不需要经常添加 括号，因此，如果我们这样做，并且用户假设优先顺序是逻辑选择的，以最小化括号，那么他们很可能会正确推断。</p>
<p>这种内部一致性，使得语言更加容易学习，因为用户偶然发现的边缘情况和异常更少。这很好，因为在用户使用我们的语言之前，我们必须将这些语法和语义加载到大脑中。更简单，更理性的语言是有意义的</p>
<p>但是，对于许多用户来说，有一条捷径可以将我们的语言理念，融入到他们已经熟悉的其他语言中，我们语言的使用者，通常熟悉其他语言，如果我们的语言中使用了一些与常见语言相同的语法或者语义，那么他们将需要学习的东西将更少。</p>
<p>这对于语法特别有用，现在，你可能不太记得了，但是早在你学习第一门编程语言的时候，代码可能看起来很陌生，很难接近，只有通过艰苦的努力，你才能学会阅读和接受它，如果你为你的新语言，设计了一个新颖的语法，你实际上，在强迫用户重新开始这个过程。</p>
<p>利用用户已经知道的知识，是你简化语言，可以采用的最强大的工具之一。几乎不可能高估它的价值。但是，我们会面临一个棘手的问题：当用户都知道，某个东西比较糟糕时，会发生什么呢？C的位运算符的优先级，是一个没有意义的错误，数百万人已经习惯了这个错误。</p>
<p>Do you stay true to your language’s own internal logic and ignore history? Do you start from a blank slate and first principles? Or do you weave your language into the rich tapestry of programming history and give your users a leg up by starting from something they already know?</p>
<p>There is no perfect answer here, only trade-offs. You and I are obviously biased towards liking novel languages, so our natural inclination is to burn the history books and start our own story.</p>
<p>In practice, it’s often better to make the most of what users already know. Getting them to come to your language requires a big leap. The smaller you can make that chasm, the more people will be willing to cross it. But you can’t always stick to history, or your language won’t have anything new and compelling to give people a reason to jump over.</p>
<p>你是否要坚持逻辑正确，忽略历史遗留问题。你是从一张白板和第一原则开始的吗？或者你是把自己的语言，融入到编程语言的历史中呢？从用户已经知道的东西开始，给他们一个帮助？</p>
<p>这里没有完美的答案，只有权衡，对我而言，更加喜欢新颖的语言，所以，我们将自然的烧掉历史书，开始我们自己的故事</p>
<p>实际上，最好是充分利用用户已有知识，让他们适应你的语言是一个巨大的飞跃，你越是缩小这个鸿沟，人们越是有可能跨过它。但是，你也不能总是坚持历史，否则你的语言不会有任何创新，让人们想要跳过鸿沟。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
