<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>crafting-interpreters-zh</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4717236929129160" crossorigin="anonymous"></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-MMN1K84KRS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-MMN1K84KRS');
</script>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">å‰è¨€</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">æ¬¢è¿</li><li class="chapter-item expanded "><a href="welcome/welcome.html"><strong aria-hidden="true">1.</strong> æ¬¢è¿</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="welcome/introduction.html"><strong aria-hidden="true">1.1.</strong> ä»‹ç»</a></li><li class="chapter-item expanded "><a href="welcome/a-map-of-the-territory.html"><strong aria-hidden="true">1.2.</strong> æ€»è§ˆå›¾</a></li><li class="chapter-item expanded "><a href="welcome/the-lox-language.html"><strong aria-hidden="true">1.3.</strong> Loxè¯­è¨€</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">è§£ææ ‘</li><li class="chapter-item expanded "><a href="tree/tree.html"><strong aria-hidden="true">2.</strong> è§£ææ ‘</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tree/scanning.html"><strong aria-hidden="true">2.1.</strong> æ‰«æ</a></li><li class="chapter-item expanded "><a href="tree/representing-code.html"><strong aria-hidden="true">2.2.</strong> ä»£ç è¡¨ç¤º</a></li><li class="chapter-item expanded "><a href="tree/parsing-expression.html"><strong aria-hidden="true">2.3.</strong> è§£æè¡¨è¾¾å¼</a></li><li class="chapter-item expanded "><a href="tree/evaluating-expression.html"><strong aria-hidden="true">2.4.</strong> è®¡ç®—è¡¨è¾¾å¼</a></li><li class="chapter-item expanded "><a href="tree/statements-and-state.html"><strong aria-hidden="true">2.5.</strong> è¯­å¥å’ŒçŠ¶æ€</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">crafting-interpreters-zh</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="åŸºæœ¬ä»‹ç»"><a class="header" href="#åŸºæœ¬ä»‹ç»">åŸºæœ¬ä»‹ç»</a></h1>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/header.png?raw=true" alt="header" /></p>
<h2 id="è¿è¡Œè§£é‡Šå™¨"><a class="header" href="#è¿è¡Œè§£é‡Šå™¨">è¿è¡Œè§£é‡Šå™¨</a></h2>
<pre><code>// 1. æºç ä¸‹è½½
git clone https://github.com/Kua-Fu/jlox.git

// 2. ç¼–è¯‘
gradle build

// 3. è¿è¡Œ
java -cp app/build/classes/java/main com.craftinginterpreters.lox.App 

</code></pre>
<h2 id="tool-ä½¿ç”¨"><a class="header" href="#tool-ä½¿ç”¨">tool ä½¿ç”¨</a></h2>
<pre><code>// 1. æºç ä¸‹è½½
git clone https://github.com/Kua-Fu/jlox.git

// 2. ç¼–è¯‘
gradle build

// 3. è¿è¡Œ
java -cp app/build/classes/java/main com.craftinginterpreters.tool.GenerateAst someDir

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¬¢è¿"><a class="header" href="#æ¬¢è¿">æ¬¢è¿</a></h1>
<p>This may be the beginning of a grand adventure. Programming languages encompass a h
uge space to explore and play in. Plenty of room for your own creations to share with others or just enjoy yourself. Brilliant computer scientists and software engineers have spent entire careers traversing this land without ever reaching the end. If this book is your first entry into the country, welcome.</p>
<p>The pages of this book give you a guided tour through some of the world of languages. But before we strap on our hiking boots and venture out, we should familiarize ourselves with the territory. The chapters in this part introduce you to the basic concepts used by programming languages and how those concepts are organized.</p>
<p>We will also get acquainted with Lox, the languages we'll spend the rest of the book implementing(twice).</p>
<hr />
<p>è¿™å°†æ˜¯ä¸€æ¬¡ä¼Ÿå¤§çš„å†’é™©ã€‚ç¨‹åºç¼–ç¨‹æ‹¥æœ‰æ— é™çš„æ¢ç´¢å’Œåº”ç”¨ç©ºé—´ã€‚ä½ å¯ä»¥ä¸ä»–äººåˆ†äº«ç¼–ç¨‹ä¹è¶£æˆ–è€…åªæ˜¯è‡ªå¨±è‡ªä¹ã€‚æ°å‡ºçš„è®¡ç®—æœºç§‘å­¦å®¶å’Œè½¯ä»¶å·¥ç¨‹å¸ˆä¸€ç›´åœ¨ç¼–ç¨‹é¢†åŸŸæ¢ç´¢ï¼Œç»ˆå…¶ä¸€ç”Ÿä¹åœ¨å…¶ä¸­ã€‚å¦‚æœä½ æ˜¯ç¬¬ä¸€æ¬¡æ¥è§¦è¿™ä¸ªé¢†åŸŸï¼Œé‚£ä¹ˆçƒ­çƒˆæ¬¢è¿ä½ ï¼</p>
<p>æœ¬ä¹¦å°†å’Œä½ ä¸€èµ·å‚è§‚è¯­è¨€ä¸–ç•Œã€‚ä½†æ˜¯ï¼Œåœ¨æˆ‘ä»¬å¼€å§‹å†’é™©ä¹‹å‰ï¼Œéœ€è¦å…ˆäº†è§£è¦è¸è¶³çš„åœŸåœ°ã€‚æ¥ä¸‹æ¥ç« èŠ‚ï¼Œå°†å‘æ‚¨ä»‹ç»ç¼–ç¨‹è¯­è¨€ä¸­çš„å¸¸ç”¨æ¦‚å¿µå’Œè¿™äº›åŸºæœ¬æ¦‚å¿µçš„ç»„ç»‡æ–¹å¼ã€‚</p>
<p>æˆ‘ä»¬è¿˜å°†ä»‹ç»ä¸€é—¨æ–°çš„è¯­è¨€ Lox, æœ¬ä¹¦ä¼šå¸¦ä½ å®ç°2æ¬¡ Lox è¯­è¨€ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ä»‹ç»"><a class="header" href="#ä»‹ç»">ä»‹ç»</a></h1>
<blockquote>
<p>fairy tales are more than true: not because they tell us that dragons exist, but because they tell us that dragons can be beaten. </p>
<p align="right"> â€”â€” G.K. Chesterton by way of Neil Gaiman, Coraline </p>
<p>ç«¥è¯ä¸ä»…ä»…æ˜¯çœŸå®çš„: å®ƒä¸ä»…å‘Šè¯‰æˆ‘ä»¬é¾™çš„å­˜åœ¨ï¼Œæ›´åœ¨äºå®ƒå‘Šè¯‰æˆ‘ä»¬å‹‡å£«å¯ä»¥æˆ˜èƒœæ¶é¾™ã€‚</p>
<p align="right"> â€”â€” G.K. Chesterton by way of Neil Gaiman, Coraline </p>
</blockquote>
<p>I'm really excited we're going on this journey together. This is a book on implementing interpreters for programming languages. It's also a book on how to design a language worth implementing. It's the book I wish I'd had when I first started getting into languages, and it's the book I've been writing in my head for nearly a decade.</p>
<p>éå¸¸é«˜å…´æˆ‘ä»¬å¯ä»¥ä¸€èµ·å¼€å¯æ–°çš„æ—…ç¨‹ï¼Œ</p>
<p>è¿™æ˜¯ä¸€æœ¬ä»‹ç»ç¼–ç¨‹è¯­è¨€è§£é‡Šå™¨çš„ä¹¦ï¼Œ è¿™æœ¬ä¹¦è¿˜ä¼šä»‹ç»å¦‚ä½•è‡ªå·±å®ç°ä¸€é—¨è¯­è¨€ã€‚</p>
<p>è¿™æœ¬ä¹¦åœ¨æˆ‘è„‘æµ·ä¸­å·²ç»åå¤é…é…¿äº†åå¹´äº†ï¼Œå¤šä¹ˆå¸Œæœ›åœ¨æˆ‘åˆšæ¥è§¦ç¼–ç¨‹è¯­è¨€æ—¶ï¼Œèƒ½é‡åˆ°è¿™æœ¬ä¹¦ã€‚ğŸ¶</p>
<blockquote>
<p>to my friends and family, sorry I've been so absentminded!</p>
<p>å¯¹äºæˆ‘çš„æœ‹å‹å’Œå®¶äººï¼Œå¾ˆæŠ±æ­‰æˆ‘ä¸€ç›´å¿ƒä¸åœ¨ç„‰ã€‚</p>
</blockquote>
<p>In these pages, we will walk step-by-step through two complete interpreters for a full-featured language. I assume this is your first foray into languages, so I'll cover each concept and line of code you need to build a complete, usable, fast language implementation.</p>
<p>In order to cram two full implementations inside one book without it turning into a doorstop, this text is lighter on theory than others. As we build each piece of the system, I will introduce the history and concepts behind it. I'll try to get your familiar with the lingo so that if you ever find yourself at a cocktail party full of PL(parogramming language) researchers, you'll fit in.</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†é€šè¿‡å®ç°ä¸¤ä¸ªå®Œæ•´çš„è§£é‡Šå™¨ï¼Œå»å®ç°ä¸€ä¸ªåŠŸèƒ½é½å…¨çš„è¯­è¨€ã€‚æˆ‘ä¼šå‡è®¾ä½ ç¬¬ä¸€æ¬¡æ¥è§¦è¯­è¨€ç¼–ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä¼šè¯¦ç»†ä»‹ç»æ¯ä¸€ä¸ªæ¦‚å¿µï¼Œåˆ—å‡ºè¯¦ç»†çš„ä»£ç ï¼Œè€Œè¿™ä¸€åˆ‡å°†ä¼šæ„å»ºå®Œæ•´ã€å¯ç”¨ã€å¿«é€Ÿçš„è¯­è¨€ã€‚</p>
<p>ä¸ºäº†åœ¨ä¸€æœ¬ä¹¦ä¸­ï¼Œå®ç°ä¸¤ä¸ªè§£é‡Šå™¨ï¼Œç›¸å¯¹äºå…¶ä»–çš„ç¼–è¯‘è¯­è¨€ä¹¦ç±ï¼Œæˆ‘ä»¬ä¼šæ›´å°‘ä»‹ç»ç¼–è¯‘åŸç†ï¼Œæˆ‘ä»¬ä¸æƒ³æˆä¸ºå­¦ä¹ ç¼–è¯‘ç†è®ºçš„æ‹¦è·¯è™ã€‚åœ¨æ„å»ºç¼–è¯‘ç³»ç»Ÿçš„æ¯ä¸€ä¸ªéƒ¨åˆ†ï¼Œæˆ‘å°†ä»‹ç»å…¶èƒŒåçš„å†å²å’Œæ¦‚å¿µã€‚æˆ‘å°†å°½å¯èƒ½ä½¿ç”¨è¡Œè¯ï¼Œè¿™æ ·å³ä½¿å°†æ¥ä½ å‡ºç°åœ¨ä¸€ä¸ªç¼–ç¨‹è¯­è¨€çš„é¸¡å°¾é…’ä¼šï¼Œä¹Ÿå¯ä»¥å¿«é€Ÿèå…¥å…¶ä¸­ã€‚</p>
<blockquote>
<p>Strangely enough, a situation I have found myself in multiple times. You wouldn't believe how much some of them can drink.</p>
<p>å¥‡æ€ªçš„æ˜¯ï¼Œæˆ‘å‘ç°è‡ªå·±å¤šæ¬¡é™·å…¥è¿™ç§åœºæ™¯ã€‚ä½ ä¸åº”è¯¥å‡æƒ³ä»–ä»¬éƒ½å¾ˆèƒ½å–ã€‚</p>
</blockquote>
<p>But we're mostly going to spend our brain juice getting the language up and running. This is not to say theory isn't important. Being able to reason precisely and formally about syntax and semantics is a vital skill when working on a language. But, presonally, I learn best by doing. It's hard for me to wade through paragraphs full of abstract concepts and really absorb them. But if I've coded something, run it, and debugged it, then I get it.</p>
<p>æˆ‘ä»¬å°†èŠ±è´¹ç²¾åŠ›å»å¼€å‘è¿è¡Œè¯­è¨€ï¼Œè€Œè¿™å¹¶ä¸ä»£è¡¨ç†è®ºä¸é‡è¦ã€‚åœ¨å­¦ä¹ è¯­è¨€æ—¶å€™ï¼ŒæŒæ¡è¯­æ³•å’Œè¯­ä¹‰è§„åˆ™éå¸¸é‡è¦ã€‚ä½†æ˜¯ï¼Œä¸ªäººç»éªŒï¼Œæˆ‘æ€»æ˜¯ä»å®è·µä¸­è·å–æ›´å¤šçš„ä¸œè¥¿ï¼Œæˆ‘é€šå¸¸å¾ˆéš¾çœ‹æ‡‚æˆ–è€…çœŸçš„ç†è§£å……æ»¡æŠ½è±¡æ¦‚å¿µçš„æ®µè½ã€‚ä½†æ˜¯ï¼Œå½“æˆ‘åœ¨ä»£ç ä¸­ç¼–ç ã€è¿è¡Œã€è°ƒè¯•ä¸­ï¼Œæ¥è§¦è¿‡æŸä¸ªæ¦‚å¿µï¼Œæˆ‘å°†èƒ½çœŸæ­£æŒæ¡å®ƒã€‚</p>
<blockquote>
<p>Static type systems in particular require rigorous formal reasoning. Hacking on a type system has the same feel as proving a theorem in mathematics. </p>
<p>é™æ€ç±»å‹ç³»ç»Ÿï¼Œå°¤å…¶éœ€è¦ä¸¥æ ¼çš„å½¢å¼æ¨ç†ã€‚åœ¨ç±»å‹ç³»ç»Ÿä¸Šè¿›è¡Œç¼–ç¨‹ï¼Œéå¸¸åƒæ˜¯è¯æ˜ä¸€ä¸ªæ•°å­¦å®šç†ã€‚</p>
</blockquote>
<blockquote>
<p>It turns out this is no coincidence. In the early half of last century, Haskell Curry and William Alvin Howard showed that they are two sides of the same coin: <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">the Curry-Howard isomorphism</a></p>
<p>äº‹å®è¯æ˜ï¼Œè¿™ä¸ªæ„Ÿè§‰å¹¶éæ˜¯å·§åˆã€‚åœ¨20ä¸–çºªä¸ŠåŠå¶ï¼ŒHaskell Curry å’Œ William Alvin Howardä¸¥æ ¼è¯æ˜äº†ç¼–ç¨‹è¯­è¨€å’Œæ•°å­¦è¯æ˜ä¹‹é—´çš„å…³ç³»ï¼Œç§°ä¸º<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">æŸ¯é‡Œ-éœåå¾·åŒæ„</a></p>
</blockquote>
<p>That's my goal for you. I want you to come away with a solid intuition of how a real language lives and breathes. My hope is that when you read other, more theoretical books later, the concepts there will firmly stick in your mind, adhered to this tangible substrate.</p>
<p>æœ¬ä¹¦çš„ä¸€ä¸ªç›®æ ‡ï¼Œå°±æ˜¯è®©ä½ æ›´åŠ çœŸåˆ‡çš„è®¤è¯†ä¸€é—¨è¯­è¨€ï¼Œå¯ä»¥å‡­ç›´è§‰æ„ŸçŸ¥ä¸€é—¨è¯­è¨€å¦‚ä½•ç¼–å†™ä¸è¿è¡Œã€‚å¸Œæœ›å½“ä»¥åå­¦ä¹ æ›´å¤šçš„ç¼–è¯‘åŸç†æ—¶å€™ï¼Œå¯ä»¥é€šè¿‡ç°åœ¨åŸ¹å…»çš„ç›´è§‰ï¼Œç‰¢ç‰¢è®°ä½ä¹¦ä¸­çš„æ¦‚å¿µã€‚</p>
<h2 id="ä¸€why-learn-this-stuff"><a class="header" href="#ä¸€why-learn-this-stuff">ä¸€ã€Why learn this stuff?</a></h2>
<p>ä¸ºä»€ä¹ˆè¦å­¦ä¹ è¿™äº›ä¸œè¥¿ï¼Ÿ</p>
<p>Every introduction to every compiler book seems to have this section. I don't know what it is about programming languages that causes such existential doubt. I don't think ornithology books worry about justifying their existence. They assume the reader loves birds and start teaching.</p>
<p>But programming languages are a little different. I suppose it is true that the odds of any of us creating a broadly successful, general-purpose programming language are slim. The designers of the world's widely used languages could fit in a Volkswagen bus, even without putting the pop-top camper up. If joining that elite group was the only reason to learn languages, it would be hard to justify. Fortunately, it isn't.</p>
<p>ä¼¼ä¹æ¯æœ¬ç¼–è¯‘å™¨ä»‹ç»ä¹¦ç±ï¼Œéƒ½åŒ…å«è¿™ä¸ªè®¨è®ºã€‚æˆ‘ä¸çŸ¥é“ï¼Œä¸ºä»€ä¹ˆç¼–ç¨‹è¯­è¨€ä¼šå‡ºç°è¿™æ ·çš„ç–‘æƒ‘ã€‚é¸Ÿç±»å­¦ç ”ç©¶ä¹¦ç±ä»æ¥ä¸è®¤ä¸ºäººä»¬ä¼šæ€€ç–‘å®ƒæ˜¯å¦è¯¥å­˜åœ¨ï¼Œä»–ä»¬æ€»æ˜¯å‡è®¾è¯»è€…å–œæ¬¢é¸Ÿï¼Œç„¶åå¼€å§‹æ•™å­¦ã€‚</p>
<p>ä½†æ˜¯ç¼–ç¨‹è¯­è¨€æ€»æ˜¯æœ‰ç‚¹ä¸ä¸€æ ·ã€‚æˆ‘è®¤ä¸ºï¼Œæˆ‘ä»¬å¤§éƒ¨åˆ†äººï¼Œéƒ½æ— æ³•åˆ›å»ºä¸€ä¸ªå¹¿æ³›æˆåŠŸçš„é€šç”¨ç¼–ç¨‹è¯­è¨€ã€‚ä¸–ç•Œä¸Šæœ€å¹¿æ³›ä½¿ç”¨çš„è¯­è¨€è®¾è®¡è€…å¯ä»¥é€‚åº”é©¾é©¶å¤§ä¼—æ±½è½¦ï¼Œå³ä½¿è½¦ä¸Šæ²¡æœ‰å®‰è£…æµè¡Œçš„éœ²è¥è®¾å¤‡ã€‚å¦‚æœå­¦ä¹ ç¼–è¯‘å™¨ï¼Œä»…ä»…æ˜¯ä¸ºäº†åŠ å…¥è¿™ä¸ªç¼–ç¨‹ç²¾è‹±ç¾¤ä½“ï¼Œé‚£ä¹ˆå¤§å¯ä¸å¿…ã€‚å¹¸è¿çš„æ˜¯ï¼Œäº‹å®ä¹Ÿå¹¶éå¦‚æ­¤ã€‚</p>
<h3 id="11-little-language-are-everywhere"><a class="header" href="#11-little-language-are-everywhere">1.1 Little language are everywhere</a></h3>
<p>For every successful general-purpose language, there are a thousand successful niche ones. We used to call them â€œlittle languagesâ€, but inflation in the jargon economy led to the name â€œdomain-specific languagesâ€.These are pidgins tailor-built to a specific task. Think application scripting languages, template engines, markup formats, and configuration files.</p>
<p>Almost every large software project needs a handful of these. When you can, itâ€™s good to reuse an existing one instead of rolling your own. Once you factor in documentation, debuggers, editor support, syntax highlighting, and all of the other trappings, doing it yourself becomes a tall order.</p>
<p>å¯¹äºæ¯ä¸€ç§é€šç”¨çš„æµè¡Œè¯­è¨€ï¼Œéƒ½å¯¹åº”ç€æˆåƒå°ä¼—è¯­è¨€ã€‚æˆ‘ä»¬å¯ä»¥ç§°ä¸ºè¿™äº›è¯­è¨€ä¸ºå°ä¼—è¯­è¨€ï¼Œä½†æ˜¯åœ¨è¡Œä¸šæœ¯è¯­ä¸­ï¼Œé€šå¸¸äººä»¬ä¼šä½¿ç”¨é¢†åŸŸç‰¹å®šè¯­è¨€(DSL)æ¥æè¿°ã€‚å®ƒä»¬éƒ½æ˜¯ä¸ºäº†æ‰§è¡Œç‰¹å®šä»»åŠ¡è®¾è®¡ï¼Œæƒ³è±¡ä¸€ä¸‹ï¼Œè„šæœ¬è¯­è¨€ã€æ¨¡ç‰ˆå¼•æ“ã€æ ‡è®°æ ¼å¼ã€é…ç½®æ–‡ä»¶ã€‚</p>
<p>å‡ ä¹æ¯ä¸ªå¤§å‹é¡¹ç›®ä¸­ï¼Œæˆ‘ä»¬æ€»ä¼šä½¿ç”¨ä¸Šå›¾ä¸­çš„éƒ¨åˆ†è¯­è¨€ã€‚é€šå¸¸æˆ‘ä»¬ä¼šå¤ç”¨å·²ç»å‡ºç°çš„è¯­è¨€ï¼Œè€Œä¸æ˜¯è‡ªå·±é€ è½®å­ã€‚ä½†æ˜¯ï¼Œå½“ä½ è€ƒè™‘åˆ°æ–‡æ¡£ã€è°ƒè¯•ã€ç¼–è¾‘å™¨æ”¯æŒã€è¯­æ³•é«˜äº®å’Œå…¶ä»–ç±»ä¼¼åŠŸèƒ½ï¼Œå°±éœ€è¦è‡ªå·±åŠ¨æ‰‹äº†ã€‚ğŸ˜„</p>
<blockquote>
<p>A random selection of some little languages you might run into.</p>
<p>éšæœºé€‰æ‹©ä¸€äº›ï¼Œä½ å¯èƒ½ä¼šé‡åˆ°çš„å°è¯­ç§ã€‚</p>
</blockquote>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/little-languages.png?raw=true" alt="A random selection of some little languages you might run into." /></p>
<p>But thereâ€™s still a good chance youâ€™ll find yourself needing to whip up a parser or other tool when there isnâ€™t an existing library that fits your needs. Even when you are reusing some existing implementation, youâ€™ll inevitably end up needing to debug and maintain it and poke around in its guts.</p>
<p>å½“æ²¡æœ‰ç°æœ‰åº“åŒ¹é…æ–°éœ€æ±‚æ—¶å€™ï¼Œå¯èƒ½éœ€è¦å¼€å‘æ–°çš„è§£æå™¨æˆ–è€…ä¸€äº›å°å·¥å…·ã€‚å³ä½¿å¯¹äºæŸäº›æ­£åœ¨ä½¿ç”¨çš„ç¬¬ä¸‰æ–¹åº“ï¼Œä¹Ÿä¼šéœ€è¦ä¸æ–­è¿›è¡Œè°ƒè¯•å’Œç»´æŠ¤ï¼Œå¹¶ä¸”éœ€è¦å¯¹å…¶æ·±å…¥ç ”ç©¶ã€‚</p>
<h3 id="12-languages-are-great-exercise"><a class="header" href="#12-languages-are-great-exercise">1.2 Languages are great exercise</a></h3>
<p>è¯­è¨€æ˜¯å¥½çš„é”»ç‚¼</p>
<p>Long distance runners sometimes train with weights strapped to their ankles or at high altitudes where the atmosphere is thin. When they later unburden themselves, the new relative ease of light limbs and oxygen-rich air enables them to run farther and faster.</p>
<p>Implementing a language is a real test of programming skill. The code is complex and performance critical. You must master recursion, dynamic arrays, trees, graphs, and hash tables. You probably use hash tables at least in your day-to-day programming, but do you really understand them?</p>
<p>While I intend to show you that an interpreter isnâ€™t as daunting as you might believe, implementing one well is still a challenge.</p>
<p>é•¿è·‘è¿åŠ¨å‘˜ä¼šåœ¨è®­ç»ƒæ—¶å€™ï¼Œåœ¨è„šè¸ä¸Šç»‘ä¸Šé‡ç‰©ï¼Œæˆ–è€…åœ¨é«˜æµ·æ‹”ã€ç©ºæ°”ç¨€è–„åœ°åŒºè®­ç»ƒã€‚å½“ä»–ä»¬å¸ä¸‹è´Ÿé‡æ—¶å€™ï¼Œç›¸å¯¹è½»æ¾çš„å››è‚¢å’Œæ­£å¸¸çš„æ°§æ°”ï¼Œä½¿å¾—ä»–ä»¬ï¼Œå¯ä»¥è·‘å¾—æ›´å¿«æ›´è¿œã€‚</p>
<p>å®ç°ä¸€é—¨è¯­è¨€æ˜¯å¯¹ç¼–ç¨‹æŠ€èƒ½çš„çœŸæ­£æµ‹è¯•ã€‚ä»£ç ä¼šéå¸¸å¤æ‚ï¼Œè€Œä¸”æ€§èƒ½ä¹Ÿå¾ˆé‡è¦ã€‚ä½ å¿…é¡»æŒæ¡é€’å½’ç®—æ³•ã€åŠ¨æ€æ•°ç»„ã€æ ‘ã€å›¾å’Œå“ˆå¸Œè¡¨ã€‚å¯èƒ½ä½ æ¯æ—¥çš„ç¼–ç¨‹ä»£ç ä¸­éƒ½ä¼šä½¿ç”¨å“ˆå¸Œè¡¨ï¼Œä½†æ˜¯ä½ çœŸçš„ç†è§£å®ƒå—ï¼Ÿå¥½å§ï¼Œè®©æˆ‘ä»¬ä»å¤´å¼€å§‹ï¼Œæˆ‘ä¿è¯ä½ ä¸€å®šå¯ä»¥å­¦ä¼šçš„ã€‚</p>
<p>è™½ç„¶æˆ‘æƒ³å‘ä½ ä»¬å±•ç¤ºï¼Œç¼–è¯‘å™¨å¹¶ä¸åƒæˆ‘ä»¬è®¤ä¸ºçš„é‚£ä¹ˆå¯æ€•ï¼Œä½†æ˜¯å®ç°ä¸€ä¸ªå¥½çš„ç¼–è¯‘å™¨ä»ç„¶æ˜¯ä¸€ä¸ªæœ‰æŒ‘æˆ˜çš„ä»»åŠ¡ã€‚å½“ä½ åšåˆ°äº†è¿™ä¸€ç‚¹ï¼Œä½ ä¼šå˜å¾—æ›´åŠ å¼ºå¤§ï¼Œå¹¶ä¸”åœ¨æ—¥å¸¸å¼€å‘å·¥ä½œä¸­ï¼Œä½¿ç”¨æ•°æ®ç»“æ„å’Œç®—æ³•ä¼šæ›´åŠ ç†Ÿç»ƒã€‚</p>
<h3 id="13-one-more-reason"><a class="header" href="#13-one-more-reason">1.3 One more reason</a></h3>
<p>å¦ä¸€ä¸ªåŸå› </p>
<p>This last reason is hard for me to admit, because itâ€™s so close to my heart. Ever since I learned to program as a kid, I felt there was something magical about languages. When I first tapped out BASIC programs one key at a time I couldnâ€™t conceive how BASIC itself was made.</p>
<p>Later, the mixture of awe and terror on my college friendsâ€™ faces when talking about their compilers class was enough to convince me language hackers were a different breed of humanâ€”some sort of wizards granted privileged access to arcane arts.</p>
<p>Itâ€™s a charming image, but it has a darker side. I didnâ€™t feel like a wizard, so I was left thinking I lacked some inborn quality necessary to join the cabal. Though Iâ€™ve been fascinated by languages ever since I doodled made-up keywords in my school notebook, it took me decades to muster the courage to try to really learn them. </p>
<p>When I did finally start cobbling together my own little interpreters, I quickly learned that, of course, there is no magic at all.</p>
<p>There are a few techniques you donâ€™t often encounter outside of languages, and some parts are a little difficult.  But not more difficult than other obstacles youâ€™ve overcome. My hope is that if youâ€™ve felt intimidated by languages and this book helps you overcome that fear, maybe Iâ€™ll leave you just a tiny bit braver than you were before.</p>
<p>And, who knows, maybe you will make the next great language. Someone has to.</p>
<p>æœ€åä¸€ä¸ªåŸå› æˆ‘æœ¬äººå¾ˆéš¾æ‰¿è®¤ï¼Œå› ä¸ºå®ƒä¸€ç›´æ·±è—æˆ‘å¿ƒåº•ã€‚å½“æˆ‘å°æ—¶å€™æ¥è§¦ç¼–ç¨‹ï¼Œæˆ‘å°±è§‰å¾—ç¼–ç¨‹è¯­è¨€éå¸¸ç¥å¥‡ã€‚å½“æˆ‘ç¬¬ä¸€æ¬¡ä¸€ä¸ªæŒ‰é”®ä¸€ä¸ªæŒ‰é”®æ•²å‡º BASIC ç¨‹åºæ—¶å€™ï¼Œæˆ‘æ— æ³•æƒ³è±¡ BASIC å†…éƒ¨æ˜¯å¦‚ä½•è¿è¡Œçš„ã€‚</p>
<p>åæ¥ï¼Œå½“æˆ‘çš„æœ‹å‹ä»¬è°ˆè®ºèµ·ç¼–è¯‘å™¨è¯¾ç¨‹æ—¶å€™ï¼Œä»–ä»¬è„¸ä¸Šå……æ»¡äº†æ•¬ç•å’Œææƒ§ï¼Œè¿™åŠ æ·±äº†æˆ‘çš„æƒ³æ³•ï¼šç¼–è¯‘å™¨é«˜æ‰‹æ˜¯å¦å¤–ä¸€ç§äººç±»ï¼Œä¸€äº›å·«å¸ˆæ‰èƒ½æ‹¥æœ‰çš„å¤©èµ‹ã€‚</p>
<p>è¿™æ˜¯ä¸€ä¸ªè¿·äººçš„å½¢è±¡ï¼Œä½†æ˜¯å®ƒä¹Ÿæœ‰é»‘æš—çš„ä¸€é¢ï¼Œæˆ‘ä¸è§‰å¾—è‡ªå·±æ˜¯ä¸€ä¸ªå·«å¸ˆï¼Œæ‰€ä»¥æˆ‘ä¸è®¤ä¸ºè‡ªå·±æ‹¥æœ‰å·«å¸ˆçš„å¤©èµ‹ã€‚è™½ç„¶ä»æˆ‘åœ¨å­¦æ ¡ç¬”è®°æœ¬ä¸Šï¼Œä¹±å†™å…³é”®è¯æ—¶å€™ï¼Œå°±å¯¹äºç¼–ç¨‹è¯­è¨€ååˆ†ç€è¿·ï¼Œä½†æ˜¯ï¼Œæˆ‘èŠ±äº†å‡ åå¹´æ—¶é—´æ‰çœŸæ­£å¼€å§‹å­¦ä¹ ç¼–è¯‘å™¨ã€‚ç¼–è¯‘å™¨çš„é‚£ç§ç¥å¥‡ä¹‹å¤„ã€ä¸ç®€å•çš„æ„Ÿè§‰ï¼Œè®©æˆ‘ä¸€ç›´å¾˜å¾Šåœ¨é—¨å¤–ã€‚</p>
<p>å½“æˆ‘å¼€å§‹ç¼–å†™è‡ªå·±çš„ç¼–è¯‘å™¨æ—¶å€™ï¼Œå¾ˆå¿«å°±æ˜ç™½äº†ï¼Œè¿™ä¸ªé¢†åŸŸæ ¹æœ¬æ²¡æœ‰é­”æ³•ã€‚ä»…ä»…åªæ˜¯ä»£ç ï¼Œè¯†åˆ«ä»£ç çš„ä¹Ÿéƒ½æ˜¯æ™®é€šäººã€‚</p>
<p>æœ‰ä¸€äº›è¯­è¨€ä¹‹å¤–çš„æŠ€å·§ï¼Œæˆ‘ä»¬ä¸ä¼šç»å¸¸é‡åˆ°ï¼Œä½†æ˜¯è¿™ä¸€éƒ¨åˆ†æœ‰äº›éš¾åº¦ã€‚ä½†æ˜¯ï¼Œä¹Ÿä¸ä¼šæ¯”ä½ æ‰€å…‹æœçš„å…¶ä»–éšœç¢æ›´åŠ æ£˜æ‰‹ã€‚æˆ‘çš„å¸Œæœ›æ˜¯ï¼Œå¦‚æœä½ å’Œæˆ‘ä¸€æ ·ï¼Œå¯¹ç¼–è¯‘å™¨æ„Ÿåˆ°ææƒ§ï¼Œé‚£ä¹ˆè¿™æœ¬ä¹¦å°†å¸®åŠ©ä½ å…‹æœè¿™ä¸ªææƒ§ï¼Œä¹Ÿè®¸è¿™ä¹‹åï¼Œä½ å°†å˜å¾—æ›´åŠ å‹‡æ•¢ã€‚</p>
<p>æœ€åï¼Œä½ è¿˜å¯èƒ½æˆä¸ºä¸‹ä¸€ä¸ªä¼Ÿå¤§è¯­è¨€çš„åˆ›å§‹äººï¼Œå¿…é¡»æœ‰äººå»åšã€‚è°çŸ¥é“å‘¢ï¼Ÿ</p>
<blockquote>
<p>And its practitioners donâ€™t hesitate to play up this image. Two of the seminal texts on programming languages feature a dragon and a wizard on their covers.</p>
<p>ç¼–è¯‘åŸç†çš„ä»ä¸šè€…å¾ˆå–œæ¬¢æ¸²æŸ“è¿™ç§å½¢è±¡ï¼Œä¸¤æœ¬å…³äºç¼–ç¨‹è¯­è¨€çš„å¼€åˆ›æ€§è‘—ä½œå°é¢ä¸Šéƒ½æœ‰ä¸€æ¡é¾™å’Œä¸€ä¸ªå·«å¸ˆ</p>
</blockquote>
<h2 id="äºŒhow-the-book-is-organized"><a class="header" href="#äºŒhow-the-book-is-organized">äºŒã€How the book is organized</a></h2>
<p>æœ¬ä¹¦çš„ç»„ç»‡æ–¹å¼</p>
<p>This book is broken into three parts. You're reading the first one now. It's a couple of chapters to get you oriented, teach you some of the lingo that language hackers use, and introduce you to Lox, the language we'll be implementing.</p>
<p>Each of the other two parts builds one complete Lox interpreter. Within those parts, each chapter is structured the same way. The chapter takes a single language feature, tachers you the concepts bebind it, and walks you through an implementation.</p>
<p>It took a good bit of trial and error on my part, but I managed to carve up the two interpreters into chapter-sized chunks that build on the previous chapters but require nothing from later ones. From the very first chapter, you'll have a working program you can run and play with. With each passing chapter, it grows increasing full-featured until you eventually have a complete language.</p>
<p>Aside from copious, scintillating English prose, chapters have a few other delightful facets.</p>
<p>è¿™æœ¬ä¹¦å°†åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼Œç°åœ¨æ­£åœ¨é˜…è¯»çš„æ˜¯ç¬¬ä¸€éƒ¨åˆ†ã€‚è¿™å‡ ç« ä¼šè®©ä½ æœ‰ä¸€äº›æ–¹å‘æ„Ÿï¼Œæ•™ä½ ä½¿ç”¨é«˜æ‰‹å¸¸ç”¨çš„æœ¯è¯­ã€‚ç„¶åï¼Œä¼šä»‹ç»Loxè¯­è¨€ï¼Œæˆ‘ä»¬å°†è¦å®ç°çš„è¯­è¨€ã€‚</p>
<p>å…¶ä»–ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¼šåˆ†åˆ«å®ç°ä¸€ä¸ªå®Œæ•´çš„è§£é‡Šå™¨ã€‚åœ¨è¿™ä¸¤ä¸ªéƒ¨åˆ†ï¼Œæ¯ä¸€ç« çš„ç»“æ„éƒ½æ˜¯ç›¸åŒçš„ï¼Œæœ¬ç« èŠ‚é‡‡ç”¨å•ä¸€è¯­è¨€åŠŸèƒ½ï¼Œå‘æ‚¨ä»‹ç»èƒŒåçš„æ¦‚å¿µï¼Œå¹¶ä¸”å¼•å¯¼ä½ å»å®ç°ã€‚</p>
<p>å¯¹æˆ‘æ¥è¯´ï¼Œéœ€è¦ä¸€äº›å°è¯•å’Œè¯•é”™ï¼Œä½†æˆ‘è¿˜æ˜¯æŠŠä¸¤ä¸ªè§£é‡Šå™¨åˆ†ä¸ºç« èŠ‚å¤§å°çš„éƒ¨åˆ†ï¼Œè¿™äº›ç« èŠ‚åŸºäºå‰é¢å‡ ç« çš„åŸºç¡€çŸ¥è¯†ï¼Œä¸éœ€è¦ç†è§£åé¢å‡ ç« çš„å†…å®¹ã€‚ä»ç¬¬ä¸€ç« å¼€å§‹ï¼Œä½ å°±æ‹¥æœ‰äº†ä¸€ä¸ªå¯ä»¥è¿è¡Œå’Œä½¿ç”¨çš„å·¥ä½œç¨‹åºã€‚éšç€æ›´å¤šç« èŠ‚çš„å­¦ä¹ ï¼Œè¿™ä¸ªå·¥ä½œç¨‹åºä¼šè¶Šæ¥è¶Šå…¨é¢ï¼Œç›´åˆ°æœ€ç»ˆï¼Œä½ ä¼šæ‹¥æœ‰ä¸€ä¸ªå®Œæ•´çš„ç¼–ç¨‹è¯­è¨€ã€‚</p>
<p>é™¤äº†ä¸°å¯Œã€åä¸½çš„æ­£æ–‡å¤–ï¼Œæ¯ä¸ªç« èŠ‚è¿˜æœ‰ä¸€äº›ä»¤äººæ„‰å¿«çš„éƒ¨åˆ†ã€‚</p>
<h3 id="21-the-code"><a class="header" href="#21-the-code">2.1 The code</a></h3>
<p>We're about crafting interpreters, so this book contains real code. Every single line of code needed is included, and each snippet tells you where to insert it in your ever-growing implementation.</p>
<p>Many other language books and language implementations use tools like <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a> and <a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a>, so-called <strong>compiler-compilers</strong>, that automatically generate some of the source files for an implementation from some higher-level description. There are pros and cons to tool like those, and strong opinionsâ€”â€”some might say religious convictions â€”â€” on both sides.</p>
<p>We will abstain from using them here. I want to ensure there are no dark corners where magic and confusion can hide, so weâ€™ll write everything by hand. As youâ€™ll see, itâ€™s not as bad as it sounds, and it means you really will understand each line of code and how both interpreters work.</p>
<p>A book has different constraints from the â€œreal worldâ€ and so the coding style here might not always reflect the best way to write maintainable production software. If I seem a little cavalier about, say, omitting private or declaring a global variable, understand I do so to keep the code easier on your eyes. The pages here arenâ€™t as wide as your IDE and every character counts.</p>
<p>Also, the code doesnâ€™t have many comments. Thatâ€™s because each handful of lines is surrounded by several paragraphs of honest-to-God prose explaining it. When you write a book to accompany your program, you are welcome to omit comments too. Otherwise, you should probably use // a little more than I do.</p>
<p>While the book contains every line of code and teaches what each means, it does not describe the machinery needed to compile and run the interpreter. I assume you can slap together a makefile or a project in your IDE of choice in order to get the code to run. </p>
<p>æˆ‘ä»¬æ˜¯ä»‹ç»è§£é‡Šå™¨çš„ï¼Œæ‰€ä»¥æœ¬ä¹¦ä¼šåŒ…å«çœŸæ˜¯å¯ç”¨çš„ä»£ç ã€‚æ¯è¡Œä»£ç ï¼Œæ¯ä¸ªä»£ç æ®µï¼Œéƒ½ä¼šå‘Šè¯‰ä½ å®ƒä»¬çš„ä½œç”¨å’Œåœ¨å®ç°çš„ä¸æ–­å®Œå–„çš„è§£é‡Šå™¨ä¸­çš„ä½ç½®ã€‚</p>
<p>è®¸å¤šå…¶ä»–è¯­è¨€å’Œè¯­è¨€å®ç°ä¹¦ç±ä¸­ï¼Œé€šå¸¸ä¼šä½¿ç”¨ Lexï¼ŒYaccç­‰ç§°ä¸ºç¼–è¯‘ç¼–è¯‘å™¨çš„ç¼–è¯‘è¯­è¨€ï¼Œè¿™äº›è¯­è¨€ï¼Œå¯ä»¥ä»æ›´é«˜çº§çš„æè¿°ä¸­è‡ªåŠ¨ç”Ÿæˆæºæ–‡ä»¶ã€‚ ç›´æ¥ä½¿ç”¨è¿™äº›è¯­è¨€å·¥å…·ï¼Œæœ‰å¥½å¤„ä¹Ÿæœ‰å¼Šç«¯ï¼Œè€Œå¯¹äºè¿™ä¸¤ä¸ªè§‚ç‚¹ï¼Œéƒ½æœ‰å¾ˆå¤šå®—æ•™ä¿¡ä»°èˆ¬çš„æ‹¥è¶¸ã€‚</p>
<p>æœ¬ä¹¦å°†é¿å…ä½¿ç”¨ç¼–è¯‘å™¨è¯­è¨€ï¼Œæˆ‘æƒ³è¦ç¡®ä¿æ²¡æœ‰é»‘æš—çš„è§’è½ï¼Œéšè—ç€ä¸€äº›é­”æ³•å’ŒæœªçŸ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†æ‰‹å†™æ‰€æœ‰å†…å®¹ã€‚æ­£å¦‚ä½ çœ‹åˆ°çš„ï¼Œè¿™å¹¶ä¸åƒå¬èµ·æ¥é‚£ä¹ˆç³Ÿç³•ï¼Œè¿™æ„å‘³ç€ä½ å°†çœŸæ­£ç†è§£æ¯ä¸€è¡Œä»£ç ï¼Œå¹¶ä¸”çœŸçš„ç†è§£è¿™ä¸¤ä¸ªè§£é‡Šå™¨æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚</p>
<p>ä¸€æœ¬ä¹¦ä¸åŒäºçœŸå®ä¸–ç•Œçš„çº¦æŸï¼Œå› æ­¤æœ¬ä¹¦çš„ç¼–ç é£æ ¼å¯èƒ½å¹¶ä¸æ˜¯ç¼–å†™å¯ç»´æŠ¤æ€§ç”Ÿäº§çº§åˆ«è½¯ä»¶çš„æœ€ä½³å®è·µã€‚å¦‚æœæˆ‘çœç•¥äº† private æˆ–è€… å¿½ç•¥äº†å…¨å±€å˜é‡å£°æ˜ï¼Œè¯·ç†è§£æˆ‘è¿™ä¹ˆåšæ˜¯ä¸ºäº†è®©ä»£ç æ›´åŠ å®¹æ˜“ç†è§£ï¼Œè€Œä¸æ˜¯æ¥æºäºå‚²æ…¢ã€‚è¿™é‡Œçš„é¡µé¢æ²¡æœ‰ IDE é‚£ä¹ˆå®½ï¼Œä½†æ˜¯å®ƒä»¬éƒ½éå¸¸é‡è¦ã€‚</p>
<p>æ­¤å¤–ï¼Œä»£ç æ²¡æœ‰å¤ªå¤šçš„æ³¨é‡Šï¼Œè¿™æ˜¯å› ä¸ºæ¯æ®µä»£ç ä¸Šä¸‹æ–‡ï¼Œéƒ½æ˜¯å¯¹å…¶çš„å¤§æ®µæ­£æ–‡è¯´æ˜ã€‚å½“ä½ è‡ªå·±ç¼–å†™ä¸€æœ¬ä»£ç å®ç°çš„ä¹¦ç±æ—¶å€™ï¼Œä¹Ÿæ¬¢è¿ä½ çœç•¥å…¶ä¸­çš„æ³¨é‡Šã€‚å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨æ›´å¤šçš„ //</p>
<p>è™½ç„¶è¿™æœ¬ä¹¦åŒ…å«äº†ç¼–è¯‘å™¨çš„æ¯ä¸€è¡Œä»£ç ï¼Œä»‹ç»äº†æ¯ä¸€è¡Œä»£ç çš„å«ä¹‰ï¼Œä½†æ˜¯æˆ‘å¹¶æ²¡æœ‰æè¿°ç¼–è¯‘å’Œè¿è¡Œä»£ç çš„å…·ä½“æœºå™¨ä¿¡æ¯ã€‚æˆ‘é¢„æƒ³ä½ å¯ä»¥ä½¿ç”¨è‡ªå·±ç†Ÿæ‚‰çš„ IDE åˆ›å»ºä¸€ä¸ªæ–‡ä»¶æˆ–æ˜¯ä¸€ä¸ªé¡¹ç›®ã€‚è¿™äº›å…·ä½“æœºå™¨è¯´æ˜å¾ˆå¿«å°±ä¼šè¿‡æ—¶ï¼Œæˆ‘å¸Œæœ›è¿™æœ¬ä¹¦å¯ä»¥åƒ XOç™½å…°åœ°ä¸€æ ·å†ä¹…å¼¥æ–°ï¼Œè€Œä¸æ˜¯åƒ backyard hoochï¼ˆä¸€ç›´ä¿è´¨æœŸä¸é•¿çš„èœ‚èœœé…’ï¼‰ä¸€æ ·å¾ˆå¿«è¿‡æ—¶ã€‚</p>
<blockquote>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/yak.png?raw=true" alt="yak" /></p>
<p>Yacc is a tool that takes in a grammar file and produces a source file for a compiler, so itâ€™s sort of like a â€œcompilerâ€ that outputs a compiler, which is where we get the term â€œcompiler-compilerâ€.</p>
<p>Yacc wasnâ€™t the first of its ilk, which is why itâ€™s named â€œYaccâ€â€”Yet Another Compiler-Compiler. A later similar tool is Bison, named as a pun on the pronunciation of Yacc like â€œyakâ€.</p>
<p>If you find all of these little self-references and puns charming and fun, youâ€™ll fit right in here. If not, well, maybe the language nerd sense of humor is an acquired taste.</p>
<p>Yacc æ˜¯ä¸€ä¸ªå·¥å…·ï¼Œå¯ä»¥æ¥æ”¶è¯­æ³•æ–‡ä»¶ï¼Œç„¶åä¸ºç¼–è¯‘å™¨ç”Ÿæˆæºæ–‡ä»¶ã€‚æ‰€ä»¥ï¼Œå®ƒå¥½åƒæ˜¯ä¸€ä¸ªå¯ä»¥è¾“å‡º&quot;ç¼–è¯‘å™¨&quot;çš„ç¼–è¯‘å™¨ï¼Œä¸€èˆ¬ä½¿ç”¨æœ¯è¯­&quot;ç¼–è¯‘å™¨ç¼–è¯‘ç¨‹åº&quot;å½¢å®¹ Yacc</p>
<p>Yaccå¹¶ä¸æ˜¯ç¬¬ä¸€ä¸ª&quot;ç¼–è¯‘å™¨ç¼–è¯‘ç¨‹åº&quot;, è¿™å°±æ˜¯è¿™ä¸ªç¨‹åºç¼©å†™çš„æ¥æºï¼šå¦ä¸€ä¸ªç¼–è¯‘å™¨ç¼–è¯‘ç¨‹åºã€‚è¿˜æœ‰ä¸€ä¸ªç›¸ä¼¼çš„å·¥å…·ï¼Œç§°ä¸º Bisonï¼ˆé‡ç‰›), å‘½åæ¥æºäº Yaccçš„åŒå…³è¯­ yak ï¼ˆç‰¦ç‰›)ã€‚</p>
<p>å¦‚æœä½ å‘ç°ï¼Œè¿™äº›å°å°çš„è‡ªæˆ‘æš—ç¤ºå’ŒåŒå…³è¯­ï¼Œå¾ˆæœ‰é­…åŠ›å’Œä¹è¶£ï¼Œä½ å°†å¾ˆå¿«é€‚åº”è¿™é‡Œã€‚å¦‚æœä½ å¯¹æ­¤å¹¶ä¸æ„Ÿå†’ï¼Œå¯èƒ½ä¹¦å‘†å­çš„å¹½é»˜æ„Ÿæ˜¯åå¤©å…»æˆçš„ã€‚</p>
</blockquote>
<h3 id="22-snippets"><a class="header" href="#22-snippets">2.2 Snippets</a></h3>
<p>ä»£ç æ®µ</p>
<p>Since the book contains literally every line of code needed for the implementations, the snippets are quite precise. Also, because I try to keep the program in a runnable state even when major features are missing, sometimes we add temporary code that gets replaced in later snippets.</p>
<p>A snippet with all the bells and whistles looks like this:</p>
<p>In the center, you have the new code to add. It may have a few faded out lines above or below to show where it goes in the existing surrounding code. There is also a little blurb telling you in which file and where to place the snippet. If that blurb says â€œreplace _ linesâ€, there is some existing code between the faded lines that you need to remove and replace with the new snippet.</p>
<pre><code class="language-java">
	// lox/Scanner.java in scanToken() replace 1 line
	
	default:
        if (isDigit(c)) {
          number();
        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }
        break;
		
</code></pre>
<p>å› ä¸ºæœ¬ä¹¦ä¸­åŒ…å«æœ‰æ‰€æœ‰ç¼–è¯‘å™¨çš„å®ç°ä»£ç ï¼Œæ‰€ä»¥ä¹¦ä¸­æ¶‰åŠçš„ä»£ç æ®µéå¸¸å‡†ç¡®ã€‚æ­¤å¤–ï¼Œå› ä¸ºæˆ‘è¯•å›¾è®©ç¨‹åºå³ä½¿åœ¨ç¼ºå°‘ä¸»è¦åŠŸèƒ½çš„æƒ…å†µä¸‹ï¼Œä¹Ÿå¯ä»¥ä¿æŒå¯è¿è¡ŒçŠ¶æ€ã€‚æ‰€ä»¥ï¼Œæœ‰æ—¶å€™æˆ‘ä¼šæ·»åŠ ä¸´æ—¶ä»£ç ï¼Œåœ¨ä¹‹åç« èŠ‚ä¼šæ›¿æ¢è¿™äº›ä¸´æ—¶ä»£ç ã€‚</p>
<p>ä»£ç æ®µç¤ºä¾‹å¦‚ä¸‹:</p>
<p>ä¸­é—´ä»£ç æ˜¯å®é™…è¦æ·»åŠ çš„ä»£ç ï¼Œä¸Šé¢å’Œä¸‹é¢çš„ä»£ç è¡¨ç¤ºè¦æ·»åŠ ä»£ç çš„ä½ç½®ã€‚è¿˜æœ‰ä¸€ä¸ªå°æç¤ºï¼Œå‘Šè¯‰ä½ è¿™æ®µä»£ç æ·»åŠ åˆ°å“ªä¸ªæ–‡ä»¶çš„å“ªä¸ªå‡½æ•°ä¸­ã€‚å¦‚ä½•å°æç¤ºä¸Šé¢å†™äº† &quot;æ›¿æ¢è¯¥è¡Œ&quot;, è¡¨ç¤ºæ–°å¢çš„ä»£ç éœ€è¦æ›¿æ¢ä¹‹å‰çš„ä»£ç ã€‚</p>
<h3 id="23-asides"><a class="header" href="#23-asides">2.3 Asides</a></h3>
<p>Asides contain biographical sketches, historical background, references to related topics, and suggestions of other areas to explore. Thereâ€™s nothing that you need to know in them to understand later parts of the book, so you can skip them if you want. I wonâ€™t judge you, but I might be a little sad.</p>
<p>æ—ç™½åŒ…å«äº†ä¼ è®°å†å²ã€å†å²èƒŒæ™¯ã€ç›¸å…³ä¸»é¢˜çš„å‚è€ƒæ–‡çŒ®ä»¥åŠæ¨èçš„å»¶ä¼¸é˜…è¯»ã€‚å¦‚æœæ˜¯ä¸ºäº†é˜…è¯»åé¢ç« èŠ‚çš„å†…å®¹ï¼Œä½ ä¸éœ€è¦é˜…è¯»æ—ç™½ï¼Œä¹Ÿå°±æ˜¯è¯´ä½ å¯ä»¥ç›´æ¥è·³è¿‡æ—ç™½ã€‚æˆ‘ä¸ä¼šæ‰¹è¯„ä½ ï¼Œä½†æ˜¯æˆ‘ä¼šæ„Ÿåˆ°éš¾è¿‡ ğŸ˜«ã€‚</p>
<blockquote>
<p>Well, some asides do, at least. Most of them are just dumb jokes and amateurish drawings.</p>
<p>å—¯ï¼Œè¿˜æœ‰äº›æ—ç™½ä¸å°½å¦‚äººæ„ï¼Œè¿™äº›æ—ç™½å¤§éƒ¨åˆ†éƒ½æ˜¯æ„šè ¢çš„ç¬‘è¯å’Œä¸šä½™æ°´å¹³çš„ç»˜ç”»ã€‚</p>
</blockquote>
<h3 id="24-challenges"><a class="header" href="#24-challenges">2.4 Challenges</a></h3>
<p>Each chapter ends with a few exercises. Unlike textbook problem sets, which tend to review material you already covered, these are to help you learn more than whatâ€™s in the chapter. They force you to step off the guided path and explore on your own. They will make you research other languages, figure out how to implement features, or otherwise get you out of your comfort zone.</p>
<p>Vanquish the challenges and youâ€™ll come away with a broader understanding and possibly a few bumps and scrapes. Or skip them if you want to stay inside the comfy confines of the tour bus. Itâ€™s your book.</p>
<p>æ¯ä¸ªç« èŠ‚éƒ½ä»¥ä¸€äº›ç»ƒä¹ é¢˜ç»“æŸã€‚ä½†æ˜¯ä¸åŒäºæ•™ç§‘ä¹¦çš„ä¹ é¢˜é›†ï¼Œå®ƒä»¬é€šå¸¸è®©ä½ å¤ä¹ å·²ç»å­¦è¿‡çš„çŸ¥è¯†ï¼Œæœ¬ä¹¦çš„ä¹ é¢˜æ›´åŠ å€¾å‘äºè®©ä½ å­¦åˆ°æ›´å¤šçš„ä¸œè¥¿ã€‚è¿™äº›ä¹ é¢˜ä¼šè®©ä½ ç¦»å¼€ç« èŠ‚çš„å·²æœ‰è·¯å¾„ï¼Œç‹¬è‡ªæ¢ç´¢æ›´å¤šçš„æœªçŸ¥é¢†åŸŸã€‚å®ƒä»¬ä¼šè®©ä½ å»ç ”ç©¶å…¶ä»–è¯­è¨€ï¼Œå»å¯»æ‰¾å¦‚ä½•å®ç°åŠŸèƒ½ï¼Œæˆ–è€…è®©ä½ èµ°å‡ºèˆ’é€‚åŒºã€‚</p>
<p>æ¥å—ä¹ é¢˜é›†çš„æŒ‘æˆ˜ï¼Œå¹¶ä¸”æˆ˜èƒœå®ƒä»¬ï¼Œä½ å°†ä¼šæœ‰æ›´åŠ å¹¿é˜”çš„è§†é‡ï¼Œè™½ç„¶ä½ å¯èƒ½ä¼šé‡åˆ°ä¸€äº›åå·å’ŒæŒ«æŠ˜ã€‚å¦‚æœä½ æƒ³è¦å‘†åœ¨èˆ’æœçš„æ¸¸è§ˆè½¦å†…ï¼Œä½ ä¹Ÿå¯ä»¥è·³è¿‡è¿™äº›æŒ‘æˆ˜ä¹ é¢˜ï¼Œæ¯•ç«Ÿè¿™æ˜¯ä½ çš„ä¹¦ã€‚</p>
<blockquote>
<p>A word of warning: the challenges often ask you to make changes to the interpreter youâ€™re building. Youâ€™ll want to implement those in a copy of your code. The later chapters assume your interpreter is in a pristine (â€œunchallengedâ€?) state.</p>
<p>ä¸€å¥è­¦å‘Šâš ï¸ï¼Œè¿™äº›æŒ‘æˆ˜é€šå¸¸ä¼šè¦æ±‚ä½ ä¿®æ”¹å·²æ„å»ºçš„è§£é‡Šå™¨ï¼Œå»ºè®®ä½ åœ¨å‰¯æœ¬é¡¹ç›®ä¸­å®ç°è¿™äº›æŒ‘æˆ˜ï¼Œæˆ‘ä»¬åé¢çš„ç« èŠ‚åŸºäºæ²¡æœ‰ä¿®æ”¹çš„è§£é‡Šå™¨ã€‚</p>
</blockquote>
<h3 id="25-design-notes"><a class="header" href="#25-design-notes">2.5 Design notes</a></h3>
<p>è®¾è®¡æ€è·¯</p>
<p>Most â€œprogramming languageâ€ books are strictly programming language implementation books. They rarely discuss how one might happen to design the language being implemented. Implementation is fun because it is so precisely defined. We programmers seem to have an affinity for things that are black and white, ones and zeroes.</p>
<p>Personally, I think the world needs only so many implementations of FORTRAN 77. At some point, you find yourself designing a new language. Once you start playing that game, then the softer, human side of the equation becomes paramount.  Things like which features are easy to learn, how to balance innovation and familiarity, what syntax is more readable and to whom.</p>
<p>All of that stuff profoundly affects the success of your new language. I want your language to succeed, so in some chapters I end with a â€œdesign noteâ€, a little essay on some corner of the human aspect of programming languages. Iâ€™m no expert on thisâ€”I donâ€™t know if anyone really isâ€”so take these with a large pinch of salt. That should make them tastier food for thought, which is my main aim.</p>
<p>I know a lot of language hackers whose careers are based on this. You slide a language spec under their door, wait a few months, and code and benchmark results come out. Hopefully your new language doesnâ€™t hardcode assumptions about the width of a punched card into its grammar.</p>
<p>å¤§å¤šæ•°çš„ç¼–ç¨‹è¯­è¨€ä¹¦ç±ï¼Œéƒ½æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„ç¼–å†™ä»£ç å®ç°ï¼Œä»–ä»¬å¾ˆå°‘è®¨è®ºå¦‚ä½•è®¾è®¡ä¸€é—¨è¯­è¨€ã€è®¾è®¡ä¸€æ®µå®ç°ã€‚å®ç°éå¸¸æœ‰è¶£ï¼Œå› ä¸ºå®ƒæ˜¯ç¡®å®šçš„ï¼Œè€Œä¸”è¢«ç²¾ç¡®å®šä¹‰ã€‚æˆ‘ä»¬ç¨‹åºå‘˜ä¼¼ä¹å¯¹äºç¡®å®šæ€§çš„ä¸œè¥¿ï¼Œä¾‹å¦‚ï¼šé»‘ä¸ç™½ï¼Œ1ä¸0ï¼Œå¤©ç”Ÿæœ‰å¥½æ„Ÿã€‚</p>
<p>å°±æˆ‘ä¸ªäººè€Œè¨€ï¼Œæˆ‘è®¤ä¸ºä¸–ç•Œä¸Šåªéœ€è¦ Fortran77 ï¼ˆ1976å¹´ï¼Œç¾å›½æ ‡å‡†åŒ–åä¼šé‡æ–°å¯¹Fortranï¼ˆx3.9-1966ï¼‰è¿›è¡Œäº†è¯„ä¼°ï¼Œå…¬å¸ƒäº†æ–°çš„Fortranæ ‡å‡†ï¼Œä¹Ÿå°±æ˜¯Fortran 77ã€‚Fortran 77æ˜¯å…·æœ‰ç»“æ„åŒ–ç‰¹æ€§çš„ç¼–ç¨‹è¯­è¨€ã€‚Fortran77åœ¨çŸ­æ—¶é—´å†…è·å–äº†å·¨å¤§çš„æˆåŠŸï¼Œå¹¿æ³›åœ°åº”ç”¨äºç§‘å­¦å’Œå·¥ç¨‹è®¡ç®—ï¼Œå‡ ä¹ç»Ÿæ²»äº†æ•°å€¼è®¡ç®—é¢†åŸŸã€‚ï¼‰ä¸­å®ç°çš„åŠŸèƒ½ã€‚ä½†æ˜¯åœ¨æŸäº›æ—¶å€™ï¼Œä½ å‘ç°è‡ªå·±åœ¨è®¾è®¡ä¸€é—¨æ–°è¯­è¨€ã€‚ä¸€æ—¦ä½ å¼€å§‹è®¾è®¡è¯­è¨€è¿™ä¸ªæ¸¸æˆï¼Œé‚£ä¹ˆäººæ€§åŒ–çš„ä¸€é¢å˜å¾—éå¸¸é‡è¦ã€‚éœ€è¦è€ƒè™‘æ›´åŠ å…·ä½“çš„å†…å®¹ï¼Œä¾‹å¦‚ï¼šå“ªäº›åŠŸèƒ½æ›´æ˜“äºå­¦ä¹ ï¼Œå¦‚ä½•å¹³è¡¡åˆ›æ–°å’Œä¿ç•™ï¼Œå“ªäº›è¯­æ³•æ›´æ˜“äºé˜…è¯»ï¼Œå­¦ä¹ è¯­è¨€çš„äººç¾¤æ˜¯è°ï¼Ÿ</p>
<p>æ‰€æœ‰è¿™äº›éƒ½æ·±åˆ»çš„å½±å“ç€ä¸€é—¨æ–°è¯­è¨€çš„æˆåŠŸä¸å¦ã€‚æˆ‘å¸Œæœ›ä½ çš„æ–°è¯­è¨€å¯ä»¥æˆåŠŸï¼Œæ‰€ä»¥æˆ‘ä¼šåœ¨æŸäº›ç« èŠ‚çš„ç»“å°¾ï¼Œå‘è¡¨ä¸€äº›è®¾è®¡æ–¹é¢çš„æ€è€ƒï¼Œè¿™æ˜¯ä¸€äº›ç¼–ç¨‹è¯­è¨€ä¸­äººä»¬è®¾è®¡çš„æœ€ä½³å®è·µã€‚æˆ‘ä¸æ˜¯è®¾è®¡æ–¹é¢çš„ä¸“å®¶ï¼Œä¸çŸ¥é“æ˜¯å¦æœ‰äººçœŸçš„è¿™ä¹ˆæƒ³â€”åœ¨ä¸€äº›ç¼–ç¨‹è¯­è¨€çš„æ­£æ–‡ä¸­ï¼Œæ·»åŠ ä¸€äº›è®¾è®¡æ–¹é¢çš„å†…å®¹ã€‚è¿™åº”è¯¥ä¼šè®©è®¾è®¡å†…å®¹ç§°ä¸ºæ›´åŠ ç¾å‘³çš„æ€æƒ³é£Ÿç²®ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘çš„ä¸»è¦ç›®æ ‡ã€‚</p>
<p>æˆ‘è®¤è¯†å¾ˆå¤šç¼–ç¨‹é«˜æ‰‹ï¼Œä»–ä»¬çš„èŒä¸šå°±åœ¨äºæ­¤â€”â€”ä½ å°†ä¸€é—¨è¯­è¨€çš„è§„èŒƒå‘ŠçŸ¥ä»–ä»¬ï¼Œç­‰å¾…å‡ ä¸ªæœˆï¼Œä½ å°†ä¼šå¾—åˆ°è¿™é—¨æ–°è¯­è¨€çš„ä»£ç å’ŒåŸºå‡†æµ‹è¯•ç»“æœã€‚å¸Œæœ›ä½ çš„æ–°è¯­è¨€ï¼Œä¸ä¼šå°†ç©¿å­”çº¸çš„å®½åº¦ä¿¡æ¯ï¼Œç¡¬ç¼–ç åˆ°è¯­è¨€è¯­æ³•ä¸­ã€‚</p>
<h2 id="ä¸‰the-first-interpreter"><a class="header" href="#ä¸‰the-first-interpreter">ä¸‰ã€The First Interpreter</a></h2>
<p>ç¬¬ä¸€ä¸ªè§£é‡Šå™¨</p>
<p>Weâ€™ll write our first interpreter, jlox, in Java. The focus is on concepts. Weâ€™ll write the simplest, cleanest code we can to correctly implement the semantics of the language. This will get us comfortable with the basic techniques and also hone our understanding of exactly how the language is supposed to behave.</p>
<p>Java is a great language for this. Itâ€™s high level enough that we donâ€™t get overwhelmed by fiddly implementation details, but itâ€™s still pretty explicit. Unlike in scripting languages, there tends to be less complex machinery hiding under the hood, and youâ€™ve got static types to see what data structures youâ€™re working with.</p>
<p>æˆ‘ä»¬å°†ä½¿ç”¨Javaè¯­è¨€å®ç°ç¬¬ä¸€ä¸ªè§£é‡Šå™¨ï¼Œjloxï¼Œç¬¬ä¸€ä¸ªè§£é‡Šå™¨çš„é‡ç‚¹æ˜¯åŸºæœ¬æ¦‚å¿µï¼Œæˆ‘ä»¬å°†ç¼–å†™æœ€ç®€æ´ã€æœ€åŸºç¡€çš„ä»£ç ï¼Œå®ç°è§£é‡Šå™¨çš„è¯­ä¹‰ã€‚è¿™å°†è®©æˆ‘ä»¬ç†Ÿæ‚‰åŸºæœ¬çš„æŠ€æœ¯ï¼Œè®©æˆ‘ä»¬èƒ½æ›´åŠ å‡†ç¡®ç†è§£è¯­è¨€è¡Œä¸ºã€‚</p>
<p>Java æ˜¯ä¸€é—¨å¾ˆå¥½çš„è¯­è¨€ï¼Œæˆ‘ä»¬ä¸éœ€è¦å…³æ³¨åº•å±‚çš„å¤§é‡å®ç°ç»†èŠ‚ï¼Œå› ä¸ºJava æ˜¯ä¸€é—¨é«˜çº§è¯­è¨€ï¼Œæ‹¥æœ‰æ›´å¤šçš„ç¡®å®šæ€§ã€‚å’Œè„šæœ¬è¯­è¨€ä¸åŒçš„æ˜¯ï¼ŒJava ä¸ä¸åŒæœºå™¨çš„å…³è”æ€§å¹¶æ²¡æœ‰é‚£ä¹ˆå¤æ‚ï¼Œé€šå¸¸ï¼Œä½ å¯ä»¥ä½¿ç”¨é™æ€ç±»å‹å»è·å–æŸ¥çœ‹å½“å‰æ­£åœ¨ä½¿ç”¨çš„æ•°æ®ç»“æ„ã€‚</p>
<blockquote>
<p>The book uses Java and C, but readers have ported the code to many other languages. If the languages I picked arenâ€™t your bag, take a look at those.</p>
<p>æœ¬ä¹¦å°†ä½¿ç”¨ Java, Cè¯­è¨€ï¼Œä½†æ˜¯è¯»è€…å¯èƒ½æ›´åŠ ç†Ÿæ‚‰å…¶ä»–çš„ç¼–ç¨‹è¯­è¨€ï¼Œå¦‚æœæˆ‘ä½¿ç”¨çš„è¯­è¨€ä¸æ˜¯ä½ çš„èœï¼Œå¯ä»¥å°è¯•ä½¿ç”¨ä½ æœ€ç†Ÿæ‚‰çš„è¯­è¨€ã€‚</p>
</blockquote>
<p>I also chose Java specifically because it is an object-oriented language.  That paradigm swept the programming world in the â€™90s and is now the dominant way of thinking for millions of programmers. Odds are good youâ€™re already used to organizing code into classes and methods, so weâ€™ll keep you in that comfort zone.</p>
<p>While academic language folks sometimes look down on object-oriented languages, the reality is that they are widely used even for language work. GCC and LLVM are written in C++, as are most JavaScript virtual machines. Object-oriented languages are ubiquitous, and the tools and compilers for a language are often written in the same language.</p>
<p>And, finally, Java is hugely popular. That means thereâ€™s a good chance you already know it, so thereâ€™s less for you to learn to get going in the book. If you arenâ€™t that familiar with Java, donâ€™t freak out. I try to stick to a fairly minimal subset of it.  I use the diamond operator from Java 7 to make things a little more terse,  but thatâ€™s about it as far as â€œadvancedâ€ features go. If you know another object-oriented language, like C# or C++, you can muddle through.</p>
<p>By the end of part II, weâ€™ll have a simple, readable implementation. Itâ€™s not very fast, but itâ€™s correct. However, we are only able to accomplish that by building on the Java virtual machineâ€™s own runtime facilities. We want to learn how Java itself implements those things.</p>
<p>æˆ‘ä»¬é€‰æ‹©Javaï¼Œè¿˜å› ä¸ºå®ƒæ˜¯ä¸€é—¨é¢å‘å¯¹è±¡çš„è¯­è¨€ã€‚è¿™ç§ç¼–ç¨‹èŒƒå¼åœ¨90å¹´ä»£å¸­å·äº†æ•´ä¸ªä¸–ç•Œï¼Œç°åœ¨ä¹Ÿæ˜¯æ•°ç™¾ä¸‡ç¨‹åºå‘˜çš„ä¸»æµæ€ç»´æ–¹å¼ã€‚å¾ˆå¯èƒ½ä½ å·²ç»ä¹ æƒ¯äº†å°†ä»£ç ç»„ç»‡æˆç±»å’Œæ–¹æ³•ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ä¹Ÿä¼šè®©ä½ å¤„äºèˆ’é€‚åŒºä¸­ã€‚</p>
<p>è™½ç„¶ï¼Œå­¦æœ¯ç ”ç©¶è¯­è¨€çš„äººä»¬ï¼Œæœ‰æ—¶å€™çœ‹ä¸èµ·é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€ï¼Œä½†æ˜¯å®é™…æƒ…å†µæ˜¯ï¼Œå³ä½¿åœ¨ä»–ä»¬æ—¥å¸¸ç¼–ç¨‹å·¥ä½œä¸­ï¼Œä¹Ÿä¼šå¹¿æ³›ä½¿ç”¨é¢å‘å¯¹è±¡è¯­è¨€ã€‚GCC/LLVM è¿˜æœ‰å¤§å¤šæ•°çš„ JavaScript è™šæ‹Ÿæœºéƒ½æ˜¯ä½¿ç”¨é¢å‘å¯¹è±¡çš„C++è¯­è¨€å®ç°çš„ã€‚é¢å‘å¯¹è±¡è¯­è¨€æ— å¤„ä¸åœ¨ï¼Œä¸€é—¨è¯­è¨€çš„ç¼–è¯‘å™¨å’Œå·¥å…·ï¼Œé€šå¸¸ä¼šä½¿ç”¨ç›¸åŒçš„è¯­è¨€å®ç°ã€‚</p>
<p>æœ€åï¼ŒJavaéå¸¸æµè¡Œã€‚è¿™æ„å‘³ç€ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½æœºä¼šå»ä½¿ç”¨ç†Ÿæ‚‰è¿™é—¨è¯­è¨€ã€‚å¦‚æœä½ ä¸ç†Ÿæ‚‰Javaï¼Œä¹Ÿä¸ç”¨æ‹…å¿ƒï¼Œæœ¬ä¹¦ä¸­åªä¼šä½¿ç”¨ä¸€å°éƒ¨åˆ†åŠŸèƒ½ï¼Œæˆ‘å°†ä½¿ç”¨Java7 æ ‡å‡†é‡Œé¢çš„è¿ç®—ç¬¦ï¼Œç›¸å¯¹äºä½¿ç”¨æ›´å¤šçš„é«˜çº§ç”¨æ³•ï¼Œè¿™ä¼šè®©ç¼–ç¨‹å˜å¾—æ›´åŠ ç®€æ´ã€‚å¦‚æœä½ è¿˜ç†Ÿæ‚‰å…¶ä»–çš„é¢å‘å¯¹è±¡è¯­è¨€ï¼Œä¾‹å¦‚: C#, C++, ä½ ä¹Ÿå¯ä»¥å°è¯•ä½¿ç”¨å®ƒä»¬å»å®ç°ç¼–è¯‘å™¨ã€‚</p>
<p>åœ¨ç¬¬äºŒéƒ¨åˆ†ç»“æŸæ—¶å€™ï¼Œæˆ‘ä»¬å°†æœ‰ä¸€ä¸ªç®€å•æ˜“è¯»çš„è§£é‡Šå™¨å®ç°ï¼Œå®ƒçš„è¿è¡Œæ€§èƒ½ä¸æ˜¯å¾ˆé«˜ï¼Œä½†æ˜¯å¯ä»¥ä¿è¯å‡†ç¡®æ€§ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å®ç°çš„è§£é‡Šå™¨ï¼Œæ˜¯åŸºäºJava è¯­è¨€å’Œ Java è™šæ‹Ÿæœºåº•å±‚ã€‚æˆ‘ä»¬æƒ³è¦äº†è§£ Javaæœ¬èº«æ˜¯å¦‚ä½•å®ç°è¿™äº›åŠŸèƒ½çš„ã€‚</p>
<blockquote>
<p>A compiler reads files in one language, translates them, and outputs files in another language. You can implement a compiler in any language, including the same language it compiles, a process called self-hosting.</p>
<p>You canâ€™t compile your compiler using itself yet, but if you have another compiler for your language written in some other language, you use that one to compile your compiler once. Now you can use the compiled version of your own compiler to compile future versions of itself, and you can discard the original one compiled from the other compiler. This is called bootstrapping, from the image of pulling yourself up by your own bootstraps.</p>
<p>ç¼–è¯‘å™¨è¯»å–ä¸€ç§è¯­è¨€çš„åŸå§‹æ–‡ä»¶ï¼Œç¿»è¯‘å®ƒä»¬ï¼Œç„¶åè¾“å‡ºä¸ºå¦å¤–ä¸€é—¨è¯­è¨€çš„æ–‡ä»¶ã€‚ä½ å¯ä»¥ç”¨ä»»ä½•è¯­è¨€å®ç°ç¼–è¯‘å™¨ï¼Œç”šè‡³ä½ å¯ä»¥ä½¿ç”¨ç›¸åŒçš„è¯­è¨€å»å®ç°è¯¥è¯­è¨€çš„ç¼–è¯‘å™¨ï¼Œè¿™é€šå¸¸è¢«ç§°ä¸ºè‡ªç¼–è¯‘ã€‚</p>
<p>ä¸€å¼€å§‹ï¼Œä½ æ— æ³•ä½¿ç”¨ç›¸åŒçš„è¯­è¨€å†™æˆä¸€ä¸ªç¼–è¯‘å™¨ï¼Œä½†æ˜¯å¦‚æœä½ å·²ç»ä½¿ç”¨è¿‡å…¶ä»–è¯­è¨€å®ç°äº†æ–°è¯­è¨€çš„ç¼–è¯‘å™¨ï¼Œé‚£ä¹ˆä½ å°±å¯ä»¥ä½¿ç”¨å·²ç»å®ç°çš„ç¼–è¯‘å™¨ï¼Œå»ç¼–è¯‘ä¸€æ¬¡ï¼Œç„¶åä½ å¯ä»¥è·å–åˆ°ä½¿ç”¨æ–°è¯­è¨€å®ç°çš„ç¼–è¯‘å™¨ã€‚æ¥ä¸‹æ¥ï¼Œä½ å¯ä»¥æ„‰å¿«çš„ä½¿ç”¨æ–°çš„ç¼–è¯‘å™¨ï¼Œå»å‡çº§æ–°çš„ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œä¹Ÿå¯ä»¥æ‰”æ‰ä¹‹å‰çš„å…¶ä»–è¯­è¨€å†™æˆçš„ç¼–è¯‘å™¨äº†ã€‚ä¸“ä¸šæœ¯è¯­ä¸€èˆ¬ç§°ä¸ºè‡ªä¸¾ï¼Œå›¾ä¸­å½¢è±¡çš„æè¿°äº†ä¸€ä¸ªäººçš„è‡ªä¸¾ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/bootstrap.png?raw=true" alt="bootstraps" /></p>
</blockquote>
<h2 id="å››the-second-interpreter"><a class="header" href="#å››the-second-interpreter">å››ã€The Second Interpreter</a></h2>
<p>ç¬¬äºŒä¸ªç¼–è¯‘å™¨</p>
<p>So in the next part, we start all over again, but this time in C. C is the perfect language for understanding how an implementation really works, all the way down to the bytes in memory and the code flowing through the CPU.</p>
<p>A big reason that weâ€™re using C is so I can show you things C is particularly good at, but that does mean youâ€™ll need to be pretty comfortable with it. You donâ€™t have to be the reincarnation of Dennis Ritchie, but you shouldnâ€™t be spooked by pointers either.</p>
<p>If you arenâ€™t there yet, pick up an introductory book on C and chew through it, then come back here when youâ€™re done. In return, youâ€™ll come away from this book an even stronger C programmer. Thatâ€™s useful given how many language implementations are written in C: Lua, CPython, and Rubyâ€™s MRI, to name a few.</p>
<p>åœ¨ä¸‹ä¸ªéƒ¨åˆ†ä¸­ï¼Œæˆ‘ä»¬å°†ä»å¤´å¼€å§‹ï¼Œä½†æ˜¯è¿™ä¸€æ¬¡å°†ä½¿ç”¨Cè¯­è¨€ã€‚Cè¯­è¨€å¯ä»¥è®©æˆ‘ä»¬æ›´å¥½çš„ç†è§£è®¡ç®—æœºæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæ·±å…¥åˆ°åº•å±‚ï¼Œä¾‹å¦‚ï¼šå†…å­˜ä¸­çš„å­—èŠ‚å’Œ cpu æ‰§è¡Œçš„ä»£ç ã€‚</p>
<p>æˆ‘ä»¬ä½¿ç”¨Cè¯­è¨€å®ç°è§£é‡Šå™¨çš„ä¸€ä¸ªé‡è¦åŸå› æ˜¯ï¼Œæˆ‘å¯ä»¥ä½¿ç”¨Cè¯­è¨€ä¸€äº›ç‰¹åˆ«æ“…é•¿çš„åŠŸèƒ½ï¼Œä½†æ˜¯è¿™ä¹Ÿæ„å‘³ç€ä½ å¿…é¡»éå¸¸ç†Ÿæ‚‰Cè¯­è¨€ã€‚ä½ ä¸éœ€è¦åƒåˆ›å§‹äºº Dennis Ritchie ä¸€æ ·ç†Ÿæ‚‰ Cè¯­è¨€ï¼Œä½†æ˜¯ä½ è‡³å°‘ä¸èƒ½è¢«æŒ‡é’ˆå“å€’ã€‚</p>
<p>å¦‚æœä½ è¿˜ä¸å¤ªäº†è§£Cè¯­è¨€ï¼Œé‚£ä¹ˆå…ˆæ‹¿èµ·ä¸€æœ¬Cè¯­è¨€å…¥é—¨ä¹¦ç±ä»”ç»†é˜…è¯»åï¼Œå†å›åˆ°è¿™é‡Œã€‚ä½œä¸ºå›æŠ¥ï¼Œä½ å°†å˜æˆä¸€ä¸ªæ›´å¼ºå¤§çš„Cè¯­è¨€ç¨‹åºå‘˜ã€‚ä½ å¯ä»¥å…ˆçœ‹çœ‹æœ‰å“ªäº›è¯­è¨€æ˜¯åŸºäºCè¯­è¨€å®ç°çš„ï¼šLuaï¼ŒCPythonï¼ŒRubyçš„MRIå®ç°ï¼Œç­‰ç­‰ã€‚</p>
<p>In our C interpreter, clox, we are forced to implement for ourselves all the things Java gave us for free. Weâ€™ll write our own dynamic array and hash table. Weâ€™ll decide how objects are represented in memory, and build a garbage collector to reclaim them.</p>
<p>åœ¨Cè¯­è¨€å®ç°çš„è§£é‡Šå™¨ clox ä¸­ï¼Œæˆ‘ä»¬å°†è¦å®ç°ä¸€äº› Javaä¸­åŸç”Ÿå­˜åœ¨çš„ç»“æ„ï¼Œä¾‹å¦‚ï¼šæˆ‘ä»¬å°†å®ç°åŠ¨æ€æ•°ç»„å’Œå“ˆå¸Œè¡¨ï¼Œæˆ‘ä»¬å°†è®¾è®¡å†³å®šå¦‚ä½•åœ¨å†…å­˜ä¸­è¡¨ç¤ºå¯¹è±¡ï¼Œå¹¶ä¸”æ„å»ºåƒåœ¾é‡‡é›†å™¨å›æ”¶å®ƒä»¬ã€‚</p>
<blockquote>
<p>I pronounce the name like â€œsea-locksâ€, but you can say it â€œclocksâ€ or even â€œclochâ€, where you pronounce the â€œxâ€ like the Greeks do if it makes you happy.</p>
<p>æˆ‘æŠŠè¿™ä¸ªåå­—è¯»æˆ&quot;sea-locks&quot;, ä½†æ˜¯ä½ ä¹Ÿå¯ä»¥è¯»æˆï¼Œ&quot;clocks&quot; æˆ–è€… &quot;cloch&quot;, å¦‚æœä½ å¼€å¿ƒçš„è¯ï¼Œè¿˜å¯ä»¥åƒå¸Œè…Šäººä¸€æ ·è¯» &quot;x&quot;</p>
</blockquote>
<p>Our Java implementation was focused on being correct. Now that we have that down, weâ€™ll turn to also being fast. Our C interpreter will contain a compiler that translates Lox to an efficient bytecode representation (donâ€™t worry, Iâ€™ll get into what that means soon), which it then executes. This is the same technique used by implementations of Lua, Python, Ruby, PHP, and many other successful languages.</p>
<p>ç¬¬ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬ç”¨Javaè¯­è¨€å®ç°çš„è§£é‡Šå™¨ jloxä¸»è¦ä¸“æ³¨äºå‡†ç¡®æ€§ï¼Œç°åœ¨æˆ‘ä»¬å·²ç»å®ç°äº†å‡†ç¡®æ€§ï¼Œæ¥ä¸‹æ¥å°†ä¸“æ³¨äºæ€§èƒ½ã€‚æˆ‘ä»¬çš„cloxè§£é‡Šå™¨ï¼Œå°†å®ç°ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œå°†lox ç¼–è¯‘ä¸ºæœ‰æ•ˆçš„å­—èŠ‚ç ï¼ˆåˆ«æ‹…å¿ƒï¼Œå¾ˆå¿«æˆ‘å°†è§£é‡Šå®ƒæ˜¯ä»€ä¹ˆï¼‰ï¼Œç„¶åæ‰§è¡Œå­—èŠ‚ç ã€‚è¿™ä¸å…¶ä»–è¯­è¨€çš„å®ç°ä½¿ç”¨ç›¸åŒæŠ€æœ¯ï¼Œä¾‹å¦‚ï¼šLuaï¼ŒPythonï¼ŒRubyï¼ŒPHPç­‰ç­‰ã€‚</p>
<blockquote>
<p>Did you think this was just an interpreter book? Itâ€™s a compiler book as well. Two for the price of one!</p>
<p>ä½ è®¤ä¸ºè¿™åªæ˜¯ä¸€æœ¬è§£é‡Šå™¨ä»‹ç»ä¹¦ç±å—ï¼Œå…¶å®å®ƒè¿˜æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨ä»‹ç»ä¹¦ç±ã€‚è¿™ä¸¤è€…æ²¡æœ‰æœ¬è´¨åŒºåˆ«ã€‚</p>
</blockquote>
<p>Weâ€™ll even try our hand at benchmarking and optimization. By the end, weâ€™ll have a robust, accurate, fast interpreter for our language, able to keep up with other professional caliber implementations out there. Not bad for one book and a few thousand lines of code.</p>
<p>æˆ‘ä»¬ç”šè‡³ä¼šå°è¯•åŸºå‡†æµ‹è¯•å’Œä¼˜åŒ–ã€‚åˆ°æœ€åï¼Œæˆ‘ä»¬å°†å®ç°ä¸€ä¸ªå¼ºå¤§ã€å‡†ç¡®ã€å¿«é€Ÿçš„è¯­è¨€è§£é‡Šå™¨ï¼Œèƒ½å¤Ÿå’Œå…¶ä»–ä¸“ä¸šçº§åˆ«çš„è¯­è¨€åª²ç¾ï¼Œè€Œè¿™å¯¹äºä¸€æœ¬ä¹¦å’Œå‡ åƒè¡Œä»£ç è€Œè¨€ï¼Œå¹¶ä¸ç®€å•ã€‚</p>
<h2 id="äº”-challenges"><a class="header" href="#äº”-challenges">äº”ã€ Challenges</a></h2>
<p>ä¹ é¢˜</p>
<ol>
<li>
<p>There are at least siz domain-specific languages used in the <a href="https://github.com/munificent/craftinginterpreters">little system I cobbled together</a> to write and publish this book. What are they?</p>
<p>åœ¨æˆ‘ç¼–å†™æœ¬ä¹¦ä¸­ï¼Œè‡³å°‘ä½¿ç”¨äº†6ç§å°ä¼—è¯­è¨€ï¼Œè¯·åˆ—ä¸¾ä¸­å®ƒä»¬ï¼Ÿ</p>
</li>
<li>
<p>Get a &quot;Hello, world!&quot; program written and running in Java. Set up whatever makefiles or IDE projects you need to get it working. If you have a debugger, get comfortable with it and step through your program as it runs.</p>
<p>ä½¿ç”¨ Javaè¯­è¨€å®ç°ä¸€ä¸ª &quot;hello, world&quot; ç¨‹åºï¼Œæè¿°ä¸€ä¸‹ä½ ä½¿ç”¨çš„IDE å’Œé…ç½®æ–‡ä»¶ï¼Œå¦‚æœä½ çš„IDEæœ‰è°ƒè¯•å™¨ï¼Œè¯·ä½¿ç”¨è°ƒè¯•å™¨ï¼Œä¸€æ­¥æ­¥è°ƒè¯•ä»£ç ã€‚</p>
</li>
<li>
<p>Do the same thing for C. To get some practice with pointers, define a <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly linked list</a> of heap-allocated strings. Write functions to insert, find, and delete items from it. Test them.</p>
<p>ä½¿ç”¨Cè¯­è¨€å®ç°ä¸€ä¸ª &quot;hello, world&quot; ç¨‹åºï¼Œä¸ºäº†ç»ƒä¹ æŒ‡é’ˆï¼Œå®šä¹‰ä¸€ä¸ªå †åˆ†é…å­—ç¬¦ä¸²çš„åŒé“¾è¡¨ï¼Œç¼–å†™å‡½æ•°æ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤é“¾è¡¨å…ƒç´ ã€‚</p>
</li>
</ol>
<h2 id="å…­design-note-whats-in-a-name"><a class="header" href="#å…­design-note-whats-in-a-name">å…­ã€Design Note: What's in a name?</a></h2>
<p>è®¾è®¡æ€è·¯ï¼šå¦‚ä½•å‘½åï¼Ÿ</p>
<p>One of the hardest challenges in writing book was coming up with a name for the language it implements. I went through pages of candidates before I found one that worked. As you'll discover on the first day you start building your own language, naming is deviously hard. A good name satisfies a few criteria:</p>
<ol>
<li>
<p>It isn't in use.</p>
<p>You can run into all sorts of trouble, legal and social, if you inadvertently step on someone elseâ€™s name.</p>
</li>
<li>
<p>It's easy to pronounce. If things go well, hordes of people will be saying and writing your languageâ€™s name. Anything longer than a couple of syllables or a handful of letters will annoy them to no end.</p>
</li>
<li>
<p>It's distinct enough to search for. People will Google your languageâ€™s name to learn about it, so you want a word thatâ€™s rare enough that most results point to your docs. Though, with the amount of AI search engines are packing today, thatâ€™s less of an issue. Still, you wonâ€™t be doing your users any favors if you name your language â€œforâ€.</p>
</li>
<li>
<p>It doesn't have negative connotations across a number of cultures. This is hard to be on guard for, but itâ€™s worth considering. The designer of Nimrod ended up renaming his language to â€œNimâ€ because too many people remember that Bugs Bunny used â€œNimrodâ€ as an insult. (Bugs was using it ironically.)</p>
</li>
</ol>
<p>If your potential name makes it through that gauntlet, keep it. Donâ€™t get hung up on trying to find an appellation that captures the quintessence of your language.</p>
<p>æœ¬ä¹¦ç¼–å†™è¿‡ç¨‹ä¸­ä¸€ä¸ªæŒ‘æˆ˜æ˜¯ï¼Œå¦‚ä½•ä¸ºå®ç°çš„è¯­è¨€å‘½åã€‚æˆ‘éœ€è¦ä»ä¼—å¤šçš„å€™é€‰ä¸­ï¼Œæ‰¾åˆ°æœ€åˆé€‚çš„ã€‚æ­£å¦‚ä½ åœ¨æ„å»ºè‡ªå·±è¯­è¨€æ—¶å€™ä¼šé‡åˆ°çš„ä¸€æ ·ï¼Œå‘½åéå¸¸å›°éš¾ï¼Œä¸€ä¸ªå¥½çš„å‘½åç¬¦åˆä¸‹é¢çš„æ ‡å‡†ï¼š</p>
<ol>
<li>
<p>è¯¥åå­—ä¹‹å‰æ²¡æœ‰è¢«ä½¿ç”¨ã€‚å¦‚æœä½ ä¸å°å¿ƒä½¿ç”¨äº†ä»–äººçš„å‘½åï¼Œå¯èƒ½ä¼šæœ‰éå¸¸å¤šçš„éº»çƒ¦ï¼ŒåŒ…å«æ³•å¾‹å’Œç¤¾ä¼šé—®é¢˜ã€‚</p>
</li>
<li>
<p>è¯¥åå­—éœ€è¦æœ—æœ—ä¸Šå£ï¼Œå¦‚æœä¸€åˆ‡é¡ºåˆ©çš„è¯ï¼Œä¼šæœ‰éå¸¸å¤šäººä¹¦å†™ã€è¯´å‡ºä½ çš„è¯­è¨€åç§°ï¼Œè€Œä»»ä½•æ‹—å£çš„åå­—ï¼Œéƒ½ä¼šç»™äººä»¬å¸¦æ¥å›°æƒ‘ã€‚</p>
</li>
<li>
<p>è¯¥åå­—éœ€è¦è¶³å¤Ÿç‰¹åˆ«ï¼Œæ›´å®¹æ˜“æœç´¢åˆ°ã€‚äººä»¬ç¬¬ä¸€æ—¶é—´ä¼šä½¿ç”¨æœç´¢å¼•æ“äº†è§£ä½ çš„è¯­è¨€ï¼Œå¦‚æœä½ ä½¿ç”¨ä¸€ä¸ªè¶³å¤Ÿç‰¹åˆ«çš„å•è¯å‘½åï¼Œé‚£ä¹ˆå¤§å®¶å°†å¾ˆå®¹æ˜“è·å–åˆ°ã€‚å°½ç®¡ï¼Œéšç€æœç´¢å¼•æ“æ‹¥æœ‰æ›´å¤šçš„AIèƒ½åŠ›ï¼Œæ›´å®¹æ˜“æ˜¾ç¤ºä½ çš„è¯­è¨€ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ æŠŠè‡ªå·±çš„æ–°è¯­è¨€å‘½åä¸º&quot;for&quot;, é‚£ä¹ˆè¿™é€šå¸¸ä¸èƒ½å¸¦ç»™ä½¿ç”¨è€…ä»»ä½•å¸®åŠ©ã€‚</p>
</li>
<li>
<p>è¯¥åå­—åœ¨å…¶ä»–æ–‡åŒ–ä¸­æ²¡æœ‰è´Ÿé¢å«ä¹‰ã€‚è¿™ä¸€ç‚¹å¾ˆéš¾é˜²èŒƒï¼Œä½†æ˜¯éœ€è¦è®¤çœŸè€ƒè™‘ã€‚Nimrod çš„è®¾è®¡è€…æœ€ç»ˆå°†è¿™ä¸ªè¯­è¨€å‘½åä¸º &quot;Nim&quot;, Bugs Bunnyæ›¾ç»æ•…æ„ä½¿ç”¨æœ‰äº‰è®®çš„åç§° Nimrod å‘½åæ–°çš„è¯­è¨€ï¼Œäººä»¬ä¾ç„¶è®°å¾—ã€‚</p>
</li>
</ol>
<p>å¦‚æœä½ çš„å€™é€‰å‘½åï¼Œé€šè¿‡äº†ä¸Šé¢çš„æ ‡å‡†ï¼Œé‚£ä¹ˆç•™ç€å®ƒå§ã€‚ä¸è¦è¯•å›¾å»æ‰¾åˆ°ä¸€ä¸ªèƒ½æŠ“ä½ä½ çš„è¯­è¨€ç²¾é«“çš„åç§°ã€‚å¦‚æœè¯´ä¸–ç•Œä¸Šå…¶ä»–å·²ç»æˆåŠŸçš„è¯­è¨€æ•™ä¼šäº†æˆ‘ä»¬ä»€ä¹ˆçš„è¯ï¼Œé‚£å°±æ˜¯è¯­è¨€åå­—å’Œè¯­è¨€ç²¾é«“æ²¡æœ‰å…³è”ã€‚ä½ æ‰€éœ€è¦çš„åªæ˜¯ä¸€ä¸ªï¼Œç‹¬ç‰¹çš„åç§°ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ€»è§ˆå›¾"><a class="header" href="#æ€»è§ˆå›¾">æ€»è§ˆå›¾</a></h1>
<h2 id="a-map-of-the-territory"><a class="header" href="#a-map-of-the-territory">A Map of the Territory</a></h2>
<blockquote>
<p>you must have a map, no matter how rough. Otherwise you wander all over the place. In The Lord of the Rings I never made anyone go farther than he could on a given day.</p>
<p align="right">â€”â€” J.R.R. Tolkien</p>
</blockquote>
<p>é¢†åœŸå›¾</p>
<blockquote>
<p>ä¸ç®¡æœ‰å¤šä¹ˆç²—ç³™ï¼Œä½ éƒ½å¿…é¡»æ‹¥æœ‰ä¸€å¹…é¢†åœŸåœ°å›¾ï¼Œå¦åˆ™ä½ å°†åˆ°å¤„æ¸¸è¡ã€‚åœ¨ã€ŠæŒ‡ç¯ç‹ã€‹ä¸­ï¼Œæˆ‘ä»æ¥éƒ½æ²¡æœ‰è®©ä»»ä½•äººä¸€å¤©å†…èµ°çš„æ›´è¿œã€‚</p>
<p align="right">â€”â€” J.R.R. Tolkien</p>
</blockquote>
<p>We donâ€™t want to wander all over the place, so before we set off, letâ€™s scan the territory charted by previous language implementers. It will help us understand where we are going and the alternate routes others have taken.</p>
<p>First, let me establish a shorthand.  Much of this book is about a languageâ€™s implementation, which is distinct from the language itself in some sort of Platonic ideal form. Things like â€œstackâ€, â€œbytecodeâ€, and â€œrecursive descentâ€, are nuts and bolts one particular implementation might use. From the userâ€™s perspective, as long as the resulting contraption faithfully follows the languageâ€™s specification, itâ€™s all implementation detail.</p>
<p>Weâ€™re going to spend a lot of time on those details, so if I have to write â€œlanguage implementationâ€ every single time I mention them, Iâ€™ll wear my fingers off. Instead, Iâ€™ll use â€œlanguageâ€ to refer to either a language or an implementation of it, or both, unless the distinction matters.</p>
<p>æˆ‘ä»¬ä¸æƒ³åˆ°å¤„çé€›ï¼Œæ‰€ä»¥åœ¨å‡ºå‘ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæµè§ˆä¸€ä¸‹ä»¥å‰çš„è¯­è¨€å®ç°è€…ç»˜åˆ¶çš„é¢†åœŸå›¾ã€‚è¿™å°†å¸®åŠ©æˆ‘ä»¬ç†è§£æˆ‘ä»¬çš„ç›®æ ‡ï¼Œäº†è§£æ›´å¤šçš„æ›¿ä»£è·¯å¾„ã€‚</p>
<p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬å»ºç«‹ä¸€ä¸ªæ¦‚è§ˆã€‚æœ¬ä¹¦çš„å¤§éƒ¨åˆ†å†…å®¹éƒ½æ˜¯å¦‚ä½•å®ç°ä¸€é—¨è¯­è¨€ï¼Œè¿™å’Œä¸€é—¨è¯­è¨€æœ¬èº«æŸæ‹‰å›¾å¼çš„ç†æƒ³æ¦‚å¿µæœ‰æ‰€ä¸åŒã€‚ åƒæ˜¯æ ˆã€å­—èŠ‚ç ã€é€’å½’ä¸‹é™ç­‰ä¸œè¥¿ï¼Œæ˜¯ä¸€ä¸ªç‰¹å®šå®ç°å¯èƒ½ä¼šç”¨åˆ°çš„å…·ä½“ç»†èŠ‚ã€‚ ä»ç”¨æˆ·çš„è§’åº¦ï¼Œåªè¦ç”Ÿæˆçš„å†…å®¹è¿˜éµå¾ªç€è¯­è¨€çš„è§„èŒƒï¼Œå®ƒå°±æ˜¯æ‰€æœ‰çš„å®ç°ç»†èŠ‚ã€‚</p>
<p>æˆ‘ä»¬å°†åœ¨è¿™äº›ç»†èŠ‚ä¸ŠèŠ±è´¹å¤§é‡æ—¶é—´ï¼Œå› æ­¤ï¼Œå¦‚æœæ¯æ¬¡æåˆ°è¿™äº›ç»†èŠ‚ï¼Œæˆ‘éƒ½è¦åŠ ä¸Šè¯­è¨€å®ç°è¯´æ˜ï¼Œé‚£ä¹ˆæˆ‘ä¼šç´¯æ™•çš„ã€‚æ‰€ä»¥ï¼Œæˆ‘å°†ä½¿ç”¨è¯­è¨€æ¥è¡¨ç¤ºä¸€é—¨è¯­è¨€æˆ–è€…è¿™é—¨è¯­è¨€çš„å®ç°ï¼Œæˆ–è€…ä¸¤è€…ï¼Œé™¤éä¸¤è€…çš„åŒºåˆ«éå¸¸é‡è¦ã€‚</p>
<h2 id="ä¸€the-parts-of-a-language"><a class="header" href="#ä¸€the-parts-of-a-language">ä¸€ã€The Parts of a Language</a></h2>
<p>è¯­è¨€çš„ç»„æˆéƒ¨åˆ†</p>
<p>Engineers have been building programming languages since the Dark Ages of computing. As soon as we could talk to computers, we discovered doing so was too hard, and we enlisted their help. I find it fascinating that even though todayâ€™s machines are literally a million times faster and have orders of magnitude more storage, the way we build programming languages is virtually unchanged.</p>
<p>Though the area explored by language designers is vast, the trails theyâ€™ve carved through it are few. Not every language takes the exact same pathâ€”some take a shortcut or twoâ€”but otherwise they are reassuringly similar, from Rear Admiral Grace Hopperâ€™s first COBOL compiler all the way to some hot, new, transpile-to-JavaScript language whose â€œdocumentationâ€ consists entirely of a single, poorly edited README in a Git repository somewhere.</p>
<p>è‡ªè®¡ç®—çš„é»‘æš—æ—¶ä»£ä»¥æ¥ï¼Œå·¥ç¨‹å¸ˆä»¬ä¸€ç›´åœ¨æ„å»ºç¼–ç¨‹è¯­è¨€ã€‚å½“æˆ‘ä»¬å¯ä»¥ä¸ç”µè„‘äº¤æµæ—¶å€™ï¼Œæˆ‘ä»¬å‘ç°è¿™æ ·åšå¤ªéš¾äº†ï¼Œéœ€è¦ç”µè„‘çš„å¸®åŠ©ã€‚æˆ‘å‘ç°ä¸€ä¸ªæœ‰è¶£çš„ç°è±¡ï¼Œå³ä½¿ä»Šå¤©çš„æœºå™¨è¿è¡Œé€Ÿåº¦å¿«äº†æ•°ç™¾ä¸‡å€ï¼Œå­˜å‚¨é‡ä¹Ÿå¢åŠ äº†å‡ ä¸ªæ•°é‡çº§ï¼Œä½†æ˜¯æˆ‘ä»¬æ„å»ºç¼–ç¨‹è¯­è¨€çš„æ–¹å¼å‡ ä¹æ²¡æœ‰ä»»ä½•æ”¹å˜ã€‚</p>
<p>è™½ç„¶ï¼Œè¯­è¨€è®¾è®¡è€…æ¢ç´¢çš„é¢†åŸŸéå¸¸å¤§ï¼Œä½†æ˜¯ä»–ä»¬åœ¨å…¶ä¸­å¼€è¾Ÿçš„é“è·¯å´éå¸¸å°‘ã€‚å¹¶ä¸æ˜¯æ‰€æœ‰çš„è¯­è¨€éƒ½èµ°ç›¸åŒçš„è·¯å¾„ï¼Œæœ‰äº›è¯­è¨€çš„å®ç°ï¼Œä¼šèµ°ä¸€ã€ä¸¤æ¡æ·å¾„ã€‚ä½†æ˜¯ä»å¦ä¸€ä¸ªè§’åº¦æ¥çœ‹ï¼Œå®ƒä»¬éƒ½æ˜¯ç›¸ä¼¼çš„ã€‚ä»ç¬¬ä¸€ä¸ª COBOLç¼–è¯‘å™¨åˆ°ç°åœ¨æœ€æ–°çš„å¯ä»¥è½¬æ¢ä¸º JavaScriptçš„è¯­è¨€ï¼Œåœ¨å®ƒä»¬ gitä»“åº“READMEæ–‡ä»¶ä¸­çš„æè¿°éƒ½æ˜¯ç›¸ä¼¼çš„ã€‚</p>
<blockquote>
<p>There are certainly dead ends, sad little cul-de-sacs of CS papers with zero citations and now-forgotten optimizations that only made sense when memory was measured in individual bytes.</p>
<p>æ¯«æ— ç–‘é—®ï¼Œè®¡ç®—æœºç§‘å­¦è®ºæ–‡å­˜åœ¨ä¸€äº›æ­»èƒ¡åŒã€‚è¿™äº›è®ºæ–‡ç°åœ¨å·²ç»æ²¡æœ‰äººå¼•ç”¨ï¼Œéƒ½æ˜¯åœ¨å†…å­˜éœ€è¦ä»¥ä¸€ä¸ªä¸€ä¸ªå­—èŠ‚æ¥è¡¡é‡æ—¶æœŸçš„ä¼˜åŒ–ä½¿ç”¨è®ºæ–‡ã€‚</p>
</blockquote>
<p>I visualize the network of paths an implementation may choose as climbing a mountain. You start off at the bottom with the program as raw source text, literally just a string of characters. Each phase analyzes the program and transforms it to some higher-level representation where the semanticsâ€”what the author wants the computer to doâ€”become more apparent.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/mountain.png?raw=true" alt="a map of the territory" /></p>
<p>Eventually we reach the peak. We have a birdâ€™s-eye view of the userâ€™s program and can see what their code means. We begin our descent down the other side of the mountain. We transform this highest-level representation down to successively lower-level forms to get closer and closer to something we know how to make the CPU actually execute.</p>
<p>æˆ‘æŠŠç¼–è¯‘é¢†åŸŸå›¾ï¼Œæƒ³è±¡ä¸ºä¸€å¹…åŒ…å«å¾ˆå¤šè·¯å¾„çš„çˆ¬å±±å›¾ã€‚ä»åº•éƒ¨å¼€å§‹ï¼Œä¸€å¼€å§‹åªæ˜¯ä¸€ä¸ªæ–‡æœ¬ï¼Œå®é™…ä¸Šåªæ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ç»è¿‡ï¼Œæ¯ä¸ªåˆ†æé˜¶æ®µï¼Œéƒ½ä¼šç”Ÿæˆæ›´åŠ é«˜çº§çš„è¡¨ç¤ºï¼Œè®¾è®¡è€…å¸Œæœ›è®¡ç®—æœºæ‰§è¡Œçš„è¯­è¨€éƒ½æ›´åŠ æ˜ç¡®ã€‚</p>
<p>æœ€åï¼Œæˆ‘ä»¬çˆ¬ä¸Šäº†å±±é¡¶ã€‚æˆ‘ä»¬é¸Ÿç°å…¨å±€ï¼Œå¯ä»¥å¾—åˆ°ä½¿ç”¨è€…ç¼–å†™çš„ä»£ç å«ä¹‰ã€‚æˆ‘ä»¬ä»å±±çš„å¦ä¸€è¾¹å¼€å§‹ä¸‹å±±ï¼Œæˆ‘ä»¬å°†è¿ç»­å°†é«˜çº§åˆ«çš„è¡¨ç¤ºè½¬æ¢ä¸ºæ›´ä½çº§åˆ«çš„è¡¨ç¤ºï¼Œä»¥è¶Šæ¥è¶Šæ¥è¿‘è®¡ç®—æœº CPUæ‰§è¡Œçš„è¯­è¨€ã€‚</p>
<p>Letâ€™s trace through each of those trails and points of interest. Our journey begins on the left with the bare text of the userâ€™s source code:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/string.png?raw=true" alt="string" /></p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¿½è¸ªæ¯ä¸€æ¡è·¯å¾„ã€æ¯ä¸€ä¸ªåœç•™ç‚¹ï¼Œæˆ‘ä»¬çš„æ—…é€”ä»å·¦è¾¹å±±è„šå¼€å§‹ï¼ˆç”¨æˆ·æºä»£ç ï¼‰ã€‚</p>
<h3 id="11-scanning"><a class="header" href="#11-scanning">1.1 Scanning</a></h3>
<p>æ‰«æ</p>
<p>The first step is scanning, also known as lexing, or (if youâ€™re trying to impress someone) lexical analysis. They all mean pretty much the same thing. I like â€œlexingâ€ because it sounds like something an evil supervillain would do, but Iâ€™ll use â€œscanningâ€ because it seems to be marginally more commonplace.</p>
<p>A scanner (or lexer) takes in the linear stream of characters and chunks them together into a series of something more akin to â€œwordsâ€. In programming languages, each of these words is called a token. Some tokens are single characters, like ( and ,. Others may be several characters long, like numbers (123), string literals (&quot;hi!&quot;), and identifiers (min).</p>
<p>Some characters in a source file donâ€™t actually mean anything. Whitespace is often insignificant, and comments, by definition, are ignored by the language. The scanner usually discards these, leaving a clean sequence of meaningful tokens.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/tokens.png?raw=true" alt="tokens" /></p>
<p>ç¬¬ä¸€æ­¥æ˜¯æ‰«æï¼Œä¹Ÿç§°ä¸ºè¯æ³•ï¼Œå¦‚æœä½ æƒ³ç»™åˆ«äººç•™ä¸‹æ·±åˆ»å°è±¡ï¼Œè¿˜å¯ä»¥ç§°ä¸ºè¯æ³•åˆ†æã€‚ä»–ä»¬çš„å«ä¹‰éƒ½å·®ä¸å¤šï¼Œæˆ‘æ›´å–œæ¬¢è¯æ³•ï¼Œå› ä¸ºè¿™å¬èµ·æ¥åƒæ˜¯ä¸€ä¸ªæ¶ä½œå‰§ï¼Œä½†æ˜¯æ¥ä¸‹æ¥æˆ‘ä¼šä½¿ç”¨æ‰«æè¡¨ç¤ºè¿™ä¸ªè¿‡ç¨‹ï¼Œå› ä¸ºè¿™ç§è¯´æ³•æ›´åŠ å¸¸è§ã€‚</p>
<p>ä¸€ä¸ªæ‰«æå™¨ï¼Œæ¥æ”¶çº¿æ€§çš„å­—ç¬¦ä¸²ï¼Œå°†å®ƒä»¬åˆ†å—ä¸ºä¸€ä¸ªä¸ªå•è¯ï¼Œåœ¨ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œåˆ†æˆçš„å•è¯ç§°ä¸º token, ä¸€äº› token æ˜¯å•å­—ç¬¦ï¼Œä¾‹å¦‚: <code>(</code> <code>,</code> è¿˜æœ‰ä¸€äº›tokené•¿åº¦æ˜¯å¤šä¸ªå­—ç¬¦ï¼Œä¾‹å¦‚: æ•°å­— <code>123</code> ï¼Œå­—ç¬¦ä¸² <code>&quot;hi!&quot;</code> , æ ‡è¯†ç¬¦ <code>min</code></p>
<p>æºæ–‡ä»¶ä¸­çš„æŸäº›å­—ç¬¦æ²¡æœ‰å®é™…æ„ä¹‰ã€‚ç©ºç™½å­—ç¬¦ï¼Œé€šå¸¸æ²¡æœ‰å®é™…æ„ä¹‰ï¼Œè¿˜æœ‰æ³¨é‡Šï¼Œæ ¹æ®è¯­è¨€å®šä¹‰ï¼Œæ³¨é‡Šä¼šè¢«è¯­è¨€å¿½ç•¥ã€‚æ‰«æå™¨é€šå¸¸ä¼šå¿½ç•¥è¿™äº›å†…å®¹ï¼Œæœ€ç»ˆç”Ÿæˆä¸€ä¸ªå¹²å‡€çš„æœ‰æ„ä¹‰çš„token åºåˆ—ã€‚</p>
<h3 id="12-parsing"><a class="header" href="#12-parsing">1.2 Parsing</a></h3>
<p>è§£æ</p>
<p>The next step is parsing. This is where our syntax gets a grammarâ€”the ability to compose larger expressions and statements out of smaller parts. Did you ever diagram sentences in English class? If so, youâ€™ve done what a parser does, except that English has thousands and thousands of â€œkeywordsâ€ and an overflowing cornucopia of ambiguity. Programming languages are much simpler.</p>
<p>A parser takes the flat sequence of tokens and builds a tree structure that mirrors the nested nature of the grammar. These trees have a couple of different namesâ€”parse tree or abstract syntax treeâ€”depending on how close to the bare syntactic structure of the source language they are.  In practice, language hackers usually call them syntax trees, ASTs, or often just trees.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/ast.png?raw=true" alt="ast" /></p>
<p>ä¸‹ä¸€æ­¥æ˜¯è§£æï¼Œè¿™å°±æ˜¯æˆ‘ä»¬è·å¾—è¯­æ³•çš„åœ°æ–¹ï¼Œè¯­æ³•å¯ä»¥å°†è¾ƒå°çš„éƒ¨åˆ†ç»„åˆæˆè¾ƒå¤§çš„è¡¨è¾¾å¼å’Œè¯­å¥ã€‚ä½ åœ¨è‹±è¯­è¯¾å ‚ä¸Šç”»è¿‡å¥å­å›¾å—ï¼Ÿå¦‚æœæ˜¯è¿™æ ·çš„è¯ï¼Œä½ å·²ç»å®Œæˆäº†è§£æå™¨çš„å·¥ä½œã€‚é™¤äº†è‹±è¯­æœ‰æˆåƒä¸Šä¸‡ä¸ªå…³é”®è¯å’Œæ›´å¤šçš„æ­§ä¹‰ã€‚ç›¸è¾ƒè€Œè¨€ï¼Œç¼–ç¨‹è¯­è¨€å°±ç®€å•å¤ªå¤šäº†ã€‚</p>
<p>è§£æå™¨æ¥æ”¶token åºåˆ—ï¼Œç„¶åæ„å»ºå‡ºååº”è¯­æ³•åµŒå¥—æ€§è´¨çš„æ ‘ç»“æ„ã€‚è¿™äº›æ ‘æœ‰ä¸€äº›ä¸åŒçš„åç§°ï¼Œä¾‹å¦‚ï¼šåç§°è§£ææ ‘ï¼ŒæŠ½è±¡è¯­æ³•æ ‘ï¼Œå‘½åå–å†³äºè¿™äº›æ ‘å’Œæºè¯­è¨€çš„ç®€å•è¯­æ³•ç»“æ„çš„æ¥è¿‘ç¨‹åº¦ã€‚åœ¨å®è·µä¸­ï¼Œè¯­è¨€é«˜æ‰‹ç»å¸¸ç§°å®ƒä»¬ä¸ºè¯­æ³•æ ‘ï¼ŒASTæˆ–è€…é€šå¸¸å°±ç§°ä¸ºæ ‘ã€‚</p>
<p>Parsing has a long, rich history in computer science that is closely tied to the artificial intelligence community. Many of the techniques used today to parse programming languages were originally conceived to parse human languages by AI researchers who were trying to get computers to talk to us.</p>
<p>It turns out human languages were too messy for the rigid grammars those parsers could handle, but they were a perfect fit for the simpler artificial grammars of programming languages. Alas, we flawed humans still manage to use those simple grammars incorrectly, so the parserâ€™s job also includes letting us know when we do by reporting syntax errors.</p>
<p>è§£æåœ¨è®¡ç®—æœºç§‘å­¦ä¸­æ‹¥æœ‰æ‚ ä¹…ä¸°å¯Œçš„å†å²ï¼Œä¸äººå·¥æ™ºèƒ½é¢†åŸŸå¯†åˆ‡ç›¸å…³ã€‚ä»Šå¤©ç”¨äºè§£æç¼–ç¨‹è¯­è¨€çš„è®¸å¤šæŠ€æœ¯æœ€åˆæ˜¯ç”±äººå·¥æ™ºèƒ½ç ”ç©¶äººå‘˜æ„æ€çš„ï¼Œä»–ä»¬æœ€åˆè®¾æƒ³æ˜¯è®©è®¡ç®—æœºä¸äººå¯¹è¯äº¤æµã€‚</p>
<p>äº‹å®è¯æ˜ï¼Œå¯¹äºè§£æå™¨æ‰€èƒ½è§£æçš„è¯­æ³•è€Œè¨€ï¼Œäººç±»çš„è¯­è¨€å¤ªå¤æ‚äº†ï¼Œä½†æ˜¯è¿™äº›è§£æå™¨å´éå¸¸é€‚åˆç¼–ç¨‹è¯­è¨€ä¸­çš„äººç±»å®šä¹‰çš„è¯­æ³•è§„åˆ™ã€‚å“ï¼Œæˆ‘ä»¬è¿™äº›æ™®é€šçš„äººï¼Œåœ¨ä½¿ç”¨è¿™äº›ç®€å•è¯­æ³•æ—¶å€™ï¼Œä»ç„¶ä¼šçŠ¯é”™è¯¯ï¼Œæ‰€ä»¥ï¼Œè§£æå™¨è¿˜ä¼šæŠ¥å‘Šè¯­æ³•é”™è¯¯ï¼Œè®©æˆ‘ä»¬çŸ¥é“ã€‚</p>
<h3 id="13-static-analysis"><a class="header" href="#13-static-analysis">1.3 Static analysis</a></h3>
<p>é™æ€åˆ†æ</p>
<p>The first two stages are pretty similar across all implementations. Now, the individual characteristics of each language start coming into play. At this point, we know the syntactic structure of the codeâ€”things like which expressions are nested in whichâ€”but we donâ€™t know much more than that.</p>
<p>In an expression like a + b, we know we are adding a and b, but we donâ€™t know what those names refer to. Are they local variables? Global? Where are they defined?</p>
<p>å‰é¢ä¸¤ä¸ªé˜¶æ®µï¼ˆæ‰«æã€è§£æï¼‰åœ¨æ‰€æœ‰çš„å®ç°ä¸­éƒ½æ˜¯ç›¸ä¼¼çš„ï¼Œç°åœ¨ï¼Œæ¯ç§è¯­è¨€çš„ç‰¹æ€§å¼€å§‹æ˜¾ç°å‡ºæ¥äº†ã€‚è§£æè¿‡åï¼Œæˆ‘ä»¬çŸ¥é“äº†ä»£ç çš„è¯­æ³•ç»“æ„ï¼Œä¾‹å¦‚ï¼šæˆ‘ä»¬çŸ¥é“äº†åŒ…å«äº†å“ªäº›è¡¨è¾¾å¼ï¼Œä½†æ˜¯æˆ‘ä»¬äº†è§£çš„è¿˜ä¸å¤Ÿå¤šã€‚</p>
<p>åœ¨åƒè¡¨è¾¾å¼ a + bä¸­ï¼Œæˆ‘ä»¬çŸ¥é“è¡¨è¾¾å¼æ˜¯ aä¸bæ±‚å’Œï¼Œä½†æ˜¯æˆ‘ä»¬å¹¶ä¸çŸ¥é“aï¼Œbå…·ä½“è¡¨ç¤ºä»€ä¹ˆï¼Œå®ƒä»¬æ˜¯å±€éƒ¨å˜é‡å—ï¼Œæ˜¯å…¨å±€å˜é‡å—ï¼Œå®ƒä»¬æ˜¯åœ¨å“ªé‡Œå®šä¹‰çš„å‘¢ï¼Ÿ</p>
<p>The first bit of analysis that most languages do is called binding or resolution. For each identifier, we find out where that name is defined and wire the two together. This is where scope comes into playâ€”the region of source code where a certain name can be used to refer to a certain declaration.</p>
<p>If the language is statically typed, this is when we type check. Once we know where a and b are declared, we can also figure out their types. Then if those types donâ€™t support being added to each other, we report a type error.</p>
<p>å¤§å¤šæ•°è¯­è¨€çš„ç¬¬ä¸€ç‚¹åˆ†æå«åšï¼Œç»‘å®šæˆ–è§£æã€‚å¯¹äºæ¯ä¸ªæ ‡è¯†ç¬¦ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°è¯¥æ ‡è¯†ç¬¦åç§°çš„å®šä¹‰ä½ç½®ï¼Œå¹¶ä¸”å°†ä¸¤è€…è¿æ¥åœ¨ä¸€èµ·ï¼Œè¿™å°±æ˜¯ä½œç”¨åŸŸå‘æŒ¥ä½œç”¨çš„åœ°æ–¹â€”â€”æºä»£ç çš„æŸä¸ªåŒºåŸŸä¸­ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå…·ä½“åç§°æ¥å¼•ç”¨æŸä¸ªå£°æ˜ã€‚</p>
<p>å¦‚æœè¯­è¨€æ˜¯é™æ€è¯­è¨€ï¼Œè¿™æ—¶å€™ï¼Œæˆ‘ä»¬è¿˜è¦è¿›è¡Œç±»å‹åˆ¤æ–­ï¼Œä¸€æ—¦æˆ‘ä»¬æ‰¾åˆ°äº† aï¼Œbçš„å£°æ˜ä½ç½®ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è·å–åˆ°å®ƒä»¬çš„æ•°æ®ç±»å‹ã€‚ç„¶åï¼Œå¦‚æœè¿™äº›æ•°æ®ç±»å‹ä¸æ”¯æŒåŠ æ³•è§„åˆ™ï¼Œæˆ‘ä»¬å°†æŠ¥å‘Šä¸€ä¸ªç±»å‹é”™è¯¯ã€‚</p>
<blockquote>
<p>The language weâ€™ll build in this book is dynamically typed, so it will do its type checking later, at runtime.</p>
</blockquote>
<blockquote>
<p>æœ¬ä¹¦ä¸­æ„å»ºçš„è¯­è¨€æ˜¯åŠ¨æ€è¯­è¨€ï¼Œæ‰€ä»¥ï¼Œç±»å‹æ£€æŸ¥å°†å‘ç”Ÿåœ¨è¿è¡Œæ—¶ï¼Œè€Œä¸æ˜¯å½“å‰é˜¶æ®µã€‚</p>
</blockquote>
<p>Take a deep breath. We have attained the summit of the mountain and a sweeping view of the userâ€™s program. All this semantic insight that is visible to us from analysis needs to be stored somewhere. There are a few places we can squirrel it away:</p>
<ul>
<li>
<p>Often, it gets stored right back as attributes on the syntax tree itselfâ€”extra fields in the nodes that arenâ€™t initialized during parsing but get filled in later.</p>
</li>
<li>
<p>Other times, we may store data in a lookup table off to the side. Typically, the keys to this table are identifiersâ€”names of variables and declarations. In that case, we call it a symbol table and the values it associates with each key tell us what that identifier refers to.</p>
</li>
<li>
<p>The most powerful bookkeeping tool is to transform the tree into an entirely new data structure that more directly expresses the semantics of the code. Thatâ€™s the next section.</p>
</li>
</ul>
<p>æ·±å‘¼å¸ï¼Œæˆ‘ä»¬å·²ç»ç™»ä¸Šäº†å±±é¡¶ï¼Œç”¨æˆ·ç¨‹åºä¸€è§ˆæ— ä½™ã€‚ä»åˆ†æé˜¶æ®µåï¼Œè·å–åˆ°çš„è¯­ä¹‰é™„åŠ ä¿¡æ¯ï¼Œéœ€è¦ä¿å­˜åœ¨æŸä¸ªåœ°æ–¹ã€‚æœ‰å‡ ä¸ªåœ°æ–¹å¯ä»¥ä¿å­˜è¿™äº›ä¿¡æ¯ã€‚</p>
<ul>
<li>
<p>é€šå¸¸ï¼Œå®ƒä½œä¸ºå±æ€§å­˜å‚¨åœ¨è¯­æ³•æ ‘çš„å…¶ä»–å­—æ®µä¸­ï¼Œè¿™äº›å­—æ®µåœ¨è§£æé˜¶æ®µæ²¡æœ‰åˆå§‹åŒ–ï¼Œä½†æ˜¯åœ¨åˆ†æé˜¶æ®µä¼šè¢«å¡«å……</p>
</li>
<li>
<p>å…¶ä»–æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ•°æ®ä¿å­˜åœ¨æ—è¾¹çš„æŸ¥æ‰¾è¡¨ä¸­ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œè¯¥æŸ¥æ‰¾è¡¨çš„keyæ˜¯æ ‡è¯†ç¬¦ï¼ˆå˜é‡åç§°å’Œå£°æ˜ï¼‰ã€‚è¿™è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºç¬¦å·è¡¨ï¼Œè¡¨ä¸­keyå¯¹åº”çš„valueï¼Œè¡¨ç¤ºè¯¥æ ‡è¯†ç¬¦å¯¹åº”çš„å®é™…å€¼æ˜¯ä»€ä¹ˆ</p>
</li>
<li>
<p>æ›´åŠ å¼ºå¤§çš„è®°å½•æ–¹å¼æ˜¯ï¼Œå°†è¯­æ³•æ ‘è½¬æ¢ä¸ºä¸€ä¸ªå…¨æ–°çš„æ•°æ®ç»“æ„ï¼Œæ›´åŠ ç›´æ¥çš„è¡¨ç¤ºä»£ç çš„å«ä¹‰ã€‚è¿™æ˜¯ä¸‹ä¸€èŠ‚çš„å†…å®¹ã€‚</p>
</li>
</ul>
<p>Everything up to this point is considered the front end of the implementation. You might guess everything after this is the back end, but no. Back in the days of yore when â€œfront endâ€ and â€œback endâ€ were coined, compilers were much simpler. Later researchers invented new phases to stuff between the two halves. Rather than discard the old terms, William Wulf and company lumped those new phases into the charming but spatially paradoxical name middle end.</p>
<p>åˆ°ç°åœ¨ä¸ºæ­¢ï¼Œæ‰€æœ‰å†…å®¹é˜¶æ®µï¼Œéƒ½æ˜¯å®ç°çš„å‰ç«¯éƒ¨åˆ†ã€‚ä½ å¯èƒ½ä¼šæƒ³è±¡ï¼Œé‚£ä¹ˆä¹‹åçš„å†…å®¹æ˜¯åç«¯äº†ï¼Œå…¶å®å¹¶ä¸æ˜¯ï¼Œå“ˆå“ˆğŸ˜„ã€‚å½“ç¼–è¯‘å™¨ï¼Œåˆšå¼€å§‹æœ‰å‰ç«¯ã€åç«¯æ¦‚å¿µçš„æ—¶å€™ï¼Œé‚£æ—¶å€™çš„ç¼–è¯‘å™¨éå¸¸ç®€å•ã€‚åæ¥ï¼Œç ”ç©¶äººå‘˜åˆå‘æ˜äº†å…¶ä»–é˜¶æ®µï¼Œå®ƒä»¬åœ¨å‰ç«¯ã€åç«¯ä¹‹é—´ã€‚<a href="https://en.wikipedia.org/wiki/William_Wulf">William Wulf</a> å’Œä»–ä»¬å…¬å¸å¹¶æ²¡æœ‰æŠ›å¼ƒæ—§çš„æœ¯è¯­ï¼Œä»–ä»¬æŠŠè¿™äº›æ–°å‘æ˜çš„é˜¶æ®µå½’ä¸ºæœ‰æ„æ€çš„ä½†æ˜¯æœ‰äº›çŸ›ç›¾çš„æœ¯è¯­ï¼Œä¸­é—´ç«¯ã€‚</p>
<h3 id="14-intermediate-representations"><a class="header" href="#14-intermediate-representations">1.4 Intermediate representations</a></h3>
<p>ä¸­é—´è¡¨ç¤ºæ³•</p>
<p>You can think of the compiler as a pipeline where each stageâ€™s job is to organize the data representing the userâ€™s code in a way that makes the next stage simpler to implement. The front end of the pipeline is specific to the source language the program is written in. The back end is concerned with the final architecture where the program will run.</p>
<p>In the middle, the code may be stored in some intermediate representation (IR) that isnâ€™t tightly tied to either the source or destination forms (hence â€œintermediateâ€). Instead, the IR acts as an interface between these two languages.</p>
<p>æˆ‘ä»¬å¯ä»¥å°†ç¼–è¯‘å™¨è§†ä¸ºä¸€ä¸ªç®¡é“ï¼Œæ¯ä¸ªé˜¶æ®µçš„å·¥ä½œæ˜¯ç”¨ä¸€ç§æ›´æ˜“äºå®ç°çš„æ–¹å¼ï¼Œç»„ç»‡è¡¨ç¤ºç”¨æˆ·ä»£ç ã€‚ç®¡é“å‰ç«¯ï¼Œä½œç”¨äºç¼–å†™ç¨‹åºçš„æºè¯­è¨€ï¼Œåç«¯ä¸ç¨‹åºè¿è¡Œçš„æœ€ç»ˆæ¶æ„ç›¸å…³ã€‚</p>
<p>åœ¨ä¸­é—´ç«¯ï¼Œä»£ç å¯èƒ½å­˜å‚¨åœ¨ä¸€äº›ä¸­é—´è¡¨ç¤ºä¸­ï¼Œè¿™äº›è¡¨ç¤ºï¼Œä¸æºè¯­è¨€å’Œç›®æ ‡å½¢å¼éƒ½æ²¡æœ‰ç´§å¯†å…³è”ã€‚ç›¸åï¼Œè¿™ç§ä¸­é—´è¡¨ç¤ºï¼Œå……å½“æºè¯­è¨€å’Œç›®æ ‡è¯­è¨€ä¹‹é—´çš„æ¥å£ã€‚</p>
<blockquote>
<p>There are a few well-established styles of IRs out there. Hit your search engine of choice and look for â€œcontrol flow graphâ€, â€œstatic single-assignmentâ€, â€œcontinuation-passing styleâ€, and â€œthree-address codeâ€.</p>
</blockquote>
<blockquote>
<p>æœ‰ä¸€äº›æˆç†Ÿçš„ä¸­é—´è¡¨ç¤ºé£æ ¼ï¼Œæœ‰å…´è¶£çš„è¯ï¼Œå¯ä»¥å»ç ”ç©¶ä¸€ä¸‹ï¼Œæ§åˆ¶æµå›¾ã€é™æ€å•èµ‹å€¼ã€è¿ç»­ä¼ é€’æ ·å¼ã€ä¸‰åœ°å€ä»£ç ç­‰ç­‰ã€‚</p>
</blockquote>
<p>This lets you support multiple source languages and target platforms with less effort. Say you want to implement Pascal, C, and Fortran compilers, and you want to target x86, ARM, and, I dunno, SPARC. Normally, that means youâ€™re signing up to write nine full compilers: Pascalâ†’x86, Câ†’ARM, and every other combination.</p>
<p>A shared intermediate representation reduces that dramatically. You write one front end for each source language that produces the IR. Then one back end for each target architecture. Now you can mix and match those to get every combination.</p>
<p>Thereâ€™s another big reason we might want to transform the code into a form that makes the semantics more apparentâ€‰.â€‰.â€‰. </p>
<p>è¿™ç§æ–¹å¼ï¼Œå¯ä»¥è®©æˆ‘ä»¬æ›´å®¹æ˜“æ”¯æŒå¤šç§æºè¯­è¨€å’Œç›®æ ‡è¯­è¨€çš„åŒ¹é…ã€‚å‡è®¾ä½ æƒ³è¦å®ç°ï¼ŒPascalã€Cã€Fortranè¯­è¨€çš„ç¼–è¯‘å™¨ï¼Œå¹¶ä¸”è¿™äº›ç¼–è¯‘å™¨ï¼Œå¯ä»¥è¿è¡Œåœ¨X86ï¼Œ armï¼ŒSPARCç­‰æ¶æ„ä¸Šï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨ä¸­é—´è¡¨ç¤ºï¼Œä½ éœ€è¦å®ç°9ç§ç¼–è¯‘å™¨ï¼Œä¾‹å¦‚: Pascalâ€”â€”&gt; x86ï¼ŒCâ€”â€”&gt; armç­‰ç­‰ã€‚</p>
<p>ä½¿ç”¨ä¸€ç§å…±äº«çš„ä¸­é—´è¡¨ç¤ºï¼Œå¯ä»¥å¤§å¤§å‡å°‘è¿™äº›ç»„åˆã€‚å¯¹äºæ¯ä¸€ç§æºè¯­è¨€ï¼Œç¼–å†™ä¸€ä¸ªå‰ç«¯ï¼Œå°†æºè¯­è¨€è§£æä¸ºä¸­é—´è¡¨ç¤ºï¼Œå¯¹äºæ¯ä¸ªç›®æ ‡æ¶æ„ï¼Œé’ˆå¯¹ä¸­é—´è¡¨ç¤ºï¼Œç¼–å†™ä¸€ä¸ªåç«¯ã€‚æ‰€ä»¥ï¼Œç°åœ¨åªéœ€è¦å®ç° 6 ä¸­å‰ç«¯ã€åç«¯ç»„åˆã€‚</p>
<p>è¿˜æœ‰ä¸€ä¸ªé‡è¦åŸå› ï¼Œè®©æˆ‘ä»¬ä½¿ç”¨ä¸­é—´è¡¨ç¤ºã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨ä¸­é—´è¡¨ç¤ºï¼Œå°†ä»£ç è½¬ä¸ºä¸€ç§å½¢å¼ï¼Œä½¿å¾—è¯­ä¹‰æ›´åŠ æ˜æ˜¾ã€‚</p>
<blockquote>
<p>If youâ€™ve ever wondered how GCC supports so many crazy languages and architectures, like Modula-3 on Motorola 68k, now you know. Language front ends target one of a handful of IRs, mainly GIMPLE and RTL. Target back ends like the one for 68k then take those IRs and produce native code.</p>
<p>å¦‚æœä½ æƒ³è¦çŸ¥é“ <a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>æ˜¯å¦‚ä½•æ”¯æŒè¿™ä¹ˆå¤šè¯­è¨€å’Œæ¶æ„çš„ï¼Œç°åœ¨ä½ çŸ¥é“åŸå› äº†ã€‚é’ˆå¯¹å‰ç«¯çš„å°‘é‡ä¸­é—´è¡¨ç¤ºï¼Œä¸»è¦æ˜¯ <a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a> å’Œ <a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">RTL</a>, ä¸åŒçš„ç›®æ ‡æ¶æ„ï¼Œè·å–ä¸­é—´è¡¨ç¤ºï¼Œç”Ÿæˆå¯¹åº”çš„æœºå™¨ä»£ç ã€‚</p>
</blockquote>
<h3 id="15-optimization"><a class="header" href="#15-optimization">1.5 Optimization</a></h3>
<p>ä¼˜åŒ–</p>
<p>Once we understand what the userâ€™s program means, we are free to swap it out with a different program that has the same semantics but implements them more efficientlyâ€”we can optimize it.</p>
<p>A simple example is constant folding: if some expression always evaluates to the exact same value, we can do the evaluation at compile time and replace the code for the expression with its result. If the user typed in this:</p>
<pre><code>
pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);

</code></pre>
<p>we could do all of that arithmetic in the compiler and change the code to:</p>
<pre><code>pennyArea = 0.4417860938;
</code></pre>
<p>ä¸€æ—¦æˆ‘ä»¬ç†è§£äº†ç”¨æˆ·ç¨‹åºçš„å«ä¹‰ï¼Œæˆ‘ä»¬å°±å¯ä»¥è‡ªç”±çš„æŠŠç”¨æˆ·ç¨‹åºæ›¿æ¢ä¸ºå…·æœ‰ç›¸åŒè¯­ä¹‰ï¼Œä½†æ˜¯æ›´åŠ é«˜æ•ˆçš„å®ç°çš„å¦å¤–ä¸€ç§ç¨‹åºã€‚æˆ‘ä»¬å¯ä»¥è¿›è¡Œä¼˜åŒ–ã€‚</p>
<p>ä¸€ä¸ªç®€å•ç¤ºä¾‹æ˜¯å¸¸æ•°è®¡ç®—ã€‚å¦‚æœæŸä¸ªè¡¨è¾¾å¼çš„è®¡ç®—ç»“æœæ€»æ˜¯ç›¸åŒï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨ç¼–è¯‘æ—¶å€™è®¡ç®—è¯¥è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä½¿ç”¨è¡¨è¾¾å¼è®¡ç®—ç»“æœä»£æ›¿è¯¥è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼Œå®¢æˆ·è¾“å…¥</p>
<pre><code>pennyArea = 3.14159 * (0.75 / 2) * (0.75 / 2);
</code></pre>
<p>æˆ‘ä»¬å¯ä»¥åœ¨ç¼–è¯‘æ—¶å€™è®¡ç®—å‡ºå€¼ï¼Œå°†ä»£ç ä¿®æ”¹ä¸º</p>
<pre><code>pennyArea = 0.4417860938;
</code></pre>
<p>Optimization is a huge part of the programming language business.  Many language hackers spend their entire careers here, squeezing every drop of performance they can out of their compilers to get their benchmarks a fraction of a percent faster. It can become a sort of obsession.</p>
<p>Weâ€™re mostly going to hop over that rathole in this book. Many successful languages have surprisingly few compile-time optimizations. For example, Lua and CPython generate relatively unoptimized code, and focus most of their performance effort on the runtime.</p>
<p>ä¼˜åŒ–æ˜¯ç¼–ç¨‹è¯­è¨€çš„ä¸€ä¸ªé‡è¦ç»„æˆéƒ¨åˆ†ï¼Œè®¸å¤šè¯­è¨€é«˜æ‰‹åœ¨æ•´ä¸ªèŒä¸šç”Ÿæ¶¯éƒ½åœ¨ä¸æ–­ä¼˜åŒ–ï¼Œä»ç¼–è¯‘å™¨ä¸­æ¦¨å–æ¯ä¸€ç‚¹æ€§èƒ½ï¼Œæœ€ç»ˆä½¿å¾—ä»–ä»¬çš„ç¼–è¯‘å™¨ï¼ŒåŸºå‡†æµ‹è¯•ç»“æœæé«˜äº†0.5%ï¼Œä¼˜åŒ–æ˜¯ä¸€ä¸ªä¸æ–­è¿›è¡Œçš„è¿‡ç¨‹ã€‚</p>
<p>æœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬ä¼šè·³è¿‡ä¼˜åŒ–è¿™ä¸ªæ­¥éª¤ï¼Œæœ‰å¾ˆå¤šæˆåŠŸè¯­è¨€ï¼Œä¹Ÿå¾ˆå°‘ä½¿ç”¨ç¼–è¯‘æ—¶ä¼˜åŒ–ã€‚ä¸¾ä¾‹ï¼ŒLua å’Œ CPythonç”Ÿæˆç›¸å¯¹æœªä¼˜åŒ–çš„ä»£ç ï¼Œå°†å¤§éƒ¨åˆ†ä¼˜åŒ–æ”¾åœ¨è¿è¡Œæ—¶ã€‚</p>
<blockquote>
<p>If you canâ€™t resist poking your foot into that hole, some keywords to get you started are â€œconstant propagationâ€, â€œcommon subexpression eliminationâ€, â€œloop invariant code motionâ€, â€œglobal value numberingâ€, â€œstrength reductionâ€, â€œscalar replacement of aggregatesâ€, â€œdead code eliminationâ€, and â€œloop unrollingâ€.</p>
<p>å¦‚æœä½ å¿ä¸ä½æƒ³è¦æ¢ç´¢ä¼˜åŒ–è¿™ä¸ªé¢†åŸŸï¼Œé‚£ä¹ˆä½ å¯ä»¥ä»ä¸€äº›æœ¯è¯­å…¥æ‰‹ï¼Œä¾‹å¦‚: &quot;æ’å®šä¼ æ’­&quot;, &quot;å…¬å…±å­è¡¨è¾¾å¼æ¶ˆé™¤&quot;, &quot;å¾ªç¯ä¸å˜ä»£ç &quot;, &quot;å…¨å±€å€¼ç¼–å·&quot;, &quot;å¼ºåº¦é™ä½&quot;, &quot;èšåˆæ ‡é‡ä»£æ›¿&quot;, &quot;åƒµå°¸ä»£ç æ¶ˆé™¤&quot;, &quot;å¾ªç¯å±•å¼€&quot;ã€‚</p>
</blockquote>
<h3 id="16-code-generation"><a class="header" href="#16-code-generation">1.6 Code generation</a></h3>
<p>ä»£ç ç”Ÿæˆ</p>
<p>We have applied all of the optimizations we can think of to the userâ€™s program. The last step is converting it to a form the machine can actually run. In other words, generating code (or code gen), where â€œcodeâ€ here usually refers to the kind of primitive assembly-like instructions a CPU runs and not the kind of â€œsource codeâ€ a human might want to read.</p>
<p>Finally, we are in the back end, descending the other side of the mountain. From here on out, our representation of the code becomes more and more primitive, like evolution run in reverse, as we get closer to something our simple-minded machine can understand.</p>
<p>We have a decision to make. Do we generate instructions for a real CPU or a virtual one? If we generate real machine code, we get an executable that the OS can load directly onto the chip. Native code is lightning fast, but generating it is a lot of work. Native code is lightning fast, but generating it is a lot of work. </p>
<p>æˆ‘ä»¬å·²ç»å°†èƒ½å¤Ÿæƒ³åˆ°çš„æ‰€æœ‰ä¼˜åŒ–ï¼Œåº”ç”¨äºç”¨æˆ·ä»£ç ä¸­ã€‚æœ€åä¸€æ­¥æ˜¯ï¼Œå°†ä»£ç è½¬æ¢ä¸ºæœºå™¨å¯ä»¥å®é™…è¿è¡Œçš„å½¢å¼ã€‚æ¢å¥è¯è¯´ï¼Œä»£ç ç”Ÿæˆï¼ˆæˆ–è€…ç”Ÿæˆä»£ç ï¼‰ï¼Œè¿™é‡Œçš„ä»£ç æ˜¯æŒ‡ï¼ŒCPUç›´æ¥è¿è¡Œçš„ç±»ä¼¼äºåŸå§‹æ±‡ç¼–çš„æŒ‡ä»¤ï¼Œè€Œä¸ç”¨äººä»¬å¯ä»¥ç›´æ¥é˜…è¯»çš„æºä»£ç ã€‚</p>
<p>æœ€åï¼Œæˆ‘ä»¬å¤„äºåç«¯ï¼Œä»å±±çš„å¦ä¸€ç«¯å¾€ä¸‹èµ°ã€‚ä»ç°åœ¨å¼€å§‹ï¼Œæˆ‘ä»¬å¯¹äºä»£ç çš„è¡¨ç¤ºè¶Šæ¥è¶ŠåŸå§‹ï¼Œå’Œä¸Šå±±æ–¹å‘ç›¸åï¼Œæˆ‘ä»¬å¸Œæœ›ä»£ç å˜ä¸ºæœºå™¨å¯ä»¥ç›´æ¥è¿è¡Œçš„å½¢å¼ã€‚</p>
<p>æˆ‘ä»¬éœ€è¦å†³å®šï¼Œæ˜¯ç”ŸæˆçœŸå®çš„CPUæŒ‡ä»¤ï¼Œè¿˜æ˜¯ç”Ÿæˆè™šæ‹Ÿçš„æŒ‡ä»¤ã€‚å¦‚æœæˆ‘ä»¬ç”ŸæˆçœŸå®çš„æœºå™¨ä»£ç ï¼Œæˆ‘ä»¬ä¼šå¾—åˆ°ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ“ä½œç³»ç»Ÿå¯ä»¥ç›´æ¥åŠ è½½åˆ°èŠ¯ç‰‡ä¸­ã€‚åŸç”Ÿæœ¬æœºä»£ç è¿è¡Œé€Ÿåº¦éå¸¸å¿«ï¼Œä½†æ˜¯ï¼Œç”ŸæˆçœŸå®çš„ CPUæŒ‡ä»¤éœ€è¦å¤§é‡çš„å·¥ä½œã€‚ç°åœ¨çš„æ¶æ„ï¼Œæœ‰æˆå †çš„æŒ‡ä»¤é›†ï¼Œå¤æ‚çš„ç®¡é“ï¼Œå’Œèƒ½å¤Ÿå¡æ»¡747é£æœºçš„å†å²é—ç•™åŒ…è¢±ã€‚</p>
<blockquote>
<p>For example, the AAD (â€œASCII Adjust AX Before Divisionâ€) instruction lets you perform division, which sounds useful. Except that instruction takes, as operands, two binary-coded decimal digits packed into a single 16-bit register. When was the last time you needed BCD on a 16-bit machine</p>
<p>ä¸¾ä¾‹ï¼ŒAADæŒ‡ä»¤å¯ä»¥æ‰§è¡Œé™¤æ³•è¿ç®—ï¼Œè¿™å¬èµ·æ¥éå¸¸æœ‰ç”¨ã€‚é™¤æ­¤ä¹‹å¤–ï¼ŒADDæŒ‡ä»¤ä¼šå°†ä¸¤ä¸ªäºŒè¿›åˆ¶ç¼–ç é¢åè¿›åˆ¶æ•°å­—ä½œä¸ºæ“ä½œæ•°å‹ç¼©åˆ°å•ä¸ª16ä½å¯„å­˜å™¨ä¸Šï¼Œä¸Šä¸€æ¬¡ï¼Œä½ éœ€è¦BCDï¼Œå¹¶ä¸”åœ¨16ä½æœºå™¨ï¼Œæ˜¯ä»€ä¹ˆæ—¶å€™å‘¢ï¼Ÿ</p>
</blockquote>
<p>Speaking the chipâ€™s language also means your compiler is tied to a specific architecture. If your compiler targets x86 machine code, itâ€™s not going to run on an ARM device.  All the way back in the â€™60s, during the Cambrian explosion of computer architectures, that lack of portability was a real obstacle.</p>
<p>To get around that, hackers like Martin Richards and Niklaus Wirth, of BCPL and Pascal fame, respectively, made their compilers produce virtual machine code. Instead of instructions for some real chip, they produced code for a hypothetical, idealized machine. Wirth called this p-code for portable, but today, we generally call it bytecode because each instruction is often a single byte long.</p>
<p>These synthetic instructions are designed to map a little more closely to the languageâ€™s semantics, and not be so tied to the peculiarities of any one computer architecture and its accumulated historical cruft. You can think of it like a dense, binary encoding of the languageâ€™s low-level operations.</p>
<p>è½¬æ¢ä¸ºèŠ¯ç‰‡ç‰¹å®šè¯­è¨€ï¼Œæ„å‘³ç€ä½ çš„ç¼–è¯‘å™¨å’Œç‰¹å®šæ¶æ„ç›¸å…³è”ã€‚å¦‚æœç¼–è¯‘å™¨ä»¥x86 æœºå™¨ä»£ç ä¸ºç›®æ ‡ï¼Œé‚£ä¹ˆå®ƒå°†æ— æ³•åœ¨armæ¶æ„æœºå™¨ä¸Šè¿è¡Œã€‚ä¸€ç›´è¿½æº¯åˆ°ä¸Šä¸–çºª60å¹´ä»£ï¼Œåœ¨å½“æ—¶çš„è®¡ç®—æœºä½“ç³»ç»“æ„çˆ†ç‚¸æ—¶æœŸï¼Œç¼ºä¹å¯ç§»æ¤æ€§çš„ç¼–è¯‘å™¨æ˜¯ä¸€ä¸ªçœŸæ­£çš„ç¼ºç‚¹ã€‚</p>
<p>ä¸ºäº†é¿å…è¿™ç§é—®é¢˜ï¼Œç¼–ç¨‹é«˜æ‰‹ï¼Œä¾‹å¦‚ï¼šBCPL è¯­è¨€çš„å‘æ˜è€…<a href="https://en.wikipedia.org/wiki/Martin_Richards_(computer_scientist)">Martin Richards</a> å’Œ Pascalè¯­è¨€çš„ä¸»è¦å¼€å‘è€…<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a> ,ä¸çº¦è€ŒåŒçš„ï¼Œè®©ä»–ä»¬å®ç°çš„ç¼–è¯‘å™¨æœ€ç»ˆç”Ÿæˆè™šæ‹Ÿæœºä»£ç ã€‚ä»–ä»¬ä¸ºä¸€ä¸ªå‡æƒ³çš„ã€ç†æƒ³åŒ–çš„æœºå™¨ç”Ÿæˆä»£ç ï¼Œè€Œä¸æ˜¯ä¸ºäº†ä¸€äº›çœŸå®çš„èŠ¯ç‰‡ç”ŸæˆæŒ‡ä»¤ã€‚<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>ç§°è¿™äº›ä»£ç ä¸ºPä»£ç ï¼Œå› ä¸ºå¯ç§»æ¤å•è¯çš„ç¼©å†™ï¼Œä½†æ˜¯ä»Šå¤©ï¼Œæˆ‘ä»¬é€šå¸¸ç§°ä¸ºå­—èŠ‚ç ï¼Œå› ä¸ºæ¯æ¡æŒ‡ä»¤é€šå¸¸åªæœ‰ä¸€ä¸ªå­—èŠ‚é•¿åº¦ã€‚</p>
<p>è¿™äº›åˆæˆæŒ‡ä»¤ï¼Œæ˜¯ä¸ºäº†æ›´åŠ æ¥è¿‘ä»£ç çš„è¯­ä¹‰ï¼Œè€Œä¸æ˜¯å› ä¸ºæ›´åŠ å…³è”é‚£äº›æ¶æ„æˆ–æ˜¯å…¶åçš„å†å²ã€‚æˆ‘ä»¬å¯ä»¥æƒ³è±¡å­—èŠ‚ç æ˜¯æ›´åŠ åº•å±‚çš„äºŒè¿›åˆ¶ç¼–ç ã€‚</p>
<blockquote>
<p>The basic principle here is that the farther down the pipeline you push the architecture-specific work, the more of the earlier phases you can share across architectures.</p>
<p>åŸºæœ¬çš„åŸåˆ™æ˜¯ï¼Œè¶Šæ™šæŠŠç¼–è¯‘å™¨å±€é™äºç‰¹å®šæ¶æ„ä¸Šï¼Œå°±å¯ä»¥è¶Šå¤šçš„äº«å—ä¸åŒæ¶æ„é—´ä»£ç å…±ç”¨ã€‚</p>
</blockquote>
<blockquote>
<p>There is a tension, though. Many optimizations, like register allocation and instruction selection, work best when they know the strengths and capabilities of a specific chip. Figuring out which parts of your compiler can be shared and which should be target-specific is an art.</p>
<p>ä¸è¿‡ï¼Œå­˜åœ¨ä¸€ç§å‡è¡¡ï¼Œè®¸å¤šä¼˜åŒ–ï¼Œä¾‹å¦‚ï¼šå¯„å­˜å™¨åˆ†é…å’ŒæŒ‡ä»¤é€‰æ‹©ï¼Œå½“ä½ äº†è§£ç‰¹å®šèŠ¯ç‰‡çš„ä¼˜ç‚¹å’Œèƒ½åŠ›æ—¶å€™ï¼Œä½¿ç”¨æ•ˆæœä¼šæ›´å¥½ã€‚ææ¸…æ¥šç¼–è¯‘å™¨å“ªäº›éƒ¨åˆ†å¯ä»¥å…±äº«ï¼Œå“ªäº›éƒ¨åˆ†åªé€‚ç”¨äºç‰¹å®šæ¶æ„ï¼Œæ˜¯ä¸€é—¨è‰ºæœ¯ã€‚</p>
</blockquote>
<h3 id="17-virtual-machine"><a class="header" href="#17-virtual-machine">1.7 Virtual machine</a></h3>
<p>è™šæ‹Ÿæœº</p>
<p>If your compiler produces bytecode, your work isnâ€™t over once thatâ€™s done. Since there is no chip that speaks that bytecode, itâ€™s your job to translate. Again, you have two options. You can write a little mini-compiler for each target architecture that converts the bytecode to native code for that machine. You still have to do work for each chip you support, but this last stage is pretty simple and you get to reuse the rest of the compiler pipeline across all of the machines you support. Youâ€™re basically using your bytecode as an intermediate representation.</p>
<p>Or you can write a virtual machine (VM), a program that emulates a hypothetical chip supporting your virtual architecture at runtime. Running bytecode in a VM is slower than translating it to native code ahead of time because every instruction must be simulated at runtime each time it executes. In return, you get simplicity and portability. Implement your VM in, say, C, and you can run your language on any platform that has a C compiler. This is how the second interpreter we build in this book works.</p>
<p>å¦‚æœä½ çš„ç¼–è¯‘å™¨ï¼Œæœ€ç»ˆäº§ç”Ÿå­—èŠ‚ç ï¼Œé‚£ä¹ˆï¼Œä½ çš„å·¥ä½œè¿˜æ²¡æœ‰ç»“æŸã€‚å¦‚æœä½ çš„å·¥ä½œæ˜¯ç¿»è¯‘çš„è¯ï¼Œé‚£ä¹ˆç°åœ¨æ²¡æœ‰èŠ¯ç‰‡å¯ä»¥ç›´æ¥æ‰§è¡Œå­—èŠ‚ç ã€‚åŒæ ·ï¼Œç°åœ¨ä½ æœ‰ä¸¤ä¸ªé€‰æ‹©ã€‚</p>
<p>ç¬¬ä¸€ä¸ªé€‰æ‹©æ˜¯ï¼Œä½ å¯ä»¥ä¸ºæ¯ä¸€ç§ç›®æ ‡æ¶æ„ç¼–å†™ä¸€ä¸ªå°å‹ç¼–è¯‘å™¨ï¼ŒæŠŠå­—èŠ‚ç è½¬æ¢ä¸ºæ¶æ„ä¸­æœºå™¨ä½¿ç”¨çš„æœºå™¨ç ã€‚æˆ‘ä»¬å¯ä»¥ä¸ºæ”¯æŒçš„æ¯ä¸€ç§èŠ¯ç‰‡ç¼–å†™å¯¹åº”çš„ç¼–è¯‘å™¨ï¼Œä½†æ˜¯æœ€åè¿™ä¸ªé˜¶æ®µéå¸¸ç®€å•ï¼Œä½ ä¹Ÿå¯ä»¥é‡å¤ä½¿ç”¨ç¼–è¯‘å™¨ä¹‹å‰çš„ä»£ç ã€‚æˆ‘ä»¬ä½¿ç”¨ç¼–è¯‘å™¨ç”Ÿæˆçš„å­—èŠ‚ç å½“ä½œä¸­é—´è¡¨ç¤ºã€‚</p>
<p>æˆ–è€…ï¼Œæˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€ä¸ªè™šæ‹Ÿæœºï¼Œä¸€ä¸ªåœ¨è¿è¡Œæ—¶å€™ï¼Œæ¨¡æ‹Ÿè™šæ„èŠ¯ç‰‡çš„ç¨‹åºã€‚åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œå­—èŠ‚ç æ¯”ç›´æ¥åœ¨æœ¬æœºè¿è¡Œæœºå™¨ç ï¼Œæ…¢ä¸€äº›ï¼Œå› ä¸ºè™šæ‹Ÿæœºæ¯æ¬¡è¿è¡ŒæŒ‡ä»¤ï¼Œéƒ½å¿…é¡»æ¨¡æ‹Ÿå®é™…æŒ‡ä»¤ã€‚ä½œä¸ºå›æŠ¥ï¼Œæˆ‘ä»¬è·å¾—äº†ç®€å•æ€§å’Œå¯ç§»æ¤æ€§ã€‚å‡è®¾ç”¨Cè¯­è¨€å®ç°è™šæ‹Ÿæœºï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨ä»»ä½•æœ‰Cç¼–è¯‘å™¨çš„æœºå™¨ä¸Šè¿è¡Œä»£ç ã€‚æœ¬ä¹¦ç¬¬äºŒéƒ¨åˆ†å®ç°çš„ç¼–è¯‘å™¨é‡‡ç”¨è¯¥åŸç†ã€‚</p>
<blockquote>
<p>The term â€œvirtual machineâ€ also refers to a different kind of abstraction. A system virtual machine emulates an entire hardware platform and operating system in software. This is how you can play Windows games on your Linux machine, and how cloud providers give customers the user experience of controlling their own â€œserverâ€ without needing to physically allocate separate computers for each user.</p>
<p>The kind of VMs weâ€™ll talk about in this book are language virtual machines or process virtual machines if you want to be unambiguous.</p>
<p>æœ¯è¯­è™šæ‹Ÿæœºæ˜¯ä¸€ç§æŠ½è±¡ã€‚ä¸€ä¸ªç³»ç»Ÿçº§åˆ«çš„è™šæ‹Ÿæœºï¼Œä¼šæ¨¡æ‹Ÿæ•´ä¸ªç¡¬ä»¶å¹³å°å’Œæ“ä½œç³»ç»Ÿã€‚è¿™å°±æ˜¯ï¼Œä½ å¯ä»¥åœ¨LinuxæœåŠ¡å™¨ä¸Šç©Windowsæ¸¸æˆçš„åŸå› ï¼Œè¿˜æœ‰ï¼Œè¿™ä¹Ÿæ˜¯äº‘æœåŠ¡å‚å•†ï¼Œä¸ºç”¨æˆ·åˆ†é…æŒ‡å®šçš„äº‘æœåŠ¡å™¨ï¼Œè€Œä¸éœ€è¦çœŸå®æä¾›å¯¹åº”çš„æœºå™¨çš„åŸå› ã€‚</p>
<p>ä½†æ˜¯ï¼Œæœ¬ä¹¦ä¸­æ¶‰åŠåˆ°çš„è™šæ‹Ÿæœºï¼Œåªæ˜¯è¯­è¨€è™šæ‹Ÿæœºæˆ–è€…è¿›ç¨‹è™šæ‹Ÿæœºï¼Œå¦‚æœä½ æƒ³è¦ä¸€ä¸ªå‡†ç¡®çš„æè¿°è¯ã€‚</p>
</blockquote>
<h3 id="18-runtime"><a class="header" href="#18-runtime">1.8 Runtime</a></h3>
<p>è¿è¡Œæ—¶</p>
<p>We have finally hammered the userâ€™s program into a form that we can execute. The last step is running it. If we compiled it to machine code, we simply tell the operating system to load the executable and off it goes. If we compiled it to bytecode, we need to start up the VM and load the program into that.</p>
<p>In both cases, for all but the basest of low-level languages, we usually need some services that our language provides while the program is running. For example, if the language automatically manages memory, we need a garbage collector going in order to reclaim unused bits. If our language supports â€œinstance ofâ€ tests so you can see what kind of object you have, then we need some representation to keep track of the type of each object during execution.</p>
<p>All of this stuff is going at runtime, so itâ€™s called, appropriately, the runtime. In a fully compiled language, the code implementing the runtime gets inserted directly into the resulting executable.  In, say, Go, each compiled application has its own copy of Goâ€™s runtime directly embedded in it. If the language is run inside an interpreter or VM, then the runtime lives there. This is how most implementations of languages like Java, Python, and JavaScript work.</p>
<p>æœ€ç»ˆï¼Œæˆ‘ä»¬ç»ˆäºæŠŠç”¨æˆ·ç¨‹åºï¼Œè½¬æ¢ä¸ºä¸€ç§å¯ä»¥æ‰§è¡Œçš„å½¢å¼ã€‚æœ€åä¸€æ­¥æ˜¯è¿è¡Œï¼Œå¦‚æœæˆ‘ä»¬æœ€åç¼–è¯‘ä¸ºæœºå™¨ç ï¼Œæˆ‘ä»¬åªéœ€è¦åŠ è½½å¯æ‰§è¡Œæ–‡ä»¶ï¼Œç„¶åè¿è¡Œã€‚å¦‚æœå°†å…¶ç¼–è¯‘ä¸ºå­—èŠ‚ç ï¼Œæˆ‘ä»¬éœ€è¦å¯åŠ¨è™šæ‹Ÿæœºï¼ŒæŠŠç¼–è¯‘çš„å­—èŠ‚ç åŠ è½½åˆ°è™šæ‹Ÿæœºä¸­ã€‚</p>
<p>åœ¨ä¸¤ç§åœºæ™¯ä¸‹ï¼Œé™¤äº†æœ€åŸºæœ¬çš„ä½å±‚è¯­è¨€ï¼Œå½“ç¨‹åºè¿è¡Œæ—¶ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æä¾›ä¸€äº›å…¶ä»–æœåŠ¡ã€‚ä¾‹å¦‚ï¼šå¦‚æœè¯­è¨€æ˜¯è‡ªåŠ¨ç®¡ç†å†…å­˜çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä¸€ä¸ªåƒåœ¾æ”¶é›†å™¨ï¼Œå›æ”¶ä¸å†ä½¿ç”¨çš„å†…å­˜ã€‚å¦‚æœæˆ‘ä»¬å®ç°çš„è¯­è¨€ï¼Œæ”¯æŒå®ä¾‹æµ‹è¯•ï¼Œä»¥ä¾¿äºè·å–å¯¹è±¡çš„å®é™…æ•°æ®ç±»å‹ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦ä¸€äº›åŠŸèƒ½ï¼Œè·Ÿè¸ªè¿è¡Œæ—¶å€™çš„å¯¹è±¡ã€‚</p>
<p>æ‰€æœ‰è¿™äº›éƒ½å‘ç”Ÿåœ¨ç¨‹åºè¿è¡Œæ—¶å€™ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ç§°å‘¼è¿™ä¸ªé˜¶æ®µä¸ºè¿è¡Œæ—¶ã€‚åœ¨ä¸€ä¸ªå®Œå…¨ç¼–è¯‘çš„è¯­è¨€ä¸­ï¼Œè¿è¡Œæ—¶ï¼Œä»£ç å°†ç›´æ¥æ’å…¥åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­ã€‚ä¸¾ä¾‹ï¼Œåœ¨goè¯­è¨€ä¸­ï¼Œæ¯ä¸ªç¼–è¯‘çš„åº”ç”¨ç¨‹åºéƒ½æœ‰è‡ªå·±çš„ goè¿è¡Œæ—¶å‰¯æœ¬ï¼Œç›´æ¥åµŒå…¥å…¶ä¸­ã€‚å¦‚æœè¯­è¨€åœ¨è§£é‡Šå™¨æˆ–è€…è™šæ‹Ÿæœºä¸­è¿è¡Œï¼Œé‚£ä¹ˆè¿è¡Œæ—¶å°±åœ¨å…¶ä¸­ã€‚è¿™ä¹Ÿæ˜¯ Java/Python/JavaScriptç­‰è¯­è¨€çš„è¿è¡Œå·¥ä½œæ–¹å¼ã€‚</p>
<h2 id="äºŒshortcuts-and-alternate-routes"><a class="header" href="#äºŒshortcuts-and-alternate-routes">äºŒã€Shortcuts and Alternate Routes</a></h2>
<p>å¿«æ·æ–¹å¼å’Œå¤‡é€‰è·¯å¾„</p>
<p>Thatâ€™s the long path covering every possible phase you might implement. Many languages do walk the entire route, but there are a few shortcuts and alternate paths.</p>
<p>è¿™ä¸€æ¡æ¼«é•¿çš„è·¯ï¼Œå¯èƒ½åŒ…å«ä½ çš„å®ç°çš„æ¯ä¸€ä¸ªé˜¶æ®µã€‚è®¸å¤šè¯­è¨€è´¯ç©¿äº†æ•´ä¸ªè¿‡ç¨‹ï¼Œä½†æ˜¯ä¹Ÿæœ‰ä¸€äº›è¯­è¨€ï¼Œä¼šåŒ…å«æ·å¾„å’Œå…¶ä»–å¤‡é€‰è·¯å¾„ã€‚</p>
<h3 id="21-single-pass-compilers"><a class="header" href="#21-single-pass-compilers">2.1 Single-pass compilers</a></h3>
<p>å•é€šé“ç¼–è¯‘å™¨</p>
<p>Some simple compilers interleave parsing, analysis, and code generation so that they produce output code directly in the parser, without ever allocating any syntax trees or other IRs. These single-pass compilers restrict the design of the language. You have no intermediate data structures to store global information about the program, and you donâ€™t revisit any previously parsed part of the code. That means as soon as you see some expression, you need to know enough to correctly compile it.</p>
<p>Pascal and C were designed around this limitation. At the time, memory was so precious that a compiler might not even be able to hold an entire source file in memory, much less the whole program. This is why Pascalâ€™s grammar requires type declarations to appear first in a block. Itâ€™s why in C you canâ€™t call a function above the code that defines it unless you have an explicit forward declaration that tells the compiler what it needs to know to generate code for a call to the later function.</p>
<p>ä¸€äº›ç®€å•çš„ç¼–è¯‘å™¨ï¼Œä¼šæŠŠè§£æé˜¶æ®µã€åˆ†æé˜¶æ®µã€ä»£ç ç”Ÿæˆé˜¶æ®µæ··æ‚åœ¨ä¸€èµ·ï¼Œå®ƒä»¬ç›´æ¥åœ¨è§£æè¿‡ç¨‹ç”Ÿæˆä»£ç ï¼Œè€Œä¸éœ€è¦ç”Ÿæˆè¯­æ³•æ ‘æˆ–è€…å…¶ä»–ä¸­é—´è¡¨ç¤ºã€‚è¿™äº›å•é€šé“ç¼–è¯‘å™¨é™åˆ¶äº†è¯­è¨€çš„è®¾è®¡ã€‚ä½ æ²¡æœ‰ä¸­é—´æ•°æ®ç»“æ„æ¥å­˜å‚¨æœ‰å…³ç¨‹åºçš„å…¨å±€ä¿¡æ¯ï¼Œä¹Ÿæ— æ³•é‡æ–°è®¿é—®ä»»ä½•ä¹‹å‰è§£æè¿‡çš„ä»£ç ã€‚è¿™æ„å‘³ç€ï¼Œä¸€æ—¦çœ‹åˆ°æŸä¸ªè¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦è¶³å¤Ÿçš„ä¿¡æ¯æ¥ï¼Œæ­£ç¡®çš„ç¼–è¯‘è¡¨è¾¾å¼ã€‚</p>
<p>Pascal å’Œ Cè¯­è¨€æ˜¯å›´ç»•ä¸Šé¢çš„é™åˆ¶è®¾è®¡çš„ã€‚å½“æ—¶ï¼Œå†…å­˜éå¸¸å®è´µï¼Œç¼–è¯‘å™¨ç”šè‡³æ— æ³•å°†æ•´ä¸ªæºæ–‡ä»¶æ”¾å…¥åˆ°å†…å­˜ä¸­ï¼Œæ›´ä¸ç”¨è¯´åœ¨å†…å­˜ä¸­ï¼Œä¿å­˜æ•´ä¸ªç¨‹åºäº†ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆPascalè¯­è¨€è¦æ±‚ç±»å‹å£°æ˜é¦–å…ˆå‡ºç°åœ¨ä»£ç å—ä¸­ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆåœ¨Cè¯­è¨€ä¸­ï¼Œé™¤éæœ‰ä¸€ä¸ªæ˜ç¡®çš„æ­£å‘å£°æ˜ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨ç”Ÿæˆè°ƒç”¨åé¢çš„å‡½æ•°æ‰€éœ€è¦çš„ä»£ç ï¼Œå¦åˆ™æ— æ³•åœ¨å‡½æ•°å®šä¹‰çš„ä½ç½®ä¸Šé¢ï¼Œè°ƒç”¨è¯¥å‡½æ•°ã€‚</p>
<blockquote>
<p>Syntax-directed translation is a structured technique for building these all-at-once compilers. You associate an action with each piece of the grammar, usually one that generates output code. Then, whenever the parser matches that chunk of syntax, it executes the action, building up the target code one rule at a time.</p>
<p>è¯­æ³•å®šå‘ç¿»è¯‘æ˜¯ä¸€ç§ç»“æ„åŒ–æŠ€æœ¯ï¼Œç”¨äºåŒæ—¶æ„å»ºè¿™äº›ç¼–è¯‘å™¨ï¼Œå°†æ¯ä¸€ä¸ªåŠ¨ä½œå’Œæ¯ä¸€ä¸ªè¯­æ³•ç‰‡æ®µç›¸å…³è”ï¼Œé€šå¸¸æ˜¯è¾“å‡ºä»£ç çš„è¯­æ³•ç‰‡æ®µã€‚ç„¶åï¼Œæ¯å½“è§£æå™¨åŒ¹é…è¯¥è¯­æ³•å—æ—¶å€™ï¼Œå®ƒä¼šæ‰§è¡Œæ“ä½œï¼Œä¸€æ¬¡å»ºç«‹ä¸€ä¸ªè§„åˆ™çš„ç›®æ ‡ä»£ç ã€‚</p>
</blockquote>
<h3 id="22-tree-walk-interpreters"><a class="header" href="#22-tree-walk-interpreters">2.2 Tree-walk interpreters</a></h3>
<p>æ ‘éå†è§£é‡Šå™¨</p>
<p>Some programming languages begin executing code right after parsing it to an AST (with maybe a bit of static analysis applied). To run the program, the interpreter traverses the syntax tree one branch and leaf at a time, evaluating each node as it goes.</p>
<p>This implementation style is common for student projects and little languages, but is not widely used for general-purpose languages since it tends to be slow. Some people use â€œinterpreterâ€ to mean only these kinds of implementations, but others define that word more generally, so Iâ€™ll use the inarguably explicit tree-walk interpreter to refer to these. Our first interpreter rolls this way.</p>
<p>è®¸å¤šçš„è¯­è¨€ï¼Œåœ¨è§£æé˜¶æ®µç”Ÿæˆäº†è¯­æ³•æ ‘åï¼Œå°±å¼€å§‹æ‰§è¡Œä»£ç ï¼ˆå¯èƒ½ä¼šä½¿ç”¨ä¸€äº›é™æ€åˆ†æï¼‰ã€‚ä¸ºäº†è¿è¡Œç¨‹åºï¼Œè§£é‡Šå™¨æ¯ä¸€æ¬¡éƒ½ä¼šéå†è¯­æ³•æ ‘çš„ä¸€ä¸ªåˆ†æ”¯å’Œå¶èŠ‚ç‚¹ï¼Œåœ¨æ¯ä¸€ä¸ªèŠ‚ç‚¹è¿è¡Œæ—¶å€™ï¼Œè¿›è¡Œè¯„ä¼°ã€‚</p>
<p>è¿™ç§å®ç°é£æ ¼ï¼Œåœ¨å­¦ç”Ÿä½œä¸šå’Œå°çš„è¯­è¨€ä¸­éå¸¸å¸¸è§ï¼Œä½†æ˜¯ï¼Œç”±äºè¿è¡Œé€Ÿåº¦æ¯”è¾ƒæ…¢ï¼Œæ²¡æœ‰å¹¿æ³›çš„åº”ç”¨äºé€šç”¨çš„è¯­è¨€ã€‚ä¸€äº›äººä½¿ç”¨è§£é‡Šå™¨ï¼Œè¡¨ç¤ºè¿™ç§ç±»å‹çš„å®ç°ï¼Œä½†æ˜¯ï¼Œå¦å¤–ä¸€äº›äººï¼Œä½¿ç”¨æ›´åŠ ä¸€èˆ¬çš„æœ¯è¯­æè¿°è¿™ç§å®ç°æ–¹å¼ï¼Œæœ¬ä¹¦ä¸­æˆ‘ä½¿ç”¨æ ‘éå†è§£é‡Šå™¨æ¥æè¿°è¿™ç§å®ç°ã€‚æˆ‘ä»¬ç¬¬ä¸€ä¸ªå®ç°Loxè¯­è¨€é‡‡ç”¨è¿™ç§å®ç°é£æ ¼ã€‚</p>
<blockquote>
<p>A notable exception is early versions of Ruby, which were tree walkers. At 1.9, the canonical implementation of Ruby switched from the original MRI (Matzâ€™s Ruby Interpreter) to Koichi Sasadaâ€™s YARV (Yet Another Ruby VM). YARV is a bytecode virtual machine.</p>
<p>ä¸€ä¸ªè‘—åçš„ä¾‹å­æ˜¯ï¼ŒRubyè¯­è¨€çš„æ—©æœŸç‰ˆæœ¬ï¼Œä½¿ç”¨äº†æ ‘éå†é£æ ¼çš„å®ç°æ–¹å¼ã€‚åœ¨1.9ç‰ˆæœ¬ï¼ŒRubyçš„å®ç°ä»æ—©æœŸçš„MRIå˜æ›´ä¸ºYARVï¼ŒYARVæ˜¯ä¸€ä¸ªå­—èŠ‚ç è™šæ‹Ÿæœºã€‚</p>
</blockquote>
<h3 id="23-transpilers"><a class="header" href="#23-transpilers">2.3 Transpilers</a></h3>
<p>è½¬æ¢æœº</p>
<p>Writing a complete back end for a language can be a lot of work. If you have some existing generic IR to target, you could bolt your front end onto that. Otherwise, it seems like youâ€™re stuck. But what if you treated some other source language as if it were an intermediate representation?</p>
<p>Writing a complete back end for a language can be a lot of work. If you have some existing generic IR to target, you could bolt your front end onto that. Otherwise, it seems like youâ€™re stuck. But what if you treated some other source language as if it were an intermediate representation?</p>
<p>You write a front end for your language. Then, in the back end, instead of doing all the work to lower the semantics to some primitive target language, you produce a string of valid source code for some other language thatâ€™s about as high level as yours. Then, you use the existing compilation tools for that language as your escape route off the mountain and down to something you can execute.</p>
<p>They used to call this a source-to-source compiler or a transcompiler. After the rise of languages that compile to JavaScript in order to run in the browser, theyâ€™ve affected the hipster sobriquet transpiler.</p>
<p>ä¸ºä¸€ç§è¯­è¨€ç¼–å†™ä¸€ä¸ªå®Œæ•´çš„åç«¯ï¼Œéœ€è¦å¾ˆå¤šçš„å·¥ä½œã€‚å¦‚æœä½ æœ‰ä¸€äº›ç°æœ‰çš„é€šç”¨åç«¯ç›®æ ‡ï¼Œé‚£ä¹ˆä½ å¯ä»¥æŠŠå‰ç«¯è®¾è®¡ä¸ºé€šç”¨åç«¯çš„åŒ¹é…å‰ç«¯ã€‚å¦åˆ™çš„è¯ï¼Œä½ ä¼¼ä¹å¡åœ¨è¿™é‡Œäº†ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ æŠŠå…¶ä»–çš„è¯­è¨€è§†ä¸ºä¸€ç§ä¸­é—´è¡¨ç¤ºï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥å¦‚ä½•åŒ¹é…ï¼Ÿ</p>
<p>ä½ ä¸ºè‡ªå·±çš„è¯­è¨€ç¼–å†™äº†å‰ç«¯ï¼Œç„¶åï¼Œåœ¨åç«¯ï¼Œä½ çš„æƒ³æ³•ä¸æ˜¯ï¼ŒæŠŠç”¨æˆ·ç¨‹åºçš„è¯­ä¹‰å˜æ›´ä¸ºåº•å±‚åŸå§‹çš„ç›®æ ‡è¯­è¨€ï¼Œè€Œæ˜¯æŠŠç”¨æˆ·è¯­ä¹‰è½¬æ¢ä¸ºä¸€ä¸ªæ›´é«˜çº§è¯­è¨€çš„æºä»£ç ã€‚ç„¶åï¼Œä½ å¯ä»¥ä½¿ç”¨è¿™ç§é«˜çº§è¯­è¨€çš„å·²ç»å­˜åœ¨çš„ç¼–è¯‘å™¨ï¼Œä½œä¸ºä¸‹å±±çš„å¤‡é€‰è·¯å¾„ã€‚</p>
<p>åœ¨ä»¥å‰ï¼Œè¿™ç§å®ç°æ–¹å¼è¢«ç§°ä¸ºæºä»£ç åˆ°æºä»£ç ç¼–è¯‘å™¨æˆ–è€… è½¬æ¢ç¼–è¯‘å™¨ï¼Œå½“å‡ºç°äº†ä¸€äº›è¯­è¨€ï¼Œä¸ºäº†èƒ½åœ¨æµè§ˆå™¨è¿è¡Œï¼Œï¼Œæœ€ç»ˆç¼–è¯‘ä¸ºJavaScriptåï¼Œå¤§å®¶æƒ³åˆ°äº†ä¸€ä¸ªæ–°çš„åç§° è½¬æ¢æœº æ¥æè¿°ã€‚</p>
<p>While the first transcompiler translated one assembly language to another, today, most transpilers work on higher-level languages. After the viral spread of UNIX to machines various and sundry, there began a long tradition of compilers that produced C as their output language. C compilers were available everywhere UNIX was and produced efficient code, so targeting C was a good way to get your language running on a lot of architectures.</p>
<p>Web browsers are the â€œmachinesâ€ of today, and their â€œmachine codeâ€ is JavaScript, so these days it seems almost every language out there has a compiler that targets JS since thatâ€™s the main way to get your code running in a browser.</p>
<p>The front endâ€”scanner and parserâ€”of a transpiler looks like other compilers. Then, if the source language is only a simple syntactic skin over the target language, it may skip analysis entirely and go straight to outputting the analogous syntax in the destination language.</p>
<p>If the two languages are more semantically different, youâ€™ll see more of the typical phases of a full compiler including analysis and possibly even optimization. Then, when it comes to code generation, instead of outputting some binary language like machine code, you produce a string of grammatically correct source (well, destination) code in the target language.</p>
<p>Either way, you then run that resulting code through the output languageâ€™s existing compilation pipeline, and youâ€™re good to go.</p>
<p>è™½ç„¶ç¬¬ä¸€ä¸ªè½¬æ¢æœºï¼ŒæŠŠä¸€ç§æ±‡ç¼–è¯­è¨€è½¬æ¢ä¸ºå¦å¤–ä¸€ç§æ±‡ç¼–è¯­è¨€ï¼Œä½†æ˜¯ç°åœ¨ï¼Œæˆ‘ä»¬å¸¸å¸¸æŠŠä¸€é—¨è¯­è¨€è½¬æ¢ä¸ºæ›´åŠ é«˜çº§çš„è¯­è¨€ã€‚å› ä¸ºUNIXçš„é£é¡ï¼Œç¼–è¯‘å™¨å¼€å§‹äº†ä¸€ä¸ªä¼ ç»Ÿï¼Œé‚£å°±æ˜¯æŠŠè½¬æ¢æœºè¾“å‡ºè¯­è¨€å˜ä¸º Cè¯­è¨€ã€‚Cè¯­è¨€ç¼–è¯‘å™¨ï¼Œå­˜åœ¨äºä»»æ„çš„UNIXç³»ç»Ÿä¸­ï¼Œæ”¯æŒæ›´å¤šçš„æ¶æ„ï¼Œå¹¶ä¸”Cç¼–è¯‘å™¨å¯ä»¥ç”Ÿæˆæ›´åŠ é«˜æ•ˆçš„ä»£ç ï¼Œå› æ­¤ï¼ŒæŠŠCè¯­è¨€ä½œä¸ºè¾“å‡ºç›®æ ‡ï¼Œæ˜¯ä¸€ä¸ªéå¸¸å¥½çš„æ–¹å‘ã€‚</p>
<p>ç°åœ¨ï¼Œwebæµè§ˆå™¨æ˜¯ä¸€ç§æ–°å‹æœºå™¨ï¼Œè¿™ç§æ–°æœºå™¨çš„è¿è¡Œä»£ç æ˜¯JavaScriptï¼Œæ‰€ä»¥ç°åœ¨å¾ˆå¤šè¯­è¨€éƒ½æœ‰ä¸€ä¸ªé’ˆå¯¹JSçš„ç¼–è¯‘å™¨ï¼Œæœ€ç»ˆè¾“å‡ºJSä»£ç ï¼Œè¿™æ ·å¯ä»¥è®©æ–°çš„è¯­è¨€è¿è¡Œåœ¨æµè§ˆå™¨ä¸­ã€‚<a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">è¯¦ç»†æ¸…å•</a></p>
<p>è½¬æ¢æœºçš„å‰ç«¯éƒ¨åˆ†ï¼Œæ‰«æé˜¶æ®µã€è§£æé˜¶æ®µï¼Œå’Œå…¶ä»–çš„ç¼–è¯‘å™¨ç›¸ä¼¼ï¼Œç„¶è€Œï¼Œå¦‚æœæ–°è¯­è¨€åªæ˜¯ç›®æ ‡è¯­è¨€çš„ä¸€ä¸ªç®€å•çš®è‚¤ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨å¯èƒ½ä¼šå®Œå…¨è·³è¿‡åˆ†æé˜¶æ®µï¼Œç›´æ¥è¾“å‡ºç›®æ ‡è¯­è¨€ã€‚</p>
<p>ä½†æ˜¯ï¼Œå¦‚æœè¿™ä¸¤ç§è¯­è¨€ï¼Œåœ¨è¯­ä¹‰ä¸Šéå¸¸ä¸ç›¸åŒï¼Œé‚£ä¹ˆï¼Œä½ å¯èƒ½ä¼šæ·»åŠ ä¸€äº›ä¼ ç»Ÿç¼–è¯‘å™¨çš„å…¶ä»–é˜¶æ®µï¼Œä¾‹å¦‚ï¼šåˆ†æé˜¶æ®µï¼Œä¼˜åŒ–é˜¶æ®µã€‚ä½†æ˜¯ï¼Œæœ€ç»ˆä»£ç ç”Ÿæˆé˜¶æ®µï¼Œæˆ‘ä»¬ä¸ä¼šç”Ÿæˆä¼ ç»Ÿçš„æœºå™¨ç æˆ–è€…å­—èŠ‚ç ï¼Œè€Œæ˜¯ç”Ÿæˆä¸€ä¸ªè¯­æ³•æ­£ç¡®çš„ç›®æ ‡è¯­è¨€å­—ç¬¦ä¸²ã€‚</p>
<p>æ— è®ºå¦‚ä½•ï¼Œä½ éƒ½å¯ä»¥åœ¨ç¼–è¯‘åï¼Œè·å–åˆ°ç›®æ ‡è¯­è¨€çš„æºä»£ç ï¼Œç„¶åé€šè¿‡ç›®æ ‡è¯­è¨€çš„ç¼–è¯‘å™¨ï¼Œå¼€å§‹è¿è¡Œæ–°è¯­è¨€ã€‚</p>
<blockquote>
<p>The first transcompiler, XLT86, translated 8080 assembly into 8086 assembly. That might seem straightforward, but keep in mind the 8080 was an 8-bit chip and the 8086 a 16-bit chip that could use each register as a pair of 8-bit ones. XLT86 did data flow analysis to track register usage in the source program and then efficiently map it to the register set of the 8086.</p>
<p>It was written by Gary Kildall, a tragic hero of computer science if there ever was one. One of the first people to recognize the promise of microcomputers, he created PL/M and CP/M, the first high-level language and OS for them.</p>
<p>He was a sea captain, business owner, licensed pilot, and motorcyclist. A TV host with the Kris Kristofferson-esque look sported by dashing bearded dudes in the â€™80s. He took on Bill Gates and, like many, lost, before meeting his end in a biker bar under mysterious circumstances. He died too young, but sure as hell lived before he did.</p>
<p>ç¬¬ä¸€ä¸ªè½¬æ¢æœºï¼ŒXLT86ï¼ŒæŠŠ8080 æ±‡ç¼–è½¬æ¢ä¸º8086æ±‡ç¼–ï¼Œè¿™çœ‹èµ·æ¥ä¼¼ä¹å¾ˆç®€å•ï¼Œä½†æ˜¯ï¼Œè¯·æ³¨æ„ï¼Œ8080æ˜¯ä¸€ä¸ª8ä½èŠ¯ç‰‡ï¼Œè€Œ8086æ˜¯ä¸€ä¸ª16ä½èŠ¯ç‰‡ï¼Œå¯ä»¥å°†8086çš„å¯„å­˜å™¨ï¼Œä½œä¸º8080çš„ä¸€å¯¹å¯„å­˜å™¨ä½¿ç”¨ï¼ŒXLT86è¿›è¡Œäº†æ•°æ®æµåˆ†æï¼Œç”¨äºè·Ÿè¸ªæºç¨‹åºä¸­çš„å¯„å­˜å™¨ä½¿ç”¨ï¼Œç„¶åï¼Œæœ‰æ•ˆçš„æŠŠè¿™äº›å¯„å­˜å™¨ï¼Œæ˜ å°„ä¸º8086çš„å¯„å­˜å™¨é›†ã€‚</p>
<p>XLT86 æ˜¯ç”±Gary KIldallå®ç°çš„ï¼Œä»–æ˜¯è®¡ç®—æœºç§‘å­¦é¢†åŸŸçš„ä¸€ä¸ªæ‚²å‰§äººç‰©ï¼Œä½œä¸ºæœ€æ—©è®¤è¯†åˆ°å¾®å‹è®¡ç®—æœºå‰æ™¯çš„äººä¹‹ä¸€ï¼Œä»–å¼€å‘äº†PL/M å’Œ CP/Mï¼Œè€ŒCP/Mæ˜¯ç¬¬ä¸€ç§å’Œæ“ä½œç³»ç»Ÿäº¤äº’çš„é«˜çº§è¯­è¨€ã€‚</p>
</blockquote>
<blockquote>
<p>JS used to be the only way to execute code in a browser. Thanks to WebAssembly, compilers now have a second, lower-level language they can target that runs on the web.</p>
<p>JSæ›¾ç»æ˜¯æµè§ˆå™¨ä¸­å”¯ä¸€çš„è¿è¡Œè¯­è¨€ï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬å¤šäº†ä¸€ç§é€‰æ‹© <a href="https://webassembly.org/">WebAssembly</a>, ç¼–è¯‘å™¨ç°åœ¨æ‹¥æœ‰äº†ç¬¬äºŒç§å¯ä»¥ç›´æ¥åœ¨æµè§ˆå™¨è¿è¡Œçš„è¯­è¨€ã€‚</p>
</blockquote>
<h3 id="24-just-in-time-compilation"><a class="header" href="#24-just-in-time-compilation">2.4 Just-in-time compilation</a></h3>
<p>å³æ—¶ç¼–è¯‘</p>
<p>This last one is less a shortcut and more a dangerous alpine scramble best reserved for experts. The fastest way to execute code is by compiling it to machine code, but you might not know what architecture your end userâ€™s machine supports. What to do?</p>
<p>You can do the same thing that the HotSpot Java Virtual Machine (JVM), Microsoftâ€™s Common Language Runtime (CLR), and most JavaScript interpreters do. On the end userâ€™s machine, when the program is loadedâ€”either from source in the case of JS, or platform-independent bytecode for the JVM and CLRâ€”you compile it to native code for the architecture their computer supports. Naturally enough, this is called just-in-time compilation. Most hackers just say â€œJITâ€, pronounced like it rhymes with â€œfitâ€.</p>
<p>The most sophisticated JITs insert profiling hooks into the generated code to see which regions are most performance critical and what kind of data is flowing through them. Then, over time, they will automatically recompile those hot spots with more advanced optimizations.</p>
<p>æœ€åä¸€ä¸ªä¸æ˜¯æ·å¾„ï¼Œè€Œæ˜¯å±é™©çš„é«˜å±±æ”€å²©ï¼Œæœ€å¥½ç•™ç»™ä¸“å®¶ã€‚æœ€å¿«çš„ä»£ç æ‰§è¡Œé€Ÿåº¦ï¼Œè‚¯å®šæ˜¯ç¿»è¯‘ä¸ºå…·ä½“çš„æœºå™¨ç ï¼Œä½†æ˜¯ï¼Œç¼–è¯‘é˜¶æ®µï¼Œä½ å¯èƒ½ä¸çŸ¥é“ç”¨æˆ·çš„æœºå™¨æ˜¯ä»€ä¹ˆæ¶æ„ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ</p>
<p>ä½ å¯ä»¥å€Ÿé‰´JVMï¼ˆJavaè¯­è¨€è™šæ‹Ÿæœºï¼‰ï¼ŒCLRï¼ˆå¾®è½¯çš„é€šç”¨è¯­è¨€è¿è¡Œåº“ï¼‰ï¼Œè¿˜æœ‰å¤§å¤šæ•°JSç¼–è¯‘å™¨åšçš„ï¼Œåœ¨ç”¨æˆ·çš„æœºå™¨ä¸Šï¼Œå½“ç¨‹åºåŠ è½½æ—¶å€™ï¼Œæ— è®ºæ˜¯ä»æºä»£ç ï¼Œè¿˜æ˜¯åœ¨JVM/CLRä¸­åŠ è½½å­—èŠ‚ç ï¼Œä½ å¯ä»¥å°†å…¶ç¼–è¯‘ä¸ºæœ¬æœºçš„æœºå™¨ç ã€‚å¾ˆè‡ªç„¶çš„ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºå³æ—¶ç¼–è¯‘ã€‚å¤§å¤šæ•°ç¼–ç¨‹é«˜æ‰‹ç§°è¿™ç§å®ç°ä¸ºJITï¼Œå‘éŸ³ç±»ä¼¼fitã€‚</p>
<p>æœ€å¤æ‚çš„JITï¼Œä¼šåœ¨ç”Ÿæˆä»£ç ä¸­æ’å…¥ä¸€äº›æ€§èƒ½åˆ†æä»£ç ï¼ŒæŸ¥çœ‹å“ªäº›ä»£ç å—ã€å“ªäº›æ•°æ®ç»“æ„å¯¹äºè¿è¡Œæ€§èƒ½å½±å“æœ€å¤§ã€‚ç„¶åï¼Œéšç€æ—¶é—´ç´¯ç§¯ï¼ŒJITå°†è‡ªåŠ¨ä½¿ç”¨æ›´é«˜çº§çš„ä¼˜åŒ–æ–¹å¼ï¼Œé‡æ–°ç¼–è¯‘çƒ­ç‚¹ä»£ç ã€‚</p>
<blockquote>
<p>This is, of course, exactly where the HotSpot JVM gets its name.</p>
<p>å½“ç„¶ï¼Œè¿™ä¹Ÿæ˜¯JVMçš„ä¸€ç§å®ç°ï¼ŒHotSpot JVMçš„åç§°æ¥æºã€‚</p>
</blockquote>
<h2 id="ä¸‰compilers-and-interpreters"><a class="header" href="#ä¸‰compilers-and-interpreters">ä¸‰ã€Compilers and Interpreters</a></h2>
<p>ç¼–è¯‘å™¨å’Œè§£é‡Šå™¨</p>
<p>Now that Iâ€™ve stuffed your head with a dictionaryâ€™s worth of programming language jargon, we can finally address a question thatâ€™s plagued coders since time immemorial: Whatâ€™s the difference between a compiler and an interpreter?</p>
<p>It turns out this is like asking the difference between a fruit and a vegetable. That seems like a binary either-or choice, but actually â€œfruitâ€ is a botanical term and â€œvegetableâ€ is culinary. One does not strictly imply the negation of the other. There are fruits that arenâ€™t vegetables (apples) and vegetables that arenâ€™t fruits (carrots), but also edible plants that are both fruits and vegetables, like tomatoes.</p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å¤§è„‘ä¸­å·²ç»å¡æ»¡äº†å„ç§ç¼–è¯‘æœ¯è¯­ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è§£å†³ä¸€ä¸ªè‡ªå¤ä»¥æ¥å°±å›°æ‰°ç€ç¨‹åºå‘˜çš„é—®é¢˜ï¼Œç¼–è¯‘å™¨å’Œè§£é‡Šå™¨æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ</p>
<p>å®é™…ä¸Šï¼Œè¿™ä¸ªé—®é¢˜å¯ä»¥ç±»æ¯”ä¸ºï¼Œæ°´æœå’Œè”¬èœæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿè¿™ä¸ªç­”æ¡ˆçœ‹èµ·æ¥æ˜¯ä¸€ä¸ªäºŒé€‰ä¸€é—®é¢˜ï¼Œä½†æ˜¯å®é™…ä¸Šï¼Œæ°´æœæ˜¯ä¸€ä¸ªæ¤ç‰©å­¦æœ¯è¯­ï¼Œè”¬èœåˆ™æ˜¯ä¸€ä¸ªçƒ¹é¥ªç”¨è¯­ï¼Œä¸€ä¸ªä¸œè¥¿æ˜¯æ°´æœå¹¶ä¸ä»£è¡¨å®ƒä¸å¯ä»¥æ˜¯è”¬èœï¼Œç°å®ç”Ÿæ´»ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°æŸäº›æ°´æœï¼Œä¸æ˜¯è”¬èœï¼Œä¾‹å¦‚ï¼šè‹¹æœï¼›ä¹Ÿå¯ä»¥æ‰¾åˆ°æŸäº›è”¬èœï¼Œä¸å±äºæ°´æœï¼Œä¾‹å¦‚ï¼šèƒ¡èåœï¼›ä½†æ˜¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥æ‰¾åˆ°ï¼ŒæŸäº›ä¸œè¥¿ï¼Œå³æ˜¯æ°´æœï¼Œä¹Ÿæ˜¯è”¬èœï¼Œä¾‹å¦‚ï¼šè¥¿çº¢æŸ¿ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/plants.png?raw=true" alt="plants" /></p>
<p>So, back to languages:</p>
<ul>
<li>
<p>Compiling is an implementation technique that involves translating a source language to some otherâ€”usually lower-levelâ€”form. When you generate bytecode or machine code, you are compiling. When you transpile to another high-level language, you are compiling too.</p>
</li>
<li>
<p>When we say a language implementation â€œis a compilerâ€, we mean it translates source code to some other form but doesnâ€™t execute it. The user has to take the resulting output and run it themselves.</p>
</li>
<li>
<p>Conversely, when we say an implementation â€œis an interpreterâ€, we mean it takes in source code and executes it immediately. It runs programs â€œfrom sourceâ€.</p>
</li>
</ul>
<p>é‚£ä¹ˆï¼Œè¿”å›åˆ°è¯­è¨€éƒ¨åˆ†ï¼Œ</p>
<ul>
<li>
<p>ç¼–è¯‘æ˜¯ä¸€ç§å®ç°æŠ€æœ¯ï¼Œé€šå¸¸æ˜¯å°†æºè¯­è¨€è½¬æ¢ä¸ºæ›´åŠ ä½çº§åˆ«çš„å½¢å¼ï¼Œå½“ä½ æŠŠä¸€é—¨è¯­è¨€ç¼–è¯‘ä¸ºå­—èŠ‚ç æˆ–è€…æœºå™¨ç æ—¶å€™ï¼Œä½ ä½¿ç”¨äº†ç¼–è¯‘æŠ€æœ¯ï¼Œå½“ä½ è½¬æ¢ä¸ºå¦å¤–ä¸€ç§é«˜çº§è¯­è¨€æ—¶å€™ï¼Œä½ ä¹Ÿåœ¨ä½¿ç”¨ç¼–è¯‘ã€‚</p>
</li>
<li>
<p>å½“æˆ‘ä»¬è¯´å®ç°äº†ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œæˆ‘ä»¬çš„æ„æ€æ˜¯ï¼Œå°†æºè¯­è¨€è½¬æ¢ä¸ºå…¶ä»–å½¢å¼ï¼Œä½†æ˜¯å¹¶ä¸æ‰§è¡Œï¼Œç”¨æˆ·éœ€è¦è·å–åˆ°ç¼–è¯‘ç»“æœï¼Œç„¶åå†è¿è¡Œã€‚</p>
</li>
<li>
<p>å¯¹åº”çš„ï¼Œå½“æˆ‘ä»¬è¯´å®ç°äº†ä¸€ä¸ªè§£é‡Šå™¨ï¼Œæˆ‘ä»¬çš„æ„æ€æ˜¯ï¼Œå¯ä»¥ç›´æ¥æ‰§è¡Œæºä»£ç ï¼Œçœ‹èµ·æ¥ï¼Œæˆ‘ä»¬å¥½åƒæ˜¯ç›´æ¥ä»æºè¯­è¨€è¿è¡Œã€‚</p>
</li>
</ul>
<p>Like apples and oranges, some implementations are clearly compilers and not interpreters. GCC and Clang take your C code and compile it to machine code. An end user runs that executable directly and may never even know which tool was used to compile it. So those are compilers for C.</p>
<p>In older versions of Matzâ€™s canonical implementation of Ruby, the user ran Ruby from source. The implementation parsed it and executed it directly by traversing the syntax tree. No other translation occurred, either internally or in any user-visible form. So this was definitely an interpreter for Ruby.</p>
<blockquote>
<p>Peanuts (which are not even nuts) and cereals like wheat are actually fruit, but I got this drawing wrong. What can I say, Iâ€™m a software engineer, not a botanist. I should probably erase the little peanut guy, but heâ€™s so cute that I canâ€™t bear to.</p>
<p>Now pine nuts, on the other hand, are plant-based foods that are neither fruits nor vegetables. At least as far as I can tell.</p>
</blockquote>
<p>åƒè‹¹æœå’Œæ©˜å­ä¸€æ ·ï¼Œå®ƒä»¬æ˜¯æ°´æœä½†ä¸æ˜¯è”¬èœï¼Œæœ‰ä¸€äº›å®ç°ï¼Œæ˜¯ç¼–è¯‘å™¨ï¼Œè€Œä¸æ˜¯è§£é‡Šå™¨ã€‚GCCå’ŒClang æ¥æ”¶åŸå§‹çš„Cè¯­è¨€ç¨‹åºï¼Œæœ€ç»ˆç¼–è¯‘ä¸ºæœºå™¨ç ã€‚ç”¨æˆ·æœ€ç»ˆè¿è¡Œå¯æ‰§è¡Œæ–‡ä»¶ï¼Œè€Œä¸éœ€è¦çŸ¥é“å…·ä½“ä½¿ç”¨äº†å“ªä¸ªç¼–è¯‘å™¨ï¼Œå®ƒä»¬éƒ½æ˜¯Cè¯­è¨€ç¼–è¯‘å™¨ã€‚</p>
<p>Rubyçš„è€ç‰ˆæœ¬ä¸­ï¼Œç”¨æˆ·å¯ä»¥ç›´æ¥ä»Rubyæºç è¿è¡Œã€‚Rubyè§£é‡Šå™¨ç›´æ¥è§£ææºç¨‹åºï¼Œç”Ÿæˆè¯­æ³•æ ‘ï¼Œç„¶åï¼Œéå†è¯­æ³•æ ‘ï¼Œç›´æ¥æ‰§è¡Œï¼Œæ— è®ºå¤„äºç”¨æˆ·è§’åº¦ï¼Œè¿˜æ˜¯å®é™…å†…éƒ¨æœºåˆ¶ï¼Œéƒ½æ²¡æœ‰å…¶ä»–çš„è½¬æ¢è¿‡ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šè¿™ç§å®ç°ä¸ºè§£é‡Šå™¨ã€‚</p>
<p>But what of CPython? When you run your Python program using it, the code is parsed and converted to an internal bytecode format, which is then executed inside the VM. From the userâ€™s perspective, this is clearly an interpreterâ€”they run their program from source. But if you look under CPythonâ€™s scaly skin, youâ€™ll see that there is definitely some compiling going on.</p>
<p>The answer is that it is both. CPython is an interpreter, and it has a compiler. In practice, most scripting languages work this way, as you can see:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/venn.png?raw=true" alt="venn" /></p>
<p>ä½†æ˜¯ï¼ŒCPythonæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿå½“æˆ‘ä»¬è¿è¡ŒPythonç¨‹åºæ—¶å€™ï¼ŒCPythonç¼–è¯‘å™¨å°†Pythonä»£ç è½¬æ¢ä¸ºå†…éƒ¨çš„å­—èŠ‚ç ï¼Œåœ¨Pythonè™šæ‹Ÿæœºä¸­è¿è¡Œã€‚ä»ç”¨æˆ·è§’åº¦çœ‹ï¼Œè¿™æ˜¯ä¸€ä¸ªè§£é‡Šå™¨ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥ç›´æ¥ä»åŸå§‹ä»£ç è¿è¡Œï¼Œä½†æ˜¯å¦‚æœä»å†…éƒ¨å®ç°è§’åº¦ï¼Œè¿˜å­˜åœ¨ç€ä¸€äº›ç¼–è¯‘å™¨ã€‚</p>
<p>å‡†ç¡®ç­”æ¡ˆæ˜¯ï¼ŒCPythonæ—¢æ˜¯ä¸€ä¸ªè§£é‡Šå™¨ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œå®é™…ä¸Šï¼Œå¤§éƒ¨åˆ†çš„è„šæœ¬è¯­è¨€éƒ½æ˜¯è¿™æ ·çš„</p>
<p>That overlapping region in the center is where our second interpreter lives too, since it internally compiles to bytecode. So while this book is nominally about interpreters, weâ€™ll cover some compilation too.</p>
<p>å¦‚ä¸Šå›¾ï¼Œæˆ‘ä»¬ç¬¬äºŒéƒ¨åˆ†å®ç°çš„Loxè§£é‡Šå™¨ï¼Œå¤„äºä¸­é—´çš„é‡å éƒ¨åˆ†ï¼Œå› ä¸ºæˆ‘ä»¬ä¼šç”Ÿæˆå­—èŠ‚ç ã€‚å› æ­¤ï¼Œè™½ç„¶æœ¬ä¹¦æ˜¯å…³äºè§£é‡Šå™¨ä»‹ç»çš„ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä¼šæ¶‰åŠåˆ°ç¼–è¯‘å™¨çš„å†…å®¹ã€‚</p>
<blockquote>
<p>The Go tool is even more of a horticultural curiosity. If you run go build, it compiles your Go source code to machine code and stops. If you type go run, it does that, then immediately executes the generated executable.</p>
<p>So go is a compiler (you can use it as a tool to compile code without running it), is an interpreter (you can invoke it to immediately run a program from source), and also has a compiler (when you use it as an interpreter, it is still compiling internally).</p>
<p>goè¯­è¨€çš„å‘½ä»¤æ›´åŠ èƒ½è¯´æ˜é—®é¢˜ï¼Œä¾‹å¦‚ï¼šæ‰§è¡Œå‘½ä»¤ go buildï¼Œæˆ‘ä»¬èƒ½å¾—åˆ°ä¸€ä¸ªå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¦‚æœæ‰§è¡Œå‘½ä»¤ï¼Œgo runï¼Œç¨‹åºä¼šé©¬ä¸Šè¿è¡Œã€‚</p>
<p>æ‰€ä»¥ï¼Œgoæ˜¯ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œå¯ä»¥å°†goç¨‹åºç¼–è¯‘ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼Œgoä¹Ÿæ˜¯ä¸€ä¸ªè§£é‡Šå™¨ï¼Œå¯ä»¥ç›´æ¥è¿è¡Œgoç¨‹åºï¼Œä½†æ˜¯è§£é‡Šå™¨ä¸­è¿˜åŒ…å«ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œå½“ç›´æ¥è¿è¡Œgoç¨‹åºæ—¶å€™ï¼Œå†…éƒ¨ä»æœ‰ç¼–è¯‘æ­¥éª¤ã€‚</p>
</blockquote>
<h2 id="å››our-journey"><a class="header" href="#å››our-journey">å››ã€Our Journey</a></h2>
<p>æˆ‘ä»¬çš„æ—…é€”</p>
<p>Thatâ€™s a lot to take in all at once. Donâ€™t worry. This isnâ€™t the chapter where youâ€™re expected to understand all of these pieces and parts. I just want you to know that they are out there and roughly how they fit together.</p>
<p>This map should serve you well as you explore the territory beyond the guided path we take in this book. I want to leave you yearning to strike out on your own and wander all over that mountain.</p>
<p>But, for now, itâ€™s time for our own journey to begin. Tighten your bootlaces, cinch up your pack, and come along. From here on out, all you need to focus on is the path in front of you.</p>
<p>æœ¬ç« ï¼Œæˆ‘ä»¬ä»‹ç»äº†å¾ˆå¤šå†…å®¹ï¼Œåˆ«æ‹…å¿ƒï¼Œä½ ä¸éœ€è¦ç°åœ¨å°±ç†è§£æ‰€æœ‰å†…å®¹ï¼Œæˆ‘ä»¬åªæ˜¯ï¼Œå…ˆä»‹ç»å®ƒä»¬ï¼Œä½ éœ€è¦çŸ¥é“å®ƒä»¬æ˜¯å­˜åœ¨çš„ï¼Œå¹¶ä¸”éœ€è¦çŸ¥é“å®ƒä»¬æ˜¯å¦‚ä½•ç»“åˆåœ¨ä¸€èµ·çš„ã€‚</p>
<p>æœ¬ç« æ¶‰åŠçš„åœ°å›¾å°†å¾ˆå¥½çš„é™ªä¼´ç€ä½ ï¼Œå› ä¸ºå®ƒåŒ…å«æœ‰ä¸€äº›å†…å®¹ï¼Œæœ¬ä¹¦ä¸­ä¸ä¼šæ¶‰åŠåˆ°ã€‚æˆ‘æƒ³è¦ç¦»å¼€ä½ ï¼Œè®©ä½ ç‹¬è‡ªå»æ¢ç´¢ã€äº«å—çˆ¬å±±çš„è¿‡ç¨‹ã€‚</p>
<p>ä½†æ˜¯ï¼Œç°åœ¨è¿˜ä¸æ˜¯ç‹¬è‡ªæ¢ç´¢çš„æ—¶å€™ï¼Œè®©æˆ‘ä»¬ä¸€èµ·å¼€å¯æ—…ç¨‹ã€‚ç³»ç´§é‹å¸¦ï¼Œæ”¶å¥½èƒŒåŒ…ï¼Œè·Ÿä¸Šæ¥ï¼Œä»ç°åœ¨å¼€å§‹ï¼Œä½ éœ€è¦å…³æ³¨çœ¼å‰çš„é“è·¯ã€‚</p>
<blockquote>
<p>Henceforth, I promise to tone down the whole mountain metaphor thing.</p>
<p>ä»ä»Šå¾€åï¼Œæˆ‘ä¼šæ·¡åŒ–çˆ¬å±±è¿™ä»¶äº‹æƒ…ã€‚</p>
</blockquote>
<h2 id="äº”challenges"><a class="header" href="#äº”challenges">äº”ã€CHALLENGES</a></h2>
<p>ä¹ é¢˜é›†</p>
<ol>
<li>
<p>Pick an open source implementation of a language you like. Download the source code and poke around in it. Try to find the code that implements the scanner and parser. Are they handwritten, or generated using tools like Lex and Yacc? (.l or .y files usually imply the latter.)</p>
<p>é€‰æ‹©ä¸€ç§ä½ ç†Ÿæ‚‰ã€å–œæ¬¢çš„å¼€æºè¯­è¨€ï¼Œä¸‹è½½æºç ç„¶åæµè§ˆä¸€ä¸‹ï¼Œå°è¯•æ‰¾å‡ºå…¶ä¸­çš„æ‰«æå™¨ã€è§£æå™¨éƒ¨åˆ†ï¼Œåˆ¤æ–­å®ƒä»¬æ˜¯è‡ªå·±å®ç°çš„ï¼Œè¿˜æ˜¯ä½¿ç”¨Lex/Yaccç­‰ç¼–è¯‘å™¨å·¥å…·å®ç°çš„ï¼Œå¯ä»¥æŸ¥çœ‹æ˜¯å¦å­˜åœ¨ .l, .y åç¼€çš„æ–‡ä»¶ï¼Œè¿™é€šå¸¸æ˜¯å·¥å…·ç”Ÿæˆæ–‡ä»¶ã€‚</p>
</li>
<li>
<p>Just-in-time compilation tends to be the fastest way to implement dynamically typed languages, but not all of them use it. What reasons are there to not JIT?</p>
<p>å³æ—¶ç¼–è¯‘é€šå¸¸æ˜¯åŠ¨æ€è¯­è¨€æœ€å¿«çš„å®ç°æ–¹å¼ï¼Œä½†æ˜¯å¹¶éæ‰€æœ‰çš„è¯­è¨€éƒ½åˆ©ç”¨è¿™ç§ç‰¹æ€§ï¼Œä¸ºä»€ä¹ˆå®ƒä»¬ä¸æä¾›å³æ—¶ç¼–è¯‘ï¼Ÿ</p>
</li>
<li>
<p>Most Lisp implementations that compile to C also contain an interpreter that lets them execute Lisp code on the fly as well. Why?</p>
<p>å¤§å¤šæ•°çš„Lispå®ç°ï¼Œåœ¨å®ç°ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œç¼–è¯‘ä¸ºCè¯­è¨€çš„åŒæ—¶ï¼Œè¿˜æä¾›ä¸€ä¸ªè§£é‡Šå™¨ï¼Œä¿è¯å¯ä»¥åŠ¨æ€æ‰§è¡ŒLispä»£ç ï¼Œä¸ºä»€ä¹ˆï¼Ÿ</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loxè¯­è¨€"><a class="header" href="#loxè¯­è¨€">Loxè¯­è¨€</a></h1>
<blockquote>
<p>What nicer thing can you do for somebody than make them breakfast?</p>
<p align="right">â€”â€” Anthony Bourdain</p>
<p>è¿˜æœ‰ä»€ä¹ˆæ¯”ç»™åˆ«äººåšæ—©é¤æ›´å¥½çš„äº‹æƒ…å‘¢ï¼Ÿ</p>
</blockquote>
<p>Weâ€™ll spend the rest of this book illuminating every dark and sundry corner of the Lox language, but it seems cruel to have you immediately start grinding out code for the interpreter without at least a glimpse of what weâ€™re going to end up with.</p>
<p>At the same time, I donâ€™t want to drag you through reams of language lawyering and specification-ese before you get to touch your text editor. So this will be a gentle, friendly introduction to Lox. It will leave out a lot of details and edge cases. Weâ€™ve got plenty of time for those later.</p>
<p>æˆ‘ä»¬å°†åœ¨æœ¬ä¹¦çš„å‰©ä½™éƒ¨åˆ†ï¼Œé˜æ˜Loxè¯­è¨€çš„æ¯ä¸€ä¸ªé»‘æš—å’Œæ‚ä¹±çš„è§’è½ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æ— æ³•çœ‹åˆ° Lox è¯­è¨€çš„æœ€ç»ˆæ ·å­ï¼Œå°±å¼€å§‹ç¼–å†™è§£é‡Šå™¨ä»£ç ï¼Œçœ‹èµ·æ¥æœ‰ä¸€äº›åŒ†å¿™ã€‚</p>
<p>åœ¨ä½ ä½¿ç”¨æ–‡æœ¬ç¼–è¾‘å™¨ä¹‹å‰ï¼Œæˆ‘ä¸æƒ³è¿‡å¤šä»‹ç»è¯­è¨€çš„æ ¼å¼å’Œè§„èŒƒï¼Œæ‰€ä»¥ï¼Œæœ¬ç« å°†æ˜¯ä¸€ä¸ªæ¸©å’Œå‹å¥½çš„Loxä»‹ç»ã€‚å®ƒä¼šé—æ¼å¾ˆå¤šç»†èŠ‚å’Œè¾¹ç¼˜éƒ¨åˆ†ï¼Œæˆ‘ä»¬åœ¨åé¢æœ‰è¶³å¤Ÿçš„æ—¶é—´å»å­¦ä¹ ã€‚</p>
<blockquote>
<p>A tutorial isnâ€™t very fun if you canâ€™t try the code out yourself. Alas, you donâ€™t have a Lox interpreter yet, since you havenâ€™t built one!</p>
<p>Fear not. You can use mine.</p>
<p>å¦‚æœä¸€ä¸ªæ•™ç¨‹ä¸èƒ½è‡ªå·±å†™ä»£ç ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•™ç¨‹å°±æ²¡æœ‰å¸å¼•åŠ›ã€‚ä½†æ˜¯ï¼Œä½ è¿˜æ²¡æœ‰ä¸€ä¸ªLoxè§£é‡Šå™¨ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰å»å®ç°å®ƒã€‚</p>
<p>ä¸ç”¨æ‹…å¿ƒï¼Œä½ å¯ä»¥å…ˆä½¿ç”¨æˆ‘çš„ğŸ˜„ã€‚</p>
</blockquote>
<h2 id="ä¸€hello-lox"><a class="header" href="#ä¸€hello-lox">ä¸€ã€Hello, Lox</a></h2>
<p>ç¬¬ä¸€ä¸ªç¨‹åº</p>
<pre><code class="language-c">
// Your first Lox program!
print &quot;Hello, world!&quot;;

</code></pre>
<p>Hereâ€™s your very first taste of Lox:</p>
<p>As that // line comment and the trailing semicolon imply, Loxâ€™s syntax is a member of the C family. (There are no parentheses around the string because print is a built-in statement, and not a library function.)</p>
<p>Now, I wonâ€™t claim that C has a great syntax. If we wanted something elegant, weâ€™d probably mimic Pascal or Smalltalk. If we wanted to go full Scandinavian-furniture-minimalism, weâ€™d do a Scheme. Those all have their virtues.</p>
<p>What C-like syntax has instead is something youâ€™ll often find more valuable in a language: familiarity.  I know you are already comfortable with that style because the two languages weâ€™ll be using to implement Loxâ€”Java and Câ€”also inherit it. Using a similar syntax for Lox gives you one less thing to learn.</p>
<p>ä¸Šé¢æ˜¯ç¬¬ä¸€ä¸ªLoxç¨‹åºï¼Œ</p>
<p>æ­£å¦‚ // è¡Œæ³¨é‡Šï¼Œè¡Œå°¾ï¼›æ‰€æš—ç¤ºçš„ï¼ŒLoxè¯­è¨€ï¼Œç»§æ‰¿äº†Cè¯­è¨€è¯­æ³•ã€‚hello, world å­—ç¬¦ä¸²å‘¨å›´ä¸éœ€è¦æ‹¬å·ï¼Œå› ä¸º printæ˜¯ä¸€ä¸ªå†…ç½®è¯­å¥ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªåº“å‡½æ•°ã€‚</p>
<p>ç°åœ¨ï¼Œæˆ‘ä¸ä¼šè¯´Cè¯­è¨€æœ‰å¾ˆå¥½çš„è¯­æ³•ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦ä¼˜é›…çš„ä¸œè¥¿ï¼Œå¯èƒ½æ¨¡ä»¿Pascalã€Smalltalkæ›´åŠ åˆé€‚ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦å®Œå…¨å®ç° æ–¯å ªçš„çº³ç»´äºšå®¶å…·çš„æç®€ä¸»ä¹‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆåšä¸€ä¸ªè®¡åˆ’ã€‚è¿™äº›éƒ½æœ‰å®ƒä»¬çš„ä¼˜åŠ¿ã€‚</p>
<p>ç›¸åï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»Cè¯­è¨€è¯­æ³•ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬å¯ä»¥ä»ä¸­è·å¾—æ›´æœ‰ä»·å€¼çš„ä¸œè¥¿ï¼Œç†Ÿæ‚‰åº¦ã€‚æˆ‘çŸ¥é“ï¼Œä½ å·²ç»ä¹ æƒ¯äº†è¿™ç§é£æ ¼ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ç”¨ä»¥å®ç°Loxçš„ä¸¤ç§è¯­è¨€ï¼ŒJava å’ŒCè¯­è¨€ï¼Œéƒ½æ‹¥æœ‰è¿™ç§ç†Ÿæ‚‰çš„é£æ ¼ã€‚Loxè¯­è¨€ä½¿ç”¨è¿™ç§é£æ ¼çš„è¯­æ³•ï¼Œå¯ä»¥æ›´åŠ å®¹æ˜“å…¥é—¨ã€‚</p>
<blockquote>
<p>Your first taste of Lox, the language, that is. I donâ€™t know if youâ€™ve ever had the cured, cold-smoked salmon before. If not, give it a try too.</p>
<p>ä½ ç¬¬ä¸€æ¬¡å“å°Loxè¯­è¨€ï¼Œå°±æ˜¯è¿™æ ·ã€‚æˆ‘ä¸çŸ¥é“ä½ ä¹‹å‰æœ‰æ²¡æœ‰å°è¯•è¿‡è…Œåˆ¶çš„å†·é²‘é±¼ï¼Œå¦‚æœæ²¡æœ‰ï¼Œå¯ä»¥å°è¯•ä¸€ä¸‹ã€‚</p>
</blockquote>
<blockquote>
<p>Iâ€™m surely biased, but I think Loxâ€™s syntax is pretty clean. Câ€™s most egregious grammar problems are around types. Dennis Ritchie had this idea called â€œdeclaration reflects useâ€, where variable declarations mirror the operations you would have to perform on the variable to get to a value of the base type.</p>
<p>Lox doesnâ€™t have static types, so we avoid that.</p>
<p>æˆ‘æ˜¯æœ‰åè§çš„ï¼Œä»æˆ‘çš„è§’åº¦ï¼Œæˆ‘è®¤ä¸ºLoxè¯­è¨€è¯­æ³•éå¸¸ç®€æ´ã€‚Cè¯­è¨€ä»¤äººæƒŠè®¶çš„è¯­æ³•é—®é¢˜æ˜¯ï¼Œç±»å‹ã€‚Dennis Ritchie æå‡ºä¸€ä¸ªâ€œå£°æ˜åæ˜ ä½¿ç”¨â€çš„æƒ³æ³•ï¼Œå…¶ä¸­å˜é‡å£°æ˜åæ˜ äº†ä½ å¯¹äºå˜é‡æ‰§è¡Œçš„æ“ä½œï¼Œä»¥è·å¾—åŸºç±»å‹çš„å€¼ã€‚è¿™ä¸ªæƒ³æ³•éå¸¸å¥½ï¼Œä½†æˆ‘è®¤ä¸ºï¼Œåœ¨å®è·µä¸­çš„æ•ˆæœå¹¶ä¸å¥½ã€‚</p>
<p>Loxä¸æ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œæ‰€ä»¥æˆ‘ä»¬é¿å…äº†è¿™ç§æƒ…å†µã€‚</p>
</blockquote>
<h2 id="äºŒa-high-level-language"><a class="header" href="#äºŒa-high-level-language">äºŒã€A high-level language</a></h2>
<p>é«˜çº§è¯­è¨€</p>
<p>While this book ended up bigger than I was hoping, itâ€™s still not big enough to fit a huge language like Java in it. In order to fit two complete implementations of Lox in these pages, Lox itself has to be pretty compact.</p>
<p>When I think of languages that are small but useful, what comes to mind are high-level â€œscriptingâ€ languages like JavaScript, Scheme, and Lua. Of those three, Lox looks most like JavaScript, mainly because most C-syntax languages do. As weâ€™ll learn later, Loxâ€™s approach to scoping hews closely to Scheme. The C flavor of Lox weâ€™ll build in Part III is heavily indebted to Luaâ€™s clean, efficient implementation.</p>
<p>è™½ç„¶æœ¬ä¹¦å†…å®¹å¤§å¤§è¶…è¿‡äº†ä¸€å¼€å§‹çš„è®¾æƒ³ï¼Œä½†æ˜¯è¿˜æ˜¯æ— æ³•åˆ©ç”¨ä¸€æœ¬ä¹¦æ¥ä»‹ç»Java è¿™æ ·çš„å¤§å‹è¯­è¨€ã€‚ä¸ºäº†åœ¨æ¥ä¸‹æ¥å»å®ç° Loxè¯­è¨€ä¸¤æ¬¡ï¼ŒLoxæœ¬èº«éœ€è¦éå¸¸ç´§å‡‘ã€‚</p>
<p>å½“æˆ‘ä»¬æåˆ°å°è€Œæœ‰ç”¨çš„è¯­è¨€æ—¶å€™ï¼Œé€šå¸¸ä¼šæƒ³åˆ°çš„æ˜¯ä¸€äº›è„šæœ¬è¯­è¨€ï¼Œä¾‹å¦‚ï¼šJavaScript, Scheme, Lua ç­‰ã€‚åœ¨è¿™ä¸‰ç§è„šæœ¬è¯­è¨€ä¸­ï¼ŒLoxæ›´åƒæ˜¯ JavaScriptï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯ç±»C è¯­æ³•ã€‚æ­£å¦‚åé¢å°†è¦ä»‹ç»çš„ï¼ŒLoxçš„ä»£ç å—èŒƒå›´è¡¨ç¤ºï¼Œå’ŒScheme è¯­è¨€ç›¸ä¼¼ã€‚åœ¨ç¬¬ä¸‰éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†å®ç°çš„Cè¯­è¨€ä¸ºè§£é‡Šå™¨çš„Loxè¯­è¨€ï¼Œå°†æ›´åŠ æ¥è¿‘Luaè¯­è¨€çš„ç®€æ´ã€é«˜æ•ˆç‰¹å¾ã€‚</p>
<p>Lox shares two other aspects with those three languages:</p>
<p>Lox å’Œè„šæœ¬è¯­è¨€è¿˜æœ‰ä¸‹é¢3ä¸ªç›¸åŒç‚¹ï¼š</p>
<h3 id="21-dynamic-typing"><a class="header" href="#21-dynamic-typing">2.1 Dynamic typing</a></h3>
<p>åŠ¨æ€ç±»å‹</p>
<p>Lox is dynamically typed. Variables can store values of any type, and a single variable can even store values of different types at different times. If you try to perform an operation on values of the wrong typeâ€”say, dividing a number by a stringâ€”then the error is detected and reported at runtime.</p>
<p>There are plenty of reasons to like static types, but they donâ€™t outweigh the pragmatic reasons to pick dynamic types for Lox.  A static type system is a ton of work to learn and implement.Skipping it gives you a simpler language and a shorter book. Weâ€™ll get our interpreter up and executing bits of code sooner if we defer our type checking to runtime.</p>
<p>Loxæ˜¯åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œå˜é‡å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å€¼ï¼Œå•ä¸ªå˜é‡å¯ä»¥åœ¨ä¸åŒæ—¶é—´å­˜å‚¨ä¸åŒç±»å‹çš„æ•°æ®ï¼Œå¦‚ä½•å°è¯•å¯¹äºé”™è¯¯ç±»å‹çš„å€¼æ‰§è¡Œæ“ä½œï¼Œä¾‹å¦‚ï¼šæ•°å€¼é™¤ä»¥å­—ç¬¦ä¸²ï¼Œè¿è¡Œæ—¶å€™ä¼šæ£€æµ‹ï¼Œå¹¶ä¸”æŠ¥é”™ã€‚</p>
<p>å–œæ¬¢é™æ€ç±»å‹æœ‰å¾ˆå¤šç†ç”±ï¼Œä½†æ˜¯ä¸ºäº†Loxè¯­è¨€æ›´åŠ å®ç”¨ï¼Œæˆ‘ä»¬é€‰æ‹©äº†åŠ¨æ€ç±»å‹ã€‚é™æ€ç±»å‹ç³»ç»Ÿéœ€è¦å­¦ä¹ å’Œå®ç°å¤§é‡å·¥ä½œã€‚è·³è¿‡é™æ€ç±»å‹ï¼Œä¼šè®©Loxè¯­è¨€å®ç°æ›´åŠ ç®€å•ã€‚å¦‚æœåœ¨è§£é‡Šå™¨è¿è¡Œæ—¶å€™ï¼Œæ‰§è¡Œç±»å‹æ£€æŸ¥ï¼Œæˆ‘ä»¬å¯ä»¥æ›´å¿«çš„æ‰§è¡Œä»£ç ã€‚</p>
<blockquote>
<p>Now that JavaScript has taken over the world and is used to build ginormous applications, itâ€™s hard to think of it as a â€œlittle scripting languageâ€. But Brendan Eich hacked the first JS interpreter into Netscape Navigator in ten days to make buttons animate on web pages. JavaScript has grown up since then, but it was once a cute little language.</p>
<p>æ—¢ç„¶ï¼ŒJavaScriptè¯­è¨€å·²ç»é£é¡è¯­è¨€ä¸–ç•Œï¼Œå¹¶ä¸”ç”¨äºæ„å»ºå¾ˆå¤šçš„å¤§å‹é¡¹ç›®ï¼Œæˆ‘ä»¬å¾ˆéš¾åœ¨å°†å®ƒå½“ä½œä¸€ä¸ªå°ä¼—è¯­è¨€ã€‚ä½†æ˜¯ï¼Œåœ¨ç½‘æ™¯å…¬å¸ï¼ŒBrendan Eich ä»…ä»…ä½¿ç”¨äº†10å¤©æ—¶é—´ï¼Œå°±å®Œæˆäº†ç¬¬ä¸€ä¸ªJSç¼–è¯‘å™¨ï¼Œå¹¶ä¸”å®ç°äº†ç½‘é¡µä¸­çš„æŒ‰é’®åŠ¨æ€å±•ç¤ºã€‚JavaScript ä»é‚£æ—¶å¼€å§‹ï¼Œä¸æ–­æˆé•¿ï¼Œä½†æ˜¯å®ƒæ›¾ç»æ˜¯ä¸€é—¨å¯çˆ±çš„å°è¯­è¨€ã€‚</p>
<p>Because Eich slapped JS together with roughly the same raw materials and time as an episode of MacGyver, it has some weird semantic corners where the duct tape and paper clips show through. Things like variable hoisting, dynamically bound this, holes in arrays, and implicit conversions.</p>
<p>å› ä¸ºEichä½¿ç”¨äº†ä¸ã€Šéº¦åŸºå¼—ã€‹ä¸€é›†å¤§è‡´ç›¸åŒçš„åŸææ–™å’Œæ—¶é—´åˆ¶ä½œäº†JSè¯­è¨€ï¼Œæ‰€ä»¥ï¼Œå®ƒå­˜åœ¨ç€ä¸€äº›å¥‡æ€ªçš„è¯­æ³•ï¼Œä¼šå‡ºç°ä¸€äº›èƒ¶å¸¦å’Œå›å½¢é’ˆã€‚ä¾‹å¦‚ï¼šå˜é‡æå‡ï¼ŒåŠ¨æ€ç»‘å®šï¼Œæ•°ç»„ä¸­çš„æ¼æ´å’Œéšå¼è½¬æ¢ã€‚</p>
<p>I had the luxury of taking my time on Lox, so it should be a little cleaner. After all, the two languages weâ€™ll be using to implement Lox are both statically typed.</p>
<p>ç›¸æ¯”ä¹‹ä¸‹ï¼Œæˆ‘æœ‰æ›´å¤šæ—¶é—´æ‰“ç£¨Loxè¯­è¨€ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ä¼šå‘ç°ï¼ŒLoxè¯­è¨€ä¼šæ›´åŠ ç®€æ´ã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬å®ç°Loxè¯­è¨€çš„åº•å±‚è¯­è¨€Java/Céƒ½æ˜¯é™æ€è¯­è¨€ã€‚</p>
</blockquote>
<h3 id="22-automatic-memory-management"><a class="header" href="#22-automatic-memory-management">2.2 Automatic memory management</a></h3>
<p>è‡ªåŠ¨å†…å­˜ç®¡ç†</p>
<p>High-level languages exist to eliminate error-prone, low-level drudgery, and what could be more tedious than manually managing the allocation and freeing of storage? No one rises and greets the morning sun with, â€œI canâ€™t wait to figure out the correct place to call free() for every byte of memory I allocate today!â€</p>
<p>é«˜çº§è¯­è¨€çš„å‡ºç°æ˜¯ä¸ºäº†ï¼Œæ¶ˆé™¤æ›´åŠ å®¹æ˜“å‡ºé”™ã€ä½çº§åˆ«ã€ä¹å‘³çš„å·¥ä½œï¼Œè¿˜æœ‰ä»€ä¹ˆæ¯”æ‰‹åŠ¨ç®¡ç†å†…å­˜åˆ†é…ä¸é‡Šæ”¾ï¼Œæ›´åŠ ç¹çå‘¢ï¼Ÿæ²¡æœ‰äººä¼šç«™èµ·æ¥è¿æ¥å¤ªé˜³ï¼Œæˆ‘å¿ä¸ä½è¦ä¸ºä»Šå¤©åˆ†é…çš„æ¯ä¸€ä¸ªå­—èŠ‚çš„å†…å­˜ï¼Œæ‰¾åˆ°è°ƒç”¨ free() å‡½æ•°çš„æ­£ç¡®ä½ç½®ã€‚</p>
<p>There are two main techniques for managing memory: reference counting and tracing garbage collection (usually just called garbage collection or GC). Ref counters are much simpler to implementâ€”I think thatâ€™s why Perl, PHP, and Python all started out using them. But, over time, the limitations of ref counting become too troublesome. All of those languages eventually ended up adding a full tracing GC, or at least enough of one to clean up object cycles.</p>
<p>Tracing garbage collection has a fearsome reputation. It is a little harrowing working at the level of raw memory. Debugging a GC can sometimes leave you seeing hex dumps in your dreams. But, remember, this book is about dispelling magic and slaying those monsters, so we are going to write our own garbage collector. I think youâ€™ll find the algorithm is quite simple and a lot of fun to implement.</p>
<p>å†…å­˜ç®¡ç†ä¸»è¦æœ‰ä¸¤ç§æŠ€æœ¯ï¼šå¼•ç”¨è®¡æ•° å’Œ è¿½è¸ªåƒåœ¾å›æ”¶ï¼Œé€šå¸¸ä¹Ÿç§°ä¸ºï¼Œåƒåœ¾å›æ”¶ï¼Œç¼©å†™ä¸º GC</p>
<p>å¼•ç”¨è®¡æ•°çš„å®ç°è¦ç®€å•ä¸€äº›ï¼Œæˆ‘è®¤ä¸ºè¿™ä¹Ÿæ˜¯Perl/PHP/Python è¯­è¨€ä¸€å¼€å§‹ä½¿ç”¨è¿™ä¸ªæŠ€æœ¯ï¼Œå®ç°å†…å­˜ç®¡ç†çš„åŸå› ã€‚ä½†æ˜¯ï¼Œéšç€æ—¶é—´çš„å˜æ›´ï¼Œå¼•ç”¨è®¡æ•°çš„å±€é™æ€§è¶Šæ¥è¶Šå¤šã€‚æ‰€ä»¥ï¼Œä¸Šé¢çš„è¯­è¨€ï¼Œæœ€ç»ˆéƒ½æ·»åŠ äº†å®Œæ•´çš„è¿½è¸ªGC å®ç°ï¼Œæˆ–è€…æœ‰è¶³å¤Ÿçš„ GCé€»è¾‘ å‘¨æœŸæ€§æ¸…ç†å¯¹è±¡ã€‚</p>
<p>è¿½è¸ªåƒåœ¾å›æ”¶å…·æœ‰å¯æ€•çš„åå£°ã€‚åœ¨åŸç”Ÿå†…å­˜çº§åˆ«å·¥ä½œï¼Œéå¸¸ç—›è‹¦ã€‚è°ƒè¯• GCï¼Œä¼šè®©ä½ åœ¨æ¢¦é‡Œéƒ½è¿˜åœ¨æƒ³ç€16è¿›åˆ¶è½¬å‚¨é—®é¢˜ã€‚ä½†æ˜¯ï¼Œè¯·è®°ä½ï¼Œæœ¬ä¹¦ä¼šå¸¦ç€æˆ‘ä»¬ä¸€èµ·é©±æ•£é­”æ³•ï¼Œæ€æ­»æ€ªå…½ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ä¹Ÿä¼šç¼–å†™è‡ªå·±çš„åƒåœ¾å›æ”¶ç¨‹åºã€‚æˆ‘çŒœæƒ³ï¼Œä½ ä¸€å®šä¼šå‘ç°ç®—æ³•éå¸¸ç®€å•ï¼Œå¹¶ä¸”æ•´ä¸ªç¨‹åºéå¸¸æœ‰è¶£ã€‚</p>
<blockquote>
<p>In practice, ref counting and tracing are more ends of a continuum than opposing sides. Most ref counting systems end up doing some tracing to handle cycles, and the write barriers of a generational collector look a bit like retain calls if you squint.</p>
<p>åœ¨å®è·µä¸­ï¼Œå¼•ç”¨è®¡æ•°å’Œè¿½è¸ªæŠ€æœ¯ä¼šæ··åˆä½¿ç”¨ï¼Œè€Œä¸æ˜¯ç›¸äº’å¯¹ç«‹ã€‚å¤§å¤šæ•°çš„å¼•ç”¨è®¡æ•°ï¼Œéƒ½ä¼šè¿›è¡Œä¸€äº›å‘¨æœŸæ€§çš„è¿½è¸ªï¼Œå¦‚æœä½ ä»”ç»†æŸ¥çœ‹ï¼Œåˆ†ä»£é‡‡é›†å™¨çš„ç”¨æ³•çœ‹èµ·æ¥åƒæ˜¯ä¿ç•™è°ƒç”¨ã€‚</p>
<p>For lots more on this, see <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/unified-theory-gc.pdf">â€œA Unified Theory of Garbage Collectionâ€</a> (PDF).</p>
<p>æ›´å¤šçš„ä¿¡æ¯ï¼Œå¯ä»¥æŸ¥çœ‹ <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/unified-theory-gc.pdf">â€œåƒåœ¾æ”¶é›†çš„ç»Ÿä¸€ç†è®ºâ€</a></p>
</blockquote>
<h2 id="ä¸‰data-types"><a class="header" href="#ä¸‰data-types">ä¸‰ã€Data Types</a></h2>
<p>æ•°æ®ç±»å‹</p>
<p>In Loxâ€™s little universe, the atoms that make up all matter are the built-in data types. There are only a few:</p>
<ol>
<li>
<p><strong>Booleans</strong></p>
<p>You canâ€™t code without logic and you canâ€™t logic without Boolean values. â€œTrueâ€ and â€œfalseâ€, the yin and yang of software. Unlike some ancient languages that repurpose an existing type to represent truth and falsehood, Lox has a dedicated Boolean type. </p>
<p>There are two Boolean values, obviously, and a literal for each one.</p>
<pre><code>
true;  // Not false.
false; // Not *not* false.

</code></pre>
<blockquote>
<p>Boolean variables are the only data type in Lox named after a person, George Boole, which is why â€œBooleanâ€ is capitalized. He died in 1864, nearly a century before digital computers turned his algebra into electricity. I wonder what heâ€™d think to see his name all over billions of lines of Java code.</p>
<p>å¸ƒå°”å˜é‡æ˜¯Loxè¯­è¨€ä¸­ï¼Œå”¯ä¸€ä½¿ç”¨äººåå‘½åçš„æ•°æ®ç±»å‹ã€‚Booleanæ˜¯ä¸ºäº†çºªå¿µ George Boole, ä»–äº1864å¹´å»ä¸–ï¼Œä¸€ä¸ªä¸–çºªåï¼Œè®¡ç®—æœºç§‘å­¦å°†ä»–å‘æ˜çš„å¸ƒå°”ä»£æ•°ï¼Œè½¬æ¢ä¸ºè®¡ç®—æœºè¡¨ç¤ºã€‚æˆ‘æƒ³çŸ¥é“ï¼Œå½“ä»–åœ¨æ•°åäº¿Javaä»£ç ä¸­ï¼Œçœ‹åˆ°è‡ªå·±çš„åå­—ï¼Œä¼šæœ‰ä»€ä¹ˆæ„Ÿæƒ³ğŸ˜„</p>
</blockquote>
</li>
<li>
<p><strong>Numbers</strong></p>
<p>Lox has only one kind of number: double-precision floating point. Since floating-point numbers can also represent a wide range of integers, that covers a lot of territory, while keeping things simple.</p>
<p>Full-featured languages have lots of syntax for numbersâ€”hexadecimal, scientific notation, octal, all sorts of fun stuff. Weâ€™ll settle for basic integer and decimal literals.</p>
<pre><code>
1234;  // An integer.
12.34; // A decimal number.

</code></pre>
</li>
<li>
<p><strong>Strings</strong></p>
<p>Weâ€™ve already seen one string literal in the first example. Like most languages, they are enclosed in double quotes.</p>
<p>As weâ€™ll see when we get to implementing them, there is quite a lot of complexity hiding in that innocuous sequence of characters.</p>
<pre><code>
&quot;I am a string&quot;;
&quot;&quot;;    // The empty string.
&quot;123&quot;; // This is a string, not a number.

</code></pre>
<blockquote>
<p>Even that word â€œcharacterâ€ is a trickster. Is it ASCII? Unicode? A code point or a â€œgrapheme clusterâ€? How are characters encoded? Is each character a fixed size, or can they vary?</p>
<p>å³ä½¿æ˜¯å•è¯ï¼Œå­—èŠ‚ï¼Œä¹ŸåŒ…å«äº†ä¸€äº›éšè—ä¿¡æ¯ï¼Œå­—èŠ‚æ˜¯ASCIIç¼–ç çš„ï¼Œè¿˜æ˜¯Unicodeç¼–ç ï¼›ä¸€ä¸ªå­—èŠ‚æ˜¯ä¸€ä¸ªä»£ç ç‚¹ï¼Œè¿˜æ˜¯ä¸€ä¸ªå›¾å½¢é›†ç°‡ï¼›å­—èŠ‚æ˜¯å¦‚ä½•ç¼–ç çš„ï¼Œæ˜¯å®šé•¿ç¼–ç ï¼Œè¿˜æ˜¯å˜é•¿ç¼–ç ï¼Ÿ</p>
</blockquote>
</li>
<li>
<p><strong>Nil</strong></p>
<p>Thereâ€™s one last built-in value whoâ€™s never invited to the party but always seems to show up. It represents â€œno valueâ€. Itâ€™s called â€œnullâ€ in many other languages. In Lox we spell it nil.  (When we get to implementing it, that will help distinguish when weâ€™re talking about Loxâ€™s nil versus Java or Câ€™s null.)</p>
<p>There are good arguments for not having a null value in a language since null pointer errors are the scourge of our industry. If we were doing a statically typed language, it would be worth trying to ban it. In a dynamically typed one, though, eliminating it is often more annoying than having it.</p>
</li>
</ol>
<p>åœ¨Loxçš„å°å®‡å®™ä¸­ï¼Œæ„æˆç‰©è´¨çš„åŸå­æ˜¯å†…ç½®çš„å‡ ç§æ•°æ®ç±»å‹ï¼Œè¯¦è§ä¸‹é¢çš„ä»‹ç»:</p>
<ol>
<li>
<p>å¸ƒå°”ç±»å‹</p>
<p>æ²¡æœ‰é€»è¾‘è¿ç®—ï¼Œæˆ‘ä»¬æ— æ³•è¿›è¡Œç¼–ç¨‹ï¼Œè€Œé€»è¾‘è¿ç®—ï¼Œéœ€è¦å¸ƒå°”æ•°æ®ç±»å‹ã€‚çœŸä¸å‡ï¼Œç¼–ç¨‹ä¸–ç•Œä¸­çš„é˜´ä¸é˜³ï¼Œä¸ä¸€äº›æ—©å…ˆè¯­è¨€å¤ç”¨å…¶ä»–æ•°æ®ç±»å‹è¡¨ç¤ºå¸ƒå°”ç±»å‹ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬ä¼šåœ¨Loxè¯­è¨€ä¸­å®šä¹‰ä¸€ä¸ªä¸“ç”¨çš„å¸ƒå°”æ•°æ®ç±»å‹ã€‚</p>
<p>æ˜¾ç„¶ï¼Œå¸ƒå°”å€¼æœ‰ä¸¤ä¸ªé€‰æ‹©ï¼Œæ¯ä¸ªå€¼å¯¹åº”äº†ä¸€ä¸ªæ–‡æœ¬</p>
<pre><code>true;  // Not false.
false; // Not *not* false.
</code></pre>
</li>
<li>
<p>æ•°å€¼ç±»å‹</p>
<p>Loxè¯­è¨€ï¼Œåªæœ‰ä¸€ç§æ•°å€¼ç±»å‹ï¼ŒåŒç²¾åº¦æµ®ç‚¹æ•°ã€‚å› ä¸ºæµ®ç‚¹æ•°ï¼Œå¯ä»¥åŒ…å«å¤§èŒƒå›´çš„æ•´æ•°ï¼Œè¿™æ ·åšï¼Œä¸ä½†å¯ä»¥åŒ…å«å¾ˆå¤šå…¶ä»–æ•°æ®ç±»å‹ï¼Œè€Œä¸”å¯ä»¥ä¿æŒç®€æ´ã€‚</p>
<p>åŠŸèƒ½é½å…¨çš„è¯­è¨€ï¼Œä¼šæœ‰å¾ˆå¤šçš„æ•°å­—è¯­æ³•ï¼Œä¾‹å¦‚ï¼šåå…­è¿›åˆ¶è¡¨ç¤ºã€ç§‘å­¦è®¡æ•°æ³•ã€å…«è¿›åˆ¶è¡¨ç¤ºï¼Œä»¥åŠå…¶ä»–çš„æœ‰è¶£çš„ä¸œè¥¿ã€‚ä½†æ˜¯åœ¨Loxè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å°†åªä¼šæ»¡è¶³åŸºæœ¬çš„æ•´æ•°è¿ç®—å’Œåè¿›åˆ¶è¡¨ç¤ºã€‚</p>
<pre><code>
1234;  // An integer.
12.34; // A decimal number.

</code></pre>
</li>
<li>
<p>å­—ç¬¦ä¸²</p>
<p>ä»ä¸Šé¢çš„ç¬¬ä¸€ä¸ªç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å­—ç¬¦ä¸²ç±»å‹ &quot;hello, world!&quot;ã€‚ å’Œå¤§å¤šæ•°çš„è¯­è¨€ä¸€æ ·ï¼Œå­—ç¬¦ä¸²ç±»å‹çš„æ•°æ®ï¼Œéœ€è¦ä½¿ç”¨åŒå¼•å·æ‹¬èµ·æ¥ã€‚</p>
<p>å½“æˆ‘ä»¬å®ç°å­—ç¬¦ä¸²ç±»å‹æ—¶å€™ï¼Œå°†ä¼šçœ‹åˆ°ï¼Œåœ¨è¿™ä¸ªå®šä¹‰æ˜ç¡®çš„å­—ç¬¦åºåˆ—ä¸­ï¼Œéšè—ç€è®¸å¤šå¤æ‚åœºæ™¯ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç†ã€‚</p>
<pre><code>
&quot;I am a string&quot;;
&quot;&quot;;    // The empty string.
&quot;123&quot;; // This is a string, not a number.

</code></pre>
</li>
<li>
<p>Nil</p>
<p>æœ€åï¼Œè¿˜æœ‰ä¸€ä¸ªæ•°æ®ç±»å‹ï¼Œå®ƒä¼¼ä¹ä»æ¥æ²¡æœ‰è¢«é‚€è¯·å‚åŠ ç¼–ç¨‹èšä¼šï¼Œä½†æ˜¯ä½ æ€»æ˜¯èƒ½çœ‹åˆ°å®ƒçš„èº«å½±ã€‚å®ƒï¼Œä»£è¡¨äº†ä¸å­˜åœ¨ï¼Œæ²¡æœ‰æ•°å€¼ã€‚åœ¨è®¸å¤šè¯­è¨€ä¸­ï¼Œä½¿ç”¨ null è¡¨ç¤ºå®ƒï¼Œè€Œåœ¨Loxè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ nil è¡¨ç¤ºå®ƒã€‚å½“æˆ‘ä»¬å®ç°å®ƒæ—¶ï¼Œå¯ä»¥æ›´å¥½çš„ä¸ Java/Cè¯­è¨€ä¸­çš„null åŒºåˆ«å¼€ã€‚</p>
<p>åœ¨è¯­è¨€ä¸­ï¼Œä¸ä½¿ç”¨ nil å­˜åœ¨å¾ˆå¤šå¥½å¤„ï¼Œç©ºæŒ‡é’ˆæŠ¥é”™æ˜¯ç¼–ç¨‹è¡Œä¸šå¸¸è§çš„æŠ¥é”™ã€‚å¦‚æœï¼Œæˆ‘ä»¬è¦å®ç°ä¸€é—¨é™æ€ç±»å‹è¯­è¨€ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç¦æ­¢ nilç±»å‹æ˜¯å€¼å¾—çš„ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬è¦å®ç°ä¸€é—¨åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œé€šå¸¸ï¼Œä¿ç•™ nilç±»å‹ï¼Œæ‹¥æœ‰æ›´å¤šçš„å¥½å¤„ï¼Œç›¸æ¯”äºç¦æ­¢è¯¥ç±»å‹ã€‚</p>
</li>
</ol>
<h2 id="å››expressions"><a class="header" href="#å››expressions">å››ã€Expressions</a></h2>
<p>è¡¨è¾¾å¼</p>
<p>If built-in data types and their literals are atoms, then expressions must be the molecules. Most of these will be familiar.</p>
<p>å¦‚æœå†…ç½®çš„åŸºç¡€æ•°æ®ç±»å‹å’Œå®ƒä»¬çš„æ–‡å­—ï¼Œæ˜¯åŸå­ï¼Œé‚£ä¹ˆè¡¨è¾¾å¼å°±æ˜¯åˆ†å­ï¼Œä¸‹é¢å°†ä»‹ç»å„ç§è¡¨è¾¾å¼</p>
<h3 id="41-arithmetic"><a class="header" href="#41-arithmetic">4.1 Arithmetic</a></h3>
<p>ç®—æœ¯è¡¨è¾¾å¼</p>
<p>Lox features the basic arithmetic operators you know and love from C and other languages:</p>
<p>Loxè¯­è¨€å…·æœ‰Cè¯­è¨€æˆ–è€…å…¶ä»–è¯­è¨€ä¸­ï¼Œå­˜åœ¨çš„åŸºç¡€ç®—æœ¯è¡¨è¾¾å¼</p>
<pre><code>
add + me;
subtract - me;
multiply * me;
divide / me;

</code></pre>
<p>The subexpressions on either side of the operator are operands. Because there are two of them, these are called binary operators.(It has nothing to do with the ones-and-zeroes use of â€œbinaryâ€.) </p>
<p>Because the operator is fixed in the middle of the operands, these are also called infix operators (as opposed to prefix operators where the operator comes before the operands, and postfix where it comes after).</p>
<p>One arithmetic operator is actually both an infix and a prefix one. The - operator can also be used to negate a number.</p>
<pre><code>-negateMe;
</code></pre>
<p>All of these operators work on numbers, and itâ€™s an error to pass any other types to them. The exception is the + operatorâ€”you can also pass it two strings to concatenate them.</p>
<p>è¿ç®—ç¬¦å·ï¼Œä¸¤è¾¹çš„å­è¡¨è¾¾å¼ï¼Œç§°ä¸ºæ“ä½œæ•°ã€‚å› ä¸ºè¿ç®—ç¬¦å·ï¼Œæœ‰ä¸¤ä¸ªæ“ä½œæ•°ï¼Œæ‰€ä»¥ç§°ä¸ºäºŒå…ƒè¿ç®—ç¬¦ã€‚âš ï¸è¿™é‡Œçš„äºŒå…ƒï¼Œå’ŒäºŒè¿›åˆ¶ä¸­çš„0æˆ–è€…1ï¼Œæ²¡æœ‰å…³ç³»ã€‚</p>
<p>å› ä¸ºè¿ç®—ç¬¦ï¼Œå›ºå®šåœ¨æ“ä½œæ•°çš„ä¸­é—´ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºä¸­ç¼€è¿ç®—ç¬¦ã€‚ï¼ˆä¸å‰ç¼€è¿ç®—ç¬¦ä¸åŒï¼Œå‰ç¼€è¿ç®—ç¬¦ä½äºè¡¨è¾¾å¼æœ€å‰é¢ï¼Œåç¼€è¿ç®—ç¬¦ä½äºè¡¨è¾¾å¼æœ€åã€‚ï¼‰</p>
<p>ä¸€å…ƒè¿ç®—ç¬¦ï¼Œå®é™…ä¸Šå¯ä»¥æ˜¯ä¸­ç¼€è¿ç®—ç¬¦ï¼Œä¹Ÿå¯ä»¥æ˜¯å‰ç¼€è¿ç®—ç¬¦ã€‚ä¾‹å¦‚ï¼š- å¯ä»¥è¡¨ç¤ºè´Ÿæ•°</p>
<pre><code>-negateMe;
</code></pre>
<p>ä¸Šé¢çš„ç®—æœ¯è¿ç®—ç¬¦çš„æ“ä½œæ•°ï¼Œåªèƒ½æ˜¯æ•°å€¼ç±»å‹ï¼Œå¦‚æœæ“ä½œæ•°æ˜¯å…¶ä»–æ•°æ®ç±»å‹ï¼Œè¡¨è¾¾å¼è®¡ç®—ä¼šæŠ¥é”™ã€‚ä½†æ˜¯ï¼Œæœ‰ä¸ªä¾‹å¤–ï¼Œ+è¿ç®—ç¬¦å¯ä»¥ä½œç”¨äºå­—ç¬¦ä¸²æ•°æ®ç±»å‹ï¼Œä¸¤ä¸ªå­—ç¬¦ä¸²çš„ + è¿ç®—ï¼Œè¡¨ç¤ºè¿æ¥è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ã€‚</p>
<blockquote>
<p>There are some operators that have more than two operands and the operators are interleaved between them. The only one in wide usage is the â€œconditionalâ€ or â€œternaryâ€ operator of C and friends:</p>
<p>condition ? thenArm : elseArm;</p>
<p>Some call these mixfix operators. A few languages let you define your own operators and control how they are positionedâ€”their â€œfixityâ€.</p>
<p>æœ‰äº›è¿ç®—ç¬¦ï¼Œå¯ä»¥å…·æœ‰ä¸¤ä¸ªä»¥ä¸Šçš„æ“ä½œæ•°ï¼Œè¿ç®—ç¬¦åœ¨è¿™äº›æ“ä½œæ•°ä¹‹é—´ã€‚å”¯ä¸€å¹¿æ³›ä½¿ç”¨çš„å¤šå…ƒè¿ç®—ç¬¦æ˜¯ Cè¯­è¨€ä¸­çš„æ¡ä»¶ï¼ˆä¸‰å…ƒï¼‰è¿ç®—ç¬¦ã€‚</p>
<p>condition ? thenArm : elseArm;</p>
</blockquote>
<h3 id="42-comparison-and-equality"><a class="header" href="#42-comparison-and-equality">4.2 Comparison and equality</a></h3>
<p>æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œç›¸ç­‰</p>
<p>Moving along, we have a few more operators that always return a Boolean result. We can compare numbers (and only numbers), using Ye Olde Comparison Operators.</p>
<pre><code>less &lt; than;
lessThan &lt;= orEqual;
greater &gt; than;
greaterThan &gt;= orEqual;
</code></pre>
<p>We can test two values of any kind for equality or inequality. Even different types. Values of different types are never equivalent.</p>
<pre><code>1 == 2;         // false.
&quot;cat&quot; != &quot;dog&quot;; // true.
314 == &quot;pi&quot;; // false.
123 == &quot;123&quot;; // false.
</code></pre>
<p>Iâ€™m generally against implicit conversions.</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†ä»‹ç»å‡ ä¸ªè¿”å›å¸ƒå°”å€¼çš„è¿ç®—ç¬¦ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œæ¯”è¾ƒå¹¶ä¸”ä»…ä»…æ¯”è¾ƒæ•°å€¼</p>
<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥æ¯”è¾ƒä¸¤ä¸ªä»»æ„ç±»å‹çš„æ•°æ®ï¼Œæ˜¯å¦ç›¸ç­‰, ç”šè‡³è¿™ä¸¤ä¸ªæ•°æ®ï¼Œä¸æ˜¯ç›¸åŒçš„ç±»å‹ã€‚ä¸åŒæ•°æ®ç±»å‹çš„ä¸¤ä¸ªæ•°æ®ï¼Œè‚¯å®šæ˜¯ä¸æƒ³ç­‰çš„ğŸ¤”ã€‚</p>
<p>é€šå¸¸ï¼Œæˆ‘ä»¬ä¸å»ºè®®ä½¿ç”¨éšå¼è½¬æ¢ã€‚</p>
<h3 id="43-logical-operators"><a class="header" href="#43-logical-operators">4.3 Logical operators</a></h3>
<ol>
<li>
<p>The not operator, a prefix !, returns false if its operand is true, and vice versa.</p>
<pre><code>
!true;  // false.
!false; // true.

</code></pre>
</li>
<li>
<p>The other two logical operators really are control flow constructs in the guise of expressions. An and expression determines if two values are both true. It returns the left operand if itâ€™s false, or the right operand otherwise.</p>
<pre><code>
true and false; // false.
true and true;  // true.

</code></pre>
</li>
<li>
<p>And an or expression determines if either of two values (or both) are true. It returns the left operand if it is true and the right operand otherwise.</p>
</li>
</ol>
<p>The reason and and or are like control flow structures is that they short-circuit. Not only does and return the left operand if it is false, it doesnâ€™t even evaluate the right one in that case. Conversely (contrapositively?), if the left operand of an or is true, the right is skipped.</p>
<p>é€»è¾‘è¿ç®—</p>
<ol>
<li>
<p>é€»è¾‘éè¿ç®—ç¬¦ï¼Œä½¿ç”¨ ï¼è¡¨ç¤ºï¼Œå¦‚æœæ“ä½œæ•°æ˜¯trueï¼Œåˆ™æ·»åŠ é€»è¾‘éçš„è¡¨è¾¾å¼ï¼Œå€¼ä¸ºfalseï¼Œåä¹‹äº¦ç„¶ã€‚</p>
<pre><code>
!true;  // false.
!false; // true.

</code></pre>
</li>
<li>
<p>å¦å¤–ä¸¤ä¸ªé€»è¾‘è¿ç®—ç¬¦ï¼Œä¸å…¶è¯´æ˜¯è¡¨è¾¾å¼ï¼Œæ›´åŠ å‡†ç¡®çš„è¯´æ³•æ˜¯ï¼Œæ§åˆ¶æµã€‚</p>
<p>and é€»è¾‘è¿ç®—ç¬¦ï¼Œå°†ç¡®å®šä¸¤ä¸ªæ“ä½œæ•°ï¼Œæ˜¯å¦éƒ½æ˜¯trueï¼Œå¦‚æœå·¦æ“ä½œæ•°æ˜¯falseï¼Œ åˆ™è¡¨è¾¾å¼è¿”å›å·¦æ“ä½œæ•°çš„å€¼ï¼›å¦‚æœå·¦æ“ä½œæ•°ä¸ºtrueï¼Œåˆ™è¡¨è¾¾å¼è¿”å›å³æ“ä½œæ•°çš„å€¼ã€‚</p>
<pre><code>
true and false; // false.
true and true;  // true.

</code></pre>
</li>
<li>
<p>or é€»è¾‘è¿ç®—ç¬¦ï¼Œå°†ç¡®å®šä¸¤ä¸ªæ“ä½œæ•°ï¼Œæ˜¯å¦åŒ…å«trueï¼Œå¦‚æœå·¦æ“ä½œæ•°ä¸ºtrueï¼Œåˆ™è¡¨è¾¾å¼ç»“æœï¼Œè¿”å›å·¦æ“ä½œæ•°ï¼›å¦‚æœå·¦æ“ä½œæ•°ä¸ºfalseï¼Œè¡¨è¾¾å¼å°†ä¼šè¿”å›å³æ“ä½œæ•°çš„å€¼ã€‚</p>
<pre><code>
false or false; // false.
true or false;  // true.

</code></pre>
</li>
</ol>
<p>and å’Œ or é€»è¾‘è¿ç®—ç¬¦ï¼Œæœ¬è´¨ä¸Šæ˜¯æ§åˆ¶æµç»“æ„çš„åŸå› æ˜¯ï¼Œå®ƒä»¬æ˜¯çŸ­è·¯ã€‚å½“é€»è¾‘è¿ç®—ç¬¦æ˜¯ andï¼Œå·¦æ“ä½œæ•°å€¼ä¸º falseï¼Œæˆ‘ä»¬ç”šè‡³ä¸ä¼šå»è®¡ç®—å³æ“ä½œæ•°ï¼Œç›´æ¥è¿”å›å·¦æ“ä½œæ•°çš„å€¼ã€‚å¦‚æœé€»è¾‘è¿ç®—ç¬¦æ˜¯ orï¼Œå·¦æ“ä½œæ•°å€¼ä¸º trueï¼ŒåŒæ ·çš„ï¼Œæˆ‘ä»¬ä¸ä¼šå»è®¡ç®—å³æ“ä½œæ•°ï¼Œç›´æ¥è¿”å›å·¦æ“ä½œæ•°çš„å€¼ã€‚</p>
<h3 id="44-precedence-and-grouping"><a class="header" href="#44-precedence-and-grouping">4.4 Precedence and grouping</a></h3>
<p>ä¼˜å…ˆçº§å’Œåˆ†ç»„</p>
<p>All of these operators have the same precedence and associativity that youâ€™d expect coming from C. (When we get to parsing, weâ€™ll get way more precise about that.) In cases where the precedence isnâ€™t what you want, you can use () to group stuff.</p>
<pre><code>
var average = (min + max) / 2;

</code></pre>
<p>Since they arenâ€™t very technically interesting, Iâ€™ve cut the remainder of the typical operator menagerie out of our little language. </p>
<p>æ‰€æœ‰è¿™äº›è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å’Œå…³è”æ€§ï¼Œå’ŒCè¯­è¨€ä¸­çš„ç›¸åŒã€‚å½“æˆ‘ä»¬è¿›å…¥è§£æè¿‡ç¨‹æ—¶å€™ï¼Œå°†ä¼šæ›´åŠ ç†è§£è¿™ä¸€ç‚¹ã€‚å¦‚æœï¼Œä¼˜å…ˆçº§ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼Œå¯ä»¥ä½¿ç”¨ ï¼ˆï¼‰å¯¹å†…å®¹è¿›è¡Œåˆ†ç»„ã€‚</p>
<p>å› ä¸ºåœ¨æŠ€æœ¯ä¸Šä¸å¤ªæœ‰è¶£ï¼Œåœ¨Loxè¯­è¨€ä¸­ï¼Œæˆ‘åˆ é™¤äº†ä¸€äº›å…¸å‹çš„è¿ç®—ç¬¦ï¼Œä¾‹å¦‚ï¼šä½è¿ç®—ï¼Œä½ç§»ï¼Œå–æ¨¡ï¼Œæ¡ä»¶è¿ç®—ç¬¦ç­‰ã€‚æˆ‘ä¸ä¼šè®©ä½ ä»¬è¯„åˆ†ï¼Œä½†æ˜¯å¦‚æœä½ åœ¨Loxè¯­è¨€å®ç°ä¸­ï¼Œæ·»åŠ äº†è¿™äº›è¿ç®—ç¬¦ï¼Œåœ¨æˆ‘å¿ƒä¸­ï¼Œä½ å°†ä¼šå¤§å¤§åŠ åˆ†ã€‚</p>
<p>Those are the expression forms (except for a couple related to specific features that weâ€™ll get to later), so letâ€™s move up a level.</p>
<p>ä¸Šé¢ä»‹ç»äº†è¡¨è¾¾å¼å½¢å¼ï¼Œé™¤äº†ä¸€äº›æˆ‘ä»¬ä¸‹é¢å°†è¦ä»‹ç»çš„ã€ä¸ç‰¹å®šåŠŸèƒ½ç›¸å…³çš„è¡¨è¾¾å¼ï¼Œè®©æˆ‘ä»¬ç»§ç»­å­¦ä¹ ã€‚</p>
<h2 id="äº”statements"><a class="header" href="#äº”statements">äº”ã€Statements</a></h2>
<p>è¯­å¥</p>
<p>Now weâ€™re at statements. Where an expressionâ€™s main job is to produce a value, a statementâ€™s job is to produce an effect. Since, by definition, statements donâ€™t evaluate to a value, to be useful they have to otherwise change the world in some wayâ€”usually modifying some state, reading input, or producing output.</p>
<p>Youâ€™ve seen a couple of kinds of statements already. The first one was:</p>
<pre><code>
print &quot;Hello, world!&quot;;

</code></pre>
<p>A print statement evaluates a single expression and displays the result to the user. Youâ€™ve also seen some statements like:</p>
<pre><code>
&quot;some expression&quot;;

</code></pre>
<p>An expression followed by a semicolon (;) promotes the expression to statement-hood. This is called (imaginatively enough), an expression statement.</p>
<p>If you want to pack a series of statements where a single one is expected, you can wrap them up in a block.</p>
<pre><code>
{
  print &quot;One statement.&quot;;
  print &quot;Two statements.&quot;;
}

</code></pre>
<p>Blocks also affect scoping, which leads us to the next sectionâ€‰.â€‰.â€‰. </p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å¼€å§‹å­¦ä¹ è¯­å¥ã€‚è¡¨è¾¾å¼çš„ä¸»è¦ä½œç”¨æ˜¯ç”Ÿæˆå€¼ï¼Œè¯­å¥çš„ä¸»è¦ä»»åŠ¡æ˜¯äº§ç”Ÿæ•ˆæœã€‚å› ä¸ºï¼Œè¯­å¥çš„ç»“æœä¸æ˜¯ä¸€ä¸ªå…·ä½“çš„å€¼ï¼Œæ‰€ä»¥ï¼Œä¸ºäº†èƒ½å¤Ÿæœ‰å½±å“ï¼Œè¯­å¥çš„ç»“æœå¿…é¡»å¯ä»¥ä»¥æŸç§æ–¹å¼æ”¹å˜ç¼–ç¨‹ä¸–ç•Œï¼Œä¾‹å¦‚ï¼šä¿®æ”¹æŸäº›çŠ¶æ€ï¼Œè¯»å–ç”¨æˆ·è¾“å…¥ï¼Œäº§ç”Ÿè¾“å‡ºã€‚</p>
<p>ä½ å·²ç»çœ‹åˆ°äº†å‡ ç§ä¸åŒç±»å‹çš„è¯­å¥ï¼Œä¾‹å¦‚:</p>
<pre><code>
print &quot;Hello, world!&quot;;

</code></pre>
<p>ä¸€ä¸ªprintè¯­å¥ï¼Œè®¡ç®—å‡ºå•ä¸ªè¡¨è¾¾å¼ï¼Œå¹¶ä¸”å‘ç”¨æˆ·å±•ç¤ºè®¡ç®—ç»“æœã€‚</p>
<p>è¿˜æœ‰ä¸€äº›å…¶ä»–ç±»å‹çš„è¯­å¥ï¼Œä¾‹å¦‚ï¼š</p>
<pre><code>
&quot;some expression&quot;;

</code></pre>
<p>è¡¨è¾¾å¼åé¢åŠ ä¸Š ; è¯¥è¡¨è¾¾å¼ä¼šå˜ä¸ºè¡¨è¾¾å¼è¯­å¥ã€‚</p>
<p>å¦‚æœæƒ³å°†ä¸€ç³»åˆ—è¯­å¥ï¼Œç»„åˆä¸ºä¸€æ¡è¯­å¥ï¼Œå¯ä»¥ä½¿ç”¨{}, å°†è¿™äº›è¯­å¥æ‰“åŒ…ä¸ºä¸€ä¸ªå—</p>
<pre><code>
{
  print &quot;One statement.&quot;;
  print &quot;Two statements.&quot;;
}

</code></pre>
<p>è¯­æ³•å—ï¼Œè¿˜å½±å“ç”Ÿå‘½å‘¨æœŸï¼Œé©¬ä¸Šæˆ‘ä»¬å°†ä¼šçœ‹åˆ°ã€‚</p>
<blockquote>
<p>Baking print into the language instead of just making it a core library function is a hack. But itâ€™s a useful hack for us: it means our in-progress interpreter can start producing output before weâ€™ve implemented all of the machinery required to define functions, look them up by name, and call them.</p>
<p>Loxè¯­è¨€ä¸­ï¼Œå°†printè¡¨ç¤ºä¸ºè¯­å¥ï¼Œè€Œä¸æ˜¯æ ¸å¿ƒå‡½æ•°åº“ä¸­çš„ä¸€ä¸ªprintå‡½æ•°ï¼Œæ˜¯ä¸€ç§é»‘å®¢è¡Œä¸ºã€‚è¿™å¯¹æˆ‘ä»¬æ¥è¯´æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æŠ€å·§ï¼šè¿™æ„å‘³ç€ï¼Œè§£é‡Šå™¨è¿è¡Œæ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å®šä¹‰å‡½æ•°ä¹‹å‰ï¼Œå®ç°è¾“å‡ºåŠŸèƒ½ã€‚æŒ‰ç…§åç§°æŸ¥æ‰¾å¹¶ä¸”è°ƒç”¨å®ƒä»¬ã€‚</p>
</blockquote>
<h2 id="å…­variables"><a class="header" href="#å…­variables">å…­ã€Variables</a></h2>
<p>å˜é‡</p>
<p>You declare variables using var statements. If you omit the initializer, the variableâ€™s value defaults to nil.</p>
<pre><code>
var imAVariable = &quot;here is my value&quot;;
var iAmNil;

</code></pre>
<p>Once declared, you can, naturally, access and assign a variable using its name.</p>
<pre><code>
var breakfast = &quot;bagels&quot;;
print breakfast; // &quot;bagels&quot;.
breakfast = &quot;beignets&quot;;
print breakfast; // &quot;beignets&quot;.

</code></pre>
<p>I wonâ€™t get into the rules for variable scope here, because weâ€™re going to spend a surprising amount of time in later chapters mapping every square inch of the rules. In most cases, it works like you would expect coming from C or Java.</p>
<p>å¯ä»¥ä½¿ç”¨ varè¯­å¥ï¼Œå£°æ˜å˜é‡ã€‚å¦‚æœå˜é‡çœç•¥åˆå§‹åŒ–ï¼Œè¯¥å˜é‡çš„é»˜è®¤å€¼æ˜¯nilã€‚</p>
<p>ä¸€æ—¦å£°æ˜ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å˜é‡åï¼Œè®¿é—®å’Œåˆ†é…å˜é‡ã€‚</p>
<p>åœ¨å½“å‰ç« èŠ‚ï¼Œæˆ‘ä¸ä¼šè®¨è®ºå˜é‡çš„æœ‰æ•ˆä½¿ç”¨èŒƒå›´ï¼Œå› ä¸ºï¼Œæˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­ï¼ŒèŠ±è´¹å¾ˆå¤šç¯‡å¹…è®²è§£å˜é‡çš„ä½¿ç”¨èŒƒå›´ã€‚åœ¨å¤šæ•°åœºæ™¯ä¸‹ï¼ŒLoxè¯­è¨€ä¸­ï¼Œå˜é‡çš„ä½¿ç”¨èŒƒå›´å’Œ C/Javaè¯­è¨€ä¸­çš„è§„åˆ™ç›¸åŒã€‚</p>
<blockquote>
<p>This is one of those cases where not having nil and forcing every variable to be initialized to some value would be more annoying than dealing with nil itself.</p>
<p>è¿™æ˜¯nilå­˜åœ¨çš„ä¸€ç§å¥½å¤„ï¼Œå¦‚æœæˆ‘ä»¬å¼ºåˆ¶è¦æ±‚ä»»æ„çš„å˜é‡ï¼Œéƒ½å¿…é¡»åˆå§‹åŒ–ä¸ºå…·ä½“å€¼ï¼Œé‚£ä¹ˆï¼Œè¿™ä¸ªå¼ºåˆ¶åˆå§‹åŒ–çš„è¿‡ç¨‹æ¯”æˆ‘ä»¬å®šä¸€ä¸ªä¸€ä¸ªnilç±»å‹ï¼Œæ›´åŠ éº»çƒ¦ã€‚</p>
<p>Can you tell that I tend to work on this book in the morning before Iâ€™ve had anything to eat?</p>
<p>ä½ å¯ä»¥çœ‹å‡ºæ¥æˆ‘å€¾å‘äºï¼Œåœ¨åƒæ—©é¤ä¹‹å‰ï¼Œå¼€å§‹å†™ä¸€ä¼šå„¿ä¹¦å—ï¼ŸğŸ˜‚</p>
</blockquote>
<h2 id="ä¸ƒcontrol-flow"><a class="header" href="#ä¸ƒcontrol-flow">ä¸ƒã€Control Flow</a></h2>
<p>æ§åˆ¶æµ</p>
<p>Itâ€™s hard to write useful programs if you canâ€™t skip some code or execute some more than once. That means control flow. In addition to the logical operators we already covered, Lox lifts three statements straight from C.</p>
<ol>
<li>
<p><strong>if</strong></p>
<p>An if statement executes one of two statements based on some condition.</p>
<pre><code>
if (condition) {
  print &quot;yes&quot;;
} else {
  print &quot;no&quot;;
}

</code></pre>
</li>
<li>
<p><strong>while</strong></p>
<p>A while loop executes the body repeatedly as long as the condition expression evaluates to true.</p>
<pre><code>
var a = 1;
while (a &lt; 10) {
  print a;
  a = a + 1;
}

</code></pre>
</li>
<li>
<p><strong>for</strong></p>
<p>Finally, we have for loops. This loop does the same thing as the previous while loop. Most modern languages also have some sort of for-in or foreach loop for explicitly iterating over various sequence types. In a real language, thatâ€™s nicer than the crude C-style for loop we got here. Lox keeps it basic.</p>
<pre><code>
for (var a = 1; a &lt; 10; a = a + 1) {
  print a;
}

</code></pre>
</li>
</ol>
<blockquote>
<p>We already have and and or for branching, and we could use recursion to repeat code, so thatâ€™s theoretically sufficient. It would be pretty awkward to program that way in an imperative-styled language, though.</p>
<p>æˆ‘ä»¬å·²ç»æœ‰äº† and å’Œ or é€»è¾‘è¿ç®—ç¬¦ï¼Œå¦‚æœåœ¨åŠ ä¸Šé€’å½’è°ƒç”¨å‡½æ•°ï¼Œç†è®ºä¸Šå¯ä»¥å®ç°é‡å¤æ‰§è¡Œä»£ç ã€‚ä½†æ˜¯ï¼Œè¿™ç§å‡½æ•°å¼ç¼–ç¨‹æ–¹å¼ï¼Œéå¸¸éš¾ä½¿ç”¨ã€‚</p>
</blockquote>
<blockquote>
<p>Scheme, on the other hand, has no built-in looping constructs. It does rely on recursion for repetition. Smalltalk has no built-in branching constructs, and relies on dynamic dispatch for selectively executing code.</p>
<p>lispçš„æ–¹è¨€ï¼Œscheme, æ²¡æœ‰å†…ç½®çš„å¾ªç¯è¯­å¥ã€‚å®ƒä¾èµ–é€’å½’æ‰§è¡Œï¼Œå®ç°å¤ç”¨ä»£ç ã€‚Smalltalkè¯­è¨€ï¼Œæ²¡æœ‰å†…ç½®çš„åˆ†æ”¯è¯­å¥ï¼Œå®ƒä¾èµ–åŠ¨æ€è°ƒåº¦ï¼Œæ¥é€‰æ‹©æ€§çš„æ‰§è¡Œä»£ç ã€‚</p>
</blockquote>
<blockquote>
<p>I left do while loops out of Lox because they arenâ€™t that common and wouldnâ€™t teach you anything that you wonâ€™t already learn from while. Go ahead and add it to your implementation if it makes you happy. Itâ€™s your party.</p>
<p>æˆ‘æ²¡æœ‰åœ¨Loxè¯­è¨€ä¸­ï¼Œå¼•å…¥ do whileå¾ªç¯è¯­å¥ï¼Œå› ä¸ºï¼Œè¯¥å¾ªç¯è¯­å¥ï¼Œå’Œwhileè¯­å¥ï¼Œæ•ˆæœä¸€è‡´ã€‚å¦‚æœä½ æƒ³åœ¨Loxè¯­è¨€ä¸­ï¼Œå®ç°è¯¥è¯­å¥ï¼Œé‚£ä¹ˆéå¸¸æ¬¢è¿ï¼Œå› ä¸ºè¿™æ˜¯ä½ çš„è¯­è¨€ã€‚</p>
</blockquote>
<blockquote>
<p>This is a concession I made because of how the implementation is split across chapters. A for-in loop needs some sort of dynamic dispatch in the iterator protocol to handle different kinds of sequences, but we donâ€™t get that until after weâ€™re done with control flow. We could circle back and add for-in loops later, but I didnâ€™t think doing so would teach you anything super interesting.</p>
<p>è¿™æ˜¯æˆ‘åšå‡ºçš„è®©æ­¥ï¼Œæˆ‘å°†åœ¨åé¢çš„ç« èŠ‚ä¸­ï¼Œæ·»åŠ  for-in å¾ªç¯è¯­å¥ã€‚æˆ‘ä»¬éœ€è¦åœ¨è¿­ä»£å™¨ä¸­ï¼Œæ ¹æ®ä¸åŒçš„æ•°æ®ç±»å‹ï¼ŒåŠ¨æ€è°ƒåº¦è¯¥æ•°æ®åºåˆ—ã€‚è™½ç„¶ï¼Œæˆ‘ä»¬æ·»åŠ äº† for-inè¯­å¥ï¼Œä½†æ˜¯æˆ‘å¹¶ä¸è®¤ä¸ºï¼Œè¿™ä¸ªè¯­å¥éå¸¸æœ‰è¶£ã€‚</p>
</blockquote>
<p>å¦‚æœè¯­è¨€ä¸æ”¯æŒï¼Œè·³è¿‡æ‰§è¡ŒæŸäº›ä»£ç æˆ–è€…é‡å¤æ‰§è¡ŒæŸäº›ä»£ç ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬å¾ˆéš¾å†™å‡ºæœ‰ç”¨çš„ç¨‹åºã€‚è€Œè¿™äº›ï¼Œè¡¨æ˜æˆ‘ä»¬éœ€è¦å¼•å…¥æ§åˆ¶æµã€‚é™¤äº†ä¸Šé¢ä»‹ç»çš„é€»è¾‘è¿ç®—ç¬¦ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜ä»Cè¯­è¨€ä¸­ç›´æ¥å€Ÿç”¨äº†3ç§æ§åˆ¶æµã€‚</p>
<ol>
<li>
<p>if</p>
<p>ifè¯­å¥ï¼Œæ ¹æ®æ¡ä»¶ï¼Œé€‰æ‹©æ‰§è¡Œå…¶ä¸­çš„ä¸€ä¸ªè¯­å¥ã€‚</p>
<pre><code>
if (condition) {
 print &quot;yes&quot;;
} else {
 print &quot;no&quot;;
}

</code></pre>
</li>
<li>
<p>while</p>
<p>åªè¦while è¯­å¥ä¸­ï¼Œè¡¨è¾¾å¼æ‰§è¡Œç»“æœä¸ºtrueï¼Œå¾ªç¯è¯­å¥ä¼šä¸€ç›´æ‰§è¡Œã€‚</p>
<pre><code>
var a = 1;
while (a &lt; 10) {
  print a;
  a = a + 1;
}

</code></pre>
</li>
<li>
<p>for</p>
<p>æœ€åï¼Œæˆ‘ä»¬ä»‹ç»for å¾ªç¯è¯­å¥ã€‚</p>
<pre><code>
for (var a = 1; a &lt; 10; a = a + 1) {
  print a;
}

</code></pre>
<p>forå¾ªç¯è¯­å¥ï¼Œå’Œ whileå¾ªç¯è¯­å¥ï¼Œæ•ˆæœç›¸åŒã€‚å¤§å¤šæ•°ç°ä»£è¯­å¥ï¼Œè¿˜æ”¯æŒfor-inï¼Œforeachè¯­å¥ï¼Œç”¨äºè¿­ä»£å„ç§åºåˆ—ç±»å‹æ•°æ®ã€‚åœ¨å®é™…ç¼–ç¨‹ä¸­ï¼Œè¿™ç§æ–°çš„è¯­å¥ï¼Œæ¯”Cè¯­è¨€çš„forè¯­å¥ï¼Œæ›´åŠ ç®€æ´ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬Loxè¯­è¨€ï¼Œå°†ä¿æŒæœ€åŸå§‹çš„forè¯­å¥ã€‚</p>
</li>
</ol>
<h2 id="å…«-functions"><a class="header" href="#å…«-functions">å…«ã€ Functions</a></h2>
<p>å‡½æ•°</p>
<p>A function call expression looks the same as it does in C.</p>
<pre><code>
makeBreakfast(bacon, eggs, toast);

</code></pre>
<p>You can also call a function without passing anything to it.</p>
<pre><code>
makeBreakfast();

</code></pre>
<p>Unlike in, say, Ruby, the parentheses are mandatory in this case. If you leave them off, the name doesnâ€™t call the function, it just refers to it.</p>
<p>A language isnâ€™t very fun if you canâ€™t define your own functions. In Lox, you do that with fun.</p>
<pre><code>
fun printSum(a, b) {
  print a + b;
}

</code></pre>
<p>å‡½æ•°è°ƒç”¨è¡¨è¾¾å¼å’ŒCè¯­è¨€ä¸­ä¸€æ ·ã€‚</p>
<pre><code>
makeBreakfast(bacon, eggs, toast);

</code></pre>
<p>ä¹Ÿå¯ä»¥åœ¨ä¸ä¼ é€’ä»»ä½•å‚æ•°çš„æƒ…å†µä¸‹ï¼Œè°ƒç”¨å‡½æ•°</p>
<pre><code>
makeBreakfast();

</code></pre>
<p>ä¸ Rubyè¯­è¨€ä¸ä¸€æ ·ï¼Œåœ¨è¿™ç§åœºæ™¯ï¼Œæ‹¬å·æ˜¯å¿…é¡»çš„ï¼Œå¦‚æœä¸ä½¿ç”¨æ‹¬å·ï¼Œä¸ä¼šå®é™…è°ƒç”¨å‡½æ•°ï¼Œè€Œåªä¼šå¼•ç”¨å‡½æ•°ã€‚</p>
<p>å¦‚æœä¸€é—¨è¯­è¨€æ— æ³•è‡ªå®šä¹‰å‡½æ•°ï¼Œé‚£ä¹ˆè¿™é—¨è¯­è¨€ä¹Ÿä¸ä¼šéå¸¸æœ‰æ„ä¹‰ã€‚åœ¨Loxè¯­è¨€ä¸­ï¼Œä½¿ç”¨ fun å®šä¹‰ä¸€ä¸ªå‡½æ•°ã€‚</p>
<pre><code>
fun printSum(a, b) {
  print a + b;
}

</code></pre>
<p>Nowâ€™s a good time to clarify some terminology. Some people throw around â€œparameterâ€ and â€œargumentâ€ like they are interchangeable and, to many, they are. Weâ€™re going to spend a lot of time splitting the finest of downy hairs around semantics, so letâ€™s sharpen our words. From here on out:</p>
<ul>
<li>
<p>An argument is an actual value you pass to a function when you call it. So a function call has an argument list. Sometimes you hear actual parameter used for these.</p>
</li>
<li>
<p>A parameter is a variable that holds the value of the argument inside the body of the function. Thus, a function declaration has a parameter list. Others call these formal parameters or simply formals.</p>
</li>
</ul>
<p>The body of a function is always a block. Inside it, you can return a value using a return statement.</p>
<pre><code>
fun returnSum(a, b) {
  return a + b;
}

</code></pre>
<p>If execution reaches the end of the block without hitting a return, it implicitly returns nil.</p>
<p>ç°åœ¨æ˜¯æ¾„æ¸…ä¸€äº›æœ¯è¯­çš„å¥½æ—¶æœºã€‚æœ‰äº›äººï¼Œæ€»ä¼šéšæ„çš„ä½¿ç”¨ parameter å’Œ argument ä¸¤ä¸ªæœ¯è¯­ï¼Œå¾ˆå¤šäººä¼šè®¤ä¸ºè¿™ä¸¤ä¸ªæœ¯è¯­å«ä¹‰ç›¸åŒï¼Œä½†æ˜¯å…¶å®ï¼Œå®ƒä»¬ä¹‹é—´æœ‰ä¸€äº›ä¸åŒä¹‹å¤„ï¼š</p>
<ul>
<li>
<p>argument æ˜¯è°ƒç”¨å‡½æ•°æ—¶å€™ï¼Œä¼ é€’ç»™å‡½æ•°çš„å®é™…å€¼ï¼Œäººä»¬ä¸€èˆ¬ç§°ä¸º å®å‚ï¼Œå‡½æ•°è°ƒç”¨æ—¶å€™ï¼Œä¼šä¼ é€’ä¸€ç³»åˆ—çš„å‚æ•°åˆ—è¡¨ï¼Œç§°ä¸ºå®å‚åˆ—è¡¨</p>
</li>
<li>
<p>parameter æ˜¯å®šä¹‰å‡½æ•°æ—¶å€™ï¼Œä¿å­˜å‚æ•°å€¼çš„å˜é‡ï¼Œäººä»¬ä¸€èˆ¬ç§°ä¸º å½¢å‚ï¼Œå‡½æ•°å®šä¹‰çš„æ—¶å€™ï¼Œä¼šå®šä¹‰ä¸€ç³»åˆ—çš„å‚æ•°åˆ—è¡¨ï¼Œç§°ä¸ºå½¢å‚åˆ—è¡¨ã€‚</p>
</li>
</ul>
<p>å‡½æ•°ä½“å§‹ç»ˆæ˜¯ä¸€ä¸ªä»£ç å—ã€‚åœ¨å‡½æ•°ä½“ä¸­ï¼Œå¯ä»¥ä½¿ç”¨return å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ªå€¼ã€‚</p>
<pre><code>
fun returnSum(a, b) {
  return a + b;
}

</code></pre>
<p>å¦‚æœå‡½æ•°æ‰§è¡Œåˆ°æœ«å°¾ï¼Œæ²¡æœ‰returnè¯­å¥ï¼Œä¼šéšå¼çš„è¿”å› nil</p>
<blockquote>
<p>See, I told you nil would sneak in when we werenâ€™t looking.</p>
<p>çœ‹å§ï¼Œæˆ‘å°±è¯´è¿‡ nil æ€»ä¼šåœ¨æˆ‘ä»¬ä¸æ³¨æ„çš„æ—¶å€™ï¼Œå·å·æºœè¿›æ¥ã€‚</p>
</blockquote>
<blockquote>
<p>Iâ€™ve seen languages that use fn, fun, func, and function. Iâ€™m still hoping to discover a funct, functi, or functio somewhere.</p>
<p>æˆ‘å·²ç»è§è¿‡å…¶ä»–è¯­è¨€ä¸­ï¼Œä½¿ç”¨fn fun func function å…³é”®å­—å®šä¹‰å‡½æ•°ï¼Œæˆ‘è¿˜åœ¨æœŸå¾…ï¼Œæœ‰è¯­è¨€ä½¿ç”¨å…³é”®è¯ funct functi functio</p>
</blockquote>
<blockquote>
<p>Speaking of terminology, some statically typed languages like C make a distinction between declaring a function and defining it. A declaration binds the functionâ€™s type to its name so that calls can be type-checked but does not provide a body. A definition declares the function and also fills in the body so that the function can be compiled</p>
<p>è¯´åˆ°æœ¯è¯­ï¼Œä¸€äº›é™æ€ç±»å‹è¯­è¨€ï¼Œä¾‹å¦‚ï¼šCè¯­è¨€ï¼Œåœ¨å‡½æ•°å£°æ˜å’Œå‡½æ•°å®šä¹‰ä¹‹é—´æœ‰ä¸åŒä¹‹å¤„ã€‚å‡½æ•°å£°æ˜ï¼Œå‡½æ•°åç§°å…³è”ç€å‚æ•°ç±»å‹ï¼Œä»¥ä¾¿å†è°ƒç”¨å‡½æ•°æ—¶å€™ï¼Œæ£€æŸ¥å‚æ•°ç±»å‹ï¼Œä½†æ˜¯ä¸å®šä¹‰å‡½æ•°ä½“ã€‚å‡½æ•°å®šä¹‰ï¼Œåœ¨å£°æ˜å‡½æ•°çš„åŒæ—¶ï¼Œè¿˜ä¼šå®šä¹‰å‡½æ•°ä½“ï¼Œä»¥ä¾¿å¯ä»¥ç¼–è¯‘å‡½æ•°ã€‚</p>
</blockquote>
<blockquote>
<p>Since Lox is dynamically typed, this distinction isnâ€™t meaningful. A function declaration fully specifies the function including its body.</p>
<p>å› ä¸ºLoxæ˜¯ä¸€é—¨åŠ¨æ€è¯­è¨€ï¼Œå‡½æ•°å£°æ˜å’Œå‡½æ•°å®šä¹‰æ²¡æœ‰åŒºåˆ«ï¼Œå‡½æ•°å£°æ˜éœ€è¦æŒ‡å®šå‡½æ•°ä½“ã€‚</p>
</blockquote>
<h3 id="81-closures"><a class="header" href="#81-closures">8.1 Closures</a></h3>
<p>é—­åŒ…</p>
<p>Functions are first class in Lox, which just means they are real values that you can get a reference to, store in variables, pass around, etc. This works:</p>
<pre><code>
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints &quot;3&quot;.

</code></pre>
<p>Since function declarations are statements, you can declare local functions inside another function.</p>
<pre><code>
fun outerFunction() {
  fun localFunction() {
    print &quot;I'm local!&quot;;
  }

  localFunction();
}


</code></pre>
<p>å‡½æ•°æ˜¯Loxè¯­è¨€ä¸­çš„ç¬¬ä¸€ç±»å˜é‡ï¼Œè¿™æ„å‘³ç€å®ƒä»¬æ˜¯æ‹¥æœ‰å®é™…å€¼çš„å˜é‡ã€‚æˆ‘ä»¬å¯ä»¥å¼•ç”¨/å­˜å‚¨/ä¼ é€’è¿™äº›å‡½æ•°ã€‚</p>
<pre><code>
fun addPair(a, b) {
  return a + b;
}

fun identity(a) {
  return a;
}

print identity(addPair)(1, 2); // Prints &quot;3&quot;.

</code></pre>
<p>å› ä¸ºå‡½æ•°å£°æ˜æ˜¯è¯­å¥ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å‡½æ•°ä¸­ï¼Œå®šä¹‰å†…éƒ¨å‡½æ•°</p>
<pre><code>
fun outerFunction() {
  fun localFunction() {
    print &quot;I'm local!&quot;;
  }

  localFunction();
}


</code></pre>
<p>If you combine local functions, first-class functions, and block scope, you run into this interesting situation:</p>
<pre><code>
fun returnFunction() {
  var outside = &quot;outside&quot;;

  fun inner() {
    print outside;
  }

  return inner;
}

var fn = returnFunction();
fn();

</code></pre>
<p>Here, inner() accesses a local variable declared outside of its body in the surrounding function. Is this kosher? Now that lots of languages have borrowed this feature from Lisp, you probably know the answer is yes.</p>
<p>For that to work, inner() has to â€œhold onâ€ to references to any surrounding variables that it uses so that they stay around even after the outer function has returned. We call functions that do this closures. These days, the term is often used for any first-class function, though itâ€™s sort of a misnomer if the function doesnâ€™t happen to close over any variables</p>
<p>As you can imagine, implementing these adds some complexity because we can no longer assume variable scope works strictly like a stack where local variables evaporate the moment the function returns. Weâ€™re going to have a fun time learning how to make these work correctly and efficiently.</p>
<p>å¦‚æœå°†å±€éƒ¨å‡½æ•°ã€ä¸€çº§å‡½æ•°ã€ä»£ç å—ä½œç”¨åŸŸç»„åˆåœ¨ä¸€èµ·ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°ä¸€äº›æœ‰æ„æ€çš„åœ°æ–¹ï¼š</p>
<pre><code>
fun returnFunction() {
  var outside = &quot;outside&quot;;

  fun inner() {
    print outside;
  }

  return inner;
}

var fn = returnFunction();
fn();

</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œinnerå‡½æ•°ï¼Œè°ƒç”¨äº†å¤–å±‚å‡½æ•°ä¸­çš„å±€éƒ¨å˜é‡ outside, è¿™æ ·ä¼šæŠ¥é”™å—ï¼Ÿå¾ˆå¤šè¯­è¨€éƒ½å€Ÿé‰´äº† lisp è¯­è¨€çš„è¿™ç§ç‰¹æ€§ï¼Œç­”æ¡ˆæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¤–å±‚å‡½æ•°ä¸­çš„å±€éƒ¨å˜é‡ã€‚</p>
<p>ä¸ºæ­¤ï¼Œinnerå‡½æ•°ï¼Œå¿…é¡»åŒ…å«å¯¹äºå‘¨å›´å˜é‡çš„å¼•ç”¨ï¼Œè¿™æ ·å³ä½¿å¤–éƒ¨å‡½æ•°å·²ç»è¿”å›ï¼Œè¿™äº›å±€éƒ¨å˜é‡ä»ç„¶ä¼šä¿ç•™ã€‚æˆ‘ä»¬å°†å®ç°äº†è¿™ä¸ªåŠŸèƒ½çš„å‡½æ•°é—­åŒ…ã€‚ç°å¦‚ä»Šï¼Œè¿™ä¸ªæœ¯è¯­ï¼Œé—­åŒ…ï¼Œç»å¸¸ç”¨äºç¬¬ä¸€ç±»å‡½æ•°ï¼Œå°½ç®¡å¦‚ä½•å‡½æ•°æ²¡æœ‰åœ¨ä»»ä½•å˜é‡ä¸Šé—­åˆï¼Œè¿™ä¸ªç”¨è¯æœ‰äº›ä¸å¤ªåˆé€‚ã€‚</p>
<p>å¯ä»¥æƒ³è±¡ï¼Œå®ç°è¿™ä¸ªé—­åŒ…åŠŸèƒ½ï¼Œä¼šå¢åŠ ä¸€äº›å¤æ‚æ€§ï¼Œå› ä¸ºæˆ‘ä»¬ä¸èƒ½å‡è®¾å˜é‡ï¼Œä¸¥æ ¼çš„åƒå †æ ˆä¸€æ ·å·¥ä½œï¼Œå½“å‡½æ•°è¿”å›æ—¶å€™ï¼Œå±€éƒ¨å˜é‡å°±æ¶ˆå¤±äº†ã€‚æˆ‘ä»¬å°†æœ‰ä¸€æ®µæ„‰å¿«çš„æ—¶å…‰ï¼Œå­¦ä¹ å¦‚ä½•æ­£ç¡®æœ‰æ•ˆçš„å·¥ä½œã€‚</p>
<blockquote>
<p>Peter J. Landin coined the term â€œclosureâ€. Yes, he invented damn near half the terms in programming languages. Most of them came out of one incredible paper, â€œThe Next 700 Programming Languagesâ€.</p>
<p><a href="https://zh.wikipedia.org/zh-tw/%E5%BD%BC%E5%BE%97%C2%B7%E5%85%B0%E4%B8%81">Peter J. Landin</a> åˆ›é€ äº†é—­åŒ…æ¦‚å¿µï¼Œæ˜¯çš„ï¼Œä»–å‡ ä¹å‘æ˜äº†ä¸€åŠçš„ç¼–ç¨‹è¯­è¨€æœ¯è¯­ï¼Œå…¶ä¸­å¤§éƒ¨åˆ†éƒ½å‡ºè‡ªé‚£è¾¹é‡è¦è®ºæ–‡ <a href="https://github.com/Kua-Fu/blog-book-images/blob/main/paper/The-Next-700-Programming-Languages.pdf">The Next 700 Programming Languages</a></p>
<p>In order to implement these kind of functions, you need to create a data structure that bundles together the functionâ€™s code and the surrounding variables it needs. He called this a â€œclosureâ€ because it closes over and holds on to the variables it needs.</p>
<p>ä¸ºäº†å®ç°è¿™äº›å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œå°†å‡½æ•°ä»£ç å’Œå‡½æ•°æ‰€éœ€è¦å˜é‡ç»‘å®šåœ¨ä¸€èµ·ã€‚ä»–ç§°è¿™ç§æ•°æ®ç»“æ„ä¸ºé—­åŒ…ï¼Œå› ä¸ºå®ƒåŒ…å›´ç€å‡½æ•°ï¼Œå¹¶ä¸”åŒ…å«äº†ç›¸å…³å˜é‡ã€‚</p>
</blockquote>
<h2 id="ä¹classes"><a class="header" href="#ä¹classes">ä¹ã€Classes</a></h2>
<p>ç±»</p>
<p>Since Lox has dynamic typing, lexical (roughly, â€œblockâ€) scope, and closures, itâ€™s about halfway to being a functional language. But as youâ€™ll see, itâ€™s also about halfway to being an object-oriented language. Both paradigms have a lot going for them, so I thought it was worth covering some of each.</p>
<p>Since classes have come under fire for not living up to their hype, let me first explain why I put them into Lox and this book. There are really two questions:</p>
<p>å› ä¸ºLoxè¯­è¨€å…·æœ‰åŠ¨æ€ç±»å‹ï¼Œè¯æ³•èŒƒå›´ã€é—­åŒ…ï¼Œå› æ­¤ï¼Œå®ƒå·²ç»ä¸€éƒ¨åˆ†æ˜¯å‡½æ•°å¼è¯­è¨€äº†ï¼Œä½†æ˜¯ï¼Œæ­£å¦‚æˆ‘ä»¬å°†çœ‹åˆ°çš„ï¼Œå®ƒä¹ŸåŒæ ·å…·æœ‰é¢å‘è¯­è¨€å¯¹è±¡çš„ä¸€éƒ¨åˆ†ç‰¹æ€§ã€‚è¿™ä¸¤ç§è¯­è¨€èŒƒå¼åˆ†åˆ«æœ‰å¾ˆå¤šä¼˜ç‚¹ï¼Œæˆ‘ä»¬å°†ç®€å•ä»‹ç»ä¸€äº›ï¼š</p>
<p>ä¸‹é¢æˆ‘å°†è§£é‡Šä¸€ä¸‹ï¼Œä¸ºä»€ä¹ˆLoxè¯­è¨€å…·æœ‰é¢å‘å¯¹è±¡ç‰¹æ€§ï¼š</p>
<h3 id="91-why-might-any-language-want-to-be-object-oriented"><a class="header" href="#91-why-might-any-language-want-to-be-object-oriented">9.1 Why might any language want to be object oriented?</a></h3>
<p>ä¸ºä»€ä¹ˆæ‰€æœ‰è¯­è¨€éƒ½æƒ³è¦é¢å‘å¯¹è±¡ç‰¹æ€§ï¼Ÿ</p>
<p>Now that object-oriented languages like Java have sold out and only play arena shows, itâ€™s not cool to like them anymore. Why would anyone make a new language with objects? Isnâ€™t that like releasing music on 8-track?</p>
<p>It is true that the â€œall inheritance all the timeâ€ binge of the â€™90s produced some monstrous class hierarchies, but object-oriented programming (OOP) is still pretty rad. Billions of lines of successful code have been written in OOP languages, shipping millions of apps to happy users. Likely a majority of working programmers today are using an object-oriented language. They canâ€™t all be that wrong.</p>
<p>In particular, for a dynamically typed language, objects are pretty handy. We need some way of defining compound data types to bundle blobs of stuff together.</p>
<p>If we can also hang methods off of those, then we avoid the need to prefix all of our functions with the name of the data type they operate on to avoid colliding with similar functions for different types. In, say, Racket, you end up having to name your functions like hash-copy (to copy a hash table) and vector-copy (to copy a vector) so that they donâ€™t step on each other. Methods are scoped to the object, so that problem goes away.</p>
<p>ç°åœ¨ï¼Œé¢å‘å¯¹è±¡è¯­è¨€ï¼Œä¾‹å¦‚Javaï¼Œå·²ç»æ™®éè¢«ä½¿ç”¨ï¼Œè€Œä¸”å·²ç»è¢«æ¥æ”¶åˆ°ä¸»æµç¼–ç¨‹ä¸–ç•Œäº†ï¼Œç°åœ¨åœ¨å–œæ¬¢å®ƒä»¬ï¼Œä¹Ÿä¸æ˜¯å¾ˆé…·çš„äº‹æƒ…äº†ã€‚ä¸ºä»€ä¹ˆè¿˜æœ‰äººç”¨å¯¹è±¡åˆ›é€ ä¸€é—¨æ–°è¯­è¨€ï¼Œè¿™å¥½åƒæ˜¯åœ¨8éŸ³èŠ‚ä¸Šï¼Œå†™å‡ºæ–°çš„æ­Œæ›²ã€‚</p>
<p>è¯šç„¶ï¼Œ90å¹´ä»£çš„â€œä¸€ç›´ç»§æ‰¿â€çƒ­æ½®äº§ç”Ÿäº†ä¸€äº›å¯æ€•çš„ç±»å±‚æ¬¡ç»“æ„ï¼Œä½†æ˜¯é¢å‘å¯¹è±¡è¯­è¨€ï¼ˆOOPï¼‰ä»ç„¶éå¸¸éš¾å®ç°ã€‚ç°åœ¨ï¼Œé¢å‘å¯¹è±¡è¯­è¨€ï¼Œå·²ç»åº”ç”¨äºæ•°åäº¿è¡Œä»£ç ï¼Œåˆ†å¸ƒäºæ•°ç™¾ä¸‡çš„åº”ç”¨ç¨‹åºä¸­ï¼Œä»Šå¤©å¤§å¤šæ•°çš„ç¨‹åºå‘˜éƒ½åœ¨ä½¿ç”¨é¢å‘å¯¹è±¡è¯­è¨€ã€‚</p>
<p>ç‰¹åˆ«çš„ï¼Œå¯¹äºåŠ¨æ€ç±»å‹ï¼Œå¯¹è±¡éå¸¸æ–¹ä¾¿ã€‚æˆ‘ä»¬éœ€è¦ä¸€äº›æ–¹æ³•ï¼Œå°†ä¸€äº›å¤æ‚çš„æ•°æ®ç±»å‹ç»‘å®šåœ¨ä¸€èµ·ã€‚</p>
<p>å¦‚æœæˆ‘ä»¬å¯ä»¥æŒ‚èµ·è¿™äº›æ–¹æ³•ï¼Œé‚£ä¹ˆï¼Œæˆ‘ä»¬ä¸éœ€è¦åœ¨æ‰€æœ‰å‡½æ•°å‰é¢åŠ ä¸Šå®ƒä»¬æ‰€æ“ä½œçš„æ•°æ®ç±»å‹çš„åç§°ï¼Œä»¥é¿å…å’Œä¸åŒç±»å‹çš„ç±»ä¼¼å‡½æ•°å‘ç”Ÿå†²çªã€‚ä¾‹å¦‚ï¼šåœ¨Rocketè¯­è¨€ä¸­ï¼Œä½ éœ€è¦æ ¹æ®ä¸åŒçš„æ•°æ®ç±»å‹ï¼Œåˆ†åˆ«å‘½å hash-copy å’Œ vector-copy å‡½æ•°ï¼Œè¿™æ ·å®ƒä»¬ä¸ä¼šç›¸äº’é‡å ã€‚æ–¹æ³•çš„ä½œç”¨åŸŸæ˜¯å¯¹è±¡ï¼Œè¿™æ ·é—®é¢˜ï¼Œå°±è§£å†³äº†ã€‚</p>
<h3 id="92-why-is-lox-object-oriented"><a class="header" href="#92-why-is-lox-object-oriented">9.2 Why is Lox object oriented?</a></h3>
<p>ä¸ºä»€ä¹ˆLoxè¯­è¨€æ˜¯é¢å‘å¯¹è±¡çš„ï¼Ÿ</p>
<p>I could claim objects are groovy but still out of scope for the book. Most programming language books, especially ones that try to implement a whole language, leave objects out. To me, that means the topic isnâ€™t well covered. With such a widespread paradigm, that omission makes me sad.</p>
<p>Given how many of us spend all day using OOP languages, it seems like the world could use a little documentation on how to make one. As youâ€™ll see, it turns out to be pretty interesting. Not as hard as you might fear, but not as simple as you might presume, either.</p>
<p>æˆ‘å¯ä»¥è¯´å¯¹è±¡æ˜¯ groovyè¯­è¨€ï¼Œä½†æ˜¯ä»ç„¶è¶…å‡ºäº†æœ¬ä¹¦çš„èŒƒå›´ã€‚å¤§å¤šæ•°çš„ç¼–ç¨‹è¯­è¨€ä¹¦ç±ï¼Œå°¤å…¶æ˜¯é‚£äº›æƒ³è¦å®ç°ä¸€é—¨å®Œæ•´è¯­è¨€çš„ä¹¦ç±ï¼Œéƒ½å¿½ç•¥äº†é¢å‘å¯¹è±¡ä»‹ç»ã€‚å¯¹æˆ‘è€Œè¨€ï¼Œè¿™æ„å‘³ç€é¢å‘å¯¹è±¡è¿™ä¸ªè¯é¢˜ï¼Œæ²¡æœ‰å¾ˆå¥½çš„è¢«è¦†ç›–ã€‚åœ¨å¦‚æ­¤å¹¿æ³›çš„ç¤ºä¾‹ä¸­ï¼Œè¿™ç§é—æ¼è®©æˆ‘æ„Ÿåˆ°æ‚²ä¼¤ã€‚</p>
<p>è€ƒè™‘åˆ°æˆ‘ä»¬å¤§éƒ¨åˆ†äººï¼Œæ¯å¤©éƒ½åœ¨ä½¿ç”¨é¢å‘å¯¹è±¡è¯­è¨€ï¼Œä¼¼ä¹å…¨ä¸–ç•Œéƒ½éœ€è¦ä¸€äº›å…³äºé¢å‘å¯¹è±¡è¯­è¨€çš„ä»‹ç»ã€‚æ­£å¦‚ä½ çœ‹åˆ°çš„ï¼Œç»“æœéå¸¸æœ‰æ„æ€ï¼Œæ—¢æ²¡æœ‰ä½ æƒ³è±¡çš„é‚£ä¹ˆå›°éš¾ï¼Œä½†æ˜¯ä¹Ÿæ²¡ä½ æƒ³è±¡çš„é‚£ä¹ˆç®€å•ã€‚</p>
<h3 id="93-classes-or-prototypes"><a class="header" href="#93-classes-or-prototypes">9.3 Classes or prototypes</a></h3>
<p>ç±»å’ŒåŸå‹</p>
<p>When it comes to objects, there are actually two approaches to them, classes and prototypes. Classes came first, and are more common thanks to C++, Java, C#, and friends. Prototypes were a virtually forgotten offshoot until JavaScript accidentally took over the world.</p>
<p>In class-based languages, there are two core concepts: instances and classes. Instances store the state for each object and have a reference to the instanceâ€™s class. Classes contain the methods and inheritance chain. To call a method on an instance, there is always a level of indirection. You look up the instanceâ€™s class and then you find the method there:</p>
<p>Prototype-based languages merge these two concepts. There are only objectsâ€”no classesâ€”and each individual object may contain state and methods. Objects can directly inherit from each other (or â€œdelegate toâ€ in prototypal lingo):</p>
<p>å¯¹äºå¯¹è±¡ï¼Œå®é™…ä¸Šæœ‰ä¸¤ç§æ–¹æ³•å®ç°ï¼Œç±»å’ŒåŸå‹ã€‚ç±»ï¼Œæ›´åŠ é€šç”¨ï¼Œå› ä¸ºC++ï¼Œ Javaï¼ŒC#ï¼Œfirendsç­‰è¯­è¨€ã€‚åŸå‹å‡ ä¹æ˜¯ä¸€ä¸ªè¢«é—å¿˜çš„åˆ†æ”¯ï¼Œç›´åˆ°JavaScript ä½¿ç”¨åŸå‹å®ç°äº†é¢å‘å¯¹è±¡ã€‚</p>
<p>åœ¨åŸºäºç±»çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œæœ‰ä¸¤ä¸ªæ ¸å¿ƒæ¦‚å¿µï¼šå®ä¾‹å’Œç±»ï¼Œå®ä¾‹ä¸­ä¿å­˜æ¯ä¸ªå¯¹è±¡çš„çŠ¶æ€ï¼Œè€Œä¸”å…·æœ‰å¯¹å®ä¾‹ç±»çš„å¼•ç”¨ã€‚ç±»ï¼ŒåŒ…å«å®ç°æ–¹æ³•å’Œç»§æ‰¿é“¾ã€‚å¦‚æœé€šè¿‡å®ä¾‹ï¼Œè°ƒç”¨æ–¹æ³•ï¼Œæ€»æ˜¯å­˜åœ¨ä¸€å®šç¨‹åº¦ä¸Šçš„é—´æ¥ã€‚æˆ‘ä»¬éœ€è¦å…ˆæ‰¾åˆ°å®ä¾‹å¯¹åº”çš„ç±»ï¼Œç„¶åæ‰¾åˆ°ç±»çš„æ–¹æ³•ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/class-lookup.png?raw=true" alt="class look-up" /></p>
<p>åŸºäºåŸå‹çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œèåˆäº†å®ä¾‹å’Œç±»ï¼Œè¿™ä¸¤ä¸ªæ¦‚å¿µã€‚å®ƒä»¬åªæœ‰å¯¹è±¡ï¼Œæ²¡æœ‰ç±»ï¼Œæ¯ä¸ªå•ç‹¬çš„å¯¹è±¡åŒ…å«çŠ¶æ€å’Œæ–¹æ³•ã€‚å¯¹è±¡å¯ä»¥ç›´æ¥ç›¸äº’ç»§æ‰¿ï¼ˆæˆ–è€…ç”¨åŸå‹ä¸­çš„æœ¯è¯­ï¼Œå§”æ‰˜ç»™ï¼‰</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/prototype-lookup.png?raw=true" alt="class look-up" /></p>
<p>This means that in some ways prototypal languages are more fundamental than classes. They are really neat to implement because theyâ€™re so simple. Also, they can express lots of unusual patterns that classes steer you away from.</p>
<p>But Iâ€™ve looked at a lot of code written in prototypal languagesâ€”including  <a href="http://finch.stuffwithstuff.com/index.html">some of my own devising</a>. Do you know what people generally do with all of the power and flexibility of prototypes? â€‰.â€‰.â€‰. They use them to reinvent classes.</p>
<p>I donâ€™t know why that is, but people naturally seem to prefer a class-based (Classic? Classy?) style. Prototypes are simpler in the language, but they seem to accomplish that only by pushing the complexity onto the user. So, for Lox, weâ€™ll save our users the trouble and bake classes right in.</p>
<p>è¿™æ„å‘³ç€æŸäº›æ–¹é¢ï¼ŒåŸºäºåŸå‹çš„è¯­è¨€ï¼Œæ¯”åŸºäºç±»çš„è¯­è¨€ï¼Œæ›´åŠ åŸºç¡€ï¼Œå®ƒä»¬å®ç°èµ·æ¥éå¸¸ç®€æ´ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å®ç°å¾ˆå¤šä¸å¯»å¸¸çš„æ¨¡å¼ï¼Œè€Œè¿™äº›æ¨¡å¼ï¼Œé€šå¸¸åŸºäºç±»çš„è¯­è¨€éƒ½ä¼šå°½é‡è¿œç¦»ã€‚</p>
<p>ä½†æ˜¯æˆ‘çœ‹åˆ°å¾ˆå¤šï¼Œä½¿ç”¨åŸå‹è¯­è¨€ç¼–å†™çš„ä»£ç ï¼ŒåŒ…æ‹¬æˆ‘è‡ªå·±çš„ä¸€äº›è®¾è®¡ã€‚ä½ çŸ¥é“ï¼Œäººä»¬é€šå¸¸å¦‚ä½•åˆ©ç”¨åŸå‹çš„å¼ºå¤§åŠŸèƒ½å’Œçµæ´»æ€§å—ï¼Ÿä»–ä»¬ä½¿ç”¨åŸå‹æ¥æ”¹é€ ç±»ã€‚</p>
<p>æˆ‘ä¸çŸ¥é“ä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Œäººä»¬ä¼¼ä¹æ›´åŠ å–œæ¬¢åŸºäºç±»çš„é£æ ¼ï¼Œå°½ç®¡åŸºäºåŸå‹çš„è¯­è¨€æ›´åŠ å®¹æ˜“ç†è§£ã€‚ä½†æ˜¯ï¼ŒåŸºäºåŸå‹çš„è¯­è¨€ï¼Œä¼¼ä¹å°†æ›´å¤šçš„å¤æ‚æ€§è½¬ç§»åˆ°ç”¨æˆ·èº«ä¸Šäº†ï¼Œå› æ­¤ï¼Œå¯¹äºLoxè¯­è¨€ï¼Œæˆ‘ä»¬å°†çœå»è¿™äº›éº»çƒ¦ï¼Œä¸€å¼€å§‹å°±ä½¿ç”¨åŸºäºç±»çš„é¢å‘å¯¹è±¡ã€‚</p>
<blockquote>
<p>In a statically typed language like C++, method lookup typically happens at compile time based on the static type of the instance, giving you static dispatch. In contrast, dynamic dispatch looks up the class of the actual instance object at runtime. This is how virtual methods in statically typed languages and all methods in a dynamically typed language like Lox work.</p>
<p>åœ¨C++ è¿™æ ·çš„é™æ€è¯­è¨€ä¸­ï¼ŒæŸ¥æ‰¾å®ä¾‹æ–¹æ³•ï¼Œä¸€èˆ¬æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µè¿›è¡Œçš„ï¼Œåœ¨ç¼–è¯‘æ—¶å€™ï¼Œæ ¹æ®å®ä¾‹çš„é™æ€ç±»å‹ï¼Œå®ç°é™æ€è°ƒåº¦ã€‚ç›¸åçš„ï¼ŒåŠ¨æ€è°ƒåº¦ï¼Œæ˜¯åœ¨è¿è¡Œæ—¶å€™ï¼Œæ‰ä¼šå»æŸ¥çœ‹å®ä¾‹å¯¹åº”çš„å¯¹è±¡ç±»ã€‚ è¿™å°±æ˜¯ï¼Œé™æ€è¯­è¨€ä¸­çš„è™šæ‹Ÿæ–¹æ³•ï¼Œå’ŒåŠ¨æ€è¯­è¨€ä¸­çš„æ‰€æœ‰æ–¹æ³•çš„å·¥ä½œæ–¹å¼ã€‚</p>
</blockquote>
<blockquote>
<p>In practice the line between class-based and prototype-based languages blurs. JavaScriptâ€™s â€œconstructor functionâ€ notion pushes you pretty hard towards defining class-like objects. Meanwhile, class-based Ruby is perfectly happy to let you attach methods to individual instances.</p>
<p>åœ¨å®è·µä¸­ï¼ŒåŸºäºç±»å’ŒåŸºäºåŸå‹çš„è¯­è¨€ä¹‹é—´çš„ç•Œé™å·²ç»æ¨¡ç³Šäº†ï¼ŒJavaScript çš„æ„é€ å‡½æ•°ï¼Œè®©ä½ å¾ˆéš¾å®šä¹‰ä¸€ä¸ªåŸºäºç±»çš„å¯¹è±¡ï¼›åŒæ ·çš„ï¼ŒåŸºäºç±»çš„Rubyï¼Œéå¸¸ä¹æ„è®©ä½ æŠŠæ–¹æ³•æ·»åŠ åˆ°å…·ä½“çš„å®ä¾‹ä¸Šã€‚</p>
</blockquote>
<h3 id="94-classes-in-lox"><a class="header" href="#94-classes-in-lox">9.4 Classes in Lox</a></h3>
<p>Loxè¯­è¨€ä¸­çš„ç±»</p>
<p>Enough rationale, letâ€™s see what we actually have. Classes encompass a constellation of features in most languages. For Lox, Iâ€™ve selected what I think are the brightest stars. You declare a class and its methods like so:</p>
<pre><code>
class Breakfast {
  cook() {
    print &quot;Eggs a-fryin'!&quot;;
  }

  serve(who) {
    print &quot;Enjoy your breakfast, &quot; + who + &quot;.&quot;;
  }
}

</code></pre>
<p>The body of a class contains its methods. They look like function declarations but without the fun keyword. When the class declaration is executed, Lox creates a class object and stores that in a variable named after the class. Just like functions, classes are first class in Lox.</p>
<pre><code>
// Store it in variables.
var someVariable = Breakfast;

// Pass it to functions.
someFunction(Breakfast);

</code></pre>
<p>Next, we need a way to create instances. We could add some sort of new keyword, but to keep things simple, in Lox the class itself is a factory function for instances. Call a class like a function, and it produces a new instance of itself.</p>
<pre><code>
var breakfast = Breakfast();
print breakfast; // &quot;Breakfast instance&quot;.

</code></pre>
<p>æœ‰äº†è¶³å¤Ÿçš„ç†ç”±ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹Loxè¯­è¨€æ˜¯å¦‚ä½•å®ç°çš„ã€‚åœ¨å¤§å¤šæ•°çš„è¯­è¨€ä¸­ï¼Œç±»åŒ…å«äº†ä¸€ç³»åˆ—ç‰¹å¾ï¼Œåœ¨Loxä¸­ï¼Œæˆ‘é€‰æ‹©äº†æˆ‘è®¤ä¸ºçš„æœ€é—ªäº®çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å®šä¹‰ä¸€ä¸ªç±»å’Œå®ƒçš„æ–¹æ³•ï¼š</p>
<pre><code>
class Breakfast {
  cook() {
    print &quot;Eggs a-fryin'!&quot;;
  }

  serve(who) {
    print &quot;Enjoy your breakfast, &quot; + who + &quot;.&quot;;
  }
}

</code></pre>
<p>ç±»çš„ä¸»ä½“ï¼ŒåŒ…å«äº†å®ƒçš„æ–¹æ³•ï¼Œå®ƒä»¬çœ‹èµ·æ¥åƒæ˜¯å‡½æ•°å£°æ˜ï¼Œä½†æ˜¯æ²¡æœ‰funå…³é”®å­—ã€‚å½“æ‰§è¡Œç±»å£°æ˜æ—¶å€™ï¼ŒLoxåˆ›å»ºäº†ä¸€ä¸ªç±»å¯¹è±¡ï¼Œå¹¶ä¸”å°†å®ƒä¿å­˜åœ¨ä»¥ç±»å‘½åçš„å˜é‡ä¸­ã€‚åƒå‡½æ•°ä¸€æ ·ï¼Œç±»ä¹Ÿæ˜¯ç¬¬ä¸€ç±»å¯¹è±¡ã€‚</p>
<pre><code>
// Store it in variables.
var someVariable = Breakfast;

// Pass it to functions.
someFunction(Breakfast);

</code></pre>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§åˆ›å»ºå®ä¾‹çš„æ–¹æ³•ã€‚æˆ‘ä»¬å¯ä»¥æ·»åŠ ä¸€äº›å…³é”®å­—ï¼Œä½†æ˜¯ä¸ºäº†ç®€å•èµ·è§ï¼Œåœ¨Loxè¯­è¨€ä¸­ï¼Œç±»æœ¬èº«ä½œä¸ºå®ä¾‹çš„å·¥å‚å‡½æ•°ã€‚åƒå‡½æ•°ä¸€æ ·è°ƒç”¨ç±»ï¼Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªå®ä¾‹ã€‚</p>
<pre><code>
var breakfast = Breakfast();
print breakfast; // &quot;Breakfast instance&quot;.

</code></pre>
<blockquote>
<p>Larry Wall, Perlâ€™s inventor/prophet calls this the <a href="http://wiki.c2.com/?WaterbedTheory">â€œwaterbed theoryâ€</a>. Some complexity is essential and cannot be eliminated. If you push it down in one place, it swells up in another.</p>
<p>Larry Wall, Perlè¯­è¨€åˆ›å§‹äººï¼Œç§°ä¹‹ä¸ºæ°´åºŠç†è®ºâ€”â€”æœ‰äº›å¤æ‚æ€§æ˜¯æ— æ³•æ¶ˆé™¤ï¼Œå¿…ä¸å¯å°‘çš„ã€‚å¦‚æœä½ åœ¨ä¸€ä¸ªåœ°æ–¹æ¨å®ƒï¼Œå®ƒä¼šåœ¨å¦ä¸€ä¸ªåœ°æ–¹è†¨èƒ€ã€‚</p>
<p>Prototypal languages donâ€™t so much eliminate the complexity of classes as they do make the user take that complexity by building their own class-like metaprogramming libraries.</p>
<p>åŸå‹è¯­è¨€å¹¶æ²¡æœ‰æ¶ˆé™¤ç±»çš„å¤æ‚æ€§ã€‚è€Œæ˜¯ï¼Œè®©ç”¨æˆ·è‡ªå·±æ„å»ºå…ƒç±»ç¼–ç¨‹åº“ï¼Œæ¥æ‰¿æ‹…å¤æ‚æ€§ã€‚</p>
</blockquote>
<h3 id="95-instantiation-and-initialization"><a class="header" href="#95-instantiation-and-initialization">9.5 Instantiation and initialization</a></h3>
<p>å®ä¾‹åŒ–å’Œåˆå§‹åŒ–</p>
<p>Classes that only have behavior arenâ€™t super useful. The idea behind object-oriented programming is encapsulating behavior and state together. To do that, you need fields. Lox, like other dynamically typed languages, lets you freely add properties onto objects.</p>
<pre><code>
breakfast.meat = &quot;sausage&quot;;
breakfast.bread = &quot;sourdough&quot;;

</code></pre>
<p>Assigning to a field creates it if it doesnâ€™t already exist.</p>
<p>If you want to access a field or method on the current object from within a method, you use good old this.</p>
<pre><code>
class Breakfast {
  serve(who) {
    print &quot;Enjoy your &quot; + this.meat + &quot; and &quot; +
        this.bread + &quot;, &quot; + who + &quot;.&quot;;
  }

  // ...
}

</code></pre>
<p>åªæœ‰æ–¹æ³•çš„ç±»ï¼Œä¸æ˜¯éå¸¸æœ‰ç”¨ï¼Œé¢å‘å¯¹è±¡èƒŒåçš„æ€æƒ³æ˜¯ï¼Œå°†è¡Œä¸ºå’ŒçŠ¶æ€å°è£…åœ¨ä¸€èµ·ï¼Œä¸ºæ­¤ï¼Œéœ€è¦å­—æ®µï¼ŒLoxå’Œå…¶ä»–åŠ¨æ€è¯­è¨€ä¸€æ ·ï¼Œå…è®¸ä½ åœ¨å¯¹è±¡ä¸Šè‡ªç”±æ·»åŠ å¯¹è±¡å±æ€§ã€‚</p>
<pre><code>
breakfast.meat = &quot;sausage&quot;;
breakfast.bread = &quot;sourdough&quot;;

</code></pre>
<p>å¦‚æœæŸä¸ªå­—æ®µä¸å­˜åœ¨ï¼Œåˆ™åˆ†é…ç»™è¯¥å­—æ®µå°†åˆ›å»ºè¯¥å­—æ®µï¼Œå¦‚æœæƒ³è¦ä»æ–¹æ³•ä¸­è®¿é—®ï¼Œå½“å‰å¯¹è±¡çš„å­—æ®µæˆ–è€…æ–¹æ³•ï¼Œéœ€è¦ä½¿ç”¨thiså…³é”®å­—</p>
<pre><code>
class Breakfast {
  serve(who) {
    print &quot;Enjoy your &quot; + this.meat + &quot; and &quot; +
        this.bread + &quot;, &quot; + who + &quot;.&quot;;
  }

  // ...
}

</code></pre>
<p>Part of encapsulating data within an object is ensuring the object is in a valid state when itâ€™s created. To do that, you can define an initializer. If your class has a method named init(), it is called automatically when the object is constructed. Any parameters passed to the class are forwarded to its initializer.</p>
<pre><code>
class Breakfast {
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  // ...
}

var baconAndToast = Breakfast(&quot;bacon&quot;, &quot;toast&quot;);
baconAndToast.serve(&quot;Dear Reader&quot;);
// &quot;Enjoy your bacon and toast, Dear Reader.&quot;

</code></pre>
<p>åœ¨å¯¹è±¡ä¸­å°è£…çš„éƒ¨åˆ†æ•°æ®ï¼Œæ˜¯ä¸ºäº†ç¡®ä¿å¯¹è±¡åœ¨åˆ›å»ºæ—¶å€™å¤„äºæœ‰æ•ˆçŠ¶æ€ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åˆ›å»ºä¸€ä¸ªåˆå§‹åŒ–å‡½æ•°ï¼Œå¦‚æœç±»æœ‰ä¸€ä¸ªåä¸ºinit()çš„æ–¹æ³•ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨åˆ›å»ºå®ä¾‹æ—¶å€™ï¼Œè‡ªåŠ¨è°ƒç”¨è¯¥æ–¹æ³•ã€‚ä¼ é€’ç»™ç±»çš„ä»»ä½•å‚æ•°ï¼Œéƒ½å°†å˜ä¸ºç±»çš„åˆå§‹å€¼ã€‚</p>
<pre><code>
class Breakfast {
  init(meat, bread) {
    this.meat = meat;
    this.bread = bread;
  }

  // ...
}

var baconAndToast = Breakfast(&quot;bacon&quot;, &quot;toast&quot;);
baconAndToast.serve(&quot;Dear Reader&quot;);
// &quot;Enjoy your bacon and toast, Dear Reader.&quot;

</code></pre>
<h3 id="96-inheritance"><a class="header" href="#96-inheritance">9.6 Inheritance</a></h3>
<p>ç»§æ‰¿</p>
<p>Every object-oriented language lets you not only define methods, but reuse them across multiple classes or objects. For that, Lox supports single inheritance. When you declare a class, you can specify a class that it inherits from using a less-than (&lt;) operator.</p>
<pre><code>
class Brunch &lt; Breakfast {
  drink() {
    print &quot;How about a Bloody Mary?&quot;;
  }
}

</code></pre>
<p>Here, Brunch is the derived class or subclass, and Breakfast is the base class or superclass.</p>
<p>æ¯ä¸ªé¢å‘å¯¹è±¡è¯­è¨€ï¼Œéƒ½å…è®¸ä½ å®šä¹‰æ–¹æ³•ï¼Œå¹¶ä¸”åœ¨å…¶ä»–ç±»æˆ–è€…å¯¹è±¡ä¸­å¤ç”¨è¿™äº›æ–¹æ³•ã€‚Loxè¯­è¨€ï¼ŒåŒæ ·æ”¯æŒå•ç»§æ‰¿ï¼Œå£°æ˜ç±»æ—¶å€™ï¼Œå¯ä»¥ä½¿ç”¨è¿ç®—ç¬¦ &lt; è¡¨ç¤ºè¦ç»§æ‰¿çš„ç±»ã€‚</p>
<pre><code>
class Brunch &lt; Breakfast {
  drink() {
    print &quot;How about a Bloody Mary?&quot;;
  }
}

</code></pre>
<p>Every method defined in the superclass is also available to its subclasses.</p>
<pre><code>
var benedict = Brunch(&quot;ham&quot;, &quot;English muffin&quot;);
benedict.serve(&quot;Noble Reader&quot;);

</code></pre>
<p>Even the init() method gets inherited. In practice, the subclass usually wants to define its own init() method too. But the original one also needs to be called so that the superclass can maintain its state. We need some way to call a method on our own instance without hitting our own methods.</p>
<p>As in Java, you use super for that.</p>
<pre><code>
class Brunch &lt; Breakfast {
  init(meat, bread, drink) {
    super.init(meat, bread);
    this.drink = drink;
  }
}

</code></pre>
<p>ç”±ä¸Šé¢çš„ç±»å£°æ˜ï¼Œæˆ‘ä»¬å¯ä»¥ç§° Brunch ä¸ºæ´¾ç”Ÿç±»æˆ–è€…å­ç±»ï¼Œç§° Breakfast ä¸ºåŸºç±»æˆ–è€…è¶…ç±»ã€‚</p>
<p>æ¯ä¸ªåŸºç±»ä¸­å®šä¹‰çš„æ–¹æ³•ï¼Œåœ¨å®ƒçš„æ´¾ç”Ÿç±»ä¸­ï¼Œä¹Ÿå¯ä»¥è°ƒç”¨</p>
<pre><code>
var benedict = Brunch(&quot;ham&quot;, &quot;English muffin&quot;);
benedict.serve(&quot;Noble Reader&quot;);

</code></pre>
<p>ç”šè‡³init() æ–¹æ³•ä¹Ÿå¯ä»¥è¢«ç»§æ‰¿ï¼Œå®é™…ä¸Šï¼Œå­ç±»é€šå¸¸ä¹Ÿæƒ³è¦å®šä¹‰è‡ªå·±çš„init() æ–¹æ³•ï¼Œä½†æ˜¯ä¹Ÿéœ€è¦è°ƒç”¨åŸºç±»ï¼Œä»¥ä¾¿äºåŸºç±»æ›´æ–°å®ƒçš„çŠ¶æ€ä¿¡æ¯ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªæ–¹å¼ï¼Œåªè°ƒç”¨è¶…ç±»ä¸­çš„æŸä¸ªæ–¹æ³•ï¼Œä½†æ˜¯ä¸è°ƒç”¨è‡ªèº«çš„åŒåæ–¹æ³•ã€‚åœ¨Javaä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨superå®ç°ã€‚</p>
<pre><code>
class Brunch &lt; Breakfast {
  init(meat, bread, drink) {
    super.init(meat, bread);
    this.drink = drink;
  }
}

</code></pre>
<p>Thatâ€™s about it for object orientation. I tried to keep the feature set minimal. The structure of the book did force one compromise. Lox is not a pure object-oriented language. In a true OOP language every object is an instance of a class, even primitive values like numbers and Booleans.</p>
<p>Because we donâ€™t implement classes until well after we start working with the built-in types, that would have been hard. So values of primitive types arenâ€™t real objects in the sense of being instances of classes. They donâ€™t have methods or properties. If I were trying to make Lox a real language for real users, I would fix that.</p>
<p>è¿™å°±æ˜¯é¢å‘å¯¹è±¡çš„æ–¹æ³•ï¼Œæˆ‘è¯•å›¾ä¿æŒåŠŸèƒ½é›†æœ€å°åŒ–ï¼Œæœ¬ä¹¦ç»“æ„è¿«ä½¿æˆ‘åšå‡ºä¸€å®šçš„å¦¥åã€‚Loxä¸æ˜¯ä¸€ç§çº¯ç²¹çš„é¢å‘å¯¹è±¡è¯­è¨€ï¼Œåœ¨çœŸæ­£çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œæ¯ä¸ªå¯¹è±¡éƒ½æ˜¯ä¸€ä¸ªç±»çš„å®ä¾‹ï¼Œå³ä½¿æ˜¯æ•°å€¼å’Œå¸ƒå°”ç±»å‹è¿™æ ·çš„åŸå§‹å€¼ï¼Œéƒ½æ˜¯ä¸€ä¸ªç±»çš„å®ä¾‹ã€‚</p>
<p>å› ä¸ºæˆ‘ä»¬åœ¨å¼€å§‹ä½¿ç”¨å†…ç½®ç±»åï¼Œæ‰å®ç°ç±»ï¼Œæ‰€ä»¥ï¼Œå®ç°çº¯ç²¹çš„é¢å‘å¯¹è±¡ï¼Œæ¯”è¾ƒå›°éš¾ã€‚å› æ­¤ï¼Œä»ç±»å®ä¾‹çš„æ„ä¹‰ä¸Šï¼ŒåŸºæœ¬ç±»å‹çš„å€¼ä¸æ˜¯å®ä¾‹ã€‚å®ƒä»¬æ²¡æœ‰æ–¹æ³•ï¼Œä¹Ÿæ²¡æœ‰å±æ€§ã€‚å¦‚æœï¼Œæˆ‘æƒ³è¦è®©Loxå˜ä¸ºä¸€é—¨ç”¨æˆ·å¯ç”¨çš„çœŸæ­£çš„è¯­è¨€ï¼Œæˆ‘ä¼šå°è¯•è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p>
<blockquote>
<p>Why the &lt; operator? I didnâ€™t feel like introducing a new keyword like extends. Lox doesnâ€™t use : for anything else so I didnâ€™t want to reserve that either. Instead, I took a page from Ruby and used &lt;.</p>
<p>ä¸ºä»€ä¹ˆè¦ä½¿ç”¨ &lt; è¡¨ç¤ºç»§æ‰¿ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ extends è¿™æ ·çš„å…³é”®å­—ã€‚åŒæ ·çš„ï¼ŒLoxè¯­è¨€ä¹Ÿä¸ä½¿ç”¨ : ç”¨äºä»»ä½•ç”¨é€”ï¼Œæˆ‘ä»Rubyè¯­è¨€ä¸­å¾—åˆ°çµæ„Ÿï¼Œä½¿ç”¨&lt; è¡¨ç¤ºç»§æ‰¿ã€‚</p>
<p>If you know any type theory, youâ€™ll notice itâ€™s not a totally arbitrary choice. Every instance of a subclass is an instance of its superclass too, but there may be instances of the superclass that are not instances of the subclass. That means, in the universe of objects, the set of subclass objects is smaller than the superclassâ€™s set, though type nerds usually use &lt;: for that relation.</p>
<p>å¦‚æœä½ çŸ¥é“ä¸€äº›ç±»å‹ç†è®ºï¼Œä½ ä¼šæ³¨æ„åˆ°ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå®Œå…¨æ­¦æ–­çš„å†³å®šã€‚å­ç±»çš„æ¯ä¸ªå®ä¾‹ï¼ŒåŒæ—¶ï¼Œä¹Ÿæ˜¯çˆ¶ç±»çš„ä¸€ä¸ªå®ä¾‹ã€‚å¯èƒ½å­˜åœ¨ä¸€ä¸ªå®ä¾‹ï¼Œæ˜¯çˆ¶ç±»çš„å®ä¾‹ï¼Œä½†ä¸æ˜¯å…¶å­ç±»çš„å®ä¾‹ã€‚åœ¨å¯¹è±¡å®‡å®™ä¸­ï¼Œå­ç±»å¯¹è±¡é›†åˆå°äºçˆ¶ç±»å¯¹è±¡é›†åˆï¼Œç±»å‹ç†è®ºçš„ä¹¦å‘†å­ï¼Œä¼šä½¿ç”¨ &lt;: è¡¨ç¤ºè¿™ç§å…³ç³»ã€‚</p>
<p>Lox is different from C++, Java, and C#, which do not inherit constructors, but similar to Smalltalk and Ruby, which do.</p>
<p>ä¸åŒäº C++ Java C#, å®ƒä»¬ä¸ä¼šç»§æ‰¿çˆ¶ç±»çš„æ„é€ å‡½æ•°ï¼ŒLoxè¯­è¨€ï¼Œæ›´åŠ ç±»ä¼¼ Smalltalk Rubyï¼Œä¼šç»§æ‰¿æ„é€ å‡½æ•°ã€‚</p>
</blockquote>
<h2 id="åthe-standard-library"><a class="header" href="#åthe-standard-library">åã€The Standard Library</a></h2>
<p>æ ‡å‡†åº“</p>
<p>Weâ€™re almost done. Thatâ€™s the whole language, so all thatâ€™s left is the â€œcoreâ€ or â€œstandardâ€ libraryâ€”the set of functionality that is implemented directly in the interpreter and that all user-defined behavior is built on top of.</p>
<p>This is the saddest part of Lox. Its standard library goes beyond minimalism and veers close to outright nihilism. For the sample code in the book, we only need to demonstrate that code is running and doing what itâ€™s supposed to do. For that, we already have the built-in print statement.</p>
<p>Later, when we start optimizing, weâ€™ll write some benchmarks and see how long it takes to execute code. That means we need to track time, so weâ€™ll define one built-in function, clock(), that returns the number of seconds since the program started.</p>
<p>æˆ‘ä»¬å·®ä¸å¤šå®Œæˆäº†Loxè¯­è¨€ï¼Œè¿™å°±æ˜¯æ•´ä¸ªè¯­è¨€ã€‚å‰©ä¸‹æ¥çš„éƒ¨åˆ†æ˜¯æ ¸å¿ƒåº“æˆ–è€…ç§°ä¸ºæ ‡å‡†åº“â€”â€”ç›´æ¥åœ¨è§£é‡Šå™¨ä¸­å®ç°çš„åŠŸèƒ½ï¼Œæ‰€æœ‰ç”¨æˆ·å®šä¹‰çš„æ–¹æ³•éƒ½å»ºç«‹åœ¨æ ‡å‡†åº“ä¸Šé¢ã€‚</p>
<p>è¿™æ˜¯Loxè¯­è¨€ä¸­æœ€æ‚²ä¼¤çš„åœ°æ–¹ï¼Œå®ƒçš„æ ‡å‡†åº“è¶…è¶Šäº†æç®€ä¸»ä¹‰ï¼Œè½¬å‘äº†å®Œå…¨çš„è™šæ— ä¸»ä¹‰ã€‚å¯¹äºä¹¦ä¸­çš„ç¤ºä¾‹ä»£ç ï¼Œæˆ‘ä»¬åªéœ€è¦è¯æ˜ä»£ç æ­£åœ¨è¿è¡Œæˆ–è€…æ‰§è¡Œå®ƒåº”è¯¥æ‰§è¡Œçš„æ“ä½œã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å·²ç»æœ‰äº†å†…ç½®çš„printè¯­å¥ã€‚</p>
<p>ç¨åï¼Œå½“æˆ‘ä»¬ä¼˜åŒ–æ—¶å€™ï¼Œæˆ‘ä»¬å°†ç¼–å†™ä¸€äº›åŸºå‡†æµ‹è¯•ä»£ç ï¼ŒæŸ¥çœ‹æ‰§è¡Œä»£ç çš„è€—æ—¶ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦è·Ÿè¸ªæ—¶é—´ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå†…ç½®å‡½æ•° clock() , å®ƒè¿”å›ç¨‹åºå¯åŠ¨åçš„ç§’æ•°ã€‚</p>
<p>Andâ€‰.â€‰.â€‰. thatâ€™s it. I know, right? Itâ€™s embarrassing.</p>
<p>If you wanted to turn Lox into an actual useful language, the very first thing you should do is flesh this out. String manipulation, trigonometric functions, file I/O, networking, heck, even reading input from the user would help. But we donâ€™t need any of that for this book, and adding it wouldnâ€™t teach you anything interesting, so Iâ€™ve left it out.</p>
<p>Donâ€™t worry, weâ€™ll have plenty of exciting stuff in the language itself to keep us busy.</p>
<p>å¦‚æœä½ æƒ³æŠŠLoxè¯­è¨€å˜ä¸ºä¸€é—¨çœŸæ­£æœ‰ç”¨çš„è¯­è¨€ï¼Œç¬¬ä¸€ä»¶äº‹æƒ…ï¼Œå°±æ˜¯å……å®Loxè¯­è¨€ã€‚å­—ç¬¦ä¸²æ“ä½œï¼Œä¸‰è§’å‡½æ•°ï¼Œæ–‡ä»¶I/Oï¼Œç½‘ç»œï¼Œæ£€æŸ¥ï¼Œç”šè‡³è¯»å–ç”¨æˆ·è¾“å…¥éƒ½ä¼šæœ‰æ‰€å¸®åŠ©ï¼Œä½†æ˜¯æœ¬ä¹¦å°†ä¸ä¼šæ¶‰åŠã€‚å› ä¸ºåŠ ä¸Šå®ƒä»¬ï¼Œä¸ä¼šå¢åŠ ä»»ä½•æœ‰æ„ä¹‰çš„åœ°æ–¹ï¼Œæ‰€ä»¥ï¼Œæˆ‘æŠŠå®ƒä»¬åˆ é™¤äº†ã€‚</p>
<p>åˆ«æ‹…å¿ƒï¼Œè¯­è¨€æœ¬èº«æœ‰å¾ˆå¤šä»¤äººå…´å¥‹çš„ä¸œè¥¿ï¼Œè®©æˆ‘ä»¬å¿™ä¸ªä¸åœã€‚</p>
<h2 id="åä¸€challenges"><a class="header" href="#åä¸€challenges">åä¸€ã€CHALLENGES</a></h2>
<p>ä¹ é¢˜</p>
<ol>
<li>
<p>Write some sample Lox programs and run them (you can use the implementations of Lox in my repository). Try to come up with edge case behavior I didnâ€™t specify here. Does it do what you expect? Why or why not?</p>
</li>
<li>
<p>This informal introduction leaves a lot unspecified. List several open questions you have about the languageâ€™s syntax and semantics. What do you think the answers should be?</p>
</li>
<li>
<p>Lox is a pretty tiny language. What features do you think it is missing that would make it annoying to use for real programs? (Aside from the standard library, of course.)</p>
</li>
<li>
<p>ç¼–å†™ä¸€äº›Loxç¨‹åºå¹¶ä¸”è¿è¡Œå®ƒä»¬ï¼Œ å°è¯•ç»™å‡ºä¸€äº›ä¹¦ä¸­æ²¡æœ‰æåŠçš„è¾¹ç¼˜ç¤ºä¾‹ï¼Œå®ƒæ˜¯å¦ç¬¦åˆä½ çš„æœŸæœ›ï¼Œå¹¶ç»™å‡ºåŸå› ï¼Ÿ</p>
</li>
<li>
<p>æœ¬ç« çš„ç®€çŸ­ä»‹ç»ç•™ä¸‹äº†å¾ˆå¤šæ²¡æœ‰æ˜ç¡®çš„åœ°æ–¹ï¼Œåˆ—å‡ºå…³äºè¯­è¨€çš„è¯­æ³•å’Œè¯­ä¹‰çš„å‡ ä¸ªå¼€æ”¾æ€§é—®é¢˜ï¼Œä½ è®¤ä¸ºç­”æ¡ˆæ˜¯ä»€ä¹ˆï¼Ÿ</p>
</li>
<li>
<p>Loxæ˜¯ä¸€é—¨å¾ˆå°çš„è¯­è¨€ï¼Œä½ è§‰å¾—è¿˜åº”è¯¥æ·»åŠ å“ªäº›æ–°åŠŸèƒ½ï¼Œè¿™äº›åŠŸèƒ½çš„ç¼ºå°‘ï¼Œè®©ä½ åœ¨å®é™…åº”ç”¨æ—¶å€™æ„Ÿåˆ°æ¼ç«ï¼ˆé™¤äº†æ ‡å‡†åº“ä¹‹å¤–ï¼‰</p>
</li>
</ol>
<h2 id="åäºŒdesign-note-expressions-and-statements"><a class="header" href="#åäºŒdesign-note-expressions-and-statements">åäºŒã€DESIGN NOTE: EXPRESSIONS AND STATEMENTS</a></h2>
<p>è®¾è®¡æ€æƒ³ï¼šè¡¨è¾¾å¼å’Œè¯­å¥</p>
<p>Lox has both expressions and statements. Some languages omit the latter. Instead, they treat declarations and control flow constructs as expressions too. These â€œeverything is an expressionâ€ languages tend to have functional pedigrees and include most Lisps, SML, Haskell, Ruby, and CoffeeScript.</p>
<p>To do that, for each â€œstatement-likeâ€ construct in the language, you need to decide what value it evaluates to. Some of those are easy:</p>
<ul>
<li>
<p>An if expression evaluates to the result of whichever branch is chosen. Likewise, a switch or other multi-way branch evaluates to whichever case is picked.</p>
</li>
<li>
<p>A variable declaration evaluates to the value of the variable.</p>
</li>
<li>
<p>A block evaluates to the result of the last expression in the sequence.</p>
</li>
</ul>
<p>Some get a little stranger. What should a loop evaluate to? A while loop in CoffeeScript evaluates to an array containing each element that the body evaluated to. That can be handy, or a waste of memory if you donâ€™t need the array.</p>
<p>You also have to decide how these statement-like expressions compose with other expressionsâ€”you have to fit them into the grammarâ€™s precedence table. For example, Ruby allows:</p>
<p>puts 1 + if true then 2 else 3 end + 4</p>
<p>Loxè¯­è¨€æ—¢æœ‰è¡¨è¾¾å¼ï¼Œä¹Ÿæœ‰è¯­å¥ã€‚æœ‰äº›è¯­è¨€çœç•¥äº†è¯­å¥ï¼Œå®ƒä»¬ä¼šå°†å£°æ˜å’Œæ§åˆ¶æµä¹Ÿå½“ä½œè¡¨è¾¾å¼ï¼Œè¿™äº›å…·æœ‰â€œä¸€åˆ‡éƒ½æ˜¯è¡¨è¾¾å¼â€œç‰¹æ€§çš„è¯­è¨€ï¼Œå¾€å¾€å…·æœ‰å‡½æ•°å¼è¯­è¨€ç‰¹å¾ï¼Œä¾‹å¦‚ï¼šLISPï¼ŒSMLï¼ŒHaskellï¼ŒRuby å’Œ CoffeeScript</p>
<p>è¦åšåˆ°è¿™ä¸€ç‚¹ï¼Œå¯¹äºè¯­è¨€ä¸­çš„æ¯ä¸€ä¸ªè¯­å¥ç»“æ„ï¼Œæˆ‘ä»¬éœ€è¦ç¡®å®šè¯­å¥çš„æœ€ç»ˆå€¼ã€‚å…¶ä¸­ï¼Œæœ‰äº›è¯­å¥å¾ˆç®€å•ï¼š</p>
<ul>
<li>
<p>if è¯­å¥çš„è®¡ç®—ç»“æœæ˜¯æ‰€é€‰åˆ†æ”¯çš„ç»“æœã€‚åŒæ ·çš„ï¼Œswitchè¯­å¥æˆ–è€…å…¶ä»–å¤šè·¯åˆ†æ”¯ï¼Œè®¡ç®—ç»“æœä¸ºæ ¹æ®æƒ…å†µé€‰æ‹©çš„åˆ†æ”¯çš„è®¡ç®—ç»“æœ</p>
</li>
<li>
<p>å˜é‡å£°æ˜è¯­å¥çš„ç»“æœï¼Œä¸ºå˜é‡çš„å€¼</p>
</li>
<li>
<p>ä»£ç å—çš„è®¡ç®—ç»“æœä¸ºåºåˆ—ä¸­æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„ç»“æœ</p>
</li>
</ul>
<p>è¿˜æœ‰ä¸€äº›è¯­å¥ï¼Œå˜å¾—æœ‰äº›å¥‡æ€ªï¼Œå¾ªç¯è¯­å¥çš„è®¡ç®—ç»“æœåº”è¯¥æ˜¯ä»€ä¹ˆï¼ŸCoffeeScript è¯­è¨€çš„å¾ªç¯è¯­å¥çš„è®¡ç®—ç»“æœæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œè¯¥æ•°ç»„åŒ…å«äº†ä¸»ä½“è®¡ç®—åˆ°çš„æ¯ä¸ªå…ƒç´ ã€‚è¿™å¾ˆæ–¹ä¾¿ï¼Œå¦‚æœä¸ä½¿ç”¨è¿™ä¸ªæ•°ç»„ï¼Œä¼šæµªè´¹å†…å­˜ã€‚</p>
<p>æˆ‘ä»¬è¿˜éœ€è¦ç¡®å®šä¸€äº›ç±»ä¼¼è¯­å¥çš„è¡¨è¾¾å¼ï¼Œå¦‚ä½•å’Œå…¶ä»–è¡¨è¾¾å¼ç»„åˆä½¿ç”¨ã€‚æˆ‘ä»¬éœ€è¦å°†è¿™äº›è¡¨è¾¾å¼æ”¾å…¥è¯­æ³•çš„ä¼˜å…ˆçº§è¡¨ä¸­ã€‚ä¾‹å¦‚ï¼šRubyè¯­è¨€ä¸­ï¼Œ</p>
<p>puts 1 + if true then 2 else 3 end + 4</p>
<p>è¿™å°±æ˜¯ä½ æ‰€æœŸå¾…çš„å—ï¼Ÿè¿™å°±æ˜¯ç”¨æˆ·æœŸå¾…çš„å—ï¼Ÿè¿™å¯¹äºä½ è‡ªå·±è®¾è®¡è¯­å¥æœ‰ä»€ä¹ˆå½±å“ï¼Ÿéœ€è¦æ³¨æ„ï¼ŒRubyè¯­è¨€æœ‰ä¸ªæ˜¾ç¤ºçš„å…³é”®è¯ endï¼Œè¡¨ç¤ºè¡¨è¾¾å¼ä»€ä¹ˆæ—¶å€™å®Œæˆï¼Œå¦‚æœæ²¡æœ‰endï¼Œ+4éƒ¨åˆ†å¯èƒ½è¢«è§£æä¸ºelseçš„ä¸€éƒ¨åˆ†ã€‚</p>
<p>Turning every statement into an expression forces you to answer a few hairy questions like that. In return, you eliminate some redundancy. C has both blocks for sequencing statements, and the comma operator for sequencing expressions. It has both the if statement and the ?: conditional operator. If everything was an expression in C, you could unify each of those.</p>
<p>Languages that do away with statements usually also feature implicit returnsâ€”a function automatically returns whatever value its body evaluates to without need for some explicit return syntax. For small functions and methods, this is really handy. In fact, many languages that do have statements have added syntax like =&gt; to be able to define functions whose body is the result of evaluating a single expression.</p>
<p>å°†æ¯ä¸ªè¯­å¥å˜ä¸ºè¡¨è¾¾å¼ï¼Œè¿«ä½¿æˆ‘ä»¬å›ç­”ä¸Šé¢çš„æ£˜æ‰‹é—®é¢˜ï¼Œä½œä¸ºå›æŠ¥ï¼Œè¿™æ ·åšï¼Œæ¶ˆé™¤äº†ä¸€äº›å†—ä½™ã€‚Cè¯­è¨€ä¸­ï¼Œæ—¢æœ‰è¯­å¥ï¼Œä¹ŸåŒ…å«è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼šå®ƒæ—¢æœ‰ifè¯­å¥ï¼Œä¹Ÿæœ‰ä¸‰å…ƒè¿ç®—ç¬¦ ?: ï¼Œå¦‚æœCè¯­è¨€ä¸­ä¸€åˆ‡éƒ½æ˜¯è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆè¿™ä¸¤ç§å†™æ³•å°†ç»Ÿä¸€ä¸ºä¸€ç§ã€‚</p>
<p>ä¸ä½¿ç”¨è¯­å¥çš„è¯­è¨€ï¼Œé€šå¸¸å…·æœ‰éšå¼è¿”å›ç‰¹æ€§â€”â€”å‡½æ•°ä¼šè‡ªåŠ¨è¿”å›è®¡ç®—ç»“æœï¼Œè€Œä¸éœ€è¦æ˜¾ç¤ºè¿”å›è¯­å¥ã€‚å¯¹äºå°å‡½æ•°å’Œæ–¹æ³•ï¼Œè¿™æ ·éå¸¸æ–¹ä¾¿ã€‚äº‹å®ä¸Šï¼Œå¾ˆå¤šå­˜åœ¨è¯­å¥çš„è¯­è¨€ï¼Œéƒ½å®ç°äº†=&gt; è¿™æ ·çš„è¯­æ³•ï¼Œå®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°ä½“æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼çš„è®¡ç®—ç»“æœ</p>
<p>But making all functions work that way can be a little strange. If you arenâ€™t careful, your function will leak a return value even if you only intend it to produce a side effect. In practice, though, users of these languages donâ€™t find it to be a problem.</p>
<p>For Lox, I gave it statements for prosaic reasons. I picked a C-like syntax for familiarityâ€™s sake, and trying to take the existing C statement syntax and interpret it like expressions gets weird pretty fast.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è§£ææ ‘"><a class="header" href="#è§£ææ ‘">è§£ææ ‘</a></h1>
<p>A TREE-WALK INTERPRETER</p>
<p>With this part, we begin jlox, the first of our two interpreters. Programming languages are a huge topic with piles of concepts and terminology to cram into your brain all at once. Programming language theory requires a level of mental rigor that you probably havenâ€™t had to summon since your last calculus final. (Fortunately there isnâ€™t too much theory in this book.)</p>
<p>Implementing an interpreter uses a few architectural tricks and design patterns uncommon in other kinds of applications, so weâ€™ll be getting used to the engineering side of things too. Given all of that, weâ€™ll keep the code we have to write as simple and plain as possible.</p>
<p>In less than two thousand lines of clean Java code, weâ€™ll build a complete interpreter for Lox that implements every single feature of the language, exactly as weâ€™ve specified. The first few chapters work front-to-back through the phases of the interpreterâ€”scanning, parsing, and evaluating code. After that, we add language features one at a time, growing a simple calculator into a full-fledged scripting language.</p>
<p>ç¬¬äºŒéƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä»jLoxè§£é‡Šå™¨å¼€å§‹ï¼ŒjLoxè§£é‡Šå™¨ï¼Œæ˜¯æˆ‘ä»¬å°†è¦ä»‹ç»çš„ä¸¤ä¸ªè§£é‡Šå™¨ä¹‹ä¸€ã€‚ç¼–ç¨‹è¯­è¨€æ˜¯ä¸€ä¸ªéå¸¸å¤§çš„è¯é¢˜ï¼Œæœ‰æˆå †çš„æ¦‚å¿µå’Œæœ¯è¯­ï¼Œå°†ä¸€ä¸‹å­å¡è¿›ä½ çš„å¤§è„‘ã€‚ç¼–ç¨‹è¯­è¨€ç†è®ºï¼Œéœ€è¦ä¸€å®šç¨‹åº¦ä¸Šçš„ä¸¥è°¨æ€§ï¼Œè¿™å¯èƒ½æ˜¯ä½ ä¸Šä¸€æ¬¡å¾®ç§¯åˆ†è€ƒè¯•åï¼Œå°±æ²¡æœ‰å†ç»å†è¿‡çš„ã€‚ä½†å¹¸è¿çš„æ˜¯ï¼Œæœ¬ä¹¦ä¸­ï¼Œæˆ‘ä»¬å°†å¾ˆå°‘æ¶‰åŠä¸¥è°¨çš„ç†è®ºç ”ç©¶ã€‚</p>
<p>å®ç°ä¸€ä¸ªè§£é‡Šå™¨ï¼Œä½¿ç”¨äº†å…¶ä»–ç±»å‹åº”ç”¨ç¨‹åºä¸­ï¼Œä¸å¤ªä½¿ç”¨çš„ï¼Œæ¶æ„æŠ€å·§å’Œè®¾è®¡æ¨¡å¼ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†ç†Ÿæ‚‰ä¸€äº›è½¯ä»¶å·¥ç¨‹æ–¹é¢çš„äº‹æƒ…ï¼Œæˆ‘ä»¬å°†ç¼–å†™å°½å¯èƒ½ç®€æ˜çš„ä»£ç ã€‚</p>
<p>åœ¨ä¸åˆ°ä¸¤åƒè¡ŒJavaä»£ç ä¸­ï¼Œæˆ‘ä»¬å°†å®ç°ä¸€ä¸ªLoxè¯­è¨€çš„å®Œæ•´çš„è§£é‡Šå™¨ï¼Œè¿™ä¸ªè§£é‡Šå™¨ï¼Œå®ç°äº†è¯­è¨€çš„æ‰€æœ‰ç‰¹æ€§ï¼Œæ­£å¦‚æˆ‘ä»¬æœŸæœ›çš„é‚£æ ·ã€‚æ¥ä¸‹æ¥çš„å‡ ç« ï¼Œæˆ‘ä»¬å°†ä»‹ç»è§£é‡Šå™¨çš„æ‰«æã€è§£æã€ä¼˜åŒ–é˜¶æ®µï¼Œä¹‹åï¼Œæˆ‘ä»¬å°†ä¸€æ¬¡ç›´æ¥æ·»åŠ ä¸€ä¸ªç‰¹æ€§ï¼ŒæŠŠä¸€ä¸ªç®€å•çš„è®¡ç®—å™¨ï¼Œæ‰©å±•ä¸ºä¸€ä¸ªæˆç†Ÿçš„è„šæœ¬è¯­è¨€ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ‰«æ"><a class="header" href="#æ‰«æ">æ‰«æ</a></h1>
<blockquote>
<p>Take big bites. Anything worth doing is worth overdoing.</p>
<p align="right"> â€”â€” Robert A. Heinlein, Time Enough for Love  </p>
<p>å¤§å£åƒï¼Œä»»ä½•å€¼å¾—åšçš„äº‹æƒ…ï¼Œéƒ½å€¼å¾—åšçš„è¿‡å¤´ã€‚</p>
</blockquote>
<p>The first step in any compiler or interpreter is scanning. The scanner takes in raw source code as a series of characters and groups it into a series of chunks we call tokens. These are the meaningful â€œwordsâ€ and â€œpunctuationâ€ that make up the languageâ€™s grammar.</p>
<p>Scanning is a good starting point for us too because the code isnâ€™t very hardâ€”pretty much a switch statement with delusions of grandeur. It will help us warm up before we tackle some of the more interesting material later. By the end of this chapter, weâ€™ll have a full-featured, fast scanner that can take any string of Lox source code and produce the tokens that weâ€™ll feed into the parser in the next chapter.</p>
<p>ä»»ä½•ç¼–è¯‘å™¨æˆ–è€…è§£é‡Šå™¨çš„ï¼Œç¬¬ä¸€ä¸ªé˜¶æ®µéƒ½æ˜¯æ‰«æã€‚æ‰«æå™¨å°†æºä»£ç å½“ä½œä¸€ç³»åˆ—çš„å­—ç¬¦åºåˆ—ï¼Œç»è¿‡æ‰«æåï¼Œä¼šåˆ†ç»„ä¸ºä¸€ç³»åˆ—çš„tokenï¼Œè¿™äº›tokenæ˜¯ï¼Œæ„æˆè¯­è¨€è¯­æ³•çš„åŸºæœ¬å•ä½ï¼Œä¾‹å¦‚ï¼šè‹±è¯­ä¸­çš„å•è¯å’Œæ ‡ç‚¹ç¬¦å·ã€‚</p>
<p>æ‰«æï¼Œå¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œæ˜¯ä¸€ä¸ªå¥½çš„èµ·ç‚¹ï¼Œå› ä¸ºæ‰«æéƒ¨åˆ†ä»£ç ï¼Œå¹¶ä¸å¤æ‚â€”â€”æ˜¯ä¸€ä¸ªæœ‰å¾ˆå¤š switchè¯­å¥çš„ä»£ç ã€‚æ‰«æéƒ¨åˆ†ï¼Œæ˜¯æˆ‘ä»¬åé¢å¤„ç†æ›´åŠ æœ‰è¶£é˜¶æ®µçš„çƒ­èº«ã€‚åœ¨æœ¬ç« ç»“æŸæ—¶å€™ï¼Œæˆ‘ä»¬å°†æ‹¥æœ‰ä¸€ä¸ªåŠŸèƒ½é½å…¨çš„å¿«é€Ÿæ‰«æå™¨ï¼Œå®ƒå¯ä»¥æ ¹æ®è¾“å…¥çš„ä»»æ„Loxè¯­è¨€æºä»£ç ï¼Œç”Ÿæˆæˆ‘ä»¬åé¢é˜¶æ®µä¼šä½¿ç”¨çš„ tokenåºåˆ—ã€‚</p>
<h2 id="ä¸€the-interpreter-framework"><a class="header" href="#ä¸€the-interpreter-framework">ä¸€ã€The Interpreter Framework</a></h2>
<p>è§£é‡Šå™¨æ¶æ„</p>
<p>Since this is our first real chapter, before we get to actually scanning some code we need to sketch out the basic shape of our interpreter, jlox. Everything starts with a class in Java.</p>
<pre><code class="language-java">
// lox/Lox.java
package com.craftinginterpreters.lox;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

public class Lox {
  public static void main(String[] args) throws IOException {
    if (args.length &gt; 1) {
      System.out.println(&quot;Usage: jlox [script]&quot;);
      System.exit(64); 
    } else if (args.length == 1) {
      runFile(args[0]);
    } else {
      runPrompt();
    }
  }
}

</code></pre>
<p>Stick that in a text file, and go get your IDE or Makefile or whatever set up. Iâ€™ll be right here when youâ€™re ready. Good? OK!</p>
<p>Lox is a scripting language, which means it executes directly from source. Our interpreter supports two ways of running code. If you start jlox from the command line and give it a path to a file, it reads the file and executes it.</p>
<pre><code class="language-java">
// lox/Lox.java

public class Lox {
    public static void main(String[] args) throws IOException {
		...
    }

    private static void runFile(String path) throws IOException {
        byte[] bytes = Files.readAllBytes(Paths.get(path));
        run(new String(bytes, Charset.defaultCharset()));
    }
}

</code></pre>
<p>If you want a more intimate conversation with your interpreter, you can also run it interactively. Fire up jlox without any arguments, and it drops you into a prompt where you can enter and execute code one line at a time.</p>
<pre><code class="language-java">
// lox/Lox.java
public class Lox {
    public static void main(String[] args) throws IOException {
		...
    }

    private static void runFile(String path) throws IOException {
		...
    }

    private static void runPrompt() throws IOException {
        InputStreamReader input = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(input);

        for (;;) {
            System.out.print(&quot;&gt; &quot;);
            String line = reader.readLine();
            if (line == null) {
                break;
            }
            run(line);
        }
    }
}
</code></pre>
<p>ç”±äºè¿™æ˜¯æˆ‘ä»¬çœŸæ­£çš„å¼€å§‹ç« èŠ‚ï¼Œåœ¨æˆ‘ä»¬å®é™…æ‰«æLoxä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæè¿° jlox è§£é‡Šå™¨çš„åŸºæœ¬ç»„æˆéƒ¨åˆ†ï¼Œä¸€åˆ‡ä»ä¸€ä¸ªJavaç±»å¼€å§‹ã€‚</p>
<p>å°†ä¸Šé¢ä»£ç ä¿å­˜åœ¨æ–‡ä»¶ä¸­ï¼Œå¯ä»¥é€‰æ‹©ä½ è‡ªå·±å–œæ¬¢çš„IDEã€‚</p>
<p>Loxè¯­è¨€æ˜¯ä¸€ç§è„šæœ¬è¯­è¨€ï¼Œæˆ‘çš„jloxè§£é‡Šå™¨ï¼Œæ”¯æŒä¸¤ç§è¿è¡Œæ–¹å¼ï¼Œå¦‚æœæŒ‡å®šä¸€ä¸ªæ–‡ä»¶è·¯å¾„ï¼Œjloxå°†è¯»å–å¹¶ä¸”è¿è¡Œè¯¥æ–‡ä»¶ã€‚</p>
<p>å¦‚æœä½ æƒ³è¦ä¸è§£é‡Šå™¨ï¼Œäº¤äº’è¿è¡Œï¼Œå¯ä»¥è¿è¡Œäº¤äº’æ¨¡å¼ã€‚ä¸æºå¸¦ä»»ä½•å‚æ•°è¿è¡Œjloxï¼Œå°†ä¼šè¿›å…¥äº¤äº’æ¨¡å¼ï¼Œä¸€æ¬¡å¯ä»¥è¿è¡Œä¸€è¡Œloxä»£ç ã€‚</p>
<blockquote>
<p>An interactive prompt is also called a â€œREPLâ€ (pronounced like â€œrebelâ€ but with a â€œpâ€). The name comes from Lisp where implementing one is as simple as wrapping a loop around a few built-in functions: </p>
<p>(print (eval (read)))</p>
<p>Working outwards from the most nested call, you Read a line of input, Evaluate it, Print the result, then Loop and do it all over again.</p>
<p>äº¤äº’å¼æç¤ºï¼Œä¹Ÿç§°ä¸º REPL, (Read, Evaluate, Print, Loop) , è¿™ä¸ªåç§°æ¥æºäº lispè¯­è¨€ï¼Œåœ¨lispä¸­ï¼Œå®ç°ä¸€ä¸ªäº¤äº’å¼ï¼Œå°±å¥½åƒä½¿ç”¨å†…ç½®å¤šä¸ªå‡½æ•°å’Œä¸€ä¸ªå¾ªç¯åŒ…è£…ä¸€æ ·ç®€å•ã€‚</p>
<p>(print (eval (read)))</p>
<p>ä»æœ€é‡Œé¢çš„ä»£ç å¼€å§‹ï¼Œå…ˆè¯»å–ä¸€æ®µä»£ç ï¼Œç„¶åè¿è¡Œï¼Œæœ€åæ‰“å°ç»“æœï¼Œæ¥ä¸‹æ¥ï¼Œå¼€å§‹ä¸‹ä¸€è½®å¾ªç¯ã€‚</p>
</blockquote>
<p>The readLine() function, as the name so helpfully implies, reads a line of input from the user on the command line and returns the result. To kill an interactive command-line app, you usually type Control-D. Doing so signals an â€œend-of-fileâ€ condition to the program. When that happens readLine() returns null, so we check for that to exit the loop.</p>
<p>Both the prompt and the file runner are thin wrappers around this core function:</p>
<pre><code class="language-java">// lox/Lox.java

public class Lox {
    public static void main(String[] args) throws IOException {
		...
    }

    private static void runFile(String path) throws IOException {
		...
    }

    private static void runPrompt() throws IOException {
		...
    }

    private static void run(String source) {
        Scanner scanner = new Scanner(source);
        List&lt;Token&gt; tokens = scanner.scanTokens();

        for (Token token : tokens) {
            System.out.println(token);
        }
    }
}
</code></pre>
<p>readline() å‡½æ•°ï¼Œé¡¾åæ€ä¹‰ï¼Œåœ¨å‘½ä»¤è¡Œï¼Œè¯»å–ç”¨æˆ·è¾“å…¥çš„ä¸€è¡Œï¼Œç„¶åè¿”å›è¿è¡Œç»“æœã€‚å¦‚æœæƒ³è¦ç»ˆæ­¢äº¤äº’å¼ç¨‹åºï¼Œé€šå¸¸é”®å…¥ Ctrl-D, è¿™æ ·åšï¼Œä¼šå‘ç¨‹åºå‘å‡º æ–‡ä»¶å·²ç»ç»“æŸä¿¡å·ï¼Œå½“è¿™ç§æƒ…å†µå‘ç”Ÿåï¼Œreadline() å‡½æ•°ï¼Œä¼šè¿”å›nullï¼Œæˆ‘ä»¬ç¨‹åºä¸­åˆ¤æ–­è¿”å›å€¼ï¼Œå¦‚æœæ˜¯nullï¼Œé€€å‡ºå¾ªç¯ï¼Œå³é€€å‡ºäº¤äº’å¼ç¨‹åºã€‚</p>
<p>äº¤äº’å¼æˆ–è€…ä»æ–‡ä»¶ä¸­è¯»å–ï¼Œç„¶åè¿è¡Œjlox çš„æ ¸å¿ƒå‡½æ•°æ˜¯ run</p>
<p>Itâ€™s not super useful yet since we havenâ€™t written the interpreter, but baby steps, you know? Right now, it prints out the tokens our forthcoming scanner will emit so that we can see if weâ€™re making progress.</p>
<p>å› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰å¼€å§‹ç¼–å†™è§£é‡Šå™¨ï¼Œæ‰€ä»¥jlox è¿˜ä¸æ˜¯éå¸¸æœ‰ç”¨ï¼Œä½†æ˜¯ä½ çŸ¥é“çš„ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å®ç°æ‰«æä»ªï¼Œrunå‡½æ•°å°†è¿”å›æ‰«æä»ªç”Ÿæˆçš„token åˆ—è¡¨ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡tokenåºåˆ—ï¼ŒæŸ¥çœ‹æ‰«æå™¨çš„è¿è¡Œæ•ˆæœã€‚</p>
<h3 id="11-error-handling"><a class="header" href="#11-error-handling">1.1 Error handling</a></h3>
<p>é”™è¯¯å¤„ç†</p>
<p>While weâ€™re setting things up, another key piece of infrastructure is error handling. Textbooks sometimes gloss over this because itâ€™s more a practical matter than a formal computer science-y problem. But if you care about making a language thatâ€™s actually usable, then handling errors gracefully is vital.</p>
<p>The tools our language provides for dealing with errors make up a large portion of its user interface. When the userâ€™s code is working, they arenâ€™t thinking about our language at allâ€”their headspace is all about their program. Itâ€™s usually only when things go wrong that they notice our implementation.</p>
<p>When that happens, itâ€™s up to us to give the user all the information they need to understand what went wrong and guide them gently back to where they are trying to go. Doing that well means thinking about error handling all through the implementation of our interpreter, starting now.</p>
<p>å½“æˆ‘ä»¬å¼€å§‹è¿è¡Œè§£é‡Šå™¨æ—¶å€™ï¼Œå¦å¤–ä¸€ä¸ªéœ€è¦è€ƒè™‘çš„åŸºç¡€åŠŸèƒ½æ˜¯é”™è¯¯å¤„ç†ã€‚åœ¨æ•™ç§‘ä¹¦ä¸­ï¼Œé€šå¸¸ä¸å¤ªæ¶‰åŠè¿™ä¸ªéƒ¨åˆ†ï¼Œå› ä¸ºé”™è¯¯å¤„ç†æ›´åƒæ˜¯ä¸€ä¸ªå®é™…é—®é¢˜ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªè®¡ç®—æœºç§‘å­¦çš„æ­£å¼é—®é¢˜ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬è¦çœŸæ­£ä½¿ç”¨ä¸€é—¨è¯­è¨€ï¼Œå¦‚ä½•ä¼˜é›…çš„å¤„ç†æŠ¥é”™ï¼Œæ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„éƒ¨åˆ†ã€‚</p>
<p>æˆ‘ä»¬è¯­è¨€å®ç°çš„ç”¨äºé”™è¯¯å¤„ç†çš„å·¥å…·ï¼Œæ„æˆäº†ç”¨æˆ·ç•Œé¢çš„å¾ˆå¤§ä¸€éƒ¨åˆ†ï¼Œå½“ç”¨æˆ·ä»£ç æ­£å¸¸è¿è¡Œæ—¶å€™ï¼Œä»–ä»¬ä¸ä¼šå…³å¿ƒæˆ‘ä»¬çš„è¯­è¨€ï¼Œç”¨æˆ·çš„é¡¶éƒ¨ç©ºé—´ï¼Œå°†å±•ç¤ºä»–ä»¬ç¨‹åºè¿è¡Œä¿¡æ¯ã€‚</p>
<p>å½“å‘ç”Ÿé”™è¯¯æ—¶å€™ï¼Œæˆ‘ä»¬åº”è¯¥æä¾›ç»™ç”¨æˆ·è¶³å¤Ÿçš„ä¿¡æ¯ï¼Œç”¨äºå®šä½å“ªé‡Œå‡ºç°äº†é—®é¢˜ï¼Œå¹¶å¼•å¯¼ç”¨æˆ·å›åˆ°æŠ¥é”™çš„ä½ç½®ã€‚åšå¥½è¿™ä¸€ç‚¹æ„å‘³ç€ä»ç°åœ¨å¼€å§‹ï¼Œåœ¨è§£é‡Šå™¨çš„æ•´ä¸ªå®ç°è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬éƒ½éœ€è¦è€ƒè™‘æŠ¥é”™å¤„ç†ã€‚</p>
<blockquote>
<p>Having said all that, for this interpreter, what weâ€™ll build is pretty bare bones. Iâ€™d love to talk about interactive debuggers, static analyzers, and other fun stuff, but thereâ€™s only so much ink in the pen.</p>
<p>å°½ç®¡å¦‚æ­¤ï¼Œå¯¹äºè¿™ä¸ªè§£é‡Šå™¨æ¥è¯´ï¼Œæˆ‘ä»¬å°†æ„å»ºçš„é”™è¯¯å¤„ç†ï¼Œæ˜¯éå¸¸ç®€å•çš„ã€‚æˆ‘å¾ˆæƒ³è°ˆè°ˆäº¤äº’å¼è°ƒè¯•å™¨ã€é™æ€åˆ†æå™¨å’Œå…¶ä»–æœ‰æ„æ€çš„ä¸œè¥¿ï¼Œä½†æ˜¯ç¬”é‡Œé¢ç°åœ¨åªæœ‰è¿™äº›å¢¨æ°´ã€‚</p>
</blockquote>
<pre><code class="language-java">
// lox/Lox.java, add after run()
static void error(int line, String message) {
	report(line, &quot;&quot;, message);
}

private static void report(int line, String where, String message) {
	System.err.println(&quot;[line &quot; + line + &quot;] Error&quot; + where + &quot;: &quot; + message);
	hadError = true;
}
	
</code></pre>
<p>This error() function and its report() helper tells the user some syntax error occurred on a given line. That is really the bare minimum to be able to claim you even have error reporting. Imagine if you accidentally left a dangling comma in some function call and the interpreter printed out:</p>
<pre><code>
Error: Unexpected &quot;,&quot; somewhere in your code. Good luck finding it!

</code></pre>
<p>Thatâ€™s not very helpful. We need to at least point them to the right line. Even better would be the beginning and end column so they know where in the line. Even better than that is to show the user the offending line, like:</p>
<pre><code>
Error: Unexpected &quot;,&quot; in argument list.

    15 | function(first, second,);
                               ^-- Here.
							   
</code></pre>
<p>error() å‡½æ•° å’Œ report() å‡½æ•°ï¼Œå‘Šè¯‰ç”¨æˆ·æŸä¸€è¡Œå‘ç”Ÿäº†è¯­æ³•é”™è¯¯ï¼Œè¿™å®é™…ä¸Šæ˜¯æŠ¥é”™å¤„ç†çš„æœ€ä½è¦æ±‚ã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœä½ åœ¨ä»£ç ä¸­æ·»åŠ äº†ä¸€ä¸ªå¤šä½™çš„é€—å·ï¼Œ è§£é‡Šå™¨è¿è¡Œç»“æœå¦‚ä¸‹:</p>
<pre><code>
Error: Unexpected &quot;,&quot; somewhere in your code. Good luck finding it!

</code></pre>
<p>è¿™ä¸æ˜¯éå¸¸æœ‰å¸®åŠ©ï¼Œæˆ‘ä»¬è‡³å°‘åº”è¯¥æŒ‡å‘æ­£ç¡®çš„æŠ¥é”™ä½ç½®ã€‚æ›´å¥½çš„æ–¹å¼ï¼Œæ˜¯è®¾ç½®æŠ¥é”™ä»£ç çš„èµ·å§‹ä½ç½®å’Œç»“æŸä½ç½®ï¼Œä»¥ä¾¿äºå±•ç¤ºæŠ¥é”™ä½ç½®ï¼Œæ›´åŠ å¥½çš„åšæ³•æ˜¯å±•ç¤ºæŠ¥é”™çš„åŸå§‹ä»£ç è¡Œï¼Œä¾‹å¦‚ï¼š</p>
<pre><code>
Error: Unexpected &quot;,&quot; in argument list.

    15 | function(first, second,);
                               ^-- Here.
							   
</code></pre>
<p>Iâ€™d love to implement something like that in this book but the honest truth is that itâ€™s a lot of grungy string manipulation code. Very useful for users, but not super fun to read in a book and not very technically interesting. So weâ€™ll stick with just a line number. In your own interpreters, please do as I say and not as I do.</p>
<p>The primary reason weâ€™re sticking this error reporting function in the main Lox class is because of that hadError field. Itâ€™s defined here:</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

public class Lox {
  static boolean hadError = false;
  ...
}
</code></pre>
<p>Weâ€™ll use this to ensure we donâ€™t try to execute code that has a known error. Also, it lets us exit with a non-zero exit code like a good command line citizen should.</p>
<pre><code class="language-java">
// lox/Lox.java, in runFile()

private static void runFile(String path) throws IOException {
	byte[] bytes = Files.readAllBytes(Paths.get(path));
	run(new String(bytes, Charset.defaultCharset()));

	// Indicate an error in the exit code.
	if (hadError) {
		System.exit(65);
	}
}
	

</code></pre>
<p>We need to reset this flag in the interactive loop. If the user makes a mistake, it shouldnâ€™t kill their entire session.</p>
<pre><code class="language-java">
// lox/Lox.java, in runPrompt()
    private static void runPrompt() throws IOException {
        InputStreamReader input = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(input);

        for (;;) {
            System.out.print(&quot;&gt; &quot;);
            String line = reader.readLine();
            if (line == null) {
                break;
            }
            run(line);
			hadError = false;
        }
    }



</code></pre>
<p>æˆ‘å¾ˆæƒ³åœ¨æœ¬ä¹¦ä¸­ï¼Œå®ç°ä¸Šé¢è¯´çš„æŠ¥é”™å¤„ç†åŠŸèƒ½ï¼Œè€å®è¯´ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸ç³Ÿç³•çš„å­—ç¬¦ä¸²å¤„ç†ä»£ç ã€‚å¯¹äºç”¨æˆ·æ¥è¯´ï¼Œé”™è¯¯å¤„ç†éå¸¸é‡è¦ï¼Œä½†æ˜¯ï¼Œå¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œåœ¨æŠ€æœ¯ä¸Šå®ç°ä¸æ˜¯éå¸¸æœ‰è¶£ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å°†åªä½¿ç”¨ä¸€ä¸ªè¡Œå·ï¼Œå½“ä½ å®ç°è‡ªå·±çš„è§£é‡Šå™¨æ—¶å€™ï¼Œå°½é‡æŒ‰ç…§æˆ‘è¯´çš„å»åšï¼Œè€Œä¸æ˜¯æŒ‰ç…§æˆ‘åšçš„å»åšã€‚</p>
<p>æˆ‘ä»¬åœ¨Loxä¸»ç±»ä¸­ï¼ŒåšæŒä½¿ç”¨reportå‡½æ•°çš„åŸå› æ˜¯ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå­—æ®µ hadError</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

public class Lox {
  static boolean hadError = false;
  ...
}
</code></pre>
<p>é€šè¿‡ hadError å­—æ®µï¼Œæˆ‘ä»¬å°†ç¡®ä¿åœ¨å‡ºç°æŠ¥é”™æ—¶å€™ï¼Œä¸å†æ‰§è¡Œä»£ç ã€‚æ­¤å¤–ï¼Œåˆ©ç”¨è¯¥å­—æ®µï¼Œæˆ‘ä»¬å¯ä»¥é€€å‡ºç¨‹åºï¼Œå°±åƒæ˜¯ä¸€ä¸ªå¥½çš„å‘½ä»¤è¡Œå·¥å…·é‚£æ ·ã€‚</p>
<pre><code class="language-java">
// lox/Lox.java, in runFile()

private static void runFile(String path) throws IOException {
	byte[] bytes = Files.readAllBytes(Paths.get(path));
	run(new String(bytes, Charset.defaultCharset()));

	// Indicate an error in the exit code.
	if (hadError) {
		System.exit(65);
	}
}
	

</code></pre>
<p>æˆ‘ä»¬éœ€è¦åœ¨äº¤äº’å¼æ‰§è¡Œæ—¶å€™ï¼Œé‡ç½® hadErrorä¿¡æ¯ï¼Œå¦‚æœç”¨æˆ·å†™é”™äº†å‘½ä»¤ï¼Œä¸åº”è¯¥æŠŠæ•´ä¸ªä¼šè¯æ–­å¼€ã€‚</p>
<pre><code class="language-java">
// lox/Lox.java, in runPrompt()
    private static void runPrompt() throws IOException {
        InputStreamReader input = new InputStreamReader(System.in);
        BufferedReader reader = new BufferedReader(input);

        for (;;) {
            System.out.print(&quot;&gt; &quot;);
            String line = reader.readLine();
            if (line == null) {
                break;
            }
            run(line);
			hadError = false;
        }
    }

</code></pre>
<p>The other reason I pulled the error reporting out here instead of stuffing it into the scanner and other phases where the error might occur is to remind you that itâ€™s good engineering practice to separate the code that generates the errors from the code that reports them.</p>
<p>Various phases of the front end will detect errors, but itâ€™s not really their job to know how to present that to a user. In a full-featured language implementation, you will likely have multiple ways errors get displayed: on stderr, in an IDEâ€™s error window, logged to a file, etc. You donâ€™t want that code smeared all over your scanner and parser.</p>
<p>Ideally, we would have an actual abstraction, some kind of â€œErrorReporterâ€ interface that gets passed to the scanner and parser so that we can swap out different reporting strategies. For our simple interpreter here, I didnâ€™t do that, but I did at least move the code for error reporting into a different class.</p>
<p>æˆ‘æŠŠerror reportå‡½æ•°ç‹¬ç«‹å‡ºæ¥ï¼Œè€Œä¸æ˜¯æŠŠå®ƒä»¬å†™å…¥scannerï¼Œæˆ–è€…å…¶ä»–å¯èƒ½å‘ç”Ÿé”™è¯¯çš„é˜¶æ®µï¼Œæ˜¯æé†’ä½ ï¼Œå°†äº§ç”Ÿé”™è¯¯çš„ä»£ç ï¼Œå’ŒæŠ¥å‘Šé”™è¯¯çš„ä»£ç åˆ†å¼€ï¼Œæ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å·¥ç¨‹å®è·µã€‚</p>
<p>å‰ç«¯çš„å„ä¸ªé˜¶æ®µéƒ½ä¼šæ£€æµ‹é”™è¯¯ï¼Œä½†æ˜¯å¦‚ä½•å°†é”™è¯¯å‘ˆç°ç»™ç”¨æˆ·ï¼Œå®é™…ä¸Šä¸æ˜¯å®ƒä»¬çš„å·¥ä½œã€‚åœ¨ä¸€ä¸ªå…¨åŠŸèƒ½çš„è¯­è¨€å®ç°ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå®ç°å¤šç§æŠ¥é”™å±•ç¤ºï¼Œä¾‹å¦‚ï¼šåœ¨æ ‡å‡†é”™è¯¯è¾“å‡ºä¸­ï¼ˆstderrï¼‰ï¼Œåœ¨IDEçš„æŠ¥é”™å±•ç¤ºç•Œé¢ï¼Œå°†æŠ¥é”™ä¿¡æ¯å†™å…¥æ—¥å¿—ï¼Œæˆ‘ä»¬è‚¯å®šä¸å¸Œæœ›åœ¨å‰ç«¯çš„æ¯ä¸ªé˜¶æ®µï¼Œéƒ½å®ç°ä¸€æ¬¡æŠ¥é”™å¤„ç†ã€‚</p>
<p>ç†æƒ³çŠ¶æ€ä¸‹ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªæŠ½è±¡æ¥å£ï¼ŒErrorReporter ï¼Œè¿™æ ·ï¼Œåœ¨ä¸åŒçš„ç¼–è¯‘é˜¶æ®µï¼Œä¾‹å¦‚ï¼šåœ¨æ‰«æã€è§£æé˜¶æ®µï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸åŒçš„æŠ¥é”™ç­–ç•¥ã€‚å¯¹äºæˆ‘ä»¬å½“å‰å®ç°çš„ç®€å•çš„jloxè§£é‡Šå™¨ï¼Œæˆ‘å°†ä¸æ‰“ç®—å®ç°ï¼Œä½†æ˜¯è‡³å°‘ï¼Œæˆ‘å°†æŠŠæŠ¥é”™å¤„ç†å‡½æ•°ï¼Œç§»åŠ¨åˆ°å¦å¤–ä¸€ä¸ªç±»ä¸­ã€‚</p>
<blockquote>
<p>I had exactly that when I first implemented jlox. I ended up tearing it out because it felt over-engineered for the minimal interpreter in this book.</p>
<p>å½“æˆ‘ä¸€å¼€å§‹å®ç°jloxæ—¶å€™ï¼Œæˆ‘çš„ç¡®å®ç°äº†ï¼Œä¸€ä¸ªé”™è¯¯å¤„ç†æ¥å£ï¼Œä½†æ˜¯ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘åˆæŠŠè¿™äº›ä»£ç åˆ é™¤äº†ï¼Œå› ä¸ºï¼Œå¯¹äºä¸€ä¸ªç®€æ´çš„è§£é‡Šå™¨ï¼Œæˆ‘ä»¬ä¸åº”è¯¥è¿‡åº¦è®¾è®¡é”™è¯¯å¤„ç†ã€‚</p>
</blockquote>
<p>With some rudimentary error handling in place, our application shell is ready. Once we have a Scanner class with a scanTokens() method, we can start running it. Before we get to that, letâ€™s get more precise about what tokens are.</p>
<p>æœ‰äº†åŸºæœ¬çš„æŠ¥é”™å¤„ç†ï¼Œæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥å¼€å§‹æ‰«æå™¨ï¼Œä¸€æ—¦æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå¸¦æœ‰ scanTokensæ–¹æ³•çš„Scanner ç±»ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘è¿è¡Œäº†ã€‚ä½†æ˜¯ï¼Œåœ¨çœŸæ­£è¿è¡Œæ‰«æå™¨ä¹‹å‰ï¼Œæˆ‘ä»¬è¿˜æ˜¯éœ€è¦å…ˆäº†è§£ä¸€ä¸‹ tokenã€‚</p>
<h2 id="äºŒ-lexemes-and-tokens"><a class="header" href="#äºŒ-lexemes-and-tokens">äºŒã€ Lexemes and Tokens</a></h2>
<p>è¯ç´  å’Œ token</p>
<p>Hereâ€™s a line of Lox code:</p>
<pre><code class="language-java">
var language = &quot;lox&quot;;

</code></pre>
<p>Here, var is the keyword for declaring a variable. That three-character sequence â€œv-a-râ€ means something. But if we yank three letters out of the middle of language, like â€œg-u-aâ€, those donâ€™t mean anything on their own.</p>
<p>Thatâ€™s what lexical analysis is about. Our job is to scan through the list of characters and group them together into the smallest sequences that still represent something. Each of these blobs of characters is called a lexeme. In that example line of code, the lexemes are:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lexemes.png?raw=true" alt="lexeme" /></p>
<p>The lexemes are only the raw substrings of the source code. However, in the process of grouping character sequences into lexemes, we also stumble upon some other useful information. When we take the lexeme and bundle it together with that other data, the result is a token. It includes useful stuff like:</p>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªLoxä»£ç </p>
<pre><code class="language-java">
var language = &quot;lox&quot;;

</code></pre>
<p>åœ¨è¿™é‡Œï¼Œvar ç”¨äºå£°æ˜ä¸€ä¸ªå˜é‡ï¼Œæ˜¯ä¸€ä¸ªå…³é”®å­—ï¼Œ3ä¸ªå­—ç¬¦ var æ„å‘³ç€ä»€ä¹ˆã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä» languageä¸­å–å‡º3ä¸ªå­—ç¬¦ï¼Œguaï¼Œè¿™äº›å­—æ¯æ²¡æœ‰å®é™…å«ä¹‰ã€‚</p>
<p>è¿™å°±æ˜¯è¯æ³•åˆ†æçš„æ„ä¹‰ï¼Œæˆ‘ä»¬çš„å·¥ä½œæ˜¯ï¼Œæ‰«æå­—ç¬¦åˆ—è¡¨ï¼Œç„¶åï¼ŒæŠŠå®ƒä»¬ç»„åˆæˆæœ€å°çš„åºåˆ—ï¼Œè¿™äº›åºåˆ—ä»ç„¶ä»£è¡¨äº†æŸäº›ä¸œè¥¿ï¼Œè¿™äº›å­—ç¬¦åºåˆ—ï¼Œç§°ä¸ºä¸€ä¸ªä¸ªè¯ç´ ï¼Œä¾‹å¦‚ï¼š</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lexemes.png?raw=true" alt="lexeme" /></p>
<p>è¯ç´ åªæ˜¯æºä»£ç çš„å­—ä¸²ï¼Œç„¶è€Œï¼Œåœ¨å°†å­—ç¬¦åˆ—è¡¨ç»„åˆæˆè¯ç´ åˆ—è¡¨çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬è¿˜å‘ç°äº†ä¸€äº›å…¶ä»–æœ‰ç”¨ä¿¡æ¯ã€‚å½“æˆ‘ä»¬å°†è¯ç´ å’Œå…¶ä»–æœ‰ç”¨ä¿¡æ¯ç»‘å®šåœ¨ä¸€èµ·æ—¶å€™ï¼Œæˆ‘ä»¬å°†è·å–åˆ°ä¸€ä¸ªtokenï¼Œæœ‰ç”¨ä¿¡æ¯å¦‚ä¸‹ã€‚</p>
<h3 id="21-token-type"><a class="header" href="#21-token-type">2.1 Token type</a></h3>
<p>tokneç±»å‹</p>
<p>Keywords are part of the shape of the languageâ€™s grammar, so the parser often has code like, â€œIf the next token is while then doâ€‰.â€‰.â€‰. â€ That means the parser wants to know not just that it has a lexeme for some identifier, but that it has a reserved word, and which keyword it is.</p>
<p>The parser could categorize tokens from the raw lexeme by comparing the strings, but thatâ€™s slow and kind of ugly. Instead, at the point that we recognize a lexeme, we also remember which kind of lexeme it represents. We have a different type for each keyword, operator, bit of punctuation, and literal type.</p>
<pre><code class="language-java">
// lox/TokenType.java, create new file
package com.craftinginterpreters.lox;

enum TokenType {
  // Single-character tokens.
  LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
  COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,

  // One or two character tokens.
  BANG, BANG_EQUAL,
  EQUAL, EQUAL_EQUAL,
  GREATER, GREATER_EQUAL,
  LESS, LESS_EQUAL,

  // Literals.
  IDENTIFIER, STRING, NUMBER,

  // Keywords.
  AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,
  PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,

  EOF
}

</code></pre>
<p>å…³é”®å­—æ˜¯è¯­è¨€è¯­æ³•çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤ï¼Œè§£æå™¨é€šå¸¸ä¼šæœ‰ä¸‹é¢çš„é€»è¾‘ï¼šå¦‚æœä¸‹ä¸€ä¸ªtokenæ˜¯ whileï¼Œé‚£ä¹ˆ..., è¿™æ„å‘³ç€ï¼Œè§£æå™¨ä¸ä»…ä»…æƒ³è¦çŸ¥é“ï¼Œå®ƒå…·æœ‰æŸä¸ªæ ‡è¯†ç¬¦ï¼Œè¿˜æƒ³è¦çŸ¥é“å®ƒåŒ…å«æœ‰ä¸€ä¸ªä¿ç•™å­—ï¼Œç”¨äºå…³é”®å­—å£°æ˜ã€‚</p>
<p>è§£æå™¨å¯ä»¥é€šè¿‡æ¯”è¾ƒå­—ç¬¦ä¸²ï¼Œå¯¹åŸå§‹è¯ç´ è¿›è¡Œåˆ†ç±»ï¼Œä½†æ˜¯è¿™æ ·æ—¢æ…¢ï¼Œå¹¶ä¸”éå¸¸éš¾å®ç°ã€‚ç›¸åï¼Œåœ¨æˆ‘ä»¬è¯†åˆ«ä¸€ä¸ªè¯ç´ çš„æ—¶å€™ï¼Œæ¯ä¸€ä¸ªè¯ç´ éƒ½æœ‰ç‰¹å®šçš„ç±»å‹ï¼Œä¾‹å¦‚ï¼šå…³é”®å­—ã€è¿ç®—ç¬¦ã€æ ‡ç‚¹ç¬¦å·ã€æ–‡å­—ç±»å‹ç­‰ç­‰ã€‚</p>
<pre><code class="language-java">
// lox/TokenType.java, create new file
package com.craftinginterpreters.lox;

enum TokenType {
  // Single-character tokens.
  LEFT_PAREN, RIGHT_PAREN, LEFT_BRACE, RIGHT_BRACE,
  COMMA, DOT, MINUS, PLUS, SEMICOLON, SLASH, STAR,

  // One or two character tokens.
  BANG, BANG_EQUAL,
  EQUAL, EQUAL_EQUAL,
  GREATER, GREATER_EQUAL,
  LESS, LESS_EQUAL,

  // Literals.
  IDENTIFIER, STRING, NUMBER,

  // Keywords.
  AND, CLASS, ELSE, FALSE, FUN, FOR, IF, NIL, OR,
  PRINT, RETURN, SUPER, THIS, TRUE, VAR, WHILE,

  EOF
}

</code></pre>
<blockquote>
<p>After all, string comparison ends up looking at individual characters, and isnâ€™t that the scannerâ€™s job?</p>
<p>æ¯•ç«Ÿï¼Œå­—ç¬¦ä¸²æ¯”è¾ƒä¼šæœ€ç»ˆæ¯”è¾ƒæ¯ä¸€ä¸ªå­—ç¬¦ï¼Œè¿™ä¸ªä¸æ˜¯æ‰«æå™¨çš„åŠŸèƒ½å—ï¼Ÿ</p>
</blockquote>
<h3 id="22-literal-value"><a class="header" href="#22-literal-value">2.2 Literal value</a></h3>
<p>å­—ç¬¦å€¼</p>
<p>There are lexemes for literal valuesâ€”numbers and strings and the like. Since the scanner has to walk each character in the literal to correctly identify it, it can also convert that textual representation of a value to the living runtime object that will be used by the interpreter later</p>
<p>è¯ç´ å…·æœ‰å®é™…å€¼ï¼Œå¯èƒ½æ˜¯æ•°å­—ï¼Œå­—ç¬¦ä¸²ç­‰ã€‚ç”±äºæ‰«æå™¨éœ€è¦éå†æ–‡æœ¬ä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦ï¼Œå› æ­¤ï¼Œæ‰«æå™¨æ‰«æè¿‡ç¨‹ä¸­ï¼Œä¼šå°†å…·ä½“çš„æ–‡æœ¬å€¼ï¼Œè½¬åŒ–ä¸ºä¸€ä¸ªä¸ªè¿è¡Œæ—¶å¯¹è±¡ï¼Œåœ¨æ¥ä¸‹æ¥çš„è§£é‡Šé˜¶æ®µï¼Œå°†ä½¿ç”¨è¿™äº›å¯¹è±¡ã€‚</p>
<h3 id="23-location-information"><a class="header" href="#23-location-information">2.3 Location information</a></h3>
<p>ä½ç½®ä¿¡æ¯</p>
<p>Back when I was preaching the gospel about error handling, we saw that we need to tell users where errors occurred. Tracking that starts here. In our simple interpreter, we note only which line the token appears on, but more sophisticated implementations include the column and length too.</p>
<p>å›åˆ°ä¸Šä¸€ç« ï¼Œæˆ‘å®£ä¼ é”™è¯¯å¤„ç†çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¿…é¡»å‘Šè¯‰ç”¨æˆ·é”™è¯¯å‘ç”Ÿçš„å…·ä½“ä½ç½®ï¼Œè€Œè®°å½•ä½ç½®ä¿¡æ¯ï¼Œæ˜¯ä»è¿™é‡Œå¼€å§‹çš„ã€‚åœ¨æˆ‘ä»¬å®ç°çš„ç®€å•çš„è§£é‡Šå™¨ä¸­ï¼Œæˆ‘ä»¬åªä¼šè®°å½•è¡Œä¿¡æ¯ï¼Œä½†æ˜¯ï¼Œå¯¹äºæ›´åŠ å¤æ‚çš„è§£é‡Šå™¨ï¼Œéœ€è¦è®°å½•å…·ä½“çš„åˆ—å’Œé•¿åº¦ä¿¡æ¯ã€‚</p>
<blockquote>
<p>Some token implementations store the location as two numbers: the offset from the beginning of the source file to the beginning of the lexeme, and the length of the lexeme. The scanner needs to know these anyway, so thereâ€™s no overhead to calculate them.</p>
<p>æœ‰äº›token å®ç°ä¸­ä½¿ç”¨ä¸¤ä¸ªæ•°å­—ä¿å­˜ä½ç½®ä¿¡æ¯ï¼šä»æºæ–‡ä»¶å¼€å§‹åˆ°è¯ç´ å¼€å§‹çš„åç§»é‡ï¼Œè¯ç´ çš„é•¿åº¦ï¼Œæ‰«æå™¨éœ€è¦çŸ¥é“è¿™äº›ä½ç½®ä¿¡æ¯ï¼Œè®¡ç®—è¿™ä¸ªä½ç½®ï¼Œä¸æ˜¯è¿‡åº¦è®¡ç®—ã€‚</p>
<p>An offset can be converted to line and column positions later by looking back at the source file and counting the preceding newlines. That sounds slow, and it is. However, you need to do it only when you need to actually display a line and column to the user. Most tokens never appear in an error message. For those, the less time you spend calculating position information ahead of time, the better.</p>
<p>é€šè¿‡åç§»é‡ä¿¡æ¯ï¼ˆå³æºæ–‡ä»¶åˆ°è¯ç´ çš„åç§»é‡ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡æŸ¥çœ‹æºæ–‡ä»¶ï¼Œæ¢ç®—ä¸ºå…·ä½“çš„è¡Œã€åˆ—ä¿¡æ¯ã€‚ æ³¨æ„ï¼Œæ¢è¡Œç¬¦çš„å­˜åœ¨ã€‚è¿™ä¸ªè¿‡ç¨‹çœ‹èµ·æ¥å¾ˆæ…¢ï¼Œå®é™…çš„ç¡®æ˜¯ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬åªæ˜¯åœ¨éœ€è¦å±•ç¤ºå®é™…è¡Œã€åˆ—ä¿¡æ¯æ—¶å€™ï¼Œæ‰éœ€è¦å¦‚æ­¤è®¡ç®—ã€‚ä½†æ˜¯ï¼Œå¤§å¤šæ•° tokenä¸ä¼šå‡ºç°åœ¨é”™è¯¯ä¿¡æ¯ä¸­ï¼Œæ‰€ä»¥ï¼Œå¯¹äºè¿™äº›tokenï¼Œè®¡ç®—å®ƒä»¬çš„ä½ç½®ä¿¡æ¯ä¸ä¼šæ¶ˆè€—å¾ˆå¤šæ—¶é—´ã€‚</p>
</blockquote>
<p>We take all of this data and wrap it in a class.</p>
<pre><code class="language-java">
// lox/Token.java, create new file
package com.craftinginterpreters.lox;

class Token {
  final TokenType type;
  final String lexeme;
  final Object literal;
  final int line; 

  Token(TokenType type, String lexeme, Object literal, int line) {
    this.type = type;
    this.lexeme = lexeme;
    this.literal = literal;
    this.line = line;
  }

  public String toString() {
    return type + &quot; &quot; + lexeme + &quot; &quot; + literal;
  }
}

</code></pre>
<p>æˆ‘ä»¬å°†token æ‰“åŒ…ä¸ºä¸€ä¸ªç±»ã€‚</p>
<pre><code class="language-java">
// lox/Token.java, create new file
package com.craftinginterpreters.lox;

class Token {
  final TokenType type;
  final String lexeme;
  final Object literal;
  final int line; 

  Token(TokenType type, String lexeme, Object literal, int line) {
    this.type = type;
    this.lexeme = lexeme;
    this.literal = literal;
    this.line = line;
  }

  public String toString() {
    return type + &quot; &quot; + lexeme + &quot; &quot; + literal;
  }
}

</code></pre>
<p>Now we have an object with enough structure to be useful for all of the later phases of the interpreter.</p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬æ‹¥æœ‰äº†ä¸€ä¸ªå¯¹è±¡ï¼Œå…·æœ‰è¶³å¤Ÿçš„ç»“æ„ï¼Œå¯ä»¥ç”¨äºè§£é‡Šå™¨åç»­é˜¶æ®µã€‚</p>
<h2 id="ä¸‰-regular-languages-and-expressions"><a class="header" href="#ä¸‰-regular-languages-and-expressions">ä¸‰ã€ Regular Languages and Expressions</a></h2>
<p>Now that we know what weâ€™re trying to produce, letâ€™s, well, produce it. The core of the scanner is a loop. Starting at the first character of the source code, the scanner figures out what lexeme the character belongs to, and consumes it and any following characters that are part of that lexeme. When it reaches the end of that lexeme, it emits a token.</p>
<p>Then it loops back and does it again, starting from the very next character in the source code. It keeps doing that, eating characters and occasionally, uh, excreting tokens, until it reaches the end of the input.</p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬çŸ¥é“äº†æƒ³è¦ç”Ÿäº§ä»€ä¹ˆï¼Œé‚£å°±è®©æˆ‘ä»¬å»ç”Ÿäº§å§ã€‚æ‰«æå™¨çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œä»æºä»£ç çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹ï¼Œæ‰«æå™¨è¯†åˆ«å‡ºè¯¥å­—ç¬¦æ‰€å±çš„è¯ç´ ï¼Œç„¶åï¼Œç»§ç»­æ‰«æï¼Œä¸€ç›´åˆ°è¯ç´ çš„ç»“æŸã€‚ç„¶åï¼Œæ‰«æå™¨ä¼šæäº¤ä¸€ä¸ªtokenã€‚</p>
<p>ç„¶åï¼Œæ‰«æå™¨å†æ¬¡ä»å‰ä¸€ä¸ªè¯ç´ ç»“å°¾å¼€å§‹ï¼Œå®ƒä¼šä¸€ç›´è¿™æ ·ï¼Œæ‰«æå­—ç¬¦ï¼Œå¶å°”ï¼Œåˆ°è¾¾è¯ç´ ç»“å°¾ï¼Œæäº¤tokenï¼Œä¸€ç›´åˆ°æºä»£ç çš„ç»“å°¾ã€‚</p>
<blockquote>
<p>Lexical analygator.</p>
<p>è¯æ³•åˆ†æå™¨</p>
</blockquote>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lexigator.png?raw=true" alt="lexical" /></p>
<p>The part of the loop where we look at a handful of characters to figure out which kind of lexeme it â€œmatchesâ€ may sound familiar. If you know regular expressions, you might consider defining a regex for each kind of lexeme and using those to match characters. For example, Lox has the same rules as C for identifiers (variable names and the like). This regex matches one:</p>
<pre><code>
[a-zA-Z_][a-zA-Z_0-9]*

</code></pre>
<p>åœ¨æ‰«æå™¨çš„å¾ªç¯è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡å‡ ä¸ªå­—ç¬¦ï¼Œåˆ¤æ–­å‡ºè¯ç´ çš„ç±»å‹ï¼Œè¿™çœ‹èµ·æ¥å¾ˆç†Ÿæ‚‰ã€‚å¦‚æœä½ çŸ¥é“æ­£åˆ™è¡¨è¾¾å¼ï¼Œä½ å¯èƒ½ä¼šä¸ºæ¯ç§ç±»å‹çš„è¯ç´ ï¼Œå®šä¹‰ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä½¿ç”¨å®ƒæ¥åŒ¹é…å­—ç¬¦ã€‚ä¾‹å¦‚ï¼šloxè¯­è¨€ä¸­ï¼Œå¯¹äºæ ‡è¯†ç¬¦çš„å®šä¹‰ï¼ˆå³å˜é‡åç§°ï¼‰å…·æœ‰å’ŒCè¯­è¨€ç›¸åŒçš„è§„åˆ™ï¼Œå¯ä»¥ç”¨æ­£åˆ™è¡¨è¾¾å¼è¡¨ç¤º</p>
<pre><code>
[a-zA-Z_][a-zA-Z_0-9]*

</code></pre>
<p>If you did think of regular expressions, your intuition is a deep one. The rules that determine how a particular language groups characters into lexemes are called its lexical grammar. In Lox, as in most programming languages, the rules of that grammar are simple enough for the language to be classified a regular language. Thatâ€™s the same â€œregularâ€ as in regular expressions.</p>
<p>å¦‚æœä½ æƒ³åˆ°äº†æ­£åˆ™è¡¨è¾¾å¼ï¼Œä½ çš„ç›´è§‰æ˜¯æ­£ç¡®æ·±åˆ»çš„ã€‚å¦‚ä½•å°†å­—ç¬¦åºåˆ—åˆ†ç»„ä¸ºè¯ç´ çš„è§„åˆ™ç§°ä¸ºè¯æ³•è§„åˆ™ã€‚åœ¨Loxä¸­ï¼Œå’Œå¤§å¤šæ•°çš„è¯­è¨€ä¸€æ ·ï¼Œè¯¥è¯­æ³•è§„åˆ™éå¸¸ç®€å•ï¼Œå¯ä»¥å°† loxè¯­è¨€å½’ç±»ä¸ºå¸¸è§„è¯­è¨€ï¼Œè¿™ä¸æ­£åˆ™è¡¨è¾¾å¼ä¸­çš„æ­£åˆ™æ˜¯ä¸€ä¸ªå«ä¹‰ã€‚</p>
<blockquote>
<p>It pains me to gloss over the theory so much, especially when itâ€™s as interesting as I think the Chomsky hierarchy and finite-state machines are. But the honest truth is other books cover this better than I could. Compilers: Principles, Techniques, and Tools (universally known as â€œthe dragon bookâ€) is the canonical reference.</p>
<p>æˆ‘å¾ˆç—›è‹¦çš„æ©ç›–äº†è¿™ä¸ªç†è®ºï¼Œç‰¹åˆ«æ˜¯å½“å®ƒåƒæˆ‘è®¤ä¸ºçš„<a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">ä¹”å§†æ–¯åŸºè°±ç³» (Chomsky hierarchy)</a>å’Œ<a href="https://en.wikipedia.org/wiki/Finite-state_machine">æœ‰é™çŠ¶æ€æœº (Finite-state machine)</a>ä¸€æ ·æœ‰æ„æ€ã€‚ä½†è€å®è¯´ï¼Œå…¶ä»–ä¹¦æ¯”æˆ‘å†™å¾—æ›´å¥½ä¸€äº›ï¼Œ<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">ç¼–è¯‘å™¨ï¼šåŸç†ã€æŠ€æœ¯å’Œå·¥å…·</a>ï¼Œé€šå¸¸è¢«ç§°ä¸ºé¾™ä¹¦ï¼Œæ˜¯ç¼–è¯‘å™¨é¢†åŸŸçš„æ ‡å‡†ã€‚</p>
</blockquote>
<p>You very precisely can recognize all of the different lexemes for Lox using regexes if you want to, and thereâ€™s a pile of interesting theory underlying why that is and what it means. Tools like Lex or Flex are designed expressly to let you do thisâ€”throw a handful of regexes at them, and they give you a complete scanner back.</p>
<p>Since our goal is to understand how a scanner does what it does, we wonâ€™t be delegating that task. Weâ€™re about handcrafted goods.</p>
<p>å¦‚æœä½ æƒ³çš„è¯ï¼Œä½ å¯ä»¥éå¸¸ç²¾ç¡®åœ°ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ¥è¯†åˆ«Loxçš„æ‰€æœ‰ä¸åŒè¯ç´ ï¼Œå¹¶ä¸”æœ‰ä¸€å †ç†è®ºè¯´æ˜ï¼Œä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Œä»¥åŠå®ƒçš„å«ä¹‰ã€‚åƒæ˜¯ Lex Flexå°±æ˜¯è¿™æ ·çš„å·¥å…·ï¼Œä½ å¯ä»¥å‘å®ƒä»¬æä¾›ä¸€äº›æ­£åˆ™è¡¨è¾¾å¼ï¼Œå®ƒä»¬ä¼šç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„æ‰«æå™¨ã€‚</p>
<p>å› ä¸ºæˆ‘ä»¬çš„ç›®æ ‡æ˜¯äº†è§£æ‰«æå™¨å†…éƒ¨å·¥ä½œåŸç†ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ä¼šä½¿ç”¨Lexè¿™æ ·çš„å·¥å…·ï¼Œæˆ‘ä»¬å¸Œæœ›çš„æ˜¯çº¯æ‰‹å·¥æ‰“é€ çš„å·¥è‰ºå“ã€‚</p>
<blockquote>
<p>Lex was created by Mike Lesk and Eric Schmidt. Yes, the same Eric Schmidt who was executive chairman of Google. Iâ€™m not saying programming languages are a surefire path to wealth and fame, but we can count at least one mega billionaire among us.</p>
<p>lexæ˜¯ç”±  Mike Lesk å’Œ Eric Schmidt å¼€å‘çš„å·¥å…·ï¼Œæ˜¯çš„ï¼Œå°±æ˜¯ googleå…¬å¸åˆ›å§‹äºº  Eric Schmidt. æˆ‘å¹¶ä¸æ˜¯è¯´ç¼–ç¨‹è¯­è¨€å¯ä»¥è®©äººå˜å¾—å¯Œæœ‰ï¼Œä½†æ˜¯è‡³å°‘æˆ‘ä»¬å½“ä¸­å‡ºç°äº†ä¸€ä¸ªäº¿ä¸‡å¯Œç¿ã€‚</p>
</blockquote>
<h2 id="å››the-scanner-class"><a class="header" href="#å››the-scanner-class">å››ã€The Scanner Class</a></h2>
<p>æ‰«æå™¨ç±»</p>
<p>Without further ado, letâ€™s make ourselves a scanner.</p>
<p>ä¸éœ€è¦éº»çƒ¦äº†ï¼Œæˆ‘ä»¬å°†è‡ªå·±å®ç°ä¸€ä¸ªæ‰«æå™¨ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, create new file

package com.craftinginterpreters.lox;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static com.craftinginterpreters.lox.TokenType.*; 

class Scanner {
  private final String source;
  private final List&lt;Token&gt; tokens = new ArrayList&lt;&gt;();

  Scanner(String source) {
    this.source = source;
  }
}


</code></pre>
<blockquote>
<p>I know static imports are considered bad style by some, but they save me from having to sprinkle TokenType. all over the scanner and parser. Forgive me, but every character counts in a book.</p>
<p>æˆ‘çŸ¥é“é™æ€å¯¼å…¥ï¼Œè¢«å¾ˆå¤šäººè®¤ä¸ºæ˜¯ä¸€ç§ç³Ÿç³•çš„å†™æ³•ï¼Œä½†æ˜¯ï¼Œé™æ€å¯¼å…¥ï¼Œå¯ä»¥è®©æˆ‘ä»¬çš„å¼•ç”¨ä»£ç ï¼Œä¸ç”¨å†æ·»åŠ  TokenType , æ‰«æå™¨å’Œè§£é‡Šå™¨ï¼Œä¼šå……æ»¡ TokenType, è¯·åŸè°…æˆ‘ï¼Œä¹¦ä¸­çš„æ¯ä¸€ä¸ªç« èŠ‚éƒ½å¾ˆé‡è¦ã€‚</p>
</blockquote>
<p>We store the raw source code as a simple string, and we have a list ready to fill with tokens weâ€™re going to generate. The aforementioned loop that does that looks like this:</p>
<p>æˆ‘ä»¬å°†æºä»£ç å­˜å‚¨ä¸ºä¸€ä¸ªç®€å•çš„å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªåˆ—è¡¨ï¼Œæ‰«æå™¨æäº¤çš„tokenéƒ½ä¼šå†™å…¥è¿™ä¸ªåˆ—è¡¨ã€‚ä¸Šé¢æåˆ°çš„æ‰«æå™¨å¾ªç¯ï¼Œçœ‹èµ·æ¥æ˜¯ä¸‹é¢ä»£ç ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, add after Scanner()

  List&lt;Token&gt; scanTokens() {
    while (!isAtEnd()) {
      // We are at the beginning of the next lexeme.
      start = current;
      scanToken();
    }

    tokens.add(new Token(EOF, &quot;&quot;, null, line));
    return tokens;
  }


</code></pre>
<p>The scanner works its way through the source code, adding tokens until it runs out of characters. Then it appends one final â€œend of fileâ€ token. That isnâ€™t strictly needed, but it makes our parser a little cleaner.</p>
<p>This loop depends on a couple of fields to keep track of where the scanner is in the source code.</p>
<p>æ‰«æå™¨é€šè¿‡æ‰«ææºä»£ç ï¼Œæ·»åŠ tokenï¼Œä¸€ç›´åˆ°å­—ç¬¦åºåˆ—éå†å®Œæˆã€‚ç„¶åï¼Œåœ¨æœ€åæ·»åŠ ä¸€ä¸ªâ€œæ–‡ä»¶ç»“æŸâ€çš„tokenï¼Œè¿™ä¸ªæ–‡ä»¶ç»“æŸ tokenä¸æ˜¯ä¸¥æ ¼å¿…é¡»çš„ï¼Œä½†æ˜¯å®ƒä¼šè®©æˆ‘ä»¬çš„è§£é‡Šå™¨æ›´åŠ ç®€æ´ã€‚</p>
<p>å¾ªç¯é˜¶æ®µï¼Œä¾æ®å‡ ä¸ªå­—æ®µï¼Œæ¥è¿½è¸ªæ‰«æå™¨çš„å…·ä½“ä½ç½®ä¿¡æ¯ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, in class Scanner
  private final List&lt;Token&gt; tokens = new ArrayList&lt;&gt;();
  private int start = 0;
  private int current = 0;
  private int line = 1;

  Scanner(String source) {

</code></pre>
<p>The start and current fields are offsets that index into the string. The start field points to the first character in the lexeme being scanned, and current points at the character currently being considered. The line field tracks what source line current is on so we can produce tokens that know their location.</p>
<p>Then we have one little helper function that tells us if weâ€™ve consumed all the characters.</p>
<p>start å’Œ currentå˜é‡è¡¨ç¤ºè¯ç´ çš„ä½ç½®ä¿¡æ¯ï¼Œstartå­—æ®µè¡¨ç¤ºè¯ç´ çš„ç¬¬ä¸€ä¸ªå­—ç¬¦çš„ä½ç½®ï¼Œcurrentè¡¨ç¤ºå½“å‰æ‰«æåˆ°çš„å­—ç¬¦ä½ç½®ï¼Œlineå­—æ®µè¡¨ç¤ºå½“å‰æ‰«æçš„è¡Œï¼Œæ ¹æ®è¿™äº›å­—æ®µï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ tokenä¸­çš„ä½ç½®ä¿¡æ¯ã€‚</p>
<p>æˆ‘ä»¬è¿˜å®šä¹‰ä¸€ä¸ªå‡½æ•° isAtEndï¼Œç”¨äºåˆ¤æ–­æ˜¯å¦å·²ç»æ‰«æå®Œã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanTokens()

  private boolean isAtEnd() {
    return current &gt;= source.length();
  }
  
</code></pre>
<h2 id="äº”recognizing-lexemes"><a class="header" href="#äº”recognizing-lexemes">äº”ã€Recognizing Lexemes</a></h2>
<p>è¯†åˆ«è¯ç´ </p>
<p>In each turn of the loop, we scan a single token. This is the real heart of the scanner. Weâ€™ll start simple. Imagine if every lexeme were only a single character long. All you would need to do is consume the next character and pick a token type for it. Several lexemes are only a single character in Lox, so letâ€™s start with those.</p>
<p>åœ¨å¾ªç¯è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šæ‰«ætokenï¼Œè¿™æ˜¯æ‰«æå™¨çš„æ ¸å¿ƒåŠŸèƒ½ï¼Œæˆ‘ä»¬ä»ç®€å•å¼€å§‹ï¼Œè®¾æƒ³ä¸€ä¸‹ï¼Œæ¯ä¸ªtokenéƒ½æ˜¯ä¸€ä¸ªç®€å•çš„å­—ç¬¦ï¼Œæˆ‘ä»¬éœ€è¦åšçš„æ˜¯ï¼Œç»§ç»­åˆ¤æ–­ä¸‹ä¸€ä¸ªtokenï¼Œåœ¨Loxè¯­è¨€ä¸­ï¼Œæœ‰å‡ ä¸ªè¯ç´ æ˜¯ç®€å•çš„ä¸€ä¸ªå­—ç¬¦ï¼Œæˆ‘ä»¬ä»è¿™äº›å•å­—ç¬¦è¯ç´ å¼€å§‹ï¼š</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanTokens()

  private void scanToken() {
    char c = advance();
    switch (c) {
      case '(': addToken(LEFT_PAREN); break;
      case ')': addToken(RIGHT_PAREN); break;
      case '{': addToken(LEFT_BRACE); break;
      case '}': addToken(RIGHT_BRACE); break;
      case ',': addToken(COMMA); break;
      case '.': addToken(DOT); break;
      case '-': addToken(MINUS); break;
      case '+': addToken(PLUS); break;
      case ';': addToken(SEMICOLON); break;
      case '*': addToken(STAR); break; 
    }
  }
  
</code></pre>
<blockquote>
<p>Wondering why / isnâ€™t in here? Donâ€™t worry, weâ€™ll get to it.</p>
<p>ä¸ºä»€ä¹ˆ / ç¬¦å·ä¸åœ¨ä¸Šé¢çš„åˆ¤æ–­ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šé©¬ä¸Šå‘Šè¯‰ä½ ã€‚</p>
</blockquote>
<p>Again, we need a couple of helper methods.</p>
<p>The advance() method consumes the next character in the source file and returns it. Where advance() is for input, addToken() is for output. It grabs the text of the current lexeme and creates a new token for it. Weâ€™ll use the other overload to handle tokens with literal values soon.</p>
<p>åŒæ ·çš„ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å®šä¹‰å‡ ä¸ªæ–¹æ³•ã€‚</p>
<p>advance() æ–¹æ³•è·å–æºæ–‡ä»¶ä¸­çš„ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”è¿”å›ã€‚ advance() æ–¹æ³•ä¸»è¦ç”¨äºè¾“å…¥ï¼ŒaddToken() æ–¹æ³•ç”¨äºè¾“å‡ºï¼Œå®ƒä¼šè·å–å½“å‰è¯ç´ æ–‡æœ¬ï¼Œå¹¶ä¸”åˆ›å»ºæ–°çš„tokenï¼Œä¸‹é¢å°†å¾ˆå¿«åº”ç”¨å¦å¤–ä¸€ä¸ª addToken() é‡è½½æ–¹æ³•</p>
<pre><code class="language-java">
// lox/Scanner.java, add after isAtEnd()

  private char advance() {
    return source.charAt(current++);
  }

  private void addToken(TokenType type) {
    addToken(type, null);
  }

  private void addToken(TokenType type, Object literal) {
    String text = source.substring(start, current);
    tokens.add(new Token(type, text, literal, line));
  }
  
</code></pre>
<h3 id="51-lexical-errors"><a class="header" href="#51-lexical-errors">5.1 Lexical errors</a></h3>
<p>è¯ç´ é”™è¯¯</p>
<p>Before we get too far in, letâ€™s take a moment to think about errors at the lexical level.  What happens if a user throws a source file containing some characters Lox doesnâ€™t use, like @#^, at our interpreter? Right now, those characters get silently discarded. They arenâ€™t used by the Lox language, but that doesnâ€™t mean the interpreter can pretend they arenâ€™t there. Instead, we report an error.</p>
<p>åœ¨æˆ‘ä»¬æ·±å…¥æ¢è®¨ä¹‹å‰ï¼Œéœ€è¦èŠ±ä¸€ç‚¹æ—¶é—´è€ƒè™‘ä¸€ä¸‹è¯æ±‡å±‚é¢çš„é”™è¯¯ã€‚å¦‚æœå®¢æˆ·æºæ–‡ä»¶ä¸­åŒ…å«äº†ï¼ŒLoxè¯­è¨€ä¸­æœªå®šä¹‰çš„å­—ç¬¦ï¼Œä¾‹å¦‚ @#^ï¼Œæˆ‘ä»¬çš„jloxè§£é‡Šå™¨å°†ä¼šå¦‚ä½•å¤„ç†ï¼Ÿç°åœ¨ï¼Œæˆ‘ä»¬çš„å¤„ç†æ–¹å¼æ˜¯ï¼Œæ‚„æ‚„ä¸¢å¼ƒè¿™äº›å­—ç¬¦ã€‚ä½†æ˜¯ï¼ŒLoxè¯­è¨€ä¸­ä¸ä½¿ç”¨å®ƒä»¬ï¼Œå¹¶ä¸è¡¨ç¤ºå®ƒä»¬ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬å°†æŠ¥å‘Šä¸€ä¸ªé”™è¯¯ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()
            case '*':
                addToken(STAR);
                break;
            default:
                Lox.error(line, &quot;Unexpected character.&quot;);
                break;
        }
		
</code></pre>
<p>Note that the erroneous character is still consumed by the earlier call to advance(). Thatâ€™s important so that we donâ€™t get stuck in an infinite loop.</p>
<p>Note also that we keep scanning. There may be other errors later in the program.  It gives our users a better experience if we detect as many of those as possible in one go. Otherwise, they see one tiny error and fix it, only to have the next error appear, and so on. Syntax error Whac-A-Mole is no fun.</p>
<p>(Donâ€™t worry. Since hadError gets set, weâ€™ll never try to execute any of the code, even though we keep going and scan the rest of it.)</p>
<p>éœ€è¦âš ï¸ï¼Œadvance()æ–¹æ³•ï¼Œä»ç„¶ä¼šæ¶ˆè´¹é”™è¯¯çš„å­—ç¬¦ï¼Œè¿™ä¸€ç‚¹éå¸¸é‡è¦ï¼Œå¦åˆ™ï¼Œæˆ‘ä»¬å°†é™·å…¥åˆ°æ— é™å¾ªç¯ä¸­ã€‚</p>
<p>è¿˜éœ€è¦æ³¨æ„ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨æ‰«ææºæ–‡ä»¶ï¼Œæ‰«æè¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šæœ‰å…¶ä»–æŠ¥é”™ã€‚å¦‚æœæˆ‘ä»¬ä¸€æ¬¡æ€§æ£€æµ‹åˆ°å°½å¯èƒ½å¤šçš„æŠ¥é”™ï¼Œä¼šç»™ä½¿ç”¨è€…æ›´å¥½çš„ä½“éªŒã€‚å¦åˆ™ï¼Œä½¿ç”¨è€…çœ‹åˆ°ä¸€ä¸ªå°é”™è¯¯ï¼Œå¹¶ä¸”ä¿®å¤ï¼Œç„¶åï¼Œåˆä¼šå‡ºç°ä¸‹ä¸€ä¸ªå°é”™è¯¯ï¼Œä¸€ç›´è¿™æ ·è¿›è¡Œç€ã€‚</p>
<p>åˆ«æ‹…å¿ƒï¼Œå³ä½¿é‡åˆ°æŠ¥é”™ï¼Œæˆ‘ä»¬ç»§ç»­æ‰«ææºæ–‡ä»¶ï¼Œä¹Ÿä¸ä¼šçœŸçš„æ‰§è¡Œç¨‹åºï¼Œå› ä¸º hadError çš„å­˜åœ¨ã€‚</p>
<blockquote>
<p>The code reports each invalid character separately, so this shotguns the user with a blast of errors if they accidentally paste a big blob of weird text. Coalescing a run of invalid characters into a single error would give a nicer user experience.</p>
<p>ä»£ç ä¼šåˆ†åˆ«æŠ¥å‘Šæ¯ä¸€ä¸ªéæ³•å­—ç¬¦ï¼Œå› æ­¤ï¼Œå¦‚æœå®¢æˆ·æ„å¤–ç²˜è´´äº†ä¸€å¤§å—éæ³•çš„æ–‡æœ¬ï¼Œä½¿ç”¨è€…å°†ä¼šæ”¶åˆ°éå¸¸å¤šçš„æŠ¥é”™ï¼Œå°†ä¸€ç³»åˆ—çš„é”™è¯¯åˆå¹¶ä¸ºä¸€ä¸ªé”™è¯¯ï¼Œå°†æä¾›æ›´å¥½çš„ç”¨æˆ·ä½“éªŒã€‚</p>
</blockquote>
<h3 id="52-operators"><a class="header" href="#52-operators">5.2 Operators</a></h3>
<p>æ“ä½œç¬¦</p>
<p>We have single-character lexemes working, but that doesnâ€™t cover all of Loxâ€™s operators. What about !? Itâ€™s a single character, right? Sometimes, yes, but if the very next character is an equals sign, then we should instead create a != lexeme. Note that the ! and = are not two independent operators. You canâ€™t write ! = in Lox and have it behave like an inequality operator. Thatâ€™s why we need to scan != as a single lexeme. Likewise, &lt;, &gt;, and = can all be followed by = to create the other equality and comparison operators.</p>
<p>æˆ‘ä»¬ç°åœ¨å·²ç»è€ƒè™‘åˆ°å•å­—ç¬¦çš„æ“ä½œç¬¦ï¼Œä½†æ˜¯ï¼Œè¿™å¹¶æ²¡æœ‰åŒ…å«loxä¸­çš„æ‰€æœ‰æ“ä½œç¬¦ã€‚ä¾‹å¦‚ï¼šï¼å­—ç¬¦ï¼Œæ˜¯ä¸€ä¸ªå•å­—ç¬¦æ“ä½œç¬¦å—ï¼Ÿä½†æ˜¯ï¼Œæœ‰æ—¶å€™ï¼Œç´§éšç€ ï¼åé¢çš„æ˜¯ä¸€ä¸ª = ï¼Œ æ­¤æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥åˆ›å»ºä¸€ä¸ª != ç±»å‹çš„tokenï¼Œè€Œä¸æ˜¯ç®€å•çš„ ï¼token. âš ï¸ï¼Œ! å’Œ = ä¸æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„æ“ä½œç¬¦ï¼Œåœ¨loxä¸­ï¼Œæˆ‘ä»¬ä¸ä¼šå†™ ! = è¿™ç§è¿ç®—ç¬¦ï¼Œ ä¸€èˆ¬å†™æ³•ä¸º != ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬éœ€è¦æŠŠ !=å½“ä½œä¸€ä¸ªå•ç‹¬çš„è¯ç´ ï¼Œç›¸ä¼¼çš„ï¼Œ&gt;= &lt;= ä¹Ÿåº”è¯¥è§†ä¸ºå•ç‹¬çš„è¯ç´ </p>
<p>For all of these, we need to look at the second character.</p>
<p>æ‰€ä»¥å¯¹äºè¿™äº›å­—ç¬¦ï¼Œæˆ‘ä»¬éœ€è¦ç»§ç»­æ‰«æç¬¬äºŒä¸ªå­—ç¬¦</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

      case '*': addToken(STAR); break; 
      case '!':
        addToken(match('=') ? BANG_EQUAL : BANG);
        break;
      case '=':
        addToken(match('=') ? EQUAL_EQUAL : EQUAL);
        break;
      case '&lt;':
        addToken(match('=') ? LESS_EQUAL : LESS);
        break;
      case '&gt;':
        addToken(match('=') ? GREATER_EQUAL : GREATER);
        break;

      default:
	  
</code></pre>
<p>Those cases use this new method:</p>
<p>ä¸Šé¢åœºæ™¯ï¼Œéœ€è¦æ·»åŠ æ–°çš„æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()

  private boolean match(char expected) {
    if (isAtEnd()) return false;
    if (source.charAt(current) != expected) return false;

    current++;
    return true;
  }
</code></pre>
<p>Itâ€™s like a conditional advance(). We only consume the current character if itâ€™s what weâ€™re looking for.</p>
<p>Using match(), we recognize these lexemes in two stages. When we reach, for example, !, we jump to its switch case. That means we know the lexeme starts with !. Then we look at the next character to determine if weâ€™re on a != or merely a !.</p>
<p>match() æ–¹æ³•å¥½åƒæ˜¯ä¸€ä¸ªæœ‰æ¡ä»¶çš„ advance(), åªæœ‰å½“ç°åœ¨çš„å­—ç¬¦æ˜¯æˆ‘ä»¬æœŸæœ›çš„ï¼Œæ‰ä¼šæ¶ˆè´¹ã€‚</p>
<p>ä½¿ç”¨match()ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µè¯†åˆ«è¿™äº›è¯ç´ ï¼Œå½“æ‰«æåˆ° ï¼æ—¶å€™ï¼Œæˆ‘ä»¬è¿›å…¥åˆ¤æ–­é€»è¾‘ï¼Œåˆ¤æ–­ä¸‹ä¸€ä¸ªå­—ç¬¦æ˜¯ä¸æ˜¯ =ï¼Œå¦‚æœæ˜¯=ï¼Œåˆ™æˆ‘ä»¬çš„è¯ç´ æ˜¯ !=</p>
<h2 id="å…­longer-lexemes"><a class="header" href="#å…­longer-lexemes">å…­ã€Longer Lexemes</a></h2>
<p>é•¿è¯ç´ </p>
<p>Weâ€™re still missing one operator: / for division. That character needs a little special handling because comments begin with a slash too.</p>
<p>æˆ‘ä»¬ä»ç„¶æ²¡æœ‰è€ƒè™‘åˆ° / è¿ç®—ç¬¦ï¼Œä¸€èˆ¬ç”¨äºè¡¨ç¤ºé™¤æ³•ï¼Œä½†æ˜¯ï¼Œè¯¥å­—ç¬¦éœ€è¦ä¸€äº›ç‰¹æ®Šå¤„ç†ï¼Œå› ä¸ºloxè¯­è¨€ä¸­ï¼Œæ³¨é‡Šä¹Ÿæ˜¯ / å­—ç¬¦å¼€å§‹çš„ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

        break;
      case '/':
        if (match('/')) {
          // A comment goes until the end of the line.
          while (peek() != '\n' &amp;&amp; !isAtEnd()) advance();
        } else {
          addToken(SLASH);
        }
        break;

      default:
	  
</code></pre>
<p>This is similar to the other two-character operators, except that when we find a second /, we donâ€™t end the token yet. Instead, we keep consuming characters until we reach the end of the line.</p>
<p>This is our general strategy for handling longer lexemes. After we detect the beginning of one, we shunt over to some lexeme-specific code that keeps eating characters until it sees the end.</p>
<p>è¿™ç±»ä¼¼äºå…¶ä»–çš„ä¸¤ä¸ªå­—ç¬¦ç»„æˆçš„è¯ç´ ï¼Œåªæœ‰å½“æˆ‘ä»¬æ‰¾åˆ°ç¬¬äºŒä¸ª /ï¼Œ æ‰èƒ½ç¡®å®šæ˜¯æ³¨é‡Šã€‚å½“æˆ‘ä»¬å‘ç°ä¸‹ä¸€ä¸ªå­—ç¬¦ä¾ç„¶æ˜¯ /ï¼Œæˆ‘ä»¬å°†ä¸æ–­æ¶ˆè€—å­—ç¬¦ï¼Œä¸€ç›´åˆ°è¡Œå°¾ã€‚</p>
<p>è¿™æ˜¯æˆ‘ä»¬å¤„ç†è¾ƒé•¿è¯ç´ çš„ä¸€èˆ¬ç­–ç•¥ã€‚åœ¨æˆ‘ä»¬æ£€æµ‹åˆ°ä¸€ä¸ªç‰¹æ®Šå­—ç¬¦åï¼Œæˆ‘ä»¬è½¬å‘ä¸€äº›ç‰¹å®šäºè¯¥è¯ç´ çš„ä»£ç ï¼Œè€Œè¿™äº›ä»£ç ä¸€ç›´ä¼šæ¶ˆè´¹å­—ç¬¦ï¼Œä¸€ç›´åˆ°ç»“æŸã€‚</p>
<p>Weâ€™ve got another helper:</p>
<p>è¿™ä¸ªé€»è¾‘ï¼Œå¯ä»¥å˜ä¸ºæ–°å‡½æ•° peek()</p>
<pre><code class="language-java">
// lox/Scanner.java, add after match()

  private char peek() {
    if (isAtEnd()) return '\0';
    return source.charAt(current);
  }


</code></pre>
<p>Itâ€™s sort of like advance(), but doesnâ€™t consume the character. This is called lookahead. Since it only looks at the current unconsumed character, we have one character of lookahead. The smaller this number is, generally, the faster the scanner runs. The rules of the lexical grammar dictate how much lookahead we need. Fortunately, most languages in wide use peek only one or two characters ahead.</p>
<p>peek() æ–¹æ³•å’Œadvance() æ–¹æ³•éå¸¸ç›¸ä¼¼ï¼Œä½†æ˜¯peek()æ–¹æ³•ä¸ä¼šæ¶ˆè´¹å­—ç¬¦ï¼Œæˆ‘ä»¬ç§°ä¸ºå‰ç»ã€‚ç”±äºï¼Œå®ƒåªä¼šæŸ¥çœ‹å½“å‰æ²¡æœ‰ä½¿ç”¨çš„å­—ç¬¦ï¼Œå› æ­¤æˆ‘ä»¬ç§°ä¹‹ä¸ºå‰ç»ã€‚é€šå¸¸ï¼Œè¿™ä¸ªpeek() è°ƒç”¨æ¬¡æ•°è¶Šå°‘ï¼Œæˆ‘ä»¬çš„æ‰«æå™¨ä¼šè¶Šå¿«ï¼Œè¯æ³•è§„åˆ™ï¼Œå®šä¹‰äº†æˆ‘ä»¬å¯èƒ½éœ€è¦peek() çš„æ¬¡æ•°ã€‚å¹¸è¿çš„æ˜¯ï¼Œå¤§å¤šæ•°è¯­è¨€çš„åªä¼šæœ‰1ä¸ªæˆ–è€…2ä¸ªå­—ç¬¦éœ€è¦peek()</p>
<blockquote>
<p>Technically, match() is doing lookahead too. advance() and peek() are the fundamental operators and match() combines them.</p>
<p>ä»æŠ€æœ¯è§’åº¦ï¼Œmatch() æ–¹æ³•ä¹Ÿæ˜¯ä¸€ç§å‰ç»ã€‚advance() å’Œ peek() æ–¹æ³•æ˜¯åŸºç¡€è¿ç®—å•å…ƒï¼Œmatch() æ–¹æ³•ï¼Œå¯ä»¥ç”±å®ƒä»¬ç»„åˆã€‚</p>
</blockquote>
<p>Comments are lexemes, but they arenâ€™t meaningful, and the parser doesnâ€™t want to deal with them. So when we reach the end of the comment, we donâ€™t call addToken(). When we loop back around to start the next lexeme, start gets reset and the commentâ€™s lexeme disappears in a puff of smoke.</p>
<p>While weâ€™re at it, nowâ€™s a good time to skip over those other meaningless characters: newlines and whitespace.</p>
<p>æ³¨é‡Šä¹Ÿæ˜¯è¯ç´ ï¼Œä½†æ˜¯å®ƒä»¬æ²¡æœ‰å®é™…æ„ä¹‰ï¼Œè§£æå™¨ä¹Ÿä¸ä¼šå¤„ç†å®ƒä»¬ã€‚å› æ­¤ï¼Œå½“æˆ‘ä»¬åˆ°è¾¾è¡Œå°¾æ—¶å€™ï¼Œæˆ‘ä»¬ä¸ä¼šæ·»åŠ æ–°çš„tokenï¼Œå½“æˆ‘ä»¬åˆ°è¾¾å†™ä¸€ä¸ªè¯ç´ æ—¶ï¼Œå°†æ›´æ–°startï¼Œå³ï¼Œæˆ‘ä»¬ä¸ä¼šè€ƒè™‘æ³¨é‡Šéƒ¨åˆ†è¯ç´ ã€‚</p>
<p>åŒæ ·çš„ï¼Œä¹Ÿéœ€è¦è·³è¿‡å…¶ä»–æ²¡æœ‰å®é™…æ„ä¹‰çš„å­—ç¬¦ï¼Œä¾‹å¦‚ï¼šæ¢è¡Œç¬¦ \n å’Œ å…¶ä»–ç©ºç™½ç¬¦</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

        break;

      case ' ':
      case '\r':
      case '\t':
        // Ignore whitespace.
        break;

      case '\n':
        line++;
        break;

      default:
        Lox.error(line, &quot;Unexpected character.&quot;);

</code></pre>
<p>When encountering whitespace, we simply go back to the beginning of the scan loop. That starts a new lexeme after the whitespace character. For newlines, we do the same thing, but we also increment the line counter. (This is why we used peek() to find the newline ending a comment instead of match(). We want that newline to get us here so we can update line.)</p>
<p>å½“é‡åˆ°ç©ºç™½å­—ç¬¦ï¼Œæˆ‘ä»¬å°†å›åˆ°æ‰«æå¾ªç¯å¼€å§‹ã€‚è¿™å°†åœ¨ç©ºç™½å­—ç¬¦åï¼Œå¼€å§‹æ‰«æä¸‹ä¸€ä¸ªè¯ç´ ã€‚å¯¹äºæ¢è¡Œç¬¦ï¼Œæˆ‘ä»¬åŒæ ·è¿™æ ·ï¼Œä½†æ˜¯è¿˜éœ€è¦å¢åŠ è¡Œè®¡æ•°å™¨ã€‚è¿™å°±æ˜¯ï¼Œæˆ‘ä»¬ä½¿ç”¨peek() æ¥æŸ¥æ‰¾æ³¨é‡Šè¡Œï¼Œè¡Œå°¾çš„æ¢è¡Œç¬¦ï¼Œè€Œä¸æ˜¯ä½¿ç”¨match() æ–¹æ³•ï¼Œæˆ‘ä»¬å¸Œæœ›æ¢è¡Œç¬¦ï¼Œèµ°åˆ°è¿™ä¸ªcaseåˆ†æ”¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¢åŠ è¡Œè®¡æ•°å™¨ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥æ›´æ–°è¡Œã€‚</p>
<p>Our scanner is getting smarter. It can handle fairly free-form code like:</p>
<p>æˆ‘ä»¬çš„æ‰«æå™¨è¶Šæ¥è¶Šæ™ºèƒ½äº†ï¼Œå®ƒå¯ä»¥å¤„ç†è¿™ç§ç±»å‹çš„ä»£ç </p>
<pre><code class="language-java">
// this is a comment
(( )){} // grouping stuff
!*+-/=&lt;&gt; &lt;= == // operators

</code></pre>
<h3 id="61-string-literals"><a class="header" href="#61-string-literals">6.1 String literals</a></h3>
<p>å­—ç¬¦ä¸²å¸¸é‡</p>
<p>Now that weâ€™re comfortable with longer lexemes, weâ€™re ready to tackle literals. Weâ€™ll do strings first, since they always begin with a specific character, &quot;.</p>
<p>æ—¢ç„¶ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»ä¹ æƒ¯äº†è¾ƒé•¿çš„è¯ç´ ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­å¤„ç†æ–‡å­—äº†ã€‚æˆ‘ä»¬å°†é¦–å…ˆå¤„ç†ï¼Œå­—ç¬¦ä¸²ï¼Œå®ƒä»¬æ€»æ˜¯ä»¥ &quot; å­—ç¬¦å¼€å§‹ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()
        break;

      case '&quot;': string(); break;

      default:
</code></pre>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()

  private void string() {
    while (peek() != '&quot;' &amp;&amp; !isAtEnd()) {
      if (peek() == '\n') line++;
      advance();
    }

    if (isAtEnd()) {
      Lox.error(line, &quot;Unterminated string.&quot;);
      return;
    }

    // The closing &quot;.
    advance();

    // Trim the surrounding quotes.
    String value = source.substring(start + 1, current - 1);
    addToken(STRING, value);
  }

</code></pre>
<p>Like with comments, we consume characters until we hit the &quot; that ends the string. We also gracefully handle running out of input before the string is closed and report an error for that.</p>
<p>For no particular reason, Lox supports multi-line strings. There are pros and cons to that, but prohibiting them was a little more complex than allowing them, so I left them in. That does mean we also need to update line when we hit a newline inside a string.</p>
<p>Finally, the last interesting bit is that when we create the token, we also produce the actual string value that will be used later by the interpreter. Here, that conversion only requires a substring() to strip off the surrounding quotes. If Lox supported escape sequences like \n, weâ€™d unescape those here.</p>
<p>å’Œæ³¨é‡Šä¸€æ ·ï¼Œæˆ‘ä»¬ä¸æ–­æ¶ˆè´¹å­—ç¬¦ï¼Œç›´åˆ°é‡åˆ°ç»“å°¾çš„ &quot; å­—ç¬¦ï¼Œå¦‚æœæºæ–‡ä»¶å·²ç»æ¶ˆè´¹å®Œäº†ï¼Œä½†æ˜¯ä»ç„¶æ²¡æœ‰å‘ç°å­—ç¬¦ä¸²ç»“å°¾ &quot;, æˆ‘ä»¬å°†ä¼šæŠ¥å‘Šä¸€ä¸ªé”™è¯¯ã€‚</p>
<p>æ²¡æœ‰ä»€ä¹ˆç‰¹æ®ŠåŸå› ï¼Œloxè¯­è¨€æ”¯æŒå¤šè¡Œå­—ç¬¦ä¸²ã€‚è¿™æ ·åšï¼Œå„æœ‰åˆ©å¼Šï¼Œä½†æ˜¯ç¦æ­¢ä½¿ç”¨å¤šè¡Œå­—ç¬¦ä¸²ï¼Œæ¯”æ”¯æŒä½¿ç”¨æ›´åŠ å¤æ‚ï¼Œæ‰€ä»¥ï¼Œæˆ‘å°†è¿è¡Œloxä½¿ç”¨å¤šè¡Œå­—ç¬¦ä¸²ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æœå­—ç¬¦ä¸²ä¸­é‡åˆ°æ¢è¡Œç¬¦ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ–°è¡Œè®¡æ•°å™¨ã€‚</p>
<p>æœ€åï¼Œè¿˜æœ‰ä¸€ä¸ªæœ‰æ„æ€çš„åœ°æ–¹ï¼Œå½“æˆ‘ä»¬åˆ›å»ºtokenæ—¶å€™ï¼Œè¿˜ä¼šåŒ…å«å­—ç¬¦ä¸²çš„å®é™…å€¼ï¼Œç¨åï¼Œè§£é‡Šå™¨å°†ä¼šä½¿ç”¨å­—ç¬¦ä¸²çš„å®é™…å€¼ã€‚åœ¨è¿™é‡Œï¼Œè¿˜éœ€è¦ä¸€ä¸ªå­å­—ç¬¦ä¸²å‡½æ•°ï¼Œå»é™¤å­—ç¬¦ä¸²çš„ &quot; å­—ç¬¦ã€‚å¦‚æœloxæ”¯æŒè½¬ä¹‰ï¼Œä¾‹å¦‚ï¼š\n, æˆ‘ä»¬åœ¨è¿™é‡Œå°†å–æ¶ˆè½¬ä¹‰ã€‚</p>
<h2 id="62-number-literals"><a class="header" href="#62-number-literals">6.2 Number literals</a></h2>
<p>æ•°å€¼</p>
<p>All numbers in Lox are floating point at runtime, but both integer and decimal literals are supported. A number literal is a series of digits optionally followed by a . and one or more trailing digits.</p>
<p>loxè¿è¡Œæ—¶å€™ï¼Œæ‰€æœ‰çš„æ•°å­—éƒ½æ˜¯æµ®ç‚¹æ•°ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬æ”¯æŒä½¿ç”¨è€…ä½¿ç”¨æ•´æ•° å’Œåè¿›åˆ¶çš„æ•°å­—ã€‚æ•°å€¼æ˜¯ä¸€ä¸ªæ•°å­—åºåˆ—ï¼Œå…¶ä¸­å¯èƒ½æ˜¯æ•´æ•°ï¼Œä¹Ÿå¯èƒ½æ˜¯æµ®ç‚¹æ•°ã€‚</p>
<pre><code>
1234
12.34

</code></pre>
<p>We donâ€™t allow a leading or trailing decimal point, so these are both invalid:</p>
<p>ä½†æ˜¯æˆ‘ä»¬ä¸å…è®¸ï¼Œå°æ•°ç‚¹ä¹‹å‰æˆ–è€…ä¹‹åï¼Œæ²¡æœ‰å®é™…æ•°å­—</p>
<pre><code>
.1234
1234.

</code></pre>
<blockquote>
<p>Since we look only for a digit to start a number, that means -123 is not a number literal. Instead, -123, is an expression that applies - to the number literal 123. In practice, the result is the same, though it has one interesting edge case if we were to add method calls on numbers. Consider:</p>
<p><code>print -123.abs();</code></p>
<p>This prints -123 because negation has lower precedence than method calls. We could fix that by making - part of the number literal. But then consider:</p>
<pre><code> var n = 123;
 print -n.abs();

</code></pre>
<p>This still produces -123, so now the language seems inconsistent. No matter what you do, some case ends up weird.</p>
<p>å› ä¸ºæˆ‘ä»¬å°†æ•°å­—å½“ä½œï¼Œæ•°å€¼è¯ç´ çš„ä¸€ä¸ªå¼€å§‹ï¼Œè¿™æ„å‘³ç€ -123 ä¸æ˜¯ä¸€ä¸ªæ•°å­—ã€‚å¯¹åº”çš„ï¼Œ-123 æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚å®é™…ä¸Šï¼Œè¡¨è¾¾å¼çš„è®¡ç®—ç»“æœ å’Œ -123 ç›¸åŒï¼Œæœ‰ä¸€ä¸ªæœ‰è¶£çš„è¾¹ç¼˜åœºæ™¯ï¼Œå¦‚æœå¯¹äºæ•°å­—è¿›è¡Œæ–¹æ³•è°ƒç”¨ï¼Œä¾‹å¦‚:</p>
<p><code>print -123.abs();</code></p>
<p>è¿™å°†æ‰“å°å‡º -123, å› ä¸ºè´Ÿæ•°ä¼˜å…ˆçº§ ä½äº æ–¹æ³•è°ƒç”¨ï¼Œå³å…ˆæ‰§è¡Œ abs() æ–¹æ³•ï¼Œç„¶åæ‰ä¼šæ‰§è¡Œè´Ÿæ•°è¿ç®—ã€‚æˆ‘ä»¬å¯ä»¥å°†è´Ÿæ•°ç¬¦å·ï¼Œæ·»åŠ åˆ°æ•°å€¼ä¸­ï¼Œæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ä½†æ˜¯ï¼Œè¿˜éœ€è¦è€ƒè™‘ä¸‹é¢åœºæ™¯:</p>
<pre><code>var n = 123;
print -n.abs();
</code></pre>
<p>ä¸Šé¢çš„ä»£ç ï¼Œå°†ä»ç„¶æ‰“å°å‡º -123ï¼Œæ‰€ä»¥ç°åœ¨ï¼Œloxè¯­è¨€å‡ºç°äº†ä¸ä¸€è‡´ï¼Œä¸ç®¡æˆ‘ä»¬æ€æ ·ä¿®æ”¹ï¼Œéƒ½ä¼šéå¸¸å¥‡æ€ªã€‚</p>
</blockquote>
<p>We could easily support the former, but I left it out to keep things simple. The latter gets weird if we ever want to allow methods on numbers like 123.sqrt()</p>
<p>To recognize the beginning of a number lexeme, we look for any digit. Itâ€™s kind of tedious to add cases for every decimal digit, so weâ€™ll stuff it in the default case instead.</p>
<p>å¯¹äº <code>.1234</code>è¿™ç§å½¢å¼çš„æ•°å€¼ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“å…¼å®¹å®ƒï¼Œä½†æ˜¯ï¼Œä¸ºäº†ç®€å•ï¼Œloxå°†ä¸æ”¯æŒè¿™ç§å†™æ³•ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬å…è®¸ <code>1234.</code> è¿™ç§å†™æ³•ï¼Œ<code>1234.sqrt()</code> å°†ä¼šå˜å¾—å¾ˆä»¤äººç–‘æƒ‘ã€‚</p>
<p>ä¸ºäº†è¯†åˆ«æ•°å­—è¯ç´ çš„å¼€å¤´ï¼Œæˆ‘ä»¬å°†å…ˆå‘ç°ä¸€ä¸ªæ•°å­—ï¼Œä¸ºæ¯ä¸€ä¸ªåè¿›åˆ¶æ•°å­—æ·»åŠ å¤§å°å†™éå¸¸ä¹å‘³ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å°†å®ƒä»¬å¡«å……ä¸ºé»˜è®¤çš„å¤§å°å†™ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken(), replace 1 line
      default:
        if (isDigit(c)) {
          number();
        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }
        break;
</code></pre>
<p>This relies on this little utility:</p>
<p>è¿™ä¾èµ–äºæ–°çš„æ–¹æ³• isDigit()</p>
<pre><code class="language-java">
// lox/Scanner.java, add after peek()

  private boolean isDigit(char c) {
    return c &gt;= '0' &amp;&amp; c &lt;= '9';
  } 

</code></pre>
<blockquote>
<p>The Java standard library provides Character.isDigit(), which seems like a good fit. Alas, that method allows things like Devanagari digits, full-width numbers, and other funny stuff we donâ€™t want.</p>
<p>java æ ‡å‡†åº“æä¾›äº† Character.isDigit() å‡½æ•°ï¼Œç”¨äºåˆ¤æ–­æ•°å­—ï¼Œçœ‹èµ·ä¿©å¾ˆç¬¦åˆæˆ‘ä»¬çš„è¦æ±‚ã€‚ä½†æ˜¯ï¼Œè¿™ä¸ªå‡½æ•°å¯ä»¥å…¼å®¹æ¢µæ–‡æ•°å­—ï¼Œå…¨å®½æ•°å­—ï¼Œè¿™æ ·å­è™½ç„¶éå¸¸æœ‰æ„æ€ï¼Œä½†ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„æ•°å­—ã€‚</p>
</blockquote>
<p>Once we know we are in a number, we branch to a separate method to consume the rest of the literal, like we do with strings.</p>
<p>ä¸€æ—¦æˆ‘ä»¬é‡åˆ°äº†æ•°å­—ï¼Œæˆ‘ä»¬å°†ä¸æ–­æ¶ˆè´¹ä¸‹é¢çš„å­—ç¬¦ï¼Œè¿™æ—¶å€™ï¼Œæˆ‘ä»¬å°†è¿›å…¥æ–°çš„ç‹¬ç«‹æ–¹æ³•ä¸­ï¼Œå°±åƒæ˜¯æˆ‘ä»¬å¤„ç†å­—ç¬¦ä¸²ä¸€æ ·ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()
  private void number() {
    while (isDigit(peek())) advance();

    // Look for a fractional part.
    if (peek() == '.' &amp;&amp; isDigit(peekNext())) {
      // Consume the &quot;.&quot;
      advance();

      while (isDigit(peek())) advance();
    }

    addToken(NUMBER,
        Double.parseDouble(source.substring(start, current)));
  }
  
</code></pre>
<p>We consume as many digits as we find for the integer part of the literal. Then we look for a fractional part, which is a decimal point (.) followed by at least one digit. If we do have a fractional part, again, we consume as many digits as we can find.</p>
<p>Looking past the decimal point requires a second character of lookahead since we donâ€™t want to consume the . until weâ€™re sure there is a digit after it. So we add:</p>
<p>æˆ‘ä»¬å°†å°½å¯èƒ½å¤šçš„è·å–æ•°å€¼çš„æ•´æ•°éƒ¨åˆ†ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†å¯»æ‰¾å°æ•°ç‚¹éƒ¨åˆ†ï¼Œå®ƒç”±ä¸€ä¸ª . å­—ç¬¦å¼€å§‹ï¼Œåé¢è‡³å°‘åŠ ä¸Šä¸€ä¸ªæ•°å­—ã€‚å¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªåˆ†æ•°éƒ¨åˆ†ï¼Œæˆ‘ä»¬åŒæ ·å°†æ¶ˆè´¹å°½å¯èƒ½å¤šçš„æ•°å­—ã€‚</p>
<p>æŸ¥çœ‹å°æ•°éƒ¨åˆ†ï¼Œéœ€è¦æˆ‘ä»¬å‰ç»åé¢çš„ç¬¬äºŒä¸ªå­—ç¬¦ï¼Œå› ä¸ºï¼Œå¦‚æœå°æ•°ç‚¹åé¢æ²¡æœ‰ç´§éšç€è‡³å°‘ä¸€ä¸ªæ•°å­—ï¼Œæˆ‘ä»¬å°†ä¸ä¼šè®¤ä¸ºæ˜¯ä¸€ä¸ªå°æ•°éƒ¨åˆ†ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, add after peek()

  private char peekNext() {
    if (current + 1 &gt;= source.length()) return '\0';
    return source.charAt(current + 1);
  } 
</code></pre>
<blockquote>
<p>I could have made peek() take a parameter for the number of characters ahead to look instead of defining two functions, but that would allow arbitrarily far lookahead. Providing these two functions makes it clearer to a reader of the code that our scanner looks ahead at most two characters.</p>
<p>æˆ‘æœ¬æ¥å¯ä»¥å®šä¹‰ä¸€ä¸ª peek() æ–¹æ³•ï¼Œæ¥å—ä¸€ä¸ªå‚æ•°ï¼Œè¡¨ç¤ºè¦å‰ç»çš„å­—ç¬¦æ•°ï¼Œè€Œä¸æ˜¯å®šä¹‰ä¸¤ä¸ªå‡½æ•°ï¼Œä½†æ˜¯ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å°†å…è®¸ä»»æ„é•¿åº¦çš„å‰ç»ã€‚æä¾›äº†peek() å’Œ peeknext() ä¸¤ä¸ªæ–¹æ³•ï¼Œå¯ä»¥æ›´åŠ æ˜ç¡®ï¼Œæˆ‘ä»¬çš„æ‰«æå™¨ï¼Œå°†æœ€å¤šå…è®¸2ä¸ªå­—ç¬¦çš„å‰ç»ã€‚</p>
</blockquote>
<p>Finally, we convert the lexeme to its numeric value. Our interpreter uses Javaâ€™s Double type to represent numbers, so we produce a value of that type. Weâ€™re using Javaâ€™s own parsing method to convert the lexeme to a real Java double. We could implement that ourselves, but, honestly, unless youâ€™re trying to cram for an upcoming programming interview, itâ€™s not worth your time.</p>
<p>The remaining literals are Booleans and nil, but we handle those as keywords, which gets us toâ€‰.â€‰.â€‰. </p>
<p>æœ€åï¼Œæˆ‘ä»¬å°†è¯ç´ è½¬å˜ä¸ºå®ƒçš„æ•°å€¼ã€‚æˆ‘ä»¬è§£é‡Šå™¨ï¼Œä½¿ç”¨java doubleç±»å‹è¡¨ç¤ºæ•°å­—ï¼Œæ‰€ä»¥ï¼Œæ‰«æå™¨è¿™é‡Œï¼Œæˆ‘ä»¬ä¹Ÿå°†ç”Ÿæˆä¸€ä¸ªdoubleæ•°å­—ã€‚æˆ‘ä»¬ä½¿ç”¨java çš„parseæ–¹æ³•ï¼Œå°†æ•°å€¼å˜ä¸ºåŒç²¾åº¦æ•°å­—ã€‚å…¶å®ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥è‡ªå·±å®ç°åŒç²¾åº¦æ•°å­—çš„è½¬æ¢ï¼Œä½†æ˜¯ï¼Œé™¤éä½ åœ¨å‡†å¤‡ç¼–ç¨‹é¢è¯•ï¼Œæ²¡æœ‰å¿…è¦æµªè´¹æ—¶é—´ã€‚</p>
<p>å‰©ä¸‹æ¥ï¼Œæ˜¯å¸ƒå°”ç±»å‹å’Œ nilï¼Œä½†æ˜¯æˆ‘ä»¬å°†è¿™äº›å½“ä½œå…³é”®å­—å¤„ç†ï¼Œä¸‹é¢æˆ‘ä»¬å°†æ¢è®¨è¿™äº›ã€‚</p>
<h2 id="ä¸ƒreserved-words-and-identifiers"><a class="header" href="#ä¸ƒreserved-words-and-identifiers">ä¸ƒã€Reserved Words and Identifiers</a></h2>
<p>ä¿ç•™å­—å’Œæ ‡è¯†ç¬¦</p>
<p>Our scanner is almost done. The only remaining pieces of the lexical grammar to implement are identifiers and their close cousins, the reserved words. You might think we could match keywords like or in the same way we handle multiple-character operators like &lt;=.</p>
<p>æˆ‘ä»¬çš„æ‰«æä»ªå‡ ä¹å¿«å®Œæˆäº†ã€‚è¯æ³•ä¸­è¿˜æ²¡æœ‰å®ç°çš„æ˜¯ï¼Œæ ‡è¯†ç¬¦å’Œä¿ç•™å­—ã€‚ä½ å¯èƒ½è®¤ä¸ºï¼Œæˆ‘ä»¬åº”è¯¥åƒ &lt;= ä¸€æ ·ï¼Œä¸€ä¸ªä¸ªå­—ç¬¦å»åŒ¹é…å…³é”®å­—ï¼Œä¾‹å¦‚ï¼šæˆ‘ä»¬è¦åŒ¹é… or ï¼Œä»£ç å¦‚ä¸‹</p>
<pre><code class="language-java">case 'o':
  if (match('r')) {
    addToken(OR);
  }
  break;
</code></pre>
<p>Consider what would happen if a user named a variable orchid.  The scanner would see the first two letters, or, and immediately emit an or keyword token. This gets us to an important principle called maximal munch. When two lexical grammar rules can both match a chunk of code that the scanner is looking at, whichever one matches the most characters wins.</p>
<p>That rule states that if we can match orchid as an identifier and or as a keyword, then the former wins. This is also why we tacitly assumed, previously, that &lt;= should be scanned as a single &lt;= token and not &lt; followed by =.</p>
<p>è€ƒè™‘ä¸€ä¸‹ï¼Œå½“æˆ‘ä»¬å‘½åä¸€ä¸ªå˜é‡ orchid ï¼Œå¦‚æœæˆ‘ä»¬æ‰«æåˆ°è¯¥å˜é‡ï¼Œå°†ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæ‰«æå™¨å°†ä¼šæ ¹æ®å‰é¢çš„ä¸¤ä¸ªå­—ç¬¦ or, ç«‹å³æäº¤ä¸€ä¸ªtokenï¼Œ ä¸‹é¢æˆ‘ä»¬å°†ä»‹ç»æ‰«æå™¨çš„ä¸€ä¸ªé‡è¦çš„åŸåˆ™ï¼Œ<a href="https://en.wikipedia.org/wiki/Maximal_munch">æœ€å¤§åŒ¹é…åŸåˆ™</a>, å½“æ‰«æå™¨å½“å‰æ‰«æçš„è¯ç´ ï¼ŒåŒæ—¶æ»¡è¶³ä¸¤ä¸ªè¯æ³•è§„åˆ™ï¼ŒåŒ¹é…æœ€é•¿å­—ç¬¦çš„è¯æ³•è§„åˆ™è¢«å‘½ä¸­ã€‚</p>
<p>ä¾‹å¦‚ï¼šorchidï¼Œèƒ½åŒ¹é…ä¸¤ä¸ªè¯æ³•è§„åˆ™ï¼Œå¯ä»¥è¢«å½“ä½œä¸€ä¸ªæ ‡è¯†ç¬¦orchidï¼Œæˆ–è¢«å½“ä½œä¸€ä¸ªå…³é”®è¯ or, æ ¹æ®æœ€å¤§åŒ¹é…åŸåˆ™ï¼Œæˆ‘ä»¬é€‰æ‹© orchild ä¸ºä¸€ä¸ªæ ‡è¯†ç¬¦ã€‚åŒæ ·çš„ï¼Œè¿™ä¹Ÿæ˜¯ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬æŠŠ &lt;= å½“ä½œä¸€ä¸ªå®Œæ•´çš„è¯ç´ ï¼Œè€Œä¸æ˜¯æŠŠ &lt; å½“ä½œä¸€ä¸ªè¯ç´ ã€‚</p>
<blockquote>
<p>Consider this nasty bit of C code:</p>
<p><code>---a;</code></p>
<p>Is it valid? That depends on how the scanner splits the lexemes. What if the scanner sees it like this:</p>
<p><code>- --a</code></p>
<p>Then it could be parsed. But that would require the scanner to know about the grammatical structure of the surrounding code, which entangles things more than we want. Instead, the maximal munch rule says that it is always scanned like:</p>
<p><code>-- -a</code></p>
<p>It scans it that way even though doing so leads to a syntax error later in the parser.</p>
<p>è€ƒè™‘ä¸€ä¸‹ï¼Œè¿™ä¸ªè®¨åŒçš„cä»£ç </p>
<p><code>---a;</code></p>
<p>è¿™ä¸ªè¯­å¥æ˜¯å¦åˆæ³•ï¼Œè¿™å–å†³äºæ‰«æå™¨å¦‚ä½•åˆ†å‰²è¿™ä¸ªè¯ç´ ï¼Œå¦‚æœæ‰«æå™¨æŠŠè¿™ä¸ªä»£ç çœ‹ä½œ </p>
<p><code>- --a;</code></p>
<p>è¿™æ ·ï¼Œæ˜¯å¯ä»¥è¢«è§£æçš„ï¼Œä½†æ˜¯ï¼Œè¿™éœ€è¦æ‰«æå™¨äº†è§£å‘¨å›´ä»£ç çš„è¯­æ³•ç»“æ„ï¼Œè¿™ä¼šè®©äº‹æƒ…æ¯”æˆ‘ä»¬æƒ³è±¡çš„æ›´åŠ å¤æ‚ã€‚ä½†æ˜¯ï¼Œå®é™…ä¸Šï¼ŒæŒ‰ç…§æœ€å¤§åŒ¹é…åŸåˆ™ï¼Œå®ƒå®é™…ä¸Šåº”è¯¥æ˜¯</p>
<p><code>-- -a;</code></p>
<p>æ‰«æå™¨å°†ä¼šå¦‚ä¸Šé¢è¿™æ ·ï¼Œæ‰«æä»£ç ï¼Œå³ä½¿è¿™æ ·ï¼Œä¼šå¯¼è‡´è§£æå™¨ä¸­çš„è¯­æ³•é”™è¯¯ã€‚</p>
</blockquote>
<p>Maximal munch means we canâ€™t easily detect a reserved word until weâ€™ve reached the end of what might instead be an identifier. After all, a reserved word is an identifier, itâ€™s just one that has been claimed by the language for its own use. Thatâ€™s where the term reserved word comes from.</p>
<p>æœ€å¤§åŒ¹é…åŸåˆ™ï¼Œæ„å‘³ç€æˆ‘ä»¬æ— æ³•ç®€å•çš„åˆ¤æ–­ä¸€ä¸ªè¯ç´ æ˜¯æ ‡è¯†ç¬¦ï¼Œç›´åˆ°æˆ‘ä»¬æ‰«æåˆ°äº†å¯ä»¥ç¡®å®šæ˜¯æ ‡è¯†ç¬¦ç»“å°¾çš„ä½ç½®ã€‚å®é™…ä¸Šï¼Œä¿ç•™å­—ä¹Ÿæ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œå®ƒåªæ˜¯loxè¯­è¨€ä¸ºäº†è‡ªå·±æœ¬èº«ä½¿ç”¨ï¼Œè€Œå£°æ˜çš„ä¸€ä¸ªæ ‡è¯†ç¬¦ã€‚è¿™å°±æ˜¯æœ¯è¯­ï¼Œä¿ç•™å­—çš„æ¥æºã€‚</p>
<p>So we begin by assuming any lexeme starting with a letter or underscore is an identifier.</p>
<p>æ‰€ä»¥ï¼Œæˆ‘ä»¬é¦–å…ˆå‡è®¾ä»»ä½•ä»¥å­—æ¯æˆ–è€…ä¸‹åˆ’çº¿ï¼Œå¼€å§‹çš„å•è¯ï¼Œéƒ½æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦</p>
<pre><code class="language-java">
// lox/Scanner.java, in scanToken()

      default:
        if (isDigit(c)) {
          number();
        } else if (isAlpha(c)) {
          identifier();
        } else {
          Lox.error(line, &quot;Unexpected character.&quot;);
        }

</code></pre>
<pre><code class="language-java">
// lox/Scanner.java, add after scanToken()
  private void identifier() {
    while (isAlphaNumeric(peek())) advance();

    addToken(IDENTIFIER);
  }

</code></pre>
<pre><code class="language-java">
// lox/Scanner.java, add after peekNext()

  private boolean isAlpha(char c) {
    return (c &gt;= 'a' &amp;&amp; c &lt;= 'z') ||
           (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') ||
            c == '_';
  }

  private boolean isAlphaNumeric(char c) {
    return isAlpha(c) || isDigit(c);
  }
</code></pre>
<p>That gets identifiers working. To handle keywords, we see if the identifierâ€™s lexeme is one of the reserved words. If so, we use a token type specific to that keyword. We define the set of reserved words in a map.</p>
<p>ä¸Šé¢çš„ä»£ç å°†ä¼šè¯†åˆ«å‡ºæ ‡è¯†ç¬¦ï¼Œä¸ºäº†å¤„ç†å…³é”®å­—ï¼Œæˆ‘ä»¬å°†æŸ¥çœ‹æ ‡è¯†ç¬¦çš„è¯ç´ æ˜¯å¦æ˜¯ä¸€ä¸ªä¿ç•™å­—ï¼Œå¦‚æœæ˜¯ä¿ç•™å­—ï¼Œæˆ‘ä»¬å°†ä¼šå®šä¹‰ä¸ºç‰¹æ®Šç±»å‹ï¼Œä¸‹é¢æ˜¯ä¸€ç»„é¢„å®šä¹‰çš„ä¿ç•™å­—ã€‚</p>
<pre><code class="language-java">
// lox/Scanner.java, in class Scanner
	private static final Map&lt;String, TokenType&gt; keywords;


    static {
        keywords = new HashMap&lt;&gt;();
        keywords.put(&quot;and&quot;, AND);
        keywords.put(&quot;class&quot;, CLASS);
        keywords.put(&quot;else&quot;, ELSE);
        keywords.put(&quot;false&quot;, FALSE);
        keywords.put(&quot;for&quot;, FOR);
        keywords.put(&quot;fun&quot;, FUN);
        keywords.put(&quot;if&quot;, IF);
        keywords.put(&quot;nil&quot;, NIL);
        keywords.put(&quot;or&quot;, OR);
        keywords.put(&quot;print&quot;, PRINT);
        keywords.put(&quot;return&quot;, RETURN);
        keywords.put(&quot;super&quot;, SUPER);
        keywords.put(&quot;this&quot;, THIS);
        keywords.put(&quot;true&quot;, TRUE);
        keywords.put(&quot;var&quot;, VAR);
        keywords.put(&quot;while&quot;, WHILE);
    }
</code></pre>
<p>Then, after we scan an identifier, we check to see if it matches anything in the map.</p>
<p>ç„¶åï¼Œæˆ‘ä»¬åœ¨ç¡®å®šä¸€ä¸ªæ ‡è¯†ç¬¦åï¼Œå¯ä»¥åœ¨åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦æ˜¯å…³é”®å­—</p>
<pre><code class="language-java">
// lox/Scanner.java, in identifier(), replace 1 line

    private void identifier() {
        while (isAlphaNumberic(peek()))
            advance();
        String text = source.substring(start, current);
        TokenType type = keywords.get(text);
        if (type == null)
            type = IDENTIFIER;
        addToken(type);
    }
  
</code></pre>
<p>If so, we use that keywordâ€™s token type. Otherwise, itâ€™s a regular user-defined identifier.</p>
<p>And with that, we now have a complete scanner for the entire Lox lexical grammar. Fire up the REPL and type in some valid and invalid code. Does it produce the tokens you expect? Try to come up with some interesting edge cases and see if it handles them as it should.</p>
<p>å¦‚æœæ ‡è¯†ç¬¦æ˜¯ä¸€ä¸ªå…³é”®å­—ï¼Œæˆ‘ä»¬æäº¤çš„tokenéœ€è¦ä¸ºå…³é”®å­—ç±»å‹ã€‚</p>
<p>æœ‰äº†è¿™äº›ï¼Œæˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ä¸ªå®Œæ•´çš„æ‰«æå™¨ã€‚å¯ä»¥æ‰«ææ•´ä¸ªloxç¨‹åºã€‚å¯åŠ¨æ‰«æå™¨ï¼Œè¾“å…¥ä¸€äº›loxä»£ç ï¼Œæ‰§è¡Œçœ‹çœ‹ã€‚å®ƒæ˜¯å¦ä¼šè¾“å‡ºä½ æƒ³è¦çš„tokenåˆ—è¡¨ï¼Œå°½å¯èƒ½å°è¯•ä¸€äº›è¾¹ç¼˜ç¤ºä¾‹ï¼Œçœ‹çœ‹æˆ‘ä»¬çš„æ‰«æå™¨æ˜¯å¦å¯ä»¥æ‰§è¡Œå‘¢ï¼Ÿ</p>
<h2 id="å…«æŒ‘æˆ˜ä¹ é¢˜"><a class="header" href="#å…«æŒ‘æˆ˜ä¹ é¢˜">å…«ã€æŒ‘æˆ˜ä¹ é¢˜</a></h2>
<ol>
<li>
<p>The lexical grammars of Python and Haskell are not regular. What does that mean, and why arenâ€™t they?</p>
<p>python å’Œ Haskellè¯­è¨€è¯æ³•è§„åˆ™ ä¸æ˜¯è§„åˆ™çš„ï¼Œè¿™æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿå®ƒä»¬ä¸ºä»€ä¹ˆä¸æ˜¯è§„åˆ™çš„å‘¢ï¼Ÿ</p>
</li>
<li>
<p>Aside from separating tokensâ€”distinguishing print foo from printfooâ€”spaces arenâ€™t used for much in most languages. However, in a couple of dark corners, a space does affect how code is parsed in CoffeeScript, Ruby, and the C preprocessor. Where and what effect does it have in each of those languages?</p>
<p>é™¤äº†åŒºåˆ† <code>print foo</code> å’Œ <code>printfoo</code> , ç©ºæ ¼åœ¨å¤§å¤šæ•°çš„è¯­è¨€ä¸­æ²¡æœ‰å¤ªå¤šä½œç”¨ã€‚ç„¶è€Œï¼Œåœ¨å¾ˆå¤šååƒ»çš„è§’è½ï¼Œç©ºæ ¼ä¼šå½±å“ CoffeeScript, Ruby, Cé¢„å¤„ç†å™¨ï¼Œè§£æä»£ç ã€‚åœ¨è¿™äº›è¯­è¨€ä¸­ï¼Œå®ƒä»¬åˆ†åˆ«æœ‰ä»€ä¹ˆå½±å“å‘¢ï¼Ÿ</p>
</li>
<li>
<p>Our scanner here, like most, discards comments and whitespace since those arenâ€™t needed by the parser. Why might you want to write a scanner that does not discard those? What would it be useful for?</p>
<p>æˆ‘ä»¬çš„æ‰«æå™¨å’Œå¤§å¤šæ•°çš„æ‰«æå™¨ä¸€æ ·ï¼Œä¼šä¸¢å¼ƒæ³¨é‡Šå’Œç©ºç™½å­—ç¬¦ï¼Œå› ä¸ºï¼Œè§£é‡Šå™¨ä¸éœ€è¦å®ƒã€‚ä¸ºä»€ä¹ˆè¦ç¼–å†™ä¸€ä¸ªä¿ç•™æ³¨é‡Šå’Œç©ºç™½å­—ç¬¦çš„æ‰«æå™¨å‘¢ï¼Ÿå®ƒæœ‰ä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿ</p>
</li>
<li>
<p>Add support to Loxâ€™s scanner for C-style /* ... */ block comments. Make sure to handle newlines in them. Consider allowing them to nest. Is adding support for nesting more work than you expected? Why?</p>
<p>ä¸ºloxæ‰«æå™¨ï¼Œæ·»åŠ  /* ... */ å½¢å¼çš„æ³¨é‡Šè¯­æ³•ï¼Œç¡®ä¿æ­£ç¡®å¤„ç†å…¶ä¸­çš„æ¢è¡Œç¬¦ã€‚è¿˜éœ€è¦è€ƒè™‘åµŒå¥—ï¼Œæ·»åŠ åµŒå¥—æ”¯æŒçš„å·¥ä½œé‡æ˜¯å¦è¶…è¿‡ä½ çš„é¢„æœŸï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ</p>
</li>
</ol>
<h2 id="ä¹design-note-implicit-semicolons"><a class="header" href="#ä¹design-note-implicit-semicolons">ä¹ã€DESIGN NOTE: IMPLICIT SEMICOLONS</a></h2>
<p>è®¾è®¡æ€è·¯ï¼šéšå¼åˆ†å·</p>
<p>Programmers today are spoiled for choice in languages and have gotten picky about syntax. They want their language to look clean and modern. One bit of syntactic lichen that almost every new language scrapes off (and some ancient ones like BASIC never had) is ; as an explicit statement terminator.</p>
<p>Instead, they treat a newline as a statement terminator where it makes sense to do so. The â€œwhere it makes senseâ€ part is the challenging bit. While most statements are on their own line, sometimes you need to spread a single statement across a couple of lines. Those intermingled newlines should not be treated as terminators.</p>
<p>ä»Šå¤©çš„ç¨‹åºå‘˜è¢«è¯­è¨€çš„é€‰æ‹©å® åäº†ï¼Œå¯¹è¯­æ³•å˜å¾—éå¸¸æŒ‘å‰”ï¼Œä»–ä»¬å¸Œæœ›è‡ªå·±ä½¿ç”¨çš„è¯­è¨€çœ‹èµ·æ¥å¹²å‡€ã€ç°ä»£ã€‚å‡ ä¹æ¯ä¸€ç§ç°ä»£è¯­è¨€éƒ½ä¼šåˆ é™¤ä¸€äº›è¯­æ³•è‹”è—“ï¼ˆæœ‰äº›å¤è€è¯­è¨€ï¼Œä¾‹å¦‚: BASIC, ä»æœªåˆ é™¤ï¼‰ã€‚ä¾‹å¦‚ï¼š ; ä½œä¸ºæ˜¾ç¤ºçš„è¯­å¥ç»ˆæ­¢ç¬¦</p>
<p>ç›¸åï¼Œå®ƒä»¬éƒ½å°†æ¢è¡Œç¬¦å½“ä½œè¯­å¥ç»ˆæ­¢ç¬¦å·ï¼Œåœ¨åˆé€‚çš„æ—¶å€™ã€‚å…¶ä¸­ï¼Œåˆé€‚çš„æ—¶å€™ï¼Œæ˜¯æŒ‡ä¸€ä¸ªè¯­å¥åªä¼šåœ¨ä¸€è¡Œä¸­ã€‚ä½†æ˜¯ï¼Œè¿˜æœ‰ä¸€äº›è¯­å¥ï¼Œä¼šåˆ†æ•£åˆ°å¤šè¡Œä¸­ã€‚è¿™äº›è¯­å¥åˆ†æ•£çš„è¡Œä¸­ï¼Œæ¢è¡Œç¬¦ä¸åº”è¯¥è¢«å½“ä½œç»ˆæ­¢ç¬¦å·ã€‚</p>
<p>Most of the obvious cases where the newline should be ignored are easy to detect, but there are a handful of nasty ones:</p>
<ul>
<li>
<p>A return value on the next line:</p>
<pre><code>if (condition) return
&quot;value&quot;
</code></pre>
<p>Is â€œvalueâ€ the value being returned, or do we have a return statement with no value followed by an expression statement containing a string literal?</p>
</li>
<li>
<p>A parenthesized expression on the next line:</p>
<pre><code>func
(parenthesized)

</code></pre>
<p>Is this a call to func(parenthesized), or two expression statements, one for func and one for a parenthesized expression?</p>
</li>
<li>
<p>A - on the next line:</p>
<pre><code>
first
-second

</code></pre>
<p>Is this first - secondâ€”an infix subtractionâ€”or two expression statements, one for first and one to negate second?</p>
</li>
</ul>
<p>å¤§å¤šæ•°åº”è¯¥å¿½ç•¥æ¢è¡Œç¬¦çš„åœºæ™¯ï¼Œéƒ½å¾ˆå®¹æ˜“è¢«å‘ç°ï¼Œä½†æ˜¯ï¼Œä¹Ÿæœ‰ä¸€äº›ä»¤äººè®¨åŒçš„åœºæ™¯ï¼š</p>
<ul>
<li>
<p>è¿”å›ç€åœ¨ä¸‹ä¸€è¡Œ</p>
<pre><code>if (condition) return
&quot;value&quot;
</code></pre>
<p>è¿™æ˜¯ä¸€ä¸ªreturn è¯­å¥ï¼Œè¿”å› &quot;value&quot;; è¿˜æ˜¯ä¸€ä¸ªreturnè¯­å¥ï¼Œæ²¡æœ‰è¿”å›å€¼ï¼›ç´§è·Ÿç€ä¸€ä¸ªå­—ç¬¦ä¸²è¡¨è¾¾å¼</p>
</li>
<li>
<p>ä¸‹ä¸€è¡Œï¼Œæ˜¯æ‹¬å·è¡¨è¾¾å¼</p>
<pre><code>func
(parenthesized)

</code></pre>
<p>è¿™æ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œè¿˜æ˜¯ä¸€ä¸ªfunc è¡¨è¾¾å¼ï¼Œç´§è·Ÿç€ä¸€ä¸ªæ‹¬å·è¡¨è¾¾å¼</p>
</li>
<li>
<p>è´Ÿå·å‡ºç°åœ¨ä¸‹ä¸€è¡Œ</p>
<pre><code>first
-second
</code></pre>
<p>è¿™æ˜¯ä¸€ä¸ªä¸­ç¼€å‡æ³•è¡¨è¾¾å¼ï¼Œè¿˜æ˜¯ä¸¤ä¸ªè¡¨è¾¾å¼å‘¢</p>
</li>
</ul>
<p>In all of these, either treating the newline as a separator or not would both produce valid code, but possibly not the code the user wants. Across languages, there is an unsettling variety of rules used to decide which newlines are separators. Here are a couple:</p>
<ul>
<li>
<p>Lua completely ignores newlines, but carefully controls its grammar such that no separator between statements is needed at all in most cases. This is perfectly legit:</p>
<p><code>a = 1 b = 2</code></p>
<p>Lua avoids the return problem by requiring a return statement to be the very last statement in a block. If there is a value after return before the keyword end, it must be for the return. For the other two cases, they allow an explicit ; and expect users to use that. In practice, that almost never happens because thereâ€™s no point in a parenthesized or unary negation expression statement.</p>
</li>
<li>
<p>Go handles newlines in the scanner. If a newline appears following one of a handful of token types that are known to potentially end a statement, the newline is treated like a semicolon. Otherwise it is ignored. The Go team provides a canonical code formatter, gofmt, and the ecosystem is fervent about its use, which ensures that idiomatic styled code works well with this simple rule.</p>
</li>
<li>
<p>Python treats all newlines as significant unless an explicit backslash is used at the end of a line to continue it to the next line. However, newlines anywhere inside a pair of brackets ((), [], or {}) are ignored. Idiomatic style strongly prefers the latter.</p>
<p>This rule works well for Python because it is a highly statement-oriented language. In particular, Pythonâ€™s grammar ensures a statement never appears inside an expression. C does the same, but many other languages which have a â€œlambdaâ€ or function literal syntax do not.</p>
<p>An example in JavaScript:</p>
<pre><code class="language-javascript">console.log(function() {
  statement();
});
</code></pre>
<p>Here, the console.log() expression contains a function literal which in turn contains the statement statement();.</p>
<p>Python would need a different set of rules for implicitly joining lines if you could get back into a statement where newlines should become meaningful while still nested inside brackets.</p>
</li>
<li>
<p>JavaScriptâ€™s â€œautomatic semicolon insertionâ€ rule is the real odd one. Where other languages assume most newlines are meaningful and only a few should be ignored in multi-line statements, JS assumes the opposite. It treats all of your newlines as meaningless whitespace unless it encounters a parse error. If it does, it goes back and tries turning the previous newline into a semicolon to get something grammatically valid.</p>
<p>This design note would turn into a design diatribe if I went into complete detail about how that even works, much less all the various ways that JavaScriptâ€™s â€œsolutionâ€ is a bad idea. Itâ€™s a mess. JavaScript is the only language I know where many style guides demand explicit semicolons after every statement even though the language theoretically lets you elide them.</p>
</li>
</ul>
<p>If youâ€™re designing a new language, you almost surely should avoid an explicit statement terminator. Programmers are creatures of fashion like other humans, and semicolons are as passÃ© as ALL CAPS KEYWORDS. Just make sure you pick a set of rules that make sense for your languageâ€™s particular grammar and idioms. And donâ€™t do what JavaScript did.</p>
<p>ä¸Šé¢çš„åœºæ™¯ä¸­ï¼Œå°†æ¢è¡Œç¬¦å½“ä½œåˆ†éš”ç¬¦ï¼Œæˆ–è€…ä¸æŠŠæ¢è¡Œç¬¦å½“ä½œåˆ†éš”ç¬¦ï¼Œéƒ½å¯ä»¥äº§ç”Ÿæœ‰æ•ˆçš„ä»£ç ã€‚ä½†æ˜¯ï¼Œè¿™æ ·å¯èƒ½äº§ç”Ÿçš„ä¸æ˜¯ç”¨æˆ·æƒ³è¦çš„æ•ˆæœã€‚åœ¨ä¸åŒçš„è¯­è¨€ä¸­ï¼Œæœ‰è®¸å¤šç‰¹æ®Šè§„åˆ™ï¼ŒæŒ‡å®šäº†å“ªäº›æ¢è¡Œç¬¦æ˜¯åˆ†éš”ç¬¦ã€‚</p>
<ul>
<li>
<p>Luaè¯­è¨€ä¸­ï¼Œå®Œå…¨å¿½ç•¥äº†æ¢è¡Œç¬¦ï¼Œä½†æ˜¯ï¼Œéœ€è¦å°å¿ƒçš„ä½¿ç”¨ã€‚åœ¨å¤§å¤šæ•°åœºæ™¯ï¼Œæ²¡æœ‰æ¢è¡Œç¬¦çš„è¯­å¥ï¼Œå¯ä»¥æ­£å¸¸è¿è¡Œï¼Œä¾‹å¦‚ï¼šorchid</p>
<p><code>a = 1 b = 2</code></p>
<p>Luaé€šè¿‡å°†ä»£ç å—ä¸­çš„æœ€åä¸€æ¡è¯­å¥å®šä¹‰ä¸ºreturn è¯­å¥ï¼Œæ¥é¿å…returné—®é¢˜ã€‚</p>
<p>(1) å¦‚æœå…³é”®è¯ return ä¹‹åï¼Œendå…³é”®è¯ä¹‹å‰ï¼Œå­˜åœ¨ &quot;value&quot; å­—ç¬¦ä¸²ï¼Œåˆ™Luaä¸­è¡¨ç¤ºè¿”å› &quot;value&quot;</p>
<pre><code>return 
&quot;value&quot;
</code></pre>
<p>(2) å…¶ä»–ä¸¤ç§æƒ…å†µï¼Œå‡ ä¹ä¸ä¼šå‘ç”Ÿï¼Œå› ä¸ºæ‹¬å·æˆ–è€…ä¸€å…ƒå¦å®šè¡¨è¾¾å¼è¯­å¥ï¼Œå‡ ä¹æ²¡æœ‰æ„ä¹‰</p>
</li>
<li>
<p>goè¯­è¨€ï¼Œä¼šå¤„ç†æ‰«æä»ªä¸­çš„æ¢è¡Œç¬¦ã€‚å¦‚æœæ¢è¡Œç¬¦ï¼Œå‡ºç°åœ¨å¯èƒ½æ˜¯ç»“æŸæ ‡å¿—åï¼Œåˆ™æ¢è¡Œç¬¦è¢«å½“ä½œéš”ç¦»ç¬¦ã€‚å¦åˆ™ï¼Œæ¢è¡Œç¬¦å°†è¢«å¿½ç•¥ã€‚goå¼€å‘å›¢é˜Ÿæä¾›äº†ä¸€ä¸ªä»£ç æ ¼å¼åŒ–çš„ç¨‹åºgofmtï¼Œgoç”Ÿæ€ä¸­éå¸¸çƒ­è¡·äºä½¿ç”¨å®ƒï¼Œè¿™ä¿è¯äº†ä¹ æƒ¯é£æ ¼çš„ä»£ç å’Œæ¢è¡Œç¬¦è§„åˆ™å¯ä»¥å¾ˆå¥½çš„é…åˆã€‚</p>
</li>
<li>
<p>Pythonè¯­è¨€å°†æ‰€æœ‰çš„æ¢è¡Œç¬¦ï¼Œè§†ä¸ºæœ‰æ•ˆçš„ã€‚é™¤äº†ï¼Œä½ åœ¨ä¸€è¡Œçš„æœ«å°¾ï¼Œä½¿ç”¨æ˜¾ç¤ºçš„ \ ï¼Œè¡¨ç¤ºä»£ç å°†ç»§ç»­åˆ°ä¸‹ä¸€è¡Œä¸­ã€‚ä½†æ˜¯ï¼Œåœ¨<code>() [] {} </code>ä¸­çš„æ¢è¡Œç¬¦å°†è¢«å¿½ç•¥ã€‚pythonä¹ æƒ¯é£æ ¼ä¹Ÿæ˜¯è¿™æ ·çš„</p>
<p>åœ¨Pythonä¸­ï¼Œè¿™äº›è§„åˆ™å¾ˆå¥½çš„è¿è¡Œï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ç§é«˜åº¦é¢å‘è¯­å¥çš„è¯­è¨€ã€‚ç‰¹åˆ«çš„ï¼Œpythonçš„è¯­æ³•è§„åˆ™ï¼Œä¿è¯äº†è¡¨è¾¾å¼ä¸­ï¼Œä¸ä¼šå‡ºç°è¯­å¥ã€‚Cè¯­è¨€ä¹Ÿæ˜¯è¿™æ ·åšçš„ï¼Œä½†æ˜¯å¾ˆå¤šè¯­è¨€ï¼ŒåŒ…å«äº† <code>lambda</code>å‡½æ•°æˆ–è€…å…¶ä»–å‡½æ•°ï¼Œå¯èƒ½ä¼šåœ¨è¡¨è¾¾å¼ä¸­åŒ…å«æœ‰è¯­å¥ã€‚</p>
<p>ä¾‹å¦‚ï¼Œjavascriptä¸­çš„ä»£ç </p>
<pre><code class="language-javascript">console.log(function() {
  statement();
});
</code></pre>
<p>å¦‚ä¸Šï¼Œconsole.log() å‡½æ•°ä¸­ï¼ŒåŒ…å«äº†ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œå‡½æ•°ä»£ç ä¸­åŒ…å«ä¸€ä¸ªè¯­å¥ statement();</p>
</li>
<li>
<p>javascriptè¯­è¨€</p>
</li>
</ul>
<p>å¦‚æœä½ æ­£åœ¨è®¾è®¡ä¸€ç§è¯­è¨€ï¼Œä½ åº”è¯¥é¿å…ä½¿ç”¨æ˜¾ç¤ºåˆ†éš”ç¬¦ï¼Œç¨‹åºå‘˜ä¹Ÿä¼šç´§è·Ÿæ—¶å°šï¼Œåˆ†å·å’Œæ‰€æœ‰çš„å¤§å†™å…³é”®è¯ï¼Œéƒ½æ˜¯è¿‡æ—¶è®¾è®¡ã€‚åªéœ€è¦ç¡®ä¿ï¼Œä½ é€‰æ‹©äº†ä¸€å¥—å¯¹äºæ–°è¯­è¨€ç‰¹å®šçŸ­è¯­å’Œä¹ è¯­ï¼Œéƒ½æœ‰æ„ä¹‰çš„è§„åˆ™ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="representing-code"><a class="header" href="#representing-code">Representing Code</a></h1>
<p>ä»£ç è¡¨ç¤º</p>
<blockquote>
<p>To dwellers in a wood, almost every species of tree has its voice as well as its feature.</p>
<p align="right"> Thomas Hardy, Under the Greenwood Tree</p>
<p>å¯¹äºæ£®æ—ä¸­çš„å±…æ°‘æ¥è¯´ï¼Œå‡ ä¹æ¯ä¸€æ£µæ ‘æœ¨éƒ½æœ‰è‡ªå·±çš„å£°éŸ³å’Œç‰¹å¾ã€‚</p>
</blockquote>
<p>In the last chapter, we took the raw source code as a string and transformed it into a slightly higher-level representation: a series of tokens. The parser weâ€™ll write in the next chapter takes those tokens and transforms them yet again, into an even richer, more complex representation.</p>
<p>Before we can produce that representation, we need to define it.Thatâ€™s the subject of this chapter. Along the way, weâ€™ll cover some theory around formal grammars, feel the difference between functional and object-oriented programming, go over a couple of design patterns, and do some metaprogramming.</p>
<p>åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡æ‰«æå™¨ï¼Œå°†æºä»£ç è½¬æ¢ä¸ºç¨å¾®é«˜çº§ä¸€äº›çš„è¡¨ç¤ºï¼šä¸€ç³»åˆ—çš„tokenã€‚ä¸‹ä¸€ç« ï¼Œå°†è¦ä»‹ç»çš„è§£é‡Šå™¨ï¼Œä¼šæŠŠtokensï¼Œè½¬æ¢ä¸ºæ›´åŠ ä¸°å¯Œã€å¤æ‚çš„è¡¨ç¤ºã€‚</p>
<p>åœ¨æˆ‘ä»¬ä½¿ç”¨è§£é‡Šå™¨ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå®šä¹‰tokenï¼Œè¿™æ˜¯æœ¬ç« èŠ‚çš„ä¸»é¢˜ã€‚åœ¨æœ¬ç« ï¼Œæˆ‘ä»¬å°†ä»‹ç»ä¸€äº›å½¢å¼è¯­æ³•ç†è®ºï¼Œæ„Ÿå—å‡½æ•°å¼ç¼–ç¨‹å’Œé¢å‘å¯¹è±¡ç¼–ç¨‹çš„åŒºåˆ«ã€‚æˆ‘ä»¬è¿˜å°†è®¨è®ºä¸€äº›è®¾è®¡æ¨¡å¼ï¼Œè¿›è¡Œä¸€äº›å…ƒç¼–ç¨‹ã€‚</p>
<blockquote>
<p>I was so worried about this being one of the most boring chapters in the book that I kept stuffing more fun ideas into it until I ran out of room.</p>
<p>æˆ‘ä¸€ç›´æ‹…å¿ƒï¼Œæœ¬ç« èŠ‚æ˜¯æ­¤ä¹¦ä¸­æœ€æ— èŠçš„ä¸€ç« ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä¸€ç›´æ·»åŠ æœ‰æ„æ€çš„ä¸œè¥¿ï¼Œç›´åˆ°å¡æ»¡äº†æœ¬ç« ã€‚</p>
</blockquote>
<p>Before we do all that, letâ€™s focus on the main goalâ€”a representation for code. It should be simple for the parser to produce and easy for the interpreter to consume. If you havenâ€™t written a parser or interpreter yet, those requirements arenâ€™t exactly illuminating. Maybe your intuition can help. What is your brain doing when you play the part of a human interpreter? How do you mentally evaluate an arithmetic expression like this:</p>
<pre><code>1 + 2 * 3 - 4
</code></pre>
<p>Because you understand the order of operationsâ€”the old â€œPlease Excuse My Dear Aunt Sallyâ€ stuffâ€”you know that the multiplication is evaluated before the addition or subtraction. One way to visualize that precedence is using a tree. Leaf nodes are numbers, and interior nodes are operators with branches for each of their operands.</p>
<p>In order to evaluate an arithmetic node, you need to know the numeric values of its subtrees, so you have to evaluate those first. That means working your way from the leaves up to the rootâ€”a post-order traversal:</p>
<p>A. Starting with the full tree, evaluate the bottom-most operation, 2 * 3.</p>
<p>B. Now we can evaluate the +.</p>
<p>C. Next, the -.</p>
<p>D. The final answer.</p>
<p>åœ¨æˆ‘ä»¬å¼€å§‹åšè¿™äº›ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆå…³æ³¨ä¸»è¦ç›®æ ‡-ä»£ç è¡¨ç¤ºã€‚å®ƒåº”è¯¥å®¹æ˜“è¢«è§£é‡Šå™¨ç”Ÿæˆï¼Œå¹¶ä¸”è§£é‡Šå™¨æ›´åŠ å®¹æ˜“ä½¿ç”¨å®ƒä»¬ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ è¿˜æ²¡æœ‰ç¼–å†™è¿‡è§£é‡Šå™¨æˆ–è€…ç¼–è¯‘å™¨ï¼Œé‚£ä¹ˆè¿™äº›éœ€æ±‚ä½ å¯èƒ½ä¸å¤ªç†Ÿæ‚‰ã€‚ä¹Ÿè®¸ï¼Œä½ çš„ç›´è§‰å°†ä¼šèµ·ä½œç”¨ã€‚å½“ä½ åœ¨æ‰®æ¼”äººç±»è¯­è¨€ç¿»è¯‘è§’è‰²æ—¶å€™ï¼Œä½ çš„å¤§è„‘ä¼šå¦‚ä½•æ€è€ƒï¼Ÿè®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ä¸‹é¢çš„ç¤ºä¾‹ï¼Œä½ ä¼šå¦‚ä½•è®¡ç®—ä¸‹é¢çš„ç®—æœ¯è¡¨è¾¾å¼ï¼š</p>
<pre><code>1 + 2 * 3 - 4
</code></pre>
<p>å› ä¸ºæˆ‘ä»¬çŸ¥é“ç®—æœ¯è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬çŸ¥é“ä¹˜æ³•ä¼šä¼˜å…ˆåŠ å‡æ³•ï¼Œå…ˆè®¡ç®—ã€‚å¯è§†åŒ–è¿ç®—ä¼˜å…ˆçº§çš„ä¸€ç§æ–¹æ³•æ˜¯ï¼Œä½¿ç”¨æ ‘ç»“æ„ã€‚å…¶ä¸­ï¼Œå¶èŠ‚ç‚¹æ˜¯å…·ä½“çš„æ•°å­—ï¼Œä¸­é—´å±‚èŠ‚ç‚¹æ˜¯è¿ç®—ç¬¦ã€‚</p>
<p>In order to evaluate an arithmetic node, you need to know the numeric values of its subtrees, so you have to evaluate those first. That means working your way from the leaves up to the rootâ€”a post-order traversal:</p>
<p>ä¸ºäº†è®¡ç®—ç®—æœ¯èŠ‚ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å®ƒçš„å­æ ‘çš„ç»“æœï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬éœ€è¦å…ˆè®¡ç®—è¿™äº›å­æ ‘çš„ç»“æœï¼Œè¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬éœ€è¦ä»å¶èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹è®¡ç®—ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªååºéå†ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/tree-evaluate.png?raw=true" alt="tree-travel" /></p>
<p>ç”±ä¸Šå›¾ï¼Œå¯ä»¥çœ‹åˆ°è®¡ç®—æ­¥éª¤</p>
<p>A. è®¡ç®—æœ€åº•å±‚çš„è¡¨è¾¾å¼ï¼Œ2 * 3</p>
<p>B. è®¡ç®—åŠ æ³•è¡¨è¾¾å¼</p>
<p>C. è®¡ç®—å‡æ³•è¡¨è¾¾å¼</p>
<p>D. å¾—åˆ°æœ€ç»ˆç»“æœ</p>
<p>If I gave you an arithmetic expression, you could draw one of these trees pretty easily. Given a tree, you can evaluate it without breaking a sweat. So it intuitively seems like a workable representation of our code is a tree that matches the grammatical structureâ€”the operator nestingâ€”of the language.</p>
<p>å¦‚æœæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç®—æœ¯è¡¨è¾¾å¼ï¼Œé‚£ä¹ˆå¯ä»¥å¾ˆå®¹æ˜“çš„è½¬å˜ä¸ºä¸€æ£µæ ‘ï¼ŒåŒæ ·çš„ï¼Œå¦‚æœæœ‰ä¸€æ£µæ ‘ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å®¹æ˜“å˜ä¸ºä¸€ä¸ªè¡¨è¾¾å¼ã€‚å› æ­¤ï¼Œä»ç›´è§‰ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†ä»£ç è¡¨ç¤ºä¸ºä¸€æ£µæ ‘ï¼Œè¿™æ£µæ ‘ä¸æˆ‘ä»¬ä½¿ç”¨çš„ç¼–ç¨‹è¯­è¨€çš„è¯­æ³•ç»“æ„ã€è¿ç®—ç¬¦ï¼ŒåµŒå¥—åŒ¹é…ã€‚</p>
<blockquote>
<p>Thatâ€™s not to say a tree is the only possible representation of our code. In Part III, weâ€™ll generate bytecode, another representation that isnâ€™t as human friendly but is closer to the machine.</p>
<p>è¿™å¹¶ä¸æ˜¯è¯´ï¼Œè¯­æ³•æ ‘æ˜¯æˆ‘ä»¬ä»£ç çš„å”¯ä¸€è¡¨ç¤ºæ–¹å¼ã€‚åœ¨æœ¬ä¹¦çš„ç¬¬ä¸‰éƒ¨åˆ†ï¼Œæˆ‘ä»¬è¿˜å°†ä»‹ç»å­—èŠ‚ç ï¼Œè¿™æ˜¯ä¸€ç§æ›´åŠ æ¥è¿‘æœºå™¨çš„è¡¨ç¤ºï¼Œä½†æ˜¯å¯¹äºäººç±»æ¥è¯´ï¼Œä¸æ˜¯é‚£ä¹ˆäººæ€§åŒ–ã€‚</p>
</blockquote>
<p>We need to get more precise about what that grammar is then. Like lexical grammars in the last chapter, there is a long ton of theory around syntactic grammars. Weâ€™re going into that theory a little more than we did when scanning because it turns out to be a useful tool throughout much of the interpreter. We start by moving one level up the <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>. </p>
<p>æˆ‘ä»¬éœ€è¦æ›´åŠ ç²¾ç¡®å»äº†è§£ï¼Œä»€ä¹ˆæ˜¯è¯­æ³•ã€‚å°±åƒä¸Šä¸€ç« çš„è¯æ³•è§„åˆ™ä¸€æ ·ï¼Œå…³äºè¯­æ³•è§„åˆ™ä¹Ÿæœ‰å¾ˆå¤šç†è®ºã€‚æˆ‘ä»¬å¯¹è¿™äº›ç†è®ºçš„æ¢è®¨å°†æ›´åŠ æ·±å…¥ä¸€äº›ï¼Œå› ä¸ºè¿™äº›ç†è®ºè¢«è¯æ˜ï¼Œå¯¹äºè§£é‡Šå™¨æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„å·¥å…·ã€‚æˆ‘ä»¬é¦–å…ˆè¦å­¦ä¹  <a href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky hierarchy</a>. </p>
<h2 id="ä¸€context-free-grammars"><a class="header" href="#ä¸€context-free-grammars">ä¸€ã€Context-Free Grammars</a></h2>
<p>ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•</p>
<p>In the last chapter, the formalism we used for defining the lexical grammarâ€”the rules for how characters get grouped into tokensâ€”was called a regular language. That was fine for our scanner, which emits a flat sequence of tokens. But regular languages arenâ€™t powerful enough to handle expressions which can nest arbitrarily deeply.</p>
<p>We need a bigger hammer, and that hammer is a context-free grammar (CFG). Itâ€™s the next heaviest tool in the toolbox of formal grammars. A formal grammar takes a set of atomic pieces it calls its â€œalphabetâ€. Then it defines a (usually infinite) set of â€œstringsâ€ that are â€œinâ€ the grammar. Each string is a sequence of â€œlettersâ€ in the alphabet.</p>
<p>Iâ€™m using all those quotes because the terms get a little confusing as you move from lexical to syntactic grammars. In our scannerâ€™s grammar, the alphabet consists of individual characters and the strings are the valid lexemesâ€”roughly â€œwordsâ€. In the syntactic grammar weâ€™re talking about now, weâ€™re at a different level of granularity. Now each â€œletterâ€ in the alphabet is an entire token and a â€œstringâ€ is a sequence of tokensâ€”an entire expression.</p>
<p>Oof. Maybe a table will help:</p>
<table><thead><tr><th>Terminology</th><th>Lexical grammar</th><th>Syntactic grammar</th></tr></thead><tbody>
<tr><td>The â€œalphabetâ€ isâ€‰.â€‰.â€‰.</td><td>Characters</td><td>Tokens</td></tr>
<tr><td>A â€œstringâ€ isâ€‰.â€‰.â€‰.</td><td>Lexeme or token</td><td>Expression</td></tr>
<tr><td>Itâ€™s implemented by theâ€‰.â€‰.â€‰.</td><td>Scanner</td><td>Parser</td></tr>
</tbody></table>
<p>A formal grammarâ€™s job is to specify which strings are valid and which arenâ€™t. If we were defining a grammar for English sentences, â€œeggs are tasty for breakfastâ€ would be in the grammar, but â€œtasty breakfast for are eggsâ€ would probably not.</p>
<p>åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰è¯æ±‡çš„è§„åˆ™â€”â€”å°†å­—ç¬¦åˆ†ç»„ä¸ºtokençš„è§„åˆ™ï¼Œè¢«ç§°ä¸ºæ­£åˆ™è¯­è¨€ã€‚è¿™å¯¹äºæˆ‘ä»¬å®ç°çš„æ‰«æå™¨æ˜¯éå¸¸å¥½çš„ï¼Œå®ƒå°†è¾“å‡ºä¸€ä¸ªtokenåºåˆ—ã€‚ä½†æ˜¯ï¼Œæ­£åˆ™è¯­è¨€çš„åŠŸèƒ½ä¸è¶³ä»¥å¤„ç†ä»»ä½•æ·±åº¦åµŒå¥—çš„è¡¨è¾¾å¼ã€‚</p>
<p>æˆ‘ä»¬éœ€è¦æ›´å¼ºå¤§çš„å·¥å…·ï¼Œè¿™ä¸ªå·¥å…·å°±æ˜¯CFG ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ã€‚CFGä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ï¼Œæ˜¯<a href="https://en.wikipedia.org/wiki/Formal_grammar">å½¢å¼æ–‡æ³•</a>ä¸­ç¬¬äºŒé‡è¦çš„å·¥å…·. å½¢å¼æ–‡æ³•å®šä¹‰äº†ä¸€ç»„åŸå­åŒ–çš„å­—ç¬¦è¡¨ï¼Œç§°ä¸ºå­—æ¯è¡¨ï¼Œç„¶åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ç»„å­—ç¬¦ä¸²ï¼ˆé€šå¸¸æ˜¯æ— é™çš„ï¼‰ï¼Œæ¯ä¸€ä¸ªå­—ç¬¦ä¸²éƒ½ç”±å­—æ¯è¡¨ä¸­çš„å­—æ¯ç»„åˆã€‚</p>
<p>æˆ‘ä½¿ç”¨äº†ä¸€äº›å¼•å·æ ‡æ³¨ï¼Œæ˜¯å› ä¸ºå½“æˆ‘ä»¬ä»è¯æ³•è§„åˆ™å˜æ›´åˆ°è¯­æ³•è§„åˆ™æ—¶å€™ï¼Œå…¶ä¸­çš„æœ¯è¯­ä¼šå˜å¾—ä»¤äººå›°æƒ‘ã€‚åœ¨è¯æ³•è§„åˆ™ä¸­ï¼Œå­—æ¯è¡¨æ˜¯å•ä¸ªå­—ç¬¦ç»„æˆçš„ï¼Œå­—ç¬¦ä¸²æ˜¯æœ‰æ•ˆçš„è¯ç´ ï¼ˆå³å•è¯ï¼‰ã€‚ä½†æ˜¯ï¼Œåœ¨æˆ‘ä»¬å½“å‰çš„è¯­æ³•è®¨è®ºä¸­ï¼Œç°åœ¨çš„å­—æ¯è¡¨ä¸­æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªtokenï¼Œæˆ‘ä»¬å¤„äºä¸åŒçš„ç²’åº¦çº§åˆ«ã€‚åŒæ ·çš„ï¼Œè¿™æ—¶å€™ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²è¡¨ç¤ºä¸€ç»„tokenï¼Œå³å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ã€‚</p>
<p>å®ƒä»¬çš„åŒºåˆ«ï¼Œè¯¦è§ä¸‹è¡¨ï¼š</p>
<table><thead><tr><th>æœ¯è¯­</th><th>è¯æ³•è§„åˆ™</th><th>è¯­æ³•è§„åˆ™</th></tr></thead><tbody>
<tr><td>å­—æ¯è¡¨</td><td>å­—ç¬¦åˆ—è¡¨</td><td>tokenåˆ—è¡¨</td></tr>
<tr><td>å­—ç¬¦ä¸²</td><td>è¯ç´ ï¼ˆå•è¯ï¼‰æˆ–è€…token</td><td>è¡¨è¾¾å¼</td></tr>
<tr><td>å®ç°è€…</td><td>æ‰«æå™¨</td><td>è§£æå™¨</td></tr>
</tbody></table>
<p>å½¢å¼æ–‡æ³•çš„ç›®æ ‡æ˜¯æŒ‡å®šå“ªäº›å­—ç¬¦ä¸²æœ‰æ•ˆï¼Œå“ªäº›å­—ç¬¦ä¸²æ— æ•ˆã€‚ä¾‹å¦‚ï¼šæˆ‘ä»¬æƒ³è¦ç»™ä¸€ä¸ªè‹±è¯­è¯­å¥ï¼Œå®šä¹‰è¯­æ³•è§„åˆ™ã€‚&quot;eggs are tasty for breakfast&quot; æ˜¯ä¸€ä¸ªåˆæ³•çš„è‹±è¯­è¯­å¥ï¼Œä½†æ˜¯ï¼Œâ€œtasty breakfast for are eggsâ€å°±ä¸æ˜¯ä¸€ä¸ªåˆæ³•çš„è‹±è¯­è¯­å¥ã€‚</p>
<h3 id="11-rules-for-grammars"><a class="header" href="#11-rules-for-grammars">1.1 Rules for grammars</a></h3>
<p>è¯­æ³•è§„åˆ™</p>
<p>How do we write down a grammar that contains an infinite number of valid strings? We obviously canâ€™t list them all out. Instead, we create a finite set of rules. You can think of them as a game that you can â€œplayâ€ in one of two directions.</p>
<p>If you start with the rules, you can use them to generate strings that are in the grammar. Strings created this way are called derivations because each is derived from the rules of the grammar. In each step of the game, you pick a rule and follow what it tells you to do. Most of the lingo around formal grammars comes from playing them in this direction. Rules are called productions because they produce strings in the grammar.</p>
<p>æˆ‘ä»¬å¦‚ä½•å†™å‡ºåŒ…å«æ— é™ä¸ªå­—ç¬¦ä¸²çš„è¯­æ³•ï¼Ÿæ˜¾ç„¶ï¼Œæˆ‘ä»¬ä¸å¯èƒ½ç½—åˆ—å‡ºå®ƒä»¬ã€‚ç›¸åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ç»„æœ‰é™çš„è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¯­æ³•è§„åˆ™æƒ³è±¡ä¸ºä¸€ä¸ªæ¸¸æˆï¼Œå¯ä»¥ä»ä¸¤ä¸ªæ–¹å‘ä¸­çš„ä¸€ä¸ªç©ã€‚</p>
<p>å¦‚æœä½ ä»è¯­æ³•è§„åˆ™å¼€å§‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¯­æ³•è§„åˆ™ç”Ÿæˆåˆæ³•çš„è¯­å¥ï¼Œè¿™äº›ç”Ÿæˆçš„è¯­å¥ï¼Œç§°ä¸ºæ´¾ç”Ÿè¯­å¥ï¼Œå› ä¸ºå®ƒä»¬éƒ½æ˜¯ä»è¯­æ³•è§„åˆ™ä¸­æ´¾ç”Ÿå‡ºã€‚åœ¨æ¸¸æˆçš„æ¯ä¸€æ­¥ï¼Œä½ éƒ½éœ€è¦é€‰æ‹©ä¸€æ¡è¯­æ³•è§„åˆ™ï¼Œç„¶åï¼ŒæŒ‰ç…§è§„åˆ™ç»§ç»­è¿è¡Œã€‚å½¢å¼æ–‡æ³•çš„ï¼Œå¤§éƒ¨åˆ†æœ¯è¯­éƒ½æ˜¯ä»è¿™ä¸ªæ–¹å‘ä¸­äº§ç”Ÿçš„ï¼Œè¯­æ³•è§„åˆ™è¢«ç§°ä¸ºäº§ç”Ÿå¼ï¼Œå› ä¸ºï¼Œå®ƒä»¬ç”Ÿäº§å­—ç¬¦ä¸²ã€‚</p>
<p>Each production in a context-free grammar has a headâ€”its nameâ€”and a body, which describes what it generates. In its pure form, the body is simply a list of symbols. Symbols come in two delectable flavors:</p>
<blockquote>
<p>Restricting heads to a single symbol is a defining feature of context-free grammars. More powerful formalisms like unrestricted grammars allow a sequence of symbols in the head as well as in the body.</p>
<p>å°†å¤´é™åˆ¶ä¸ºå•ä¸ªç¬¦å·ï¼Œæ˜¯ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•çš„ä¸€ä¸ªå®šä¹‰ç‰¹æ€§ï¼Œæ›´åŠ å¼ºå¤§çš„å½¢å¼ä¸»ä¹‰ï¼Œä¾‹å¦‚: <a href="https://en.wikipedia.org/wiki/Unrestricted_grammar">æ— é™åˆ¶æ–‡æ³•</a>, å…è®¸å¤´éƒ¨å’Œbodyä¸­å®šä¹‰ä¸€ç³»åˆ—ç¬¦å·</p>
</blockquote>
<ul>
<li>
<p>A terminal is a letter from the grammarâ€™s alphabet. You can think of it like a literal value. In the syntactic grammar weâ€™re defining, the terminals are individual lexemesâ€”tokens coming from the scanner like if or 1234.</p>
<p>These are called â€œterminalsâ€, in the sense of an â€œend pointâ€ because they donâ€™t lead to any further â€œmovesâ€ in the game. You simply produce that one symbol.</p>
</li>
<li>
<p>A nonterminal is a named reference to another rule in the grammar. It means â€œplay that rule and insert whatever it produces hereâ€. In this way, the grammar composes.</p>
</li>
</ul>
<p>There is one last refinement: you may have multiple rules with the same name. When you reach a nonterminal with that name, you are allowed to pick any of the rules for it, whichever floats your boat.</p>
<p>ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ä¸­çš„æ¯ä¸€ä¸ªè¾“å‡ºï¼Œéƒ½æœ‰ä¸€ä¸ªå¤´ï¼ˆåç§°ï¼‰ï¼Œä¸€ä¸ªä¸»ä½“ï¼ˆæè¿°ç”Ÿæˆçš„å†…å®¹ï¼‰ï¼Œåœ¨çº¯å½¢å¼ä¸­ï¼Œä¸»ä½“æ˜¯ä¸€ä¸ªç¬¦å·åˆ—è¡¨ã€‚ç¬¦å·ä¸»è¦åˆ†ä¸ºä¸¤ç±»ï¼š</p>
<ul>
<li>
<p>ç»ˆæ­¢ç¬¦ï¼Œæ˜¯è¯­æ³•å­—æ¯è¡¨ä¸­çš„å­—æ¯ã€‚å¯ä»¥å°†å®ƒæƒ³è±¡ä¸ºæ–‡å­—å€¼ã€‚åœ¨æˆ‘ä»¬å®šä¹‰çš„è¯­æ³•è§„åˆ™ä¸­ï¼Œç»ˆæ­¢ç¬¦æ˜¯æ¥è‡ªæ‰«æå™¨ç”Ÿæˆçš„å•ä¸ªè¯ç´ æˆ–è€…tokenï¼Œä¾‹å¦‚ï¼šifï¼Œ 1234ï¼Œè¿™äº›è¢«ç§°ä¸ºç»ˆæ­¢ç¬¦ï¼Œå› ä¸ºå®ƒä»¬ä¸ä¼šå¯¼è‡´è§„åˆ™çš„è¿›ä¸€æ­¥å‰è¿›ï¼Œå®ƒä»¬å°±æ˜¯è¯­æ³•è§„åˆ™çš„ç»ˆç‚¹ã€‚åªéœ€è¦ç”Ÿæˆä¸€ä¸ªç¬¦å·</p>
</li>
<li>
<p>éç»ˆæ­¢ç¬¦ï¼Œæ˜¯å¯¹è¯­æ³•è§„åˆ™ä¸­çš„å¦å¤–ä¸€ä¸ªè§„åˆ™çš„å¼•ç”¨ã€‚å®ƒçš„æ„æ€æ˜¯ï¼Œç»§ç»­è¿™ä¸ªè§„åˆ™ï¼Œå°†äº§ç”Ÿçš„ä»»ä½•ä¸œè¥¿ï¼Œæ’å…¥å½“å‰ä½ç½®ï¼Œè¯­æ³•å°±æ˜¯è¿™æ ·ç”Ÿæˆçš„ã€‚</p>
</li>
</ul>
<p>è¿˜æœ‰æœ€åä¸€ä¸ªæ”¹è¿›ï¼Œä½ å¯èƒ½ä¼šæœ‰å¤šä¸ªåŒåè§„åˆ™ã€‚å½“æˆ‘ä»¬é‡åˆ°è¯¥åç§°çš„éç»ˆæ­¢ç¬¦æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ä»»æ„ä¸€ä¸ªè§„åˆ™ï¼Œæ— è®ºé‚£ä¸ªè§„åˆ™ä½¿æˆ‘ä»¬ç»§ç»­è¿›è¡Œä¸‹å»ã€‚</p>
<p>To make this concrete, we need a way to write down these production rules.People have been trying to crystallize grammar all the way back to PÄá¹‡iniâ€™s Ashtadhyayi, which codified Sanskrit grammar a mere couple thousand years ago. Not much progress happened until John Backus and company needed a notation for specifying ALGOL 58 and came up with Backus-Naur form (BNF). Since then, nearly everyone uses some flavor of BNF, tweaked to their own tastes.</p>
<p>I tried to come up with something clean. Each rule is a name, followed by an arrow (â†’), followed by a sequence of symbols, and finally ending with a semicolon (;). Terminals are quoted strings, and nonterminals are lowercase words.</p>
<p>ä¸ºäº†ä½¿å…¶å…·ä½“åŒ–ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ç§æ–¹æ³•æ¥å†™ä¸‹è¿™äº›è§„åˆ™ã€‚äººä»¬ä¸€ç›´å°è¯•ç€å°†è¯­æ³•å…·ä½“åŒ–ï¼Œä¾‹å¦‚ï¼šä¸¤åƒå¹´å‰çš„PÄá¹‡ini ï¼Œç¼–å†™äº†æ¢µè¯­è¯­æ³•ä¹¦  <a href="https://en.wikipedia.org/wiki/P%C4%81%E1%B9%87ini">Aá¹£á¹­ÄdhyÄyÄ«</a> ã€‚ä½†æ˜¯ï¼Œä¸€ç›´åˆ° <a href="https://en.wikipedia.org/wiki/John_Backus">John Backus</a>å’Œä»–çš„å…¬å¸ï¼Œéœ€è¦ä¸ºALGOL 58 è¯­è¨€æŒ‡å®šä¸€ç§ç¬¦å·ï¼Œæœ€åè¢«å‘½åä¸º<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">å·´ç§‘æ–¯èŒƒå¼</a>, ç¼©å†™ä¸ºBNFï¼Œä»æ­¤ä»¥åï¼Œæ¯ä¸€ä¸ªè¯­è¨€å‘æ˜è€…éƒ½ä½¿ç”¨å˜åŒ–çš„BNFï¼Œæ ¹æ®è‡ªå·±çš„åå¥½ä¿®æ”¹ã€‚</p>
<p>æˆ‘å°è¯•ç€è®¾è®¡å‡ºä¸€ä¸ªç®€æ´çš„æ–¹å¼ï¼Œæ¯ä¸ªè§„åˆ™éƒ½æ˜¯ä¸€ä¸ªåç§°ï¼Œåé¢ç´§è·Ÿç€ä¸€ä¸ªç®­å¤´ â€”&gt;ï¼Œç„¶ååœ¨è·Ÿéšè€…ä¸€ä¸²ç¬¦å·ï¼Œæœ€ç»ˆç”¨åˆ†å·ç»“æŸ; </p>
<p>ç»ˆæ­¢ç¬¦æ˜¯å¸¦å¼•å·çš„å­—ç¬¦ä¸²ï¼Œéç»ˆæ­¢ç¬¦æ˜¯å°å†™å­—ç¬¦</p>
<blockquote>
<p>Yes, we need to define a syntax to use for the rules that define our syntax. Should we specify that metasyntax too? What notation do we use for it? Itâ€™s languages all the way down!</p>
<p>æˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªè¯­æ³•ï¼Œä½¿ç”¨è¿™äº›è¯­æ³•è§„åˆ™ï¼Œæˆ‘ä»¬å°†å®šä¹‰è¯­è¨€çš„è¯­æ³•ã€‚æˆ‘ä»¬æ˜¯å¦ä¹Ÿåº”è¯¥æŒ‡å®šå…ƒè¯­æ³•ï¼Ÿæˆ‘ä»¬ç”¨ä»€ä¹ˆç¬¦å·è¡¨ç¤ºå®ƒï¼Œä¸€ç›´ä»¥æ¥éƒ½æ˜¯è¯­è¨€ã€‚</p>
</blockquote>
<p>Using that, hereâ€™s a grammar for breakfast menus:</p>
<blockquote>
<p>Yes, I really am going to be using breakfast examples throughout this entire book. Sorry.</p>
<p>å¾ˆæŠ±æ­‰ï¼Œæˆ‘ä¸€ç›´åœ¨ä¹¦ä¸­ï¼Œä½¿ç”¨æ—©é¤ä¸¾ä¾‹ã€‚</p>
</blockquote>
<pre><code>
breakfast  â†’ protein &quot;with&quot; breakfast &quot;on the side&quot; ;
breakfast  â†’ protein ;
breakfast  â†’ bread ;

protein    â†’ crispiness &quot;crispy&quot; &quot;bacon&quot; ;
protein    â†’ &quot;sausage&quot; ;
protein    â†’ cooked &quot;eggs&quot; ;

crispiness â†’ &quot;really&quot; ;
crispiness â†’ &quot;really&quot; crispiness ;

cooked     â†’ &quot;scrambled&quot; ;
cooked     â†’ &quot;poached&quot; ;
cooked     â†’ &quot;fried&quot; ;

bread      â†’ &quot;toast&quot; ;
bread      â†’ &quot;biscuits&quot; ;
bread      â†’ &quot;English muffin&quot; ;

</code></pre>
<p>ä½¿ç”¨å®ƒï¼Œæˆ‘ä»¬å¯ä»¥å½¢æˆæ—©é¤çš„è¯­æ³•è§„åˆ™ã€‚</p>
<p>We can use this grammar to generate random breakfasts. Letâ€™s play a round and see how it works. By age-old convention, the game starts with the first rule in the grammar, here breakfast. There are three productions for that, and we randomly pick the first one. Our resulting string looks like:</p>
<p><code>protein &quot;with&quot; breakfast &quot;on the side&quot;</code></p>
<p>We need to expand that first nonterminal, protein, so we pick a production for that. Letâ€™s pick:</p>
<p><code>protein â†’ cooked &quot;eggs&quot; ;</code></p>
<p>Next, we need a production for cooked, and so we pick &quot;poached&quot;. Thatâ€™s a terminal, so we add that. Now our string looks like:</p>
<p><code>&quot;poached&quot; &quot;eggs&quot; &quot;with&quot; breakfast &quot;on the side&quot;</code></p>
<p>The next non-terminal is breakfast again. The first breakfast production we chose recursively refers back to the breakfast rule. Recursion in the grammar is a good sign that the language being defined is context-free instead of regular. In particular, recursion where the recursive nonterminal has productions on both sides implies that the language is not regular.</p>
<blockquote>
<p>Imagine that weâ€™ve recursively expanded the breakfast rule here several times, like â€œbacon with bacon with bacon withâ€‰.â€‰.â€‰. â€ In order to complete the string correctly, we need to add an equal number of â€œon the sideâ€ bits to the end. Tracking the number of required trailing parts is beyond the capabilities of a regular grammar. Regular grammars can express repetition, but they canâ€™t keep count of how many repetitions there are, which is necessary to ensure that the string has the same number of with and on the side parts.</p>
<p>æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œï¼Œé€’å½’çš„æ‰©å±•äº†æ—©é¤è§„åˆ™å¥½å‡ æ¬¡ï¼Œä¸ºäº†æ­£ç¡®çš„äº§ç”Ÿå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æœ«å°¾æ·»åŠ ç›¸åŒæ•°é‡çš„ä½ï¼Œè·Ÿè¸ªæ‰€éœ€çš„å°¾éƒ¨éƒ¨åˆ†çš„æ•°é‡ï¼Œè¶…è¿‡äº†å¸¸è§„è¯­æ³•çš„èƒ½åŠ›ã€‚å¸¸è§„è¯­æ³•ï¼Œå¯ä»¥è¡¨ç¤ºé€’å½’ï¼Œä½†æ˜¯æ— æ³•è®¡ç®—é‡å¤çš„æ¬¡æ•°ã€‚è¿™å¯¹äºç¡®ä¿å­—ç¬¦ä¸²çš„with å’Œ on the side éƒ¨åˆ†ï¼Œç»´æŒç›¸åŒæ•°é‡æ˜¯éå¸¸é‡è¦çš„ã€‚</p>
</blockquote>
<p>We could keep picking the first production for breakfast over and over again yielding all manner of breakfasts like â€œbacon with sausage with scrambled eggs with baconâ€‰.â€‰.â€‰. â€ We wonâ€™t though. This time weâ€™ll pick bread. There are three rules for that, each of which contains only a terminal. Weâ€™ll pick â€œEnglish muffinâ€.</p>
<p>With that, every nonterminal in the string has been expanded until it finally contains only terminals and weâ€™re left with:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/breakfast.png?raw=true" alt="breakfast" /></p>
<p>Throw in some ham and Hollandaise, and youâ€™ve got eggs Benedict.</p>
<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™ä¸ªè§„åˆ™ï¼Œç”Ÿæˆéšæœºçš„æ—©é¤ï¼Œè®©æˆ‘ä»¬å®é™…ç”Ÿæˆä¸€ä¸ªæ—©é¤ï¼Œçœ‹çœ‹å®ƒæ˜¯å¦‚ä½•ç”Ÿæ•ˆçš„ã€‚æŒ‰ç…§å¤è€çš„æƒ¯ä¾‹ï¼Œæ¸¸æˆä»è¯­æ³•ä¸­çš„ç¬¬ä¸€æ¡è§„åˆ™å¼€å§‹ï¼Œè¿™é‡Œæ˜¯ breakfast, å¯¹äº breakfast åç§°çš„è§„åˆ™ï¼Œæˆ‘ä»¬æœ‰3ä¸ªä¸åŒçš„ä¸»ä½“ï¼Œè®©æˆ‘ä»¬éšæœºé€‰æ‹©ä¸€ä¸ªè§„åˆ™ï¼Œ</p>
<p><code>breakfast  â†’ protein &quot;with&quot; breakfast &quot;on the side&quot; ;</code></p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†æ‰©å±•ç¬¬ä¸€ä¸ªéç»ˆæ­¢ç¬¦ protein, åŒæ ·çš„ï¼Œæˆ‘ä»¬å°†éšæœºé€‰æ‹© protein åç§°çš„è§„åˆ™ï¼Œæˆ‘ä»¬é€‰æ‹©ç¬¬3ä¸ªè§„åˆ™</p>
<p><code>protein â†’ cooked &quot;eggs&quot; ;</code></p>
<p>æ¥ç€ï¼Œæˆ‘ä»¬å°†ç»§ç»­æ‰©å±•éç»ˆæ­¢ç¬¦ cooked, è¿™é‡Œæˆ‘ä»¬é€‰æ‹© poached, è€Œè¿™æ˜¯ä¸€ä¸ªç»ˆæ­¢ç¬¦ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„è¯­æ³•è§„åˆ™åˆ°æ­¤ç»“æŸï¼Œå®Œæ•´çš„å­—ç¬¦ä¸²çœ‹èµ·æ¥æ˜¯</p>
<p><code>&quot;poached&quot; &quot;eggs&quot; &quot;with&quot; breakfast &quot;on the side&quot;</code></p>
<p>ä¸‹é¢çš„ä¸€ä¸ªéç»ˆæ­¢ç¬¦æ˜¯ breakfast , å¦‚æœæˆ‘ä»¬é€‰æ‹©ç¬¬ä¸€ä¸ªè§„åˆ™ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†é€’å½’çš„è°ƒç”¨ breakfast, è¯­æ³•ä¸­çš„é€’å½’æ˜¯ä¸€ä¸ªæ ‡å¿—ï¼Œè¡¨ç¤ºè¯­æ³•è§„åˆ™æ˜¯ä¸Šä¸‹æ–‡æ— å…³çš„ï¼Œè€Œä¸æ˜¯æ­£åˆ™çš„ã€‚ç‰¹åˆ«æƒ…å†µä¸‹ï¼Œéç»ˆæ­¢ç¬¦åœ¨è§„åˆ™ä¸¤è¾¹éƒ½å­˜åœ¨ï¼Œæ„å‘³ç€é€’å½’ï¼Œè€Œä¸æ˜¯æ­£åˆ™çš„ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥ä¸€ç›´é€‰æ‹©breakfast éç»ˆæ­¢ç¬¦çš„ç¬¬ä¸€ä¸ªè§„åˆ™ï¼Œç„¶åï¼Œæˆ‘ä»¬å°†ç”Ÿæˆæºæºä¸æ–­çš„æ—©é¤ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸ä¼šè¿™æ ·åšçš„ï¼Œæˆ‘ä»¬å°†é€‰æ‹©breakfastçš„ç¬¬3æ¡è§„åˆ™ï¼Œbreadï¼Œä¸‹é¢æ˜¯æˆ‘ä»¬çš„æ—©é¤</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/breakfast.png?raw=true" alt="breakfast" /></p>
<p>Any time we hit a rule that had multiple productions, we just picked one arbitrarily. It is this flexibility that allows a short number of grammar rules to encode a combinatorially larger set of strings. The fact that a rule can refer to itselfâ€”directly or indirectlyâ€”kicks it up even more, letting us pack an infinite number of strings into a finite grammar.</p>
<p>ä»»ä½•æ—¶å€™ï¼Œæˆ‘ä»¬é‡åˆ°äº†ä¸€ä¸ªåç§°ï¼Œå¯¹åº”ç€å¤šä¸ªè§„åˆ™ï¼Œæˆ‘ä»¬å°†é€‰æ‹©ä¸€ä¸ªã€‚æ­£æ˜¯è¿™ç§çµæ´»æ€§ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥ç”¨æœ‰é™çš„è¯­æ³•è§„åˆ™ï¼Œç»„åˆæˆæ›´å¤šçš„å­—ç¬¦ä¸²é›†åˆã€‚ä¸€ä¸ªè§„åˆ™ä¸­å¯ä»¥é€’å½’çš„è°ƒç”¨è‡ªå·±ï¼Œè¿™æ ·å­ï¼Œæˆ‘ä»¬å¯ä»¥å°†æ— é™çš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºä¸ºæœ‰é™çš„è¯­æ³•è§„åˆ™ã€‚</p>
<h3 id="12-enhancing-our-notation"><a class="header" href="#12-enhancing-our-notation">1.2 Enhancing our notation</a></h3>
<p>å¢å¼ºæˆ‘ä»¬çš„ç¬¦å·</p>
<p>Stuffing an infinite set of strings in a handful of rules is pretty fantastic, but letâ€™s take it further. Our notation works, but itâ€™s tedious. So, like any good language designer, weâ€™ll sprinkle a little syntactic sugar on topâ€”some extra convenience notation. In addition to terminals and nonterminals, weâ€™ll allow a few other kinds of expressions in the body of a rule:</p>
<ul>
<li>
<p>Instead of repeating the rule name each time we want to add another production for it, weâ€™ll allow a series of productions separated by a pipe (|).</p>
<p><code>bread â†’ &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;</code></p>
</li>
<li>
<p>Further, weâ€™ll allow parentheses for grouping and then allow | within that to select one from a series of options within the middle of a production.</p>
<p><code>protein â†’ ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;</code></p>
</li>
<li>
<p>Using recursion to support repeated sequences of symbols has a certain appealing purity, but itâ€™s kind of a chore to make a separate named sub-rule each time we want to loop. So, we also use a postfix * to allow the previous symbol or group to be repeated zero or more times.</p>
<p><code>crispiness â†’ &quot;really&quot; &quot;really&quot;* ;</code></p>
</li>
<li>
<p>A postfix + is similar, but requires the preceding production to appear at least once.</p>
<p><code>crispiness â†’ &quot;really&quot;+ ;</code></p>
</li>
<li>
<p>A postfix ? is for an optional production. The thing before it can appear zero or one time, but not more.</p>
<p><code>breakfast â†’ protein ( &quot;with&quot; breakfast &quot;on the side&quot; )? ;</code></p>
</li>
</ul>
<p>With all of those syntactic niceties, our breakfast grammar condenses down to:</p>
<pre><code>
breakfast â†’ protein ( &quot;with&quot; breakfast &quot;on the side&quot; )?
          | bread ;

protein   â†’ &quot;really&quot;+ &quot;crispy&quot; &quot;bacon&quot;
          | &quot;sausage&quot;
          | ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;

bread     â†’ &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;

</code></pre>
<p>åœ¨ä¸€äº›è§„åˆ™ä¸­ï¼Œæˆ‘ä»¬å¡«å……ä¸€ç»„æ— é™çš„å­—ç¬¦ä¸²æ˜¯éå¸¸å¥‡å¦™çš„ï¼Œä½†æ˜¯ï¼Œè®©æˆ‘ä»¬æ›´åŠ æ·±å…¥ä¸€äº›ã€‚æˆ‘ä»¬çš„è¯­æ³•ç¬¦å·ç”Ÿæ•ˆäº†ï¼Œä½†æ˜¯ååˆ†ä¹å‘³ã€‚æ‰€ä»¥ï¼Œåƒå¾ˆå¤šæœ‰é™çš„è¯­è¨€è®¾è®¡è€…ä¸€æ ·ï¼Œæˆ‘ä»¬å°†æ·»åŠ ä¸€äº›è¯­æ³•ç³–ï¼ˆå³æ·»åŠ ä¸€äº›å…¶ä»–ç¬¦å·ï¼Œæ›´åŠ æ–¹ä¾¿çš„ç¼–å†™è¯­æ³•è§„åˆ™ï¼‰ï¼Œé™¤äº†ç»ˆæ­¢ç¬¦å’Œéç»ˆæ­¢ç¬¦ï¼Œæˆ‘ä»¬è¿˜å°†åœ¨è¯­æ³•è§„åˆ™ä¸­ï¼Œä½¿ç”¨ä¸‹é¢çš„ç¬¦å·</p>
<ul>
<li>
<p>æˆ‘ä»¬å°†æ·»åŠ ç®¡é“ç¬¦| ç”¨äºåˆ†éš”è§„åˆ™åç§°ï¼Œè€Œä¸æ˜¯æ¯ä¸€æ¬¡éƒ½é‡å¤å†™å…¥å¤šä¸ªç›¸åŒè§„åˆ™åç§°</p>
<p><code>bread â†’ &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;</code></p>
</li>
<li>
<p>è¿›ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†å…è®¸ä½¿ç”¨æ‹¬å·è¿›è¡Œåˆ†ç»„ï¼Œæ¯ä¸€ä¸ªç»„ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ç®¡é“ç¬¦ | ï¼Œé€‰æ‹©å…¶ä¸­çš„ä¸€ä¸ª</p>
<p><code>protein â†’ ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;</code></p>
</li>
<li>
<p>ä½¿ç”¨é€’å½’æ¥æ”¯æŒæŸä¸ªè§„åˆ™çš„é‡å¤ä½¿ç”¨ï¼Œæ˜¯ä¸€ç§å¥½çš„æ–¹å¼ï¼Œä½†æ˜¯ï¼Œéœ€è¦æˆ‘ä»¬æ¯æ¬¡éƒ½å®šä¹‰ä¸€ä¸ªå•ç‹¬çš„å­è§„åˆ™ï¼Œè¿™æœ‰ä¸€äº›éº»çƒ¦ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸€ä¸ªåç¼€*ï¼Œè¡¨ç¤ºå‰é¢çš„è§„åˆ™æˆ–è€…ç»„ï¼Œé‡å¤é›¶æ¬¡æˆ–è€…å¤šæ¬¡ã€‚</p>
<p><code>crispiness â†’ &quot;really&quot; &quot;really&quot;* ;</code></p>
</li>
<li>
<p>ç›¸ä¼¼çš„åç¼€ï¼Œè¿˜æœ‰+ è¡¨ç¤ºå®ƒä¹‹å‰çš„è§„åˆ™æˆ–è€…ç»„ï¼Œè‡³å°‘å­˜åœ¨ä¸€æ¬¡</p>
<p><code>crispiness â†’ &quot;really&quot;+ ;</code></p>
</li>
<li>
<p>å’Œ + ç›¸ä¼¼çš„åç¼€ä¸º ? è¡¨ç¤ºå‰é¢çš„è§„åˆ™æˆ–è€…ç»„å¯ä»¥å‡ºç°é›¶æ¬¡æˆ–è€…1æ¬¡</p>
<p><code>breakfast â†’ protein ( &quot;with&quot; breakfast &quot;on the side&quot; )? ;</code></p>
</li>
</ul>
<p>å½“æˆ‘ä»¬ä½¿ç”¨äº†ä¸Šé¢çš„è¯­æ³•ç³–åï¼Œå¯ä»¥å°†æ—©é¤è§„åˆ™å˜æ›´ä¸º</p>
<pre><code>breakfast â†’ protein ( &quot;with&quot; breakfast &quot;on the side&quot; )?
          | bread ;

protein   â†’ &quot;really&quot;+ &quot;crispy&quot; &quot;bacon&quot;
          | &quot;sausage&quot;
          | ( &quot;scrambled&quot; | &quot;poached&quot; | &quot;fried&quot; ) &quot;eggs&quot; ;

bread     â†’ &quot;toast&quot; | &quot;biscuits&quot; | &quot;English muffin&quot; ;
</code></pre>
<p>Not too bad, I hope. If youâ€™re used to grep or using regular expressions in your text editor, most of the punctuation should be familiar. The main difference is that symbols here represent entire tokens, not single characters.</p>
<p>Weâ€™ll use this notation throughout the rest of the book to precisely describe Loxâ€™s grammar. As you work on programming languages, youâ€™ll find that context-free grammars (using this or EBNF or some other notation) help you crystallize your informal syntax design ideas. They are also a handy medium for communicating with other language hackers about syntax.</p>
<p>The rules and productions we define for Lox are also our guide to the tree data structure weâ€™re going to implement to represent code in memory. Before we can do that, we need an actual grammar for Lox, or at least enough of one for us to get started.</p>
<p>æˆ‘å¸Œæœ›æˆ‘ä»¬çš„è¯­æ³•ç³–ä¸ä¼šå¤ªç³Ÿç³•ï¼Œå¦‚æœä½ ä¹‹å‰ä½¿ç”¨è¿‡ grep å‘½ä»¤æˆ–è€…<a href="https://en.wikipedia.org/wiki/Regular_expression#Standards">æ­£åˆ™è¡¨è¾¾å¼</a>, é‚£ä¹ˆå…¶ä¸­å¤§éƒ¨åˆ†ç¬¦å·æ˜¯ç›¸åŒçš„å«ä¹‰ã€‚ä¸»è¦åŒºåˆ«æ˜¯ï¼Œè¿™é‡Œçš„ç¬¦å·å¯¹è±¡æ˜¯æ•´ä¸ªtokenï¼Œè€Œä¸æ˜¯å•ä¸ªå­—ç¬¦</p>
<p>åœ¨æœ¬ä¹¦æ¥ä¸‹æ¥éƒ¨åˆ†ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨è¿™ç§è¯­æ³•ï¼Œæè¿°æˆ‘ä»¬çš„loxè¯­è¨€ã€‚å½“æˆ‘ä»¬ä½¿ç”¨ç¼–ç¨‹è¯­è¨€æ—¶å€™ï¼Œä¼šå‘ç°ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ï¼ˆé€šå¸¸å…·æœ‰BNFï¼Œ<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a>èŒƒå¼ï¼‰, æœ‰åŠ©äºæˆ‘ä»¬å…·ä½“åŒ–è¯­æ³•è®¾è®¡æ€æƒ³ã€‚å®ƒä»¬ä¹Ÿæ˜¯æˆ‘ä»¬åŒç¼–ç¨‹é«˜æ‰‹äº¤æµè¯­æ³•çš„ä¾¿æ·åª’ä»‹ã€‚</p>
<p>æˆ‘ä»¬å®šä¹‰çš„loxè¯­è¨€è¯­æ³•å’Œäº§å“ï¼Œæ˜¯æˆ‘ä»¬å°†è¦å®ç°çš„è¯­æ³•æ ‘ç»“æ„çš„æŒ‡å—ï¼Œè¡¨ç¤ºå†…å­˜ä¸­çš„ä»£ç ã€‚åœ¨æˆ‘ä»¬å¯ä»¥è¿™æ ·åšä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªå®é™…çš„loxè¯­è¨€è¯­æ³•ï¼Œæˆ–è€…è‡³å°‘æœ‰ä¸€äº›è¯­æ³•å¼€å§‹æˆ‘ä»¬çš„è§£æã€‚</p>
<h3 id="13-a-grammar-for-lox-expressions"><a class="header" href="#13-a-grammar-for-lox-expressions">1.3 A Grammar for Lox expressions</a></h3>
<p>loxè¯­è¨€è¡¨è¾¾å¼è¯­æ³•</p>
<p>In the previous chapter, we did Loxâ€™s entire lexical grammar in one fell swoop. Every keyword and bit of punctuation is there. The syntactic grammar is larger, and it would be a real bore to grind through the entire thing before we actually get our interpreter up and running.</p>
<p>Instead, weâ€™ll crank through a subset of the language in the next couple of chapters. Once we have that mini-language represented, parsed, and interpreted, then later chapters will progressively add new features to it, including the new syntax. For now, we are going to worry about only a handful of expressions:</p>
<ul>
<li>
<p>Literals. Numbers, strings, Booleans, and nil.</p>
</li>
<li>
<p>Unary expressions. A prefix ! to perform a logical not, and - to negate a number.</p>
</li>
<li>
<p>Binary expressions. The infix arithmetic (+, -, *, /) and logic operators (==, !=, &lt;, &lt;=, &gt;, &gt;=) we know and love.</p>
</li>
<li>
<p>Parentheses. A pair of ( and ) wrapped around an expression.</p>
</li>
</ul>
<p>That gives us enough syntax for expressions like:</p>
<pre><code class="language-C">
1 - (2 * 3) &lt; 4 == false

</code></pre>
<p>ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬ä¸€ä¸‹å­å°±å®Œæˆäº†æ•´ä¸ªè¯æ³•è§„åˆ™çš„ä»‹ç»ï¼Œæ¯ä¸ªå…³é”®å­—å’Œæ ‡ç‚¹ç¬¦å·éƒ½åœ¨é‚£é‡Œã€‚ä½†æ˜¯ï¼Œè¯­æ³•è§„åˆ™å†…å®¹æ›´å¤šï¼Œåœ¨æˆ‘ä»¬çœŸæ­£å¯åŠ¨è§£é‡Šå™¨å¹¶ä¸”è¿è¡Œä¹‹å‰ï¼Œå¯¹äºæ•´ä¸ªè§„åˆ™çš„ä»‹ç»ï¼Œå°†æ˜¯ä¸€ä¸ªçœŸæ­£çš„éº»çƒ¦ã€‚</p>
<p>ç›¸åï¼Œæˆ‘ä»¬å°†åœ¨æ¥ä¸‹æ¥çš„å‡ ç« ä¸­ï¼Œå¿«é€Ÿæµè§ˆloxè¯­è¨€çš„ä¸€ä¸ªå­é›†ã€‚ä¸€æ—¦æˆ‘ä»¬æœ‰äº†ä»£ç è¡¨ç¤ºã€è§£æã€ç¼–è¯‘çš„è¿·ä½ è¯­è¨€ï¼Œéšåçš„ç« èŠ‚ï¼Œå°†æ·»åŠ æ–°çš„åŠŸèƒ½ä¸è¯­æ³•ã€‚è®©æˆ‘ä»¬å…ˆä»å‡ ä¸ªè¡¨è¾¾å¼å…¥é—¨ï¼š</p>
<ul>
<li>
<p>æ–‡å­—ï¼Œæ•°å€¼ã€å­—ç¬¦ä¸²ã€å¸ƒå°”ç±»å‹å’Œnil</p>
</li>
<li>
<p>ä¸€å…ƒè¡¨è¾¾å¼ï¼Œå‰ç¼€! è¡¨ç¤ºé€»è¾‘éï¼Œ å‰ç¼€-è¡¨ç¤ºè´Ÿæ•°</p>
</li>
<li>
<p>äºŒå…ƒè¡¨è¾¾å¼ï¼Œä¸­ç¼€è¿ç®—ç¬¦ + - * / å’Œ é€»è¾‘è¿ç®—ç¬¦ == != &lt; &lt;= &gt; &gt;=</p>
</li>
<li>
<p>åœ†æ‹¬å·ï¼ŒåŒ…å«ä¸€ä¸ªè¡¨è¾¾å¼</p>
</li>
</ul>
<p>ä¸‹é¢çš„è¡¨è¾¾å¼ï¼ŒåŒ…å«ä¸Šé¢çš„è¯­æ³•è§„åˆ™</p>
<pre><code class="language-C">
1 - (2 * 3) &lt; 4 == false

</code></pre>
<p>Using our handy dandy new notation, hereâ€™s a grammar for those:</p>
<p>Thereâ€™s one bit of extra metasyntax here. In addition to quoted strings for terminals that match exact lexemes, we CAPITALIZE terminals that are a single lexeme whose text representation may vary. NUMBER is any number literal, and STRING is any string literal. Later, weâ€™ll do the same for IDENTIFIER.</p>
<p>This grammar is actually ambiguous, which weâ€™ll see when we get to parsing it. But itâ€™s good enough for now.</p>
<p>ä½¿ç”¨æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„è¯­æ³•ç³–ï¼Œè¿™ä¸ªè¯­æ³•å¯ä»¥å†™æˆï¼š</p>
<pre><code>expression     â†’ literal
               | unary
               | binary
               | grouping ;

literal        â†’ NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot; ;
grouping       â†’ &quot;(&quot; expression &quot;)&quot; ;
unary          â†’ ( &quot;-&quot; | &quot;!&quot; ) expression ;
binary         â†’ expression operator expression ;
operator       â†’ &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;
               | &quot;+&quot;  | &quot;-&quot;  | &quot;*&quot; | &quot;/&quot; ;
			   
</code></pre>
<p>ä¸Šé¢è¿˜æœ‰ä¸€äº›é¢å¤–çš„è¯´æ˜ï¼Œé™¤äº†åŒ¹é…å‡†ç¡®çš„è¯ç´ ï¼Œæˆ‘ä»¬å½“ä½œç»ˆæ­¢ç¬¦ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜æŠŠå¤§å†™çš„å­—ç¬¦ä¸²å½“ä½œç»ˆæ­¢ç¬¦ã€‚NUMBERè¡¨ç¤ºä»»ä½•çš„æ•°å­—ï¼ŒSTRINGè¡¨ç¤ºä»»ä½•çš„å­—ç¬¦ä¸²ã€‚ç¨åï¼Œæˆ‘ä»¬è¿˜å°†ä»‹ç» IDENTIFIER</p>
<p>è¿™ä¸ªè¯­æ³•è§„åˆ™å®é™…ä¸Šä¸å¤Ÿæ˜ç¡®ï¼Œä½†æ˜¯æˆ‘ä»¬å°†åœ¨é‡åˆ°å®ƒä»¬æ—¶å€™ï¼Œåœ¨æ¢è®¨ï¼Œç°åœ¨æˆ‘ä»¬å°†ç»§ç»­ä¸‹é¢ä»‹ç»ã€‚</p>
<blockquote>
<p>If youâ€™re so inclined, try using this grammar to generate a few expressions like we did with the breakfast grammar before. Do the resulting expressions look right to you? Can you make it generate anything wrong like 1 + / 3?</p>
<p>å¦‚æœä½ è¿™ä¹ˆæƒ³ï¼Œè¯•ç€ä½¿ç”¨è¿™äº›è¯­æ³•è§„åˆ™ï¼Œç”Ÿæˆä¸€äº›è¡¨è¾¾å¼ï¼Œå°±åƒæˆ‘ä»¬ä¹‹å‰æ—©é¤è¯­æ³•é‚£æ ·ã€‚è¿™äº›ç”Ÿæˆçš„è¡¨è¾¾å¼æ˜¯æ­£ç¡®çš„å—ï¼Ÿå®ƒæ˜¯å¦ä¼šç”Ÿæˆåƒæ˜¯ 1 + / 3 è¿™æ ·çš„é”™è¯¯ï¼Ÿ</p>
</blockquote>
<h2 id="äºŒimplementing-syntax-trees"><a class="header" href="#äºŒimplementing-syntax-trees">äºŒã€Implementing Syntax Trees</a></h2>
<p>å®ç°è¯­æ³•æ ‘</p>
<p>Finally, we get to write some code. That little expression grammar is our skeleton. Since the grammar is recursiveâ€”note how grouping, unary, and binary all refer back to expressionâ€”our data structure will form a tree. Since this structure represents the syntax of our language, itâ€™s called a syntax tree.</p>
<p>Our scanner used a single Token class to represent all kinds of lexemes. To distinguish the different kindsâ€”think the number 123 versus the string &quot;123&quot;â€”we included a simple TokenType enum. Syntax trees are not so homogeneous. Unary expressions have a single operand, binary expressions have two, and literals have none.</p>
<p>We could mush that all together into a single Expression class with an arbitrary list of children. Some compilers do. But I like getting the most out of Javaâ€™s type system. So weâ€™ll define a base class for expressions. Then, for each kind of expressionâ€”each production under expressionâ€”we create a subclass that has fields for the nonterminals specific to that rule. This way, we get a compile error if we, say, try to access the second operand of a unary expression.</p>
<p>æœ€åï¼Œæˆ‘ä»¬å°†ç¼–å†™ä»£ç å®ç°è¯­æ³•è§„åˆ™ã€‚ä¸Šé¢çš„è¡¨è¾¾å¼è¯­æ³•ï¼Œæ˜¯æˆ‘ä»¬è¦å®ç°çš„éª¨æ¶ã€‚ç”±äºè¯­æ³•æ˜¯é€’å½’çš„ï¼Œéœ€è¦æ³¨æ„åˆ†ç»„ã€ä¸€å…ƒã€äºŒå…ƒå¯¹äºè¡¨è¾¾å¼æ˜¯å¦‚ä½•å®ç°çš„ï¼Œæˆ‘ä»¬çš„æ•°æ®ç»“æ„å°†å½¢æˆä¸€æ£µæ ‘ï¼Œå› ä¸ºè¿™æ˜¯å¯¹è¯­æ³•çš„æè¿°ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºè¯­æ³•æ ‘ã€‚</p>
<p>æˆ‘ä»¬çš„æ‰«æå™¨ï¼Œä½¿ç”¨å•ä¸ªtokenç±»å‹ï¼Œè¡¨ç¤ºæ‰€æœ‰ç±»å‹çš„è¯ç´ ã€‚ä¸ºäº†åŒºåˆ†ä¸åŒçš„ç±»å‹ï¼Œä¾‹å¦‚ï¼šæ•°å­—123 å’Œ å­—ç¬¦ä¸²&quot;123&quot;, æˆ‘ä»¬tokenç±»å‹ï¼ŒåŒ…å«æœ‰ä¸€ä¸ªTokenTypeå±æ€§ã€‚è¯­æ³•æ ‘ä¸æ˜¯é‚£ä¹ˆåŒè´¨åŒ–ï¼Œä¸€å…ƒè¡¨è¾¾å¼æœ‰ä¸€ä¸ªæ“ä½œæ•°ï¼ŒäºŒå…ƒè¡¨è¾¾å¼æœ‰ä¸¤ä¸ªæ“ä½œæ•°ï¼Œæ–‡å­—æ²¡æœ‰æ“ä½œæ•°ã€‚</p>
<p>æˆ‘ä»¬å¯ä»¥å°†è¿™äº›éƒ½ç»„åˆä¸ºä¸€ä¸ªè¡¨è¾¾å¼ç±»ä¸­ï¼Œå…¶ä¸­åŒ…å«ä»»æ„çš„å­ç±»åˆ—è¡¨ã€‚æœ‰äº›ç¼–è¯‘å™¨æ˜¯è¿™æ ·åšçš„ï¼Œä½†æ˜¯æˆ‘å–œæ¬¢å……åˆ†åˆ©ç”¨Javaç±»å‹ç³»ç»Ÿçš„åˆ†ç±»ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†é¦–å…ˆå®šä¹‰è¡¨è¾¾å¼åŸºç±»ã€‚ç„¶åï¼Œå¯¹äºæ¯ç§ç±»å‹çš„è¡¨è¾¾å¼ï¼Œå’Œè¡¨è¾¾å¼ä¸‹çš„æ¯ä¸€ä¸ªå­ç±»ï¼Œæˆ‘ä»¬éƒ½åˆ›å»ºä¸€ä¸ªå­ç±»ã€‚è¿™ä¸ªå­ç±»å…·æœ‰ç‰¹å®šè¯¥è§„åˆ™çš„éç»ˆç«¯ç¬¦ã€‚é€šè¿‡è¿™æ ·åšï¼Œå¦‚æœæˆ‘ä»¬å°è¯•è®¿é—®ä¸€å…ƒè¡¨è¾¾å¼ç±»ä¸­çš„ç¬¬äºŒä¸ªæ“ä½œæ•°ï¼Œæˆ‘ä»¬å°†æ¥æ”¶åˆ°ç¼–è¯‘æŠ¥é”™ã€‚</p>
<p>Something like this:</p>
<pre><code class="language-java">
package com.craftinginterpreters.lox;

abstract class Expr { 
  static class Binary extends Expr {
    Binary(Expr left, Token operator, Expr right) {
      this.left = left;
      this.operator = operator;
      this.right = right;
    }

    final Expr left;
    final Token operator;
    final Expr right;
  }

  // Other expressions...
}

</code></pre>
<blockquote>
<p>In particular, weâ€™re defining an abstract syntax tree (AST). In a parse tree, every single grammar production becomes a node in the tree. An AST elides productions that arenâ€™t needed by later phases.</p>
<p>ç‰¹åˆ«çš„ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ä¸ªæŠ½è±¡è¯­æ³•æ ‘ï¼Œåœ¨è§£ææ ‘ä¸­ï¼Œæ¯ä¸ªè¯­æ³•ç”Ÿæˆéƒ½æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼ŒASTæ ‘çœç•¥äº†åé¢é˜¶æ®µä¸éœ€è¦çš„éƒ¨åˆ†ã€‚</p>
</blockquote>
<blockquote>
<p>Tokens arenâ€™t entirely homogeneous either. Tokens for literals store the value, but other kinds of lexemes donâ€™t need that state. I have seen scanners that use different classes for literals and other kinds of lexemes, but I figured Iâ€™d keep things simpler.</p>
<p>token ä¹Ÿä¸æ˜¯å®Œå…¨ç›¸åŒçš„ï¼Œæ–‡å­—çš„tokenï¼Œä¼šä¿å­˜æ–‡å­—çš„å€¼ï¼Œå…¶ä»–ç±»å‹çš„tokenå¯èƒ½ä¸éœ€è¦è¿™ä¸ªä¿¡æ¯ã€‚æˆ‘è§è¿‡æ‰«æå™¨å¯¹æ–‡å­—å’Œå…¶ä»–ç±»å‹çš„è¯æ±‡ï¼Œä½¿ç”¨ä¸åŒçš„ç±»ï¼Œä½†æ˜¯æˆ‘å°†è®©äº‹æƒ…æ›´åŠ ç®€å•ã€‚</p>
</blockquote>
<blockquote>
<p>I avoid abbreviations in my code because they trip up a reader who doesnâ€™t know what they stand for. But in compilers Iâ€™ve looked at, â€œExprâ€ and â€œStmtâ€ are so ubiquitous that I may as well start getting you used to them now.</p>
<p>æˆ‘åœ¨ä»£ç ä¸­å°†å°½é‡ä¸ä½¿ç”¨ç¼©å†™ï¼Œå› ä¸ºï¼Œç¼©å†™ä¼šè®©ä¸æ˜ç™½å«ä¹‰çš„è¯»è€…æ„Ÿåˆ°å›°æƒ‘ã€‚ä½†æ˜¯ï¼Œæˆ‘è§è¿‡çš„ç¼–è¯‘å™¨ä¸­ï¼Œä½¿ç”¨ Expr å’Œ Stmt æ˜¯å¦‚æ­¤çš„æ™®éï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä»ç°åœ¨å¼€å§‹ä¹ æƒ¯ä½¿ç”¨å®ƒä»¬ã€‚</p>
</blockquote>
<p>Expr is the base class that all expression classes inherit from. As you can see from Binary, the subclasses are nested inside of it. Thereâ€™s no technical need for this, but it lets us cram all of the classes into a single Java file.</p>
<p>å®ç°ä»£ç å¦‚ä¸Šï¼ŒExpræ˜¯æ‰€æœ‰è¡¨è¾¾å¼å¯ä»¥ç»§æ‰¿çš„åŸºç±»ã€‚æ­£å¦‚æˆ‘ä»¬çœ‹åˆ°çš„Binary å­ç±»åµŒå¥—åœ¨Exprä¸­ã€‚è¿™åœ¨æŠ€æœ¯ä¸Šæ²¡æœ‰å¿…è¦ï¼Œä½†æ˜¯å¦‚æ­¤åšï¼Œæˆ‘ä»¬å¯ä»¥å°†æ‰€æœ‰ç±»å¡åˆ°ä¸€ä¸ªjavaæºæ–‡ä»¶ä¸­ã€‚</p>
<h3 id="21-disoriented-objects"><a class="header" href="#21-disoriented-objects">2.1 Disoriented objects</a></h3>
<p>é¢å‘å¯¹è±¡çš„å›°æƒ‘</p>
<p>Youâ€™ll note that, much like the Token class, there arenâ€™t any methods here. Itâ€™s a dumb structure. Nicely typed, but merely a bag of data. This feels strange in an object-oriented language like Java. Shouldnâ€™t the class do stuff?</p>
<p>The problem is that these tree classes arenâ€™t owned by any single domain. Should they have methods for parsing since thatâ€™s where the trees are created? Or interpreting since thatâ€™s where they are consumed? Trees span the border between those territories, which means they are really owned by neither.</p>
<p>In fact, these types exist to enable the parser and interpreter to communicate. That lends itself to types that are simply data with no associated behavior. This style is very natural in functional languages like Lisp and ML where all data is separate from behavior, but it feels odd in Java.</p>
<p>Functional programming aficionados right now are jumping up to exclaim â€œSee! Object-oriented languages are a bad fit for an interpreter!â€ I wonâ€™t go that far. Youâ€™ll recall that the scanner itself was admirably suited to object-orientation. It had all of the mutable state to keep track of where it was in the source code, a well-defined set of public methods, and a handful of private helpers.</p>
<p>My feeling is that each phase or part of the interpreter works fine in an object-oriented style. It is the data structures that flow between them that are stripped of behavior.</p>
<p>æˆ‘ä»¬æ³¨æ„åˆ°ï¼Œå’ŒTokenç±»ä¸€æ ·ï¼ŒExprä¸­æ²¡æœ‰ç±»æ–¹æ³•ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸å¥½çš„ç»“æ„ï¼Œåªæœ‰ä¸€å †æ•°æ®ï¼Œåœ¨Javaè¿™æ ·çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬è¿˜æœ‰è¡¥å……ä¸€äº›ä¸œè¥¿ã€‚</p>
<p>é—®é¢˜æ˜¯ï¼Œè¿™äº›è¯­æ³•æ ‘ç±»ä¸å±äºå•ä¸ªåŸŸã€‚å®ƒä»¬æ˜¯å¦åº”è¯¥æœ‰å¯¹åº”çš„è§£ææ–¹æ³•ï¼Œå½“è¯­æ³•æ ‘è¢«åˆ›å»ºå‡ºæ¥ï¼Œæˆ–è€…æ˜¯å¦åº”è¯¥æœ‰ç¼–è¯‘æ–¹æ³•ï¼Œå½“å®ƒä»¬è¢«ç¼–è¯‘æ—¶å€™ã€‚è¿™äº›è¯­æ³•æ ‘ï¼Œæ¨ªè·¨è¿™äº›è¾¹ç•Œï¼Œè¿™æ„å‘³ç€å®ƒä»¬ä¸å±äºä»»ä½•ä¸€æ–¹ã€‚</p>
<p>å®é™…ä¸Šï¼Œè¿™äº›ç±»å‹çš„å­˜åœ¨æ˜¯ä¸ºäº†è®©è§£æå™¨å’Œè§£é‡Šå™¨å¯ä»¥é€šä¿¡ã€‚è¿™æ ·çš„éœ€æ±‚ï¼Œä½¿å¾—è¿™äº›ç±»åªæœ‰ç®€å•çš„æ•°æ®ç±»å‹ï¼Œè€Œæ²¡æœ‰å…³è”è¡Œä¸ºã€‚è¿™ç§é£æ ¼åœ¨Lispï¼ŒMLè¿™äº›å‡½æ•°è¯­è¨€ä¸­ï¼Œéå¸¸è‡ªç„¶ï¼Œä½†æ˜¯ï¼Œæ‰€æœ‰æ•°æ®ä¸è¡Œä¸ºåˆ†ç¦»ï¼Œåœ¨Javaä¸­éå¸¸å¥‡æ€ªã€‚</p>
<p>æ­¤æ—¶ï¼Œå‡½æ•°å¼ç¼–ç¨‹æ‹¥æŠ¤è€…è·³èµ·æ¥å¤§å–Šï¼šçœ‹ï¼Œé¢å‘å¯¹è±¡çš„è¯­è¨€ä¸é€‚åˆç¼–å†™è§£é‡Šå™¨ã€‚æˆ‘ä¸ä¼šèµ°é‚£ä¹ˆè¿œï¼Œä½ åº”è¯¥è®°å¾—ï¼Œé¢å‘å¯¹è±¡è¯­è¨€éå¸¸é€‚åˆç¼–å†™æ‰«æå™¨ã€‚å®ƒæ‹¥æœ‰å¯å˜çŠ¶æ€æ¥è·Ÿè¸ªæºç ä½ç½®ï¼Œä¸€ç»„å®šä¹‰è‰¯å¥½çš„å…¬å…±æ–¹æ³•ï¼Œå’Œä¸€äº›helperå‡½æ•°ã€‚</p>
<p>æˆ‘çš„æ„Ÿè§‰æ˜¯ï¼Œè§£é‡Šå™¨çš„æ¯ä¸€ä¸ªé˜¶æ®µæˆ–è€…æ¯ä¸€ä¸ªéƒ¨åˆ†ï¼Œéƒ½ä»¥é¢å‘å¯¹è±¡çš„æ–¹å¼è¿è¡Œçš„éå¸¸å¥½ã€‚å®ƒä»¬ç›´æ¥çš„æ•°æ®ç»“æ„çš„é€šä¿¡ï¼Œä½¿å¾—ä¸éœ€è¦è¡Œä¸ºã€‚</p>
<h3 id="22-metaprogramming-the-trees"><a class="header" href="#22-metaprogramming-the-trees">2.2 Metaprogramming the trees</a></h3>
<p>è¯­æ³•æ ‘ä¸­çš„å…ƒç¼–ç¨‹</p>
<p>Java can express behavior-less classes, but I wouldnâ€™t say that itâ€™s particularly great at it. Eleven lines of code to stuff three fields in an object is pretty tedious, and when weâ€™re all done, weâ€™re going to have 21 of these classes.</p>
<p>I donâ€™t want to waste your time or my ink writing all that down. Really, what is the essence of each subclass? A name, and a list of typed fields. Thatâ€™s it. Weâ€™re smart language hackers, right? Letâ€™s automate.</p>
<p>Javaå¯ä»¥å®šä¹‰ä¸€ä¸ªæ²¡æœ‰æ–¹æ³•çš„ç±»ï¼Œä½†æ˜¯æˆ‘æƒ³è¯´Javaä¸å¤ªæ“…é•¿å¤„ç†è¿™ç§ç±»ã€‚åœ¨ä¸€ä¸ªå¯¹è±¡ä¸­ï¼Œä½¿ç”¨11è¡Œä»£ç ï¼Œå¡«å……3ä¸ªå­—æ®µï¼Œç›¸å½“ä¹å‘³ï¼Œå½“æˆ‘ä»¬å…¨éƒ¨å®Œæˆåï¼Œå°†å‘ç°è¿™æ ·çš„ç±»æœ‰21ä¸ª</p>
<p>æˆ‘ä¸æƒ³æµªè´¹ä½ çš„æ—¶é—´ï¼Œæˆ–è€…æˆ‘çš„å¢¨æ°´å°†è¿™äº›ç±»åˆ—ä¸¾å‡ºæ¥ã€‚çœŸçš„ï¼Œæ¯ä¸€ä¸ªç±»çš„æœ¬è´¨æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿç±»åç§°ï¼Œç±»ä¸­çš„ç±»å‹å­—æ®µåˆ—è¡¨ã€‚å°±è¿™æ ·ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è‡ªåŠ¨åŒ–åˆ›å»ºäº†</p>
<blockquote>
<p>Picture me doing an awkward robot dance when you read that. â€œAU-TO-MATE.â€</p>
<p>å½“ä½ è¯»åˆ°è¿™ç¯‡æ–‡ç« æ—¶å€™ï¼Œæƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘åœ¨è·³èˆï¼Œè·³ä¸€ä¸ªç¬¨æ‹™çš„æœºå™¨äººèˆã€‚</p>
</blockquote>
<p>Instead of tediously handwriting each class definition, field declaration, constructor, and initializer, weâ€™ll hack together a script that does it for us. It has a description of each tree typeâ€”its name and fieldsâ€”and it prints out the Java code needed to define a class with that name and state.</p>
<p>æˆ‘ä»¬å°†ç¼–å†™ä¸€ä¸ªè„šæœ¬ï¼Œç”Ÿæˆç±»ï¼Œè€Œä¸æ˜¯ï¼Œç¹ççš„ç¼–å†™æ¯ä¸€ä¸ªç±»å®šä¹‰ï¼Œå­—æ®µå£°æ˜ï¼Œæ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–å˜é‡ã€‚å®ƒå°†æè¿°æ¯ä¸€ä¸ªå®šä¹‰çš„è¯­æ³•æ ‘ç±»å‹ï¼ŒåŒ…å«ç±»åç§°å’Œç±»å­—æ®µåˆ—è¡¨ï¼Œæ‰“å°å‡ºç±»åç§°å’Œç›¸åº”çš„Javaå®šä¹‰ä»£ç </p>
<p>This script is a tiny Java command-line app that generates a file named â€œExpr.javaâ€:</p>
<p>è¿™ä¸ªè„šæœ¬æ˜¯ä¸€ä¸ªç®€å•çš„javaä»£ç ï¼Œç”Ÿæˆä¸€ä¸ªExpr.java æ–‡ä»¶</p>
<pre><code class="language-java">
// tool/GenerateAst.java, create new file

package com.craftinginterpreters.tool;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.List;

public class GenerateAst {
  public static void main(String[] args) throws IOException {
    if (args.length != 1) {
      System.err.println(&quot;Usage: generate_ast &lt;output directory&gt;&quot;);
      System.exit(64);
    }
    String outputDir = args[0];
  }
}

</code></pre>
<blockquote>
<p>I got the idea of scripting the syntax tree classes from Jim Hugunin, creator of Jython and IronPython.</p>
<p>An actual scripting language would be a better fit for this than Java, but Iâ€™m trying not to throw too many languages at you.</p>
<p>æˆ‘ä»Jython å’Œ IronPythonçš„å‘æ˜è€… Jim Huguniné‚£é‡Œè·å–åˆ°çµæ„Ÿï¼Œæœ‰å…³ç¼–å†™è¯­æ³•æ ‘ç±»è„šæœ¬çš„æƒ³æ³•ã€‚</p>
<p>å®é™…ä¸Šä¸€é—¨çœŸçš„è„šæœ¬è¯­è¨€æ›´åŠ é€‚åˆåšè¿™ä»¶äº‹ï¼Œä½†æ˜¯ï¼Œæˆ‘ä¸æƒ³ä¸€ä¸‹å­æŠ›å‡ºè¿™ä¹ˆå¤šçš„è¯­è¨€ã€‚</p>
</blockquote>
<p>Note that this file is in a different package, .tool instead of .lox. This script isnâ€™t part of the interpreter itself. Itâ€™s a tool we, the people hacking on the interpreter, run ourselves to generate the syntax tree classes. When itâ€™s done, we treat â€œExpr.javaâ€ like any other file in the implementation. We are merely automating how that file gets authored.</p>
<p>è¦æ³¨æ„ï¼Œè¿™ä¸ªæ–°çš„æ–‡ä»¶ä½äºæ–°çš„åŒ… toolï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„loxä¸­ã€‚è¿™ä¸ªè„šæœ¬ä¸å±äºè§£é‡Šå™¨çš„ä¸€éƒ¨åˆ†, å®ƒåªæ˜¯ä¸€ä¸ªå·¥å…·ï¼Œç¼–ç¨‹é«˜æ‰‹ç”¨å®ƒæ¥ï¼Œè‡ªåŠ¨ç”Ÿæˆè¯­æ³•æ ‘ã€‚è¯¥è„šæœ¬å°†ç”Ÿæˆä¸€ä¸ª Expr.javaæ–‡ä»¶</p>
<p>To generate the classes, it needs to have some description of each type and its fields.</p>
<p>For brevityâ€™s sake, I jammed the descriptions of the expression types into strings. Each is the name of the class followed by : and the list of fields, separated by commas. Each field has a type and a name.</p>
<p>The first thing defineAst() needs to do is output the base Expr class.</p>
<p>ä¸ºäº†ç”Ÿæˆä¸€ä¸ªç±»ï¼Œå¯¹äºæ¯ä¸ªç±»çš„ç±»å‹å’Œå­—æ®µï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€äº›æè¿°</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main()

    String outputDir = args[0];
    defineAst(outputDir, &quot;Expr&quot;, Arrays.asList(
      &quot;Binary   : Expr left, Token operator, Expr right&quot;,
      &quot;Grouping : Expr expression&quot;,
      &quot;Literal  : Object value&quot;,
      &quot;Unary    : Token operator, Expr right&quot;
    ));
  }


</code></pre>
<p>ä¸ºäº†ç®€æ´ï¼Œæˆ‘ä»¬æŠŠè¡¨è¾¾å¼ç±»å‹çš„æè¿°å†™å…¥åˆ°å­—ç¬¦ä¸²ä¸­ï¼Œæ¯ä¸ªç±»ä¸­ï¼Œåé¢è·Ÿä¸Šä¸€ä¸ª: ç¬¦å·å’Œä¸€äº›ç±»å­—æ®µï¼Œå­—æ®µä¸­é—´ä½¿ç”¨é€—å·åˆ†éš”ã€‚æ¯ä¸ªå­—æ®µéƒ½æœ‰ä¸€ä¸ªç±»å‹ å’Œ åç§°ã€‚</p>
<p>defineAst() éœ€è¦è¾“å‡ºExprç±»</p>
<pre><code class="language-java">
// tool/GenerateAst.java add after main()

  private static void defineAst(
      String outputDir, String baseName, List&lt;String&gt; types)
      throws IOException {
    String path = outputDir + &quot;/&quot; + baseName + &quot;.java&quot;;
    PrintWriter writer = new PrintWriter(path, &quot;UTF-8&quot;);

    writer.println(&quot;package com.craftinginterpreters.lox;&quot;);
    writer.println();
    writer.println(&quot;import java.util.List;&quot;);
    writer.println();
    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

    writer.println(&quot;}&quot;);
    writer.close();
  }
  
</code></pre>
<p>When we call this, baseName is â€œExprâ€, which is both the name of the class and the name of the file it outputs. We pass this as an argument instead of hardcoding the name because weâ€™ll add a separate family of classes later for statements.</p>
<p>å½“æˆ‘ä»¬è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼ŒbaseName æ˜¯ Expr, å®ƒå³æ˜¯ç±»çš„åç§°ï¼Œä¹Ÿæ˜¯è¾“å‡ºçš„æ–‡ä»¶çš„åç§°ã€‚æˆ‘ä»¬å°†exprå½“ä½œä¸€ä¸ªå‚æ•°ï¼Œè€Œä¸æ˜¯ç¡¬ç¼–ç ï¼Œå› ä¸ºç¨åï¼Œæˆ‘ä»¬å°†æ·»åŠ ä¸€ä¸ªç±»å®¶æ—ã€‚</p>
<p>Inside the base class, we define each subclass.</p>
<p>åœ¨åŸºç±»ä¸­ï¼Œæˆ‘ä»¬å°†å®šä¹‰æ¯ä¸€ä¸ªå­ç±»</p>
<pre><code class="language-java">
// tool/GenerateAst.java in defineAst()

 writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

    // The AST classes.
    for (String type : types) {
      String className = type.split(&quot;:&quot;)[0].trim();
      String fields = type.split(&quot;:&quot;)[1].trim(); 
      defineType(writer, baseName, className, fields);
    }
    writer.println(&quot;}&quot;);
	
</code></pre>
<pre><code class="language-java">
// tool/GenerateAst.java add after defineAst()

  private static void defineType(
      PrintWriter writer, String baseName,
      String className, String fieldList) {
    writer.println(&quot;  static class &quot; + className + &quot; extends &quot; +
        baseName + &quot; {&quot;);

    // Constructor.
    writer.println(&quot;    &quot; + className + &quot;(&quot; + fieldList + &quot;) {&quot;);

    // Store parameters in fields.
    String[] fields = fieldList.split(&quot;, &quot;);
    for (String field : fields) {
      String name = field.split(&quot; &quot;)[1];
      writer.println(&quot;      this.&quot; + name + &quot; = &quot; + name + &quot;;&quot;);
    }

    writer.println(&quot;    }&quot;);

    // Fields.
    writer.println();
    for (String field : fields) {
      writer.println(&quot;    final &quot; + field + &quot;;&quot;);
    }

    writer.println(&quot;  }&quot;);
  }
  
</code></pre>
<p>There we go. All of that glorious Java boilerplate is done. It declares each field in the class body. It defines a constructor for the class with parameters for each field and initializes them in the body.</p>
<p>Compile and run this Java program now and it blasts out a new â€œ.javaâ€ file containing a few dozen lines of code. That fileâ€™s about to get even longer.</p>
<p>æˆ‘ä»¬å·²ç»å¼€å§‹æ„é€ äº†ï¼Œæ‰€æœ‰javaç±»å·²ç»å®Œæˆäº†ï¼Œå®ƒå£°æ˜äº†ç±»ä¸­çš„æ¯ä¸€ä¸ªå­—æ®µï¼Œå®ƒä¸ºç±»å®šä¹‰äº†ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œæ„é€ å‡½æ•°ä¸­åŒ…å«æœ‰æ¯ä¸ªå­—æ®µï¼Œå¹¶ä¸”åœ¨å‡½æ•°ä¸­è¿›è¡Œå­—æ®µåˆå§‹åŒ–ã€‚</p>
<p>ç¼–è¯‘è¿è¡Œè¿™ä¸ªç¨‹åºï¼Œå°†ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„javaæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«å‡ åè¡Œä»£ç ï¼Œjavaæ–‡ä»¶å°†ä¼šå˜å¾—æ›´é•¿ã€‚</p>
<blockquote>
<p>This isnâ€™t the worldâ€™s most elegant string manipulation code, but thatâ€™s fine. It only runs on the exact set of class definitions we give it. Robustness ainâ€™t a priority.</p>
<p>è¿™ä¸æ˜¯æœ€ä¼˜é›…çš„å­—ç¬¦ä¸²æ“ä½œä»£ç ï¼Œä½†æ˜¯å®ƒå¯ä»¥åœ¨æˆ‘ä»¬å®šä¹‰çš„ç²¾ç¡®çš„ç±»é›†åˆä¸­ï¼Œç”Ÿæˆæˆ‘ä»¬æƒ³è¦çš„ç±»å®šä¹‰ä»£ç ï¼Œå¥å£®æ€§ä¸æ˜¯é¦–è¦ä»»åŠ¡ã€‚</p>
</blockquote>
<h2 id="ä¸‰working-with-trees"><a class="header" href="#ä¸‰working-with-trees">ä¸‰ã€Working with Trees</a></h2>
<p>ä½¿ç”¨æ ‘</p>
<p>Put on your imagination hat for a moment. Even though we arenâ€™t there yet, consider what the interpreter will do with the syntax trees. Each kind of expression in Lox behaves differently at runtime. That means the interpreter needs to select a different chunk of code to handle each expression type. With tokens, we can simply switch on the TokenType. But we donâ€™t have a â€œtypeâ€ enum for the syntax trees, just a separate Java class for each one.</p>
<p>å¸¦ä¸Šæƒ³è±¡çš„å¸½å­ä¸€ä¼šå„¿ï¼Œå°½ç®¡æˆ‘ä»¬è¿˜æ²¡æœ‰è¾¾åˆ°ï¼Œæƒ³è±¡ä¸€ä¸‹ï¼Œè§£é‡Šå™¨å¦‚ä½•å‡ºæ¥è¯­æ³•æ ‘ã€‚Loxçš„æ¯ä¸€ç§è¡¨è¾¾å¼åœ¨è¿è¡Œæ—¶å€™ï¼Œè¡Œä¸ºéƒ½ä¸ç›¸åŒã€‚è¿™æ„å‘³ç€ï¼Œè§£é‡Šå™¨éœ€è¦é€‰æ‹©ä¸åŒçš„ä»£ç å—ï¼Œæ¥å¤„ç†ä¸åŒç±»å‹çš„è¡¨è¾¾å¼ã€‚ä½¿ç”¨tokenï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡tokenTypeè½¬æ¢ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬æ²¡æœ‰è¯­æ³•æ ‘çš„æšä¸¾ï¼Œåªæ˜¯å¯¹äºæ¯ä¸€ä¸ªè¯­æ³•æ ‘ï¼Œæœ‰ä¸€ä¸ªç‹¬ç«‹çš„javaç±»ã€‚</p>
<p>We could write a long chain of type tests:</p>
<p>æˆ‘ä»¬å¯ä»¥ç¼–å†™ä¸€é•¿ä¸²ç±»å‹æµ‹è¯•</p>
<pre><code class="language-java">
if (expr instanceof Expr.Binary) {
  // ...
} else if (expr instanceof Expr.Grouping) {
  // ...
} else // ...

</code></pre>
<p>But all of those sequential type tests are slow. Expression types whose names are alphabetically later would take longer to execute because theyâ€™d fall through more if cases before finding the right type. Thatâ€™s not my idea of an elegant solution.</p>
<p>We have a family of classes and we need to associate a chunk of behavior with each one. The natural solution in an object-oriented language like Java is to put those behaviors into methods on the classes themselves. We could add an abstract interpret() method on Expr which each subclass would then implement to interpret itself.</p>
<p>ä½†æ˜¯ï¼Œæ‰€æœ‰è¿™äº›é¡ºåºå¼æµ‹è¯•éƒ½å¾ˆæ…¢ï¼Œå¦‚æœæŒ‰ç…§è¡¨è¾¾å¼ç±»å‹åç§°ï¼ŒæŒ‰ç…§å­—æ¯é¡ºåºæ’åºï¼Œç„¶åæ‰§è¡Œï¼Œå¯èƒ½éœ€è¦æ›´å¤šæ—¶é—´ï¼Œå› ä¸ºåœ¨æ‰¾åˆ°åˆé€‚çš„ç±»å‹ä¹‹å‰ï¼Œå¯èƒ½åŒ…å«æ›´å¤šçš„åˆ¤æ–­ï¼Œè¿™ä¸æ˜¯æˆ‘ä»¬è®¤ä¸ºçš„ä¼˜é›…çš„è§£å†³æ–¹å¼ã€‚</p>
<p>æˆ‘ä»¬æœ‰ä¸€ä¸ªç±»å®¶æ—ï¼Œéœ€è¦å°†å…¶ä¸­æ¯ä¸€ä¸ªç±»çš„è¡Œä¸ºéƒ½å…³è”åœ¨ä¸€èµ·ã€‚åœ¨Javaè¿™æ ·çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œå¾ˆè‡ªç„¶çš„è§£å†³æ–¹å¼æ˜¯ï¼Œå°†è¿™äº›ç±»è¡Œä¸ºæ”¾å…¥ç±»æ–¹æ³•ä¸­ã€‚æˆ‘ä»¬å¯ä»¥åœ¨æ¯ä¸ªç±»ä¸­éƒ½æ·»åŠ ä¸€ä¸ªæŠ½è±¡çš„æ–¹æ³•ï¼Œinterpret() , ExpråŸºç±»çš„æ¯ä¸€ä¸ªå­ç±»éƒ½å®ç°è‡ªèº«çš„interpret() æ–¹æ³•ã€‚</p>
<blockquote>
<p>This exact thing is literally called the â€œInterpreter patternâ€ in Design Patterns: Elements of Reusable Object-Oriented Software, by Erich Gamma, et al.</p>
<p>è¿™ä¸ªç¼–ç¨‹æ¨¡å¼è¢«ç§°ä¸º<a href="https://en.wikipedia.org/wiki/Interpreter_pattern">è§£é‡Šå™¨æ¨¡å¼</a>, åœ¨ä¹¦ç±<a href="https://learning.oreilly.com/library/view/design-patterns-elements/0201633612/">ã€Šè®¾è®¡æ¨¡å¼ï¼šå¯å¤ç”¨é¢å‘å¯¹è±¡è½¯ä»¶çš„åŸºç¡€ã€‹</a> ä¸­ </p>
</blockquote>
<p>This works alright for tiny projects, but it scales poorly. Like I noted before, these tree classes span a few domains. At the very least, both the parser and interpreter will mess with them. As youâ€™ll see later, we need to do name resolution on them. If our language was statically typed, weâ€™d have a type checking pass.</p>
<p>If we added instance methods to the expression classes for every one of those operations, that would smush a bunch of different domains together. That violates separation of concerns and leads to hard-to-maintain code.</p>
<p>è¿™æ ·è§£å†³ï¼Œå¯¹äºå°é¡¹ç›®æ¥è¯´å¾ˆå¥½ï¼Œå®ƒä»¬çš„è§„æ¨¡å¾ˆå°ã€‚æ­£å¦‚æˆ‘ä¹‹å‰æåˆ°çš„ï¼Œè¿™äº›è¯­æ³•æ ‘è·¨åŸŸäº†å‡ ä¸ªåŸŸï¼Œè‡³å°‘ï¼Œè§£æå™¨å’Œè§£é‡Šå™¨éƒ½ä¼šä½¿ç”¨åˆ°è¯­æ³•æ ‘ã€‚ç¨åä½ å°†çœ‹åˆ°ï¼Œæˆ‘ä»¬å°†è¿›è¡Œåç§°è§£æã€‚å¦‚æœæˆ‘ä»¬çš„è¯­è¨€æ˜¯é™æ€ç±»å‹çš„ï¼Œæˆ‘ä»¬å°†æœ‰ä¸€ä¸ªç±»å‹æ£€æŸ¥æ­¥éª¤ã€‚</p>
<p>å¦‚æœæˆ‘ä»¬å¯¹äºæ¯ä¸€ä¸ªæ“ä½œï¼Œéƒ½åœ¨è¡¨è¾¾å¼å®ä¾‹ä¸­æ·»åŠ å¯¹åº”çš„æ–¹æ³•ï¼Œé‚£ä¹ˆå°†ä¼šæŠŠä¸€ç³»åˆ—çš„åŸŸï¼Œæ··æ‚åœ¨ä¸€èµ·ã€‚è¿™è¿åäº†<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">å…³æ³¨ç‚¹åˆ†ç¦»</a>, ä¼šè®©åé¢çš„ä»£ç æ›´éš¾ç»´æŠ¤ã€‚</p>
<h3 id="31-the-expression-problem"><a class="header" href="#31-the-expression-problem">3.1 The expression problem</a></h3>
<p>è¡¨è¾¾å¼é—®é¢˜</p>
<p>This problem is more fundamental than it may seem at first. We have a handful of types, and a handful of high-level operations like â€œinterpretâ€. For each pair of type and operation, we need a specific implementation. Picture a table:</p>
<p>è¿™ä¸ªé—®é¢˜ï¼Œæ¯”æœ€åˆçœ‹èµ·æ¥æ›´åŠ æ ¹æœ¬ï¼Œæˆ‘ä»¬æœ‰ä¸€äº›ç±»å‹ï¼Œè¿˜æœ‰ä¸€äº›æ“ä½œï¼Œä¾‹å¦‚: interpret, å¯¹äºæ¯ä¸€ä¸ªç±»å‹å’Œæ“ä½œçš„ç»„åˆï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªç‰¹å®šçš„å®ç°ã€‚è¡¨æ ¼çœ‹èµ·æ¥æ˜¯è¿™æ ·ï¼š</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/table.png?raw=true" alt="table" /></p>
<p>Rows are types, and columns are operations. Each cell represents the unique piece of code to implement that operation on that type.</p>
<p>An object-oriented language like Java assumes that all of the code in one row naturally hangs together. It figures all the things you do with a type are likely related to each other, and the language makes it easy to define them together as methods inside the same class.</p>
<p>This makes it easy to extend the table by adding new rows. Simply define a new class. No existing code has to be touched. But imagine if you want to add a new operationâ€”a new column. In Java, that means cracking open each of those existing classes and adding a method to it.</p>
<p>è¡¨æ ¼ä¸­ï¼Œè¡Œæ˜¯ç±»å‹ï¼Œåˆ—æ˜¯æ“ä½œï¼Œæ¯ä¸ªå•å…ƒæ ¼è¡¨ç¤ºæŸç§ç±»å‹çš„æŸä¸ªæ“ä½œï¼Œå…·ä½“çš„å®ç°ä»£ç ã€‚</p>
<p>åœ¨Javaè¿™æ ·çš„é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œä¼šå°†ä¸€è¡Œä¸­çš„æ‰€æœ‰æ“ä½œï¼Œè‡ªç„¶çš„æ”¾åˆ°ä¸€èµ·ã€‚å®ƒè®¤ä¸ºæˆ‘ä»¬å¯¹äºæ¯ä¸ªç±»å‹çš„æ‰€æœ‰æ“ä½œéƒ½æ˜¯ç›¸äº’å…³è”çš„ã€‚Javaä¸­å¯ä»¥å¾ˆç®€å•çš„å°†è¿™äº›æ–¹æ³•å®šä¹‰åˆ°åŒä¸€ä¸ªç±»ä¸­</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/rows.png?raw=true" alt="rows" /></p>
<p>è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“çš„æ‰©å±•æ–°çš„ä¸€è¡Œï¼Œå³æ·»åŠ ä¸€ä¸ªæ–°ç±»ã€‚æ— éœ€ä¿®æ”¹ç°æœ‰ä»£ç ã€‚ä½†æ˜¯ï¼Œæƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœä½ æ·»åŠ äº†ä¸€ä¸ªæ–°çš„æ“ä½œï¼Œå³æ·»åŠ äº†ä¸€åˆ—ã€‚åœ¨Javaä¸­ï¼Œè¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸ªç±»ä¸­ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„æ–¹æ³•ã€‚</p>
<p>Functional paradigm languages in the ML family flip that around. There, you donâ€™t have classes with methods. Types and functions are totally distinct. To implement an operation for a number of different types, you define a single function. In the body of that function, you use pattern matchingâ€”sort of a type-based switch on steroidsâ€”to implement the operation for each type all in one place.</p>
<p>This makes it trivial to add new operationsâ€”simply define another function that pattern matches on all of the types.</p>
<p><a href="https://craftinginterpreters.com/representing-code.html">MLè¯­è¨€</a>å®¶æ—ä¸­çš„ï¼Œå‡½æ•°èŒƒå‹è¯­è¨€æ­£å¥½ç›¸åï¼Œåœ¨é‚£é‡Œï¼Œä½ æ²¡æœ‰ç±»å’Œç±»æ–¹æ³•çš„æ¦‚å¿µï¼Œç±»å‹å’Œå‡½æ•°å®Œå…¨ä¸ç›¸åŒã€‚ä¸ºäº†å®šä¹‰æŸä¸ªæ“ä½œï¼ˆä¸åŒçš„ç±»å‹ï¼‰ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œåœ¨æ¯ä¸ªå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ç±»å‹åŒ¹é…ï¼Œæ ¹æ®ä¸åŒçš„ç±»å‹ï¼Œå®ç°ä¸åŒçš„å…·ä½“æ“ä½œä»£ç ã€‚</p>
<p>è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“æ·»åŠ ä¸€ä¸ªæ–°çš„æ“ä½œï¼Œåœ¨æ–°æ“ä½œå¯¹åº”çš„å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬æ ¹æ®ä¸åŒç±»å‹ï¼Œå®šä¹‰ä¸åŒçš„å®ç°ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/columns.png?raw=true" alt="columns" /></p>
<p>But, conversely, adding a new type is hard. You have to go back and add a new case to all of the pattern matches in all of the existing functions.</p>
<p>ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦æ·»åŠ ä¸€ä¸ªæ–°çš„ç±»å‹ï¼Œä¼šéå¸¸éº»çƒ¦ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨æ‰€æœ‰çš„å‡½æ•°ä¸­ï¼Œæ·»åŠ ä¸€ä¸ªæ¨¡å¼ï¼ŒåŒ¹é…æ–°çš„ç±»å‹ï¼Œå¹¶ä¸”æ·»åŠ å¯¹åº”çš„ä»£ç ã€‚</p>
<blockquote>
<p>ML, short for â€œmetalanguageâ€ was created by Robin Milner and friends and forms one of the main branches in the great programming language family tree. Its children include SML, Caml, OCaml, Haskell, and F#. Even Scala, Rust, and Swift bear a strong resemblance.</p>
<p>Much like Lisp, it is one of those languages that is so full of good ideas that language designers today are still rediscovering them over forty years later.</p>
<p>ML, æ˜¯å…ƒè¯­è¨€çš„ç¼©å†™ï¼Œæ˜¯ç”±<a href="https://en.wikipedia.org/wiki/Robin_Milner">Robin Milner</a> å’Œä»–çš„æœ‹å‹ä»¬åˆ›å»ºï¼Œæ˜¯ä¼Ÿå¤§çš„ç¼–ç¨‹è¯­è¨€çš„ä¸€ä¸ªé‡è¦åˆ†æ”¯ï¼Œå—åˆ°å®ƒå½±å“çš„è¯­æ³•åŒ…æ‹¬ï¼ŒSML Caml OCaml Haskell F#ç­‰ç­‰ï¼Œå³ä½¿æ˜¯ Scala, Rust å’Œ Swiftä¹Ÿå’Œå®ƒæœ‰å¾ˆå¤šçš„ç›¸ä¼¼æ€§ã€‚</p>
<p>ä¸lispè¯­è¨€ç›¸ä¼¼ï¼ŒMLæ˜¯ä¸€é—¨å……æ»¡äº†æƒ³æ³•çš„è¯­è¨€ï¼Œä»¥è‡´äºè¯­è¨€è®¾è®¡è€…ï¼Œåœ¨40å¹´åçš„ä»Šå¤©ï¼Œä¾ç„¶å¯ä»¥å‘ç°MLä¸­çš„æ–°æƒ³æ³•ã€‚</p>
</blockquote>
<p>Each style has a certain â€œgrainâ€ to it. Thatâ€™s what the paradigm name literally saysâ€”an object-oriented language wants you to orient your code along the rows of types. A functional language instead encourages you to lump each columnâ€™s worth of code together into a function.</p>
<p>A bunch of smart language nerds noticed that neither style made it easy to add both rows and columns to the table. They called this difficulty the â€œexpression problemâ€ becauseâ€”like we are nowâ€”they first ran into it when they were trying to figure out the best way to model expression syntax tree nodes in a compiler.</p>
<p>People have thrown all sorts of language features, design patterns, and programming tricks to try to knock that problem down but no perfect language has finished it off yet. In the meantime, the best we can do is try to pick a language whose orientation matches the natural architectural seams in the program weâ€™re writing.</p>
<p>Object-orientation works fine for many parts of our interpreter, but these tree classes rub against the grain of Java. Fortunately, thereâ€™s a design pattern we can bring to bear on it.</p>
<p>æ¯ä¸€ç§ç¼–ç¨‹æ–¹å¼ï¼Œéƒ½æœ‰è‡ªå·±çš„é£æ ¼ï¼Œè¿™ä¹Ÿä½“ç°åœ¨ç¼–ç¨‹èŒƒå¼åç§°ä¸Šï¼Œé¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€ï¼Œå¸Œæœ›æˆ‘ä»¬æ²¿ç€è¡¨æ ¼ä¸­è¡Œæ–¹å‘ï¼Œå‡½æ•°å¼ç¼–ç¨‹ï¼Œé¼“åŠ±æˆ‘ä»¬æ²¿ç€åˆ—æ–¹å‘ç¼–ç¨‹ã€‚</p>
<p>ä¸€ç¾¤èªæ˜çš„ä¹¦å‘†å­æ³¨æ„åˆ°ï¼Œä¸Šé¢çš„ä¸¤ç§ç¼–ç¨‹é£æ ¼ï¼Œéƒ½æ— æ³•ç®€å•çš„æ·»åŠ ä¸€è¡Œæˆ–è€…ä¸€åˆ—ã€‚ä»–ä»¬å°†è¿™ä¸ªå›°éš¾ï¼Œç§°ä¸ºè¡¨è¾¾å¼é—®é¢˜ï¼Œå› ä¸ºå’Œæˆ‘ä»¬ç°åœ¨ä¸€æ ·ï¼Œä»–ä»¬ä¹Ÿæ˜¯åœ¨è¯•å›¾æ‰¾åˆ°ä¸€ç§æœ€å¥½çš„æ–¹æ³•ï¼Œå¯¹è¡¨è¾¾å¼è¯­æ³•æ ‘è¿›è¡Œå»ºæ¨¡æ—¶å€™ï¼Œé‡åˆ°è¿™ä¸ªé—®é¢˜ã€‚</p>
<p>äººä»¬å·²ç»æŠ›å¼ƒäº†å„ç§è¯­è¨€ç‰¹æ€§ã€è®¾è®¡æ¨¡å¼ã€ç¼–ç¨‹æŠ€å·§ï¼Œè¯•å›¾å»è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯ï¼Œè¿˜æ²¡æœ‰ä¸€ç§è¯­è¨€å¯ä»¥å®Œç¾çš„è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æ‰€ä»¥ï¼Œå½“å‰æˆ‘ä»¬æœ€å¥½çš„æ–¹æ³•æ˜¯ï¼Œé€‰æ‹©ä¸€ç§è¯­è¨€ï¼Œå®ƒçš„ç¼–ç¨‹æ–¹å‘ï¼Œå’Œæˆ‘ä»¬è¦å®ç°çš„è¯­æ³•æ ‘æ›´åŠ å¥‘åˆã€‚</p>
<p>é¢å‘å¯¹è±¡è¯­è¨€ï¼Œå¯¹äºè§£é‡Šå™¨éƒ¨åˆ†ä¸€èˆ¬æ›´åŠ åˆé€‚ï¼Œä½†æ˜¯è¿™äº›è¯­æ³•æ ‘ï¼Œå’ŒJavaçš„ç¼–ç¨‹é£æ ¼æœ‰å†²çªï¼Œå¹¸è¿çš„æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å¼•å…¥æ–°çš„è®¾è®¡æ¨¡å¼ï¼Œåˆ©ç”¨å®ƒï¼Œæ›´å¥½çš„ç¼–å†™è¯­æ³•æ ‘çš„å®ç°ã€‚</p>
<blockquote>
<p>Languages with multimethods, like Common Lispâ€™s CLOS, Dylan, and Julia do support adding both new types and operations easily. What they typically sacrifice is either static type checking, or separate compilation.</p>
<p>å…·æœ‰å¤šæ–¹æ³•çš„è¯­è¨€ï¼Œä¾‹å¦‚: Common Lisp, ç¡®å®æ”¯æŒè½»æ¾æ·»åŠ æ–°çš„ç±»å‹å’Œæ“ä½œï¼Œä½†æ˜¯ï¼Œå®ƒä»¬é€šå¸¸ä¼šç¼ºå°‘é™æ€ç±»å‹çš„æ£€æŸ¥æˆ–è€…å•ç‹¬ç¼–è¯‘ã€‚</p>
</blockquote>
<h3 id="32-the-visitor-pattern"><a class="header" href="#32-the-visitor-pattern">3.2 The Visitor pattern</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Visitor_pattern">è®¿é—®è€…æ¨¡å¼</a></p>
<p>The Visitor pattern is the most widely misunderstood pattern in all of Design Patterns, which is really saying something when you look at the software architecture excesses of the past couple of decades.</p>
<p>The trouble starts with terminology. The pattern isnâ€™t about â€œvisitingâ€, and the â€œacceptâ€ method in it doesnâ€™t conjure up any helpful imagery either. Many think the pattern has to do with traversing trees, which isnâ€™t the case at all. We are going to use it on a set of classes that are tree-like, but thatâ€™s a coincidence. As youâ€™ll see, the pattern works as well on a single object.</p>
<p>The Visitor pattern is really about approximating the functional style within an OOP language. It lets us add new columns to that table easily. We can define all of the behavior for a new operation on a set of types in one place, without having to touch the types themselves. It does this the same way we solve almost every problem in computer science: by adding a layer of indirection.</p>
<p>å½“ä½ æŸ¥çœ‹è¿‡å»å‡ åå¹´çš„è½¯ä»¶æ¶æ„å†å²ï¼Œè®¿é—®è€…æ¨¡å¼æ˜¯æœ€å®¹æ˜“è¢«è¯¯è§£çš„æ¨¡å¼</p>
<p>é—®é¢˜ä»æœ¯è¯­å¼€å§‹ï¼Œè¯¥æ¨¡å¼ä¸è®¿é—®æ— å…³ï¼Œå…¶ä¸­çš„æ¥å—æ–¹æ³•ï¼Œä¹Ÿä¸ä¼šäº§ç”Ÿä»»ä½•æœ‰ç”¨çš„å›¾åƒã€‚è®¸å¤šäººè®¤ä¸ºè¿™ç§æ¨¡å¼å’Œéå†è¯­æ³•æ ‘æœ‰å…³ï¼Œä½†äº‹å®å¹¶ä¸æ˜¯è¿™æ ·ã€‚æˆ‘ä»¬æ¥ä¸‹æ¥ï¼Œå°†åœ¨ä¸€ç»„æ ‘ç±»ï¼Œä½¿ç”¨è®¿é—®è€…æ¨¡å¼ï¼Œä½†æ˜¯è¿™åªæ˜¯å·§åˆã€‚æ­£å¦‚ï¼Œä½ å°†çœ‹åˆ°ï¼Œè¯¥æ¨¡å¼ä¹Ÿé€‚ç”¨äºå•ä¸ªå¯¹è±¡ã€‚</p>
<p>è®¿é—®è€…æ¨¡å¼ï¼Œåœ¨é¢å‘å¯¹è±¡è¯­è¨€ä¸­ï¼Œç±»ä¼¼äºå‡½æ•°å¼ã€‚å®ƒï¼Œå¯ä»¥è®©æˆ‘ä»¬è½»æ¾çš„æ·»åŠ ä¸€åˆ—ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸€ä¸ªåœ°æ–¹ï¼Œå®šä¹‰ä¸€ç»„ç±»å‹ä¸Šçš„æ–°æ“ä½œçš„æ‰€æœ‰è¡Œä¸ºï¼Œè€Œä¸éœ€è¦æ¥è§¦å…·ä½“çš„ç±»å‹ã€‚è¿™ä¸æˆ‘ä»¬è§£å†³è®¡ç®—ä¸­çš„å‡ ä¹æ‰€æœ‰é—®é¢˜çš„æ€æƒ³ä¸€æ ·â€”â€”æ·»åŠ ä¸€å±‚æŠ½è±¡ï¼Œé—´æ¥å¯»å€ã€‚</p>
<blockquote>
<p>A beignet (pronounced â€œben-yayâ€, with equal emphasis on both syllables) is a deep-fried pastry in the same family as doughnuts. When the French colonized North America in the 1700s, they brought beignets with them. Today, in the US, they are most strongly associated with the cuisine of New Orleans.</p>
<p>My preferred way to consume them is fresh out of the fryer at CafÃ© du Monde, piled high in powdered sugar, and washed down with a cup of cafÃ© au lait while I watch tourists staggering around trying to shake off their hangover from the previous nightâ€™s revelry</p>
<p>beignetæ˜¯ä¸€ç§æ²¹ç‚¸ç³•ç‚¹ï¼Œå’Œç”œç”œåœˆæ˜¯åŒä¸€ç±»å‹ç³•ç‚¹ã€‚</p>
</blockquote>
<p>Before we apply it to our auto-generated Expr classes, letâ€™s walk through a simpler example. Say we have two kinds of pastries: beignets and crullers.</p>
<p>åœ¨æˆ‘ä»¬åº”ç”¨è¯¥æ¨¡å¼äºæˆ‘ä»¬çš„Exprç±»ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆè¿›è¡Œä¸€ä¸ªç®€å•ç¤ºä¾‹ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸¤ç±»ç³•ç‚¹ï¼šç”œé¥¼å’Œç…é¥¼</p>
<pre><code class="language-java">

  abstract class Pastry {
  }

  class Beignet extends Pastry {
  }

  class Cruller extends Pastry {
  }
  
  
</code></pre>
<p>We want to be able to define new pastry operationsâ€”cooking them, eating them, decorating them, etc.â€”without having to add a new method to each class every time. Hereâ€™s how we do it. First, we define a separate interface.</p>
<p>æˆ‘ä»¬æƒ³è¦å®šä¹‰æ–°çš„ç³•ç‚¹æ“ä½œï¼Œçƒ¹é¥ªã€é£Ÿç”¨ã€è£…é¥°å®ƒä»¬ï¼Œè€Œä¸éœ€è¦å‘æ¯ä¸ªç±»ä¸­æ·»åŠ æ–¹æ³•ï¼Œä¸‹é¢æ˜¯æˆ‘ä»¬çš„åšæ³•ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªå•ç‹¬çš„æ¥å£</p>
<pre><code class="language-java">


  interface PastryVisitor {
    void visitBeignet(Beignet beignet); 
    void visitCruller(Cruller cruller);
  }
  
  
</code></pre>
<blockquote>
<p>In Design Patterns, both of these methods are confusingly named visit(), and they rely on overloading to distinguish them. This leads some readers to think that the correct visit method is chosen at runtime based on its parameter type. That isnâ€™t the case. Unlike overriding, overloading is statically dispatched at compile time.</p>
<p>Using distinct names for each method makes the dispatch more obvious, and also shows you how to apply this pattern in languages that donâ€™t support overloading.</p>
<p>åœ¨è®¾è®¡æ¨¡å¼ä¸­ï¼Œæ‰€æœ‰æ–¹æ³•åç§°éƒ½ç›¸åŒï¼Œvisit(), å®ƒä»¬éå¸¸å®¹æ˜“æ··æ·†ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨é‡è½½æ¥åŒºåˆ†å®ƒä»¬ã€‚è¿™å¯¼è‡´ä¸€äº›è¯»è€…è®¤ä¸ºï¼Œvisit()æ–¹æ³•çš„åŒºåˆ†æ˜¯åœ¨è¿è¡Œæ—¶å€™æ ¹æ®å‚æ•°ç±»å‹ä¸åŒï¼Œæ‰§è¡Œä¸åŒçš„æ–¹æ³•ï¼Œä½†æ˜¯ï¼Œå®é™…ä¸Šï¼Œä¸é‡å†™ä¸åŒï¼Œé‡è½½æ˜¯åœ¨é™æ€ç¼–è¯‘é˜¶æ®µåŒºåˆ†çš„ã€‚</p>
<p>å¯¹äºæ¯ä¸ªæ–¹æ³•ä½¿ç”¨ä¸åŒçš„åç§° visitBeignet/visitCruller å¯ä»¥è®©åˆ†æ´¾æ›´åŠ æ˜æ˜¾ã€‚å¹¶ä¸”ï¼Œè¿˜å¯ä»¥å±•ç¤ºåœ¨ä¸æ”¯æŒé‡è½½çš„è¯­è¨€ä¸­ï¼Œå¦‚ä½•å®ç°è®¿é—®è€…æ¨¡å¼ã€‚</p>
</blockquote>
<p>Each operation that can be performed on pastries is a new class that implements that interface. It has a concrete method for each type of pastry. That keeps the code for the operation on both types all nestled snugly together in one class.</p>
<p>Given some pastry, how do we route it to the correct method on the visitor based on its type? Polymorphism to the rescue! We add this method to Pastry:</p>
<p>å¯ä»¥åœ¨ç³•ç‚¹ä¸Šæ‰§è¡Œçš„æ¯ä¸ªæ“ä½œéƒ½æ˜¯ä¸€ä¸ªå®ç°è¯¥æ¥å£çš„æ–°ç±»ã€‚æ¯ä¸ªç³•ç‚¹ï¼Œéƒ½æœ‰å…·ä½“çš„åˆ¶ä½œæ–¹æ³•ï¼Œè¿™æ ·ï¼Œä¸¤ä¸ªç±»å‹çš„ç›¸åŒæ“ä½œä»£ç å°†å†™å…¥ä¸€ä¸ªç±»ä¸­</p>
<p>ç»™å®šä¸€äº›ç³•ç‚¹ï¼Œæˆ‘ä»¬å¦‚ä½•æ ¹æ®å…¶ç±»å‹å°†å®ƒä»¬å‘é€åˆ°è®¿é—®è€…çš„æ­£ç¡®æ–¹æ³•ï¼Ÿæˆ‘ä»¬å°†ä½¿ç”¨å¤šæ€ï¼Œæ¯ä¸ªå­ç±»éƒ½å°†å®ç°</p>
<pre><code class="language-java">

 abstract class Pastry {
    abstract void accept(PastryVisitor visitor);
  }
  
</code></pre>
<pre><code class="language-java">
 class Beignet extends Pastry {
    @Override
    void accept(PastryVisitor visitor) {
      visitor.visitBeignet(this);
    }
  }
  
</code></pre>
<pre><code class="language-java">

  class Cruller extends Pastry {
    @Override
    void accept(PastryVisitor visitor) {
      visitor.visitCruller(this);
    }
  }
  
</code></pre>
<p>To perform an operation on a pastry, we call its accept() method and pass in the visitor for the operation we want to execute. The pastryâ€”the specific subclassâ€™s overriding implementation of accept()â€”turns around and calls the appropriate visit method on the visitor and passes itself to it.</p>
<p>Thatâ€™s the heart of the trick right there. It lets us use polymorphic dispatch on the pastry classes to select the appropriate method on the visitor class. In the table, each pastry class is a row, but if you look at all of the methods for a single visitor, they form a column.</p>
<p>We added one accept() method to each class, and we can use it for as many visitors as we want without ever having to touch the pastry classes again. Itâ€™s a clever pattern.</p>
<p>è¦åœ¨ç³•ç‚¹ä¸Šæ‰§è¡Œæ“ä½œï¼Œæˆ‘ä»¬è°ƒç”¨å®ƒçš„accept() æ–¹æ³•ï¼Œå¹¶ä¸”ä¼ å‚æ˜¯ è¦æ‰§è¡Œæ“ä½œçš„è®¿é—®è€…ã€‚ç³•ç‚¹çš„å­ç±»ï¼Œé‡å†™ accept() æ–¹æ³•ï¼Œå®ƒä¼šå¯¹åº”ä¸åŒçš„è®¿é—®è€…ï¼Œè°ƒç”¨ä¸åŒçš„è®¿é—®æ–¹æ³•ï¼Œå¹¶å°†è‡ªèº«å½“ä½œä¼ å‚ã€‚</p>
<p>è¿™å°±æ˜¯å…³é”®æ‰€åœ¨ï¼Œå®ƒå…è®¸æˆ‘ä»¬åœ¨ç³•ç‚¹ç±»ä¸Šä½¿ç”¨å¤šæ€ï¼Œé€‰æ‹©è®¿é—®è€…ç±»ä¸Šçš„ç‰¹å®šæ–¹æ³•ï¼Œåœ¨ä¸‹é¢çš„è¡¨æ ¼ä¸­ï¼Œæ¯ä¸ªå…·ä½“çš„ç³•ç‚¹ç±»éƒ½æ˜¯ä¸€è¡Œï¼Œä½†æ˜¯ï¼Œå½“ä½ æŸ¥çœ‹å•ä¸ªè®¿é—®è€…çš„æ‰€æœ‰æ–¹æ³•ï¼Œå®ƒä»¬å°†ä¼šæ˜¯ä¸€åˆ—</p>
<p>æˆ‘ä»¬ä¸ºæ¯ä¸€ä¸ªç³•ç‚¹å­ç±»ï¼Œæ·»åŠ äº†ä¸€ä¸ªacceptæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ ¹æ®éœ€è¦ï¼Œä¸ºä»»æ„å¤šçš„è®¿é—®è€…ä½¿ç”¨ä¸åŒçš„acceptæ–¹æ³•ï¼Œè€Œæ— é¡»ä¿®æ”¹ç³•ç‚¹ç±»ï¼Œè¿™æ˜¯ä¸€ä¸ªå¥½çš„æ¨¡å¼ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/visitor.png?raw=true" alt="visitor" /></p>
<h3 id="33-visitors-for-expressions"><a class="header" href="#33-visitors-for-expressions">3.3 Visitors for expressions</a></h3>
<p>è¡¨è¾¾å¼è®¿é—®è€…æ¨¡å¼</p>
<p>OK, letâ€™s weave it into our expression classes. Weâ€™ll also refine the pattern a little. In the pastry example, the visit and accept() methods donâ€™t return anything. In practice, visitors often want to define operations that produce values. But what return type should accept() have? We canâ€™t assume every visitor class wants to produce the same type, so weâ€™ll use generics to let each implementation fill in a return type.</p>
<p>å¥½çš„ï¼Œæ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬åœ¨è¡¨è¾¾å¼ç±»ä¸­ï¼Œä½¿ç”¨è®¿é—®è€…æ¨¡å¼ï¼Œæˆ‘ä»¬è¿˜å°†å¯¹è®¿é—®è€…æ¨¡å¼è¿›è¡Œä¸€äº›æ”¹è¿›ï¼Œåœ¨ç³•ç‚¹ç¤ºä¾‹ä¸­ï¼Œvistor() å’Œ accept() æ–¹æ³•ï¼Œæ²¡æœ‰å…·ä½“çš„è¿”å›å€¼ã€‚å®é™…ä¸Šï¼ŒvistoræœŸæœ›å®šä¹‰å¯ä»¥äº§ç”Ÿå€¼çš„æ“ä½œï¼Œä½†æ˜¯,accept() æ–¹æ³•ï¼Œåº”è¯¥æœ‰ä»€ä¹ˆç±»å‹çš„è¿”å›å€¼å‘¢ï¼Ÿæˆ‘ä»¬ä¸èƒ½å‡è®¾ï¼Œæ¯ä¸€ä¸ªvisitoréƒ½è¿”å›ç›¸åŒçš„ç±»å‹ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ³›å‹ï¼Œè®©æ¯ä¸€ä¸ªå…·ä½“å®ç°ï¼Œå»å¡«å……ç±»å‹</p>
<blockquote>
<p>Another common refinement is an additional â€œcontextâ€ parameter that is passed to the visit methods and then sent back through as a parameter to accept(). That lets operations take an additional parameter. The visitors weâ€™ll define in the book donâ€™t need that, so I omitted it.</p>
<p>å¦ä¸€ä¸ªå¸¸è§çš„ç»†åŒ–æ˜¯é€šè¿‡ä¸€ä¸ªå‚æ•°context, è¯¥å‚æ•°ä¼ é€’ç»™visit(), ç„¶åï¼Œåœ¨ä½œä¸ºä¸€ä¸ªå‚æ•°ï¼Œå‘é€å›accept()ï¼Œ è¿™å…è®¸æ“ä½œä½¿ç”¨é™„åŠ å‚æ•°ï¼Œæˆ‘ä»¬åœ¨æœ¬ä¹¦ä¸­å®šä¹‰çš„è®¿é—®è€…ä¸éœ€è¦è¯¥å‚æ•°ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬çœç•¥äº†contextçš„ä»‹ç»ã€‚</p>
</blockquote>
<p>First, we define the visitor interface. Again, we nest it inside the base class so that we can keep everything in one file.</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰è®¿é—®è€…æ¥å£ï¼ŒåŒæ ·çš„ï¼Œæˆ‘ä»¬å°†å…¶åµŒå¥—åœ¨åŸºç±»ä¸­ï¼Œä»¥ä¾¿æˆ‘ä»¬å°†æ‰€æœ‰å†…å®¹ä¿å­˜åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ã€‚</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in defineAst()

    writer.println(&quot;abstract class &quot; + baseName + &quot; {&quot;);

    defineVisitor(writer, baseName, types);

    // The AST classes.


</code></pre>
<pre><code class="language-java">
// tool/GenerateAst.java, add after defineAst()
  private static void defineVisitor(
      PrintWriter writer, String baseName, List&lt;String&gt; types) {
    writer.println(&quot;  interface Visitor&lt;R&gt; {&quot;);

    for (String type : types) {
      String typeName = type.split(&quot;:&quot;)[0].trim();
      writer.println(&quot;    R visit&quot; + typeName + baseName + &quot;(&quot; +
          typeName + &quot; &quot; + baseName.toLowerCase() + &quot;);&quot;);
    }

    writer.println(&quot;  }&quot;);
  }
  
</code></pre>
<p>Here, we iterate through all of the subclasses and declare a visit method for each one. When we define new expression types later, this will automatically include them.</p>
<p>Inside the base class, we define the abstract accept() method.</p>
<p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éå†æ¯ä¸€ä¸ªå­ç±»ï¼Œå¹¶ä¸”ä¸ºæ¯ä¸€ä¸ªå­ç±»ï¼Œå£°æ˜äº†ä¸€ä¸ªè®¿é—®æ–¹æ³•ï¼Œå½“æˆ‘ä»¬å®šä¹‰æ–°çš„è¡¨è¾¾å¼ç±»æ—¶å€™ï¼Œè¿™å°†è‡ªåŠ¨åŒ…æ‹¬å®ƒä»¬</p>
<p>åœ¨åŸºç±»ä¸­ï¼Œæˆ‘ä»¬å°†å®šä¹‰æŠ½è±¡ç±» accept() æ–¹æ³•</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in defineAst()

      defineType(writer, baseName, className, fields);
    }

    // The base accept() method.
    writer.println();
    writer.println(&quot;  abstract &lt;R&gt; R accept(Visitor&lt;R&gt; visitor);&quot;);

    writer.println(&quot;}&quot;);


</code></pre>
<p>Finally, each subclass implements that and calls the right visit method for its own type.</p>
<p>æœ€åï¼Œæ¯ä¸€ä¸ªå­ç±»ä¸­éƒ½å®ç°äº†accept() æ–¹æ³•ï¼Œæ¯ä¸ªå…·ä½“çš„accept() æ–¹æ³•å°†ä¼šè°ƒç”¨æ­£ç¡®çš„visitæ–¹æ³•</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in defineType()

    writer.println(&quot;    }&quot;);

    // Visitor pattern.
    writer.println();
    writer.println(&quot;    @Override&quot;);
    writer.println(&quot;    &lt;R&gt; R accept(Visitor&lt;R&gt; visitor) {&quot;);
    writer.println(&quot;      return visitor.visit&quot; +
        className + baseName + &quot;(this);&quot;);
    writer.println(&quot;    }&quot;);

    // Fields.


</code></pre>
<p>There we go. Now we can define operations on expressions without having to muck with the classes or our generator script. Compile and run this generator script to output an updated â€œExpr.javaâ€ file. It contains a generated Visitor interface and a set of expression node classes that support the Visitor pattern using it.</p>
<p>Before we end this rambling chapter, letâ€™s implement that Visitor interface and see the pattern in action.</p>
<p>æˆ‘ä»¬ç»§ç»­å¼€å§‹ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è¡¨è¾¾å¼ä¸Šå®šä¹‰æ“ä½œï¼Œè€Œä¸éœ€è¦å¤„ç†ç±»å’Œç”Ÿæˆç±»è„šæœ¬ï¼Œ ç¼–è¯‘è¿è¡Œè¿™ä¸ªè„šæœ¬ï¼Œæ›´æ–°Expr.java æ–‡ä»¶ï¼Œå®ƒåŒ…å«ä¸€ä¸ªç”ŸæˆVisitoræ¥å£ï¼Œå’Œä¸€ç³»åˆ—è¡¨è¾¾å¼èŠ‚ç‚¹ç±»ï¼Œæ”¯æŒVisitoræ¨¡å¼ã€‚</p>
<p>åœ¨æˆ‘ä»¬ç»“æŸè¿™æ¼«æ— è¾¹é™…çš„ä¸€ç« ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å®ç°Visitoræ¥å£ï¼Œå¹¶ä¸”å®é™…ä½¿ç”¨è®¿é—®è€…æ¨¡å¼ã€‚</p>
<h2 id="å››a-not-very-pretty-printer"><a class="header" href="#å››a-not-very-pretty-printer">å››ã€A (Not Very) Pretty Printer</a></h2>
<p>When we debug our parser and interpreter, itâ€™s often useful to look at a parsed syntax tree and make sure it has the structure we expect. We could inspect it in the debugger, but that can be a chore.</p>
<p>Instead, weâ€™d like some code that, given a syntax tree, produces an unambiguous string representation of it. Converting a tree to a string is sort of the opposite of a parser, and is often called â€œpretty printingâ€ when the goal is to produce a string of text that is valid syntax in the source language.</p>
<p>Thatâ€™s not our goal here. We want the string to very explicitly show the nesting structure of the tree. A printer that returned 1 + 2 * 3 isnâ€™t super helpful if what weâ€™re trying to debug is whether operator precedence is handled correctly. We want to know if the + or * is at the top of the tree.</p>
<p>å½“æˆ‘ä»¬è°ƒè¯•è§£æå™¨å’Œè§£é‡Šå™¨æ—¶å€™ï¼ŒæŸ¥çœ‹å·²ç»è§£æçš„è¯­æ³•æ ‘ï¼Œå¹¶ä¸”ç¡®ä¿å®ƒä»¬æ‹¥æœ‰æˆ‘ä»¬æœŸæœ›çš„ç»“æ„ï¼Œé€šå¸¸éå¸¸é‡è¦ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è°ƒè¯•é˜¶æ®µæ£€æŸ¥ã€‚ä½†æ˜¯ï¼Œè¿™ä¹Ÿæ˜¯ä¸€é¡¹ç¹é‡çš„ä»»åŠ¡</p>
<p>ç›¸åï¼Œæˆ‘ä»¬æ›´å–œæ¬¢ä¸€äº›è¾“å‡ºï¼Œåœ¨ç»™å®šè¯­æ³•æ ‘åœºæ™¯ï¼Œè¾“å‡ºæ˜ç¡®çš„å­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºè¿™ä¸ªè¯­æ³•æ ‘ã€‚å°†æ ‘è¿”å›ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¿‡ç¨‹å’Œè§£æå™¨æ­£å¥½ç›¸åï¼Œè¿™é€šå¸¸ç§°ä¸ºå®Œç¾è¾“å‡ºï¼Œå¦‚æœæˆ‘ä»¬è¾“å‡ºçš„å­—ç¬¦ä¸²æ˜¯ä¸€ä¸ªåˆæ³•çš„åŸå§‹è¯­è¨€çš„å­—ç¬¦ä¸²</p>
<p>ä½†æ˜¯ï¼Œè¿™ä¸æ˜¯æˆ‘ä»¬çš„ç›®æ ‡ï¼Œæˆ‘ä»¬å¸Œæœ›å­—ç¬¦ä¸²ï¼Œå¯ä»¥éå¸¸æ˜ç¡®çš„æ˜¾ç¤ºè¯­æ³•æ ‘ç»“æ„ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦è°ƒè¯•è¿ç®—ç¬¦ä¼˜å…ˆçº§æ˜¯å¦æ­£ç¡®è¢«å¤„ç†ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æ¥è¾“å‡º 1 +  2*3 , ä¸ä¼šæœ‰å¾ˆå¤§çš„ä½œç”¨ã€‚æˆ‘ä»¬æƒ³è¦çŸ¥é“ï¼Œ+ è¿˜æ˜¯ * åœ¨è¯­æ³•æ ‘çš„é¡¶éƒ¨ã€‚</p>
<p>To that end, the string representation we produce isnâ€™t going to be Lox syntax. Instead, it will look a lot like, well, Lisp. Each expression is explicitly parenthesized, and all of its subexpressions and tokens are contained in that.</p>
<p>ä¸ºæ­¤ï¼Œæˆ‘ä»¬è¾“å‡ºçš„å­—ç¬¦ä¸²ä¸æ˜¯ç¬¦åˆloxè¯­æ³•çš„å­—ç¬¦ä¸²ï¼Œç›¸åï¼Œå®ƒçœ‹èµ·æ¥æ›´åƒæ˜¯ lispè¯­è¨€ï¼Œæ¯ä¸ªè¡¨è¾¾å¼éƒ½æ˜¾ç¤ºçš„ç”¨æ‹¬å·æ‹¬èµ·æ¥ï¼Œå…¶ä¸­åŒ…å«æ‰€æœ‰çš„å­è¡¨è¾¾å¼å’Œtoken</p>
<p>Given a syntax tree like:</p>
<p>ç»™å®šä¸‹é¢çš„è¯­æ³•æ ‘ï¼Œ</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/expression.png?raw=true" alt="expression" /></p>
<p>It produces:</p>
<p>å®ƒå¯¹åº”çš„è¾“å‡ºå­—ç¬¦ä¸²æ˜¯</p>
<p><code>(* (- 123) (group 45.67))</code></p>
<p>Not exactly â€œprettyâ€, but it does show the nesting and grouping explicitly. To implement this, we define a new class.</p>
<p>è™½ç„¶ï¼Œä¸æ˜¯éå¸¸å®Œç¾ï¼Œä½†æ˜¯å®ƒï¼Œçš„ç¡®æ˜¾ç¤ºäº†åµŒå¥—å’Œåˆ†ç»„ç»“æ„ï¼Œä¸ºäº†å®ç°è¿™ä¸ªè¾“å‡ºï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„ç±»</p>
<pre><code class="language-java">
// lox/AstPrinter.java, create new file

package com.craftinginterpreters.lox;

class AstPrinter implements Expr.Visitor&lt;String&gt; {
  String print(Expr expr) {
    return expr.accept(this);
  }
}


</code></pre>
<p>As you can see, it implements the visitor interface. That means we need visit methods for each of the expression types we have so far.</p>
<p>å¦‚æˆ‘ä»¬æ‰€è§ï¼Œå®ƒå®ç°äº†è®¿é—®è€…æ¨¡å¼çš„æ¥å£ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬éœ€è¦å¯¹æ¯ä¸ªè¡¨è¾¾å¼ç±»å‹å®ç°è®¿é—®æ–¹æ³•ï¼Œ</p>
<pre><code class="language-java">
// lox/AstPrinter.java, add after print()

    return expr.accept(this);
  }

  @Override
  public String visitBinaryExpr(Expr.Binary expr) {
    return parenthesize(expr.operator.lexeme,
                        expr.left, expr.right);
  }

  @Override
  public String visitGroupingExpr(Expr.Grouping expr) {
    return parenthesize(&quot;group&quot;, expr.expression);
  }

  @Override
  public String visitLiteralExpr(Expr.Literal expr) {
    if (expr.value == null) return &quot;nil&quot;;
    return expr.value.toString();
  }

  @Override
  public String visitUnaryExpr(Expr.Unary expr) {
    return parenthesize(expr.operator.lexeme, expr.right);
  }
}

</code></pre>
<p>Literal expressions are easyâ€”they convert the value to a string with a little check to handle Javaâ€™s null standing in for Loxâ€™s nil. The other expressions have subexpressions, so they use this parenthesize() helper method:</p>
<p>æ–‡å­—è¡¨è¾¾å¼çš„è®¿é—®è€…æ¥å£å¾ˆå®¹æ˜“å®ç°â€”â€”å®ƒä»¬å°†å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œåªéœ€è¦ç¨å¾®æ£€æŸ¥ä¸€ä¸‹ï¼Œæ˜¯å¦æ˜¯Java ä¸­çš„nullå€¼ï¼Œå¦‚æœæ˜¯ï¼Œéœ€è¦è½¬ä¸ºloxè¯­è¨€ä¸­çš„nilï¼›å…¶ä»–çš„è¡¨è¾¾å¼ï¼Œå«æœ‰å­è¡¨è¾¾å¼ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å€ŸåŠ©è¿™ä¸ªæ‹¬å·å¤„ç†å¸®åŠ©å‡½æ•°</p>
<pre><code class="language-java">
// lox/AstPrinter.java, add after visitUnaryExpr()

  private String parenthesize(String name, Expr... exprs) {
    StringBuilder builder = new StringBuilder();

    builder.append(&quot;(&quot;).append(name);
    for (Expr expr : exprs) {
      builder.append(&quot; &quot;);
      builder.append(expr.accept(this));
    }
    builder.append(&quot;)&quot;);

    return builder.toString();
  }


</code></pre>
<p>It takes a name and a list of subexpressions and wraps them all up in parentheses, yielding a string like:</p>
<p>å®ƒæ¥å—ä¸€ä¸ªåç§°å’Œä¸€ä¸²å­è¡¨è¾¾å¼ï¼Œå¹¶ä¸”å°†å®ƒä»¬éƒ½æ˜¯ç”¨æ‹¬å·æ‹¬èµ·æ¥ï¼Œç”Ÿæˆå¦‚ä¸‹çš„å­—ç¬¦ä¸²</p>
<pre><code>
(+ 1 2)

</code></pre>
<p>Note that it calls accept() on each subexpression and passes in itself. This is the recursive step that lets us print an entire tree.</p>
<p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæ¯ä¸ªå­è¡¨è¾¾å¼éƒ½ä¼šè°ƒç”¨accept() æ–¹æ³•ï¼Œå¹¶ä¸”å°†è‡ªèº«ä¼ å‚ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥é€’å½’è°ƒç”¨ï¼Œæ‰“å°å‡ºè¯­æ³•æ ‘ã€‚</p>
<blockquote>
<p>This recursion is also why people think the Visitor pattern itself has to do with trees.</p>
<p>è¿™ç§é€’å½’ï¼Œä¹Ÿè®©äººä»¬æ›´åŠ è®¤ä¸ºï¼Œè®¿é—®è€…æ¨¡å¼å’Œè¯­æ³•æ ‘æ˜¯æœ‰å…³çš„ã€‚</p>
</blockquote>
<p>We donâ€™t have a parser yet, so itâ€™s hard to see this in action. For now, weâ€™ll hack together a little main() method that manually instantiates a tree and prints it.</p>
<p>æˆ‘ä»¬è¿˜æ²¡æœ‰è§£æå™¨ï¼Œæ‰€ä»¥å¾ˆéš¾çœ‹åˆ°å…·ä½“çš„å®é™…åº”ç”¨ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å°†å…ˆå®ç°ä¸€ä¸ªdemo mainå‡½æ•°ï¼Œæ‰‹åŠ¨å®ä¾‹åŒ–è¯­æ³•æ ‘ï¼Œå¹¶ä¸”æ‰“å°</p>
<pre><code class="language-java">// lox/AstPrinter.java, add after parenthesize()

  public static void main(String[] args) {
    Expr expression = new Expr.Binary(
        new Expr.Unary(
            new Token(TokenType.MINUS, &quot;-&quot;, null, 1),
            new Expr.Literal(123)),
        new Token(TokenType.STAR, &quot;*&quot;, null, 1),
        new Expr.Grouping(
            new Expr.Literal(45.67)));

    System.out.println(new AstPrinter().print(expression));
  }


</code></pre>
<p>If we did everything right, it prints:</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¿è¡Œï¼Œå°†ä¼šè¾“å‡º</p>
<p><code>(* (- 123) (group 45.67))</code></p>
<p>You can go ahead and delete this method. We wonâ€™t need it. Also, as we add new syntax tree types, I wonâ€™t bother showing the necessary visit methods for them in AstPrinter. If you want to (and you want the Java compiler to not yell at you), go ahead and add them yourself. It will come in handy in the next chapter when we start parsing Lox code into syntax trees. Or, if you donâ€™t care to maintain AstPrinter, feel free to delete it. We wonâ€™t need it again.</p>
<p>æˆ‘ä»¬å¯ä»¥ç»§ç»­ä¸‹å»ï¼Œåˆ é™¤å½“å‰demoï¼Œæˆ‘ä»¬ä¸éœ€è¦å®ƒã€‚æ­¤å¤–ï¼Œå½“æˆ‘ä»¬æ·»åŠ æ–°çš„è¡¨è¾¾å¼ç±»å‹æ—¶å€™ï¼Œæˆ‘ä¸ä¼šè´¹å¿ƒåœ¨AstPrinterä¸­å®ç°å®ƒä»¬çš„è®¿é—®æ–¹æ³•ï¼Œå¦‚æœä½ æƒ³è¦æ·»åŠ ï¼ˆå¹¶ä¸”å¸Œæœ›Javaç¼–è¯‘å™¨ä¸ä¼šæŠ¥é”™ï¼‰ï¼Œé‚£ä¹ˆä½ å¯ä»¥è‡ªå·±æ·»åŠ å¯¹åº”çš„vistoræ–¹æ³•ï¼Œå½“æˆ‘ä»¬å°†Loxä»£ç è§£æä¸ºè¯­æ³•æ ‘æ—¶å€™ï¼Œå®ƒå°†åœ¨æ¥ä¸‹æ¥å‘æŒ¥ä½œç”¨ã€‚æˆ–è€…ï¼Œå¦‚æœä½ ä¸æƒ³ç»´æŠ¤AstPrinter, å¯ä»¥éšæ—¶åˆ é™¤å®ƒï¼Œæˆ‘ä»¬ä¸å†éœ€è¦å®ƒã€‚</p>
<h2 id="äº”challenges-1"><a class="header" href="#äº”challenges-1">äº”ã€CHALLENGES</a></h2>
<p>ä¹ é¢˜</p>
<ol>
<li>
<p>Earlier, I said that the |, *, and + forms we added to our grammar metasyntax were just syntactic sugar. Take this grammar:</p>
<p>æ—©å…ˆï¼Œæˆ‘è®²äº†æˆ‘ä»¬çš„å…ƒè¯­æ³•ä¸­ï¼Œåªæ˜¯å°† | * + å½“ä½œä¸€äº›è¯­æ³•ç³–ï¼Œ</p>
<pre><code>
expr â†’ expr ( &quot;(&quot; ( expr ( &quot;,&quot; expr )* )? &quot;)&quot; | &quot;.&quot; IDENTIFIER )+
  | IDENTIFIER
  | NUMBER


</code></pre>
<p>è¯·ç”ŸæˆåŒæ ·çš„è¯­æ³•è§„åˆ™ï¼Œä¸ä½¿ç”¨è¯­æ³•ç³–ï¼Œä¸Šé¢è¿™æ®µè¯­æ³•è§„åˆ™ï¼Œæ˜¯æè¿°äº†ä»€ä¹ˆè¡¨è¾¾å¼ï¼Ÿ</p>
</li>
<li>
<p>The Visitor pattern lets you emulate the functional style in an object-oriented language. Devise a complementary pattern for a functional language. It should let you bundle all of the operations on one type together and let you define new types easily.</p>
<p>(SML or Haskell would be ideal for this exercise, but Scheme or another Lisp works as well.)</p>
<p>è®¿é—®è€…æ¨¡å¼å…è®¸æˆ‘ä»¬åœ¨é¢å‘å¯¹è±¡è¯­è¨€ä¸­ä½¿ç”¨æ¨¡æ‹Ÿå‡½æ•°å¼ç¼–ç¨‹é£æ ¼ã€‚è¯·ï¼Œä¸ºå‡½æ•°å¼è¯­è¨€è®¾è®¡ä¸€ä¸ªæ¨¡å¼ï¼Œå®ƒå…è®¸æˆ‘ä»¬å°†æ‰€æœ‰çš„æ“ä½œå†™å…¥åˆ°ä¸€èµ·ï¼Œå¹¶ä¸”å…è®¸æˆ‘ä»¬è½»æ¾çš„å®šä¹‰æ–°çš„ç±»å‹</p>
<p>SML å’Œ Haskell æ˜¯è¿™ä¸ªç»ƒä¹ çš„ç†æƒ³è¯­è¨€ï¼Œä½†æ˜¯ Scheme å’Œ Lisp ä¹Ÿå¯ä»¥</p>
</li>
<li>
<p>In reverse Polish notation (RPN), the operands to an arithmetic operator are both placed before the operator, so 1 + 2 becomes 1 2 +. Evaluation proceeds from left to right. Numbers are pushed onto an implicit stack. An arithmetic operator pops the top two numbers, performs the operation, and pushes the result. Thus, this:</p>
<p>(1 + 2) * (4 - 3) in RPN becomes: 1 2 + 4 3 - *</p>
<p>Define a visitor class for our syntax tree classes that takes an expression, converts it to RPN, and returns the resulting string.</p>
<p>åœ¨é€†æ³¢å…°è¡¨ç¤ºæ³•ä¸­RPNï¼Œç®—æœ¯è¿ç®—ç¬¦çš„æ“ä½œæ•°æ”¾åˆ°æ“ä½œç¬¦ä¹‹å‰ï¼Œä¾‹å¦‚ï¼š1 + 2å°†å˜ä¸º 1 2 + , æ‰§è¡Œæ—¶å€™ï¼Œä»å·¦åˆ°å³ã€‚å°†æ“ä½œæ•°æ”¾å…¥å †æ ˆä¸­ï¼Œé‡åˆ°æ“ä½œç¬¦åï¼Œå°†å¼¹å‡ºå¯¹åº”çš„æ“ä½œæ•°ï¼Œæ‰§è¡Œè¿ç®—ï¼Œå°†ç»“æœé‡æ–°æ”¾å…¥å †æ ˆ</p>
<p>ä¾‹å¦‚: </p>
<p>(1 + 2) * (4 - 3)  ä½¿ç”¨é€†æ³¢å…°è¡¨ç¤ºæ³• 1 2 + 4 3 - *</p>
<p>å®šä¹‰ä¸€ä¸ªè®¿é—®è€…ç±»ï¼Œé’ˆå¯¹ä¸åŒçš„è¡¨è¾¾å¼ç±»å‹ï¼Œè¾“å‡ºå…¶é€†æ³¢å…°è¡¨ç¤ºæ³•ã€‚</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è§£æè¡¨è¾¾å¼"><a class="header" href="#è§£æè¡¨è¾¾å¼">è§£æè¡¨è¾¾å¼</a></h1>
<blockquote>
<p>Grammar, which knows how to control even kings.</p>
<p>è¯­æ³•ï¼ŒçŸ¥é“å¦‚ä½•æ§åˆ¶å›½ç‹ã€‚</p>
<p align="right">â€”â€” MoliÃ¨re </p>
</blockquote>
<p>This chapter marks the first major milestone of the book. Many of us have cobbled together a mishmash of regular expressions and substring operations to extract some sense out of a pile of text. The code was probably riddled with bugs and a beast to maintain. Writing a real parserâ€”one with decent error handling, a coherent internal structure, and the ability to robustly chew through a sophisticated syntaxâ€”is considered a rare, impressive skill. In this chapter, you will attain it.</p>
<p>è¿™ä¸€ç« æ˜¯æœ¬ä¹¦çš„ä¸€ä¸ªé‡è¦é‡Œç¨‹ç¢‘ï¼Œæˆ‘ä»¬ä¸­çš„è®¸å¤šäººéƒ½æ‹¼å‡‘äº†ä¸€å †æ­£åˆ™è¡¨è¾¾å¼å’Œå­å­—ç¬¦ä¸²å¤„ç†æ–¹æ³•ï¼Œä»¥ä¾¿åœ¨ä¸€å †æ–‡æœ¬ä¸­è·å–æ„ä¹‰ã€‚ä»£ç å¯èƒ½å­˜åœ¨æ¼æ´ï¼Œéœ€è¦ä¸æ–­ç»´æŠ¤ã€‚ç¼–å†™ä¸€ä¸ªçœŸæ­£çš„è§£æå™¨â€”â€”å…·æœ‰è‰¯å¥½çš„é”™è¯¯å¤„ç†èƒ½åŠ›ï¼Œè¿è´¯çš„å†…éƒ¨ç»“æ„ï¼Œå¯¹å¤æ‚è¯­æ³•çš„è‰¯å¥½å¤„ç†èƒ½åŠ›ï¼Œè¢«è®¤ä¸ºæ˜¯ä¸€ç§ç½•è§çš„ã€ä»¤äººå°è±¡æ·±åˆ»çš„èƒ½åŠ›ã€‚åœ¨æœ¬ç« ï¼Œæˆ‘ä»¬å°†å®ç°è¿™ä¸ªç›®æ ‡ã€‚</p>
<blockquote>
<p>â€œParseâ€ comes to English from the Old French â€œparsâ€ for â€œpart of speechâ€. It means to take a text and map each word to the grammar of the language. We use it here in the same sense, except that our language is a little more modern than Old French.</p>
<p>Like many rites of passage, youâ€™ll probably find it looks a little smaller, a little less daunting when itâ€™s behind you than when it loomed ahead.</p>
<p>parse å•è¯æ˜¯ä»å¤æ³•è¯­ä¸­æ¥çš„ï¼Œå®ƒè¡¨ç¤ºæˆ‘ä»¬å–ä¸€æ®µæ–‡å­—ï¼Œå°†æ¯ä¸€ä¸ªå•è¯æ˜ å°„åˆ°è¯­è¨€çš„è¯­æ³•ä¸­ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä½¿ç”¨çš„æ˜¯ï¼Œç›¸åŒçš„å«ä¹‰ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬è¦å®ç°çš„è¯­è¨€æ›´åŠ ç°ä»£ä¸€äº›ï¼Œç›¸æ¯”äºå¤æ³•è¯­ã€‚</p>
<p>åƒæ˜¯å¾ˆå¤šæˆäººä»ªå¼ä¸€æ ·ï¼Œä½ å¯èƒ½ä¼šå‘ç°ï¼Œè¿™ä¸ªçœ‹èµ·æ¥æœ‰ç‚¹å°ï¼Œæ¯”å®ƒéšçº¦å‡ºç°åœ¨ä½ çš„é¢å‰æ—¶å€™ï¼Œä»¤äººæ›´å°‘ä¸€äº›ç•æƒ§ã€‚</p>
</blockquote>
<p>Itâ€™s easier than you think, partially because we front-loaded a lot of the hard work in the last chapter. You already know your way around a formal grammar. Youâ€™re familiar with syntax trees, and we have some Java classes to represent them. The only remaining piece is parsingâ€”transmogrifying a sequence of tokens into one of those syntax trees.</p>
<p>Some CS textbooks make a big deal out of parsers. In the â€™60s, computer scientistsâ€”understandably tired of programming in assembly languageâ€”started designing more sophisticated, human-friendly languages like Fortran and ALGOL. Alas, they werenâ€™t very machine-friendly for the primitive computers of the time.</p>
<p>è¿™ä¸ªè§£æè¿‡ç¨‹ï¼Œæ¯”ä½ æƒ³è¦çš„è¦ç®€å•ä¸€äº›ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæå‰å®Œæˆäº†å¾ˆå¤šè‰°è‹¦çš„å·¥ä½œã€‚ä½ å·²ç»ç†Ÿæ‚‰äº†æ­£åˆ™è¯­æ³•ï¼Œè€Œä¸”æˆ‘ä»¬ä½¿ç”¨äº†å¾ˆå¤šçš„Javaç±»æ¥è¡¨ç¤ºè¿™äº›è¡¨è¾¾å¼ã€‚å‰©ä¸‹çš„è§£æéƒ¨åˆ†â€”â€”å°†ä¸€ç³»åˆ—çš„tokenè§£æä¸ºè¯­æ³•æ ‘ã€‚</p>
<p>æœ‰ä¸€äº›ç¼–ç¨‹æ•™ç§‘ä¹¦ï¼Œå¯¹è§£æå™¨éƒ¨åˆ†åšäº†å¾ˆå¤§çš„æ”¹åŠ¨ã€‚ä¸Šä¸–çºª60å¹´ä»£åˆï¼Œè®¡ç®—æœºç§‘å­¦å®¶å¯¹äºæ±‡ç¼–ç¼–ç¨‹æ„Ÿåˆ°åŒå€¦ï¼Œè¿™æ˜¯å¯ä»¥ç†è§£çš„ï¼Œäºæ˜¯ï¼Œä»–ä»¬å¼€å§‹è®¾è®¡æ›´åŠ é«˜çº§ã€äººæ€§åŒ–çš„è¯­è¨€ï¼Œä¾‹å¦‚ï¼šFortran ,Algolç­‰ç­‰ï¼Œè™½ç„¶å¯¹äºå½“æ—¶çš„åŸå§‹è®¡ç®—æœºï¼Œè¿™äº›è¯­è¨€ä¸æ˜¯å¾ˆå‹å¥½ã€‚</p>
<blockquote>
<p>Imagine how harrowing assembly programming on those old machines must have been that they considered Fortran to be an improvement.</p>
<p>æƒ³è±¡ä¸€ä¸‹ï¼Œåœ¨é‚£äº›è€æœºå™¨ä¸Šï¼Œè¿›è¡Œæ±‡ç¼–è¯­è¨€ç¼–ç¨‹æ˜¯ä¸€ä»¶å¤šä¹ˆç—›è‹¦çš„äº‹æƒ…ï¼Œæ‰€ä»¥ï¼Œè®¡ç®—æœºç§‘å­¦å®¶ä»¬ï¼Œè®¤ä¸ºä½¿ç”¨Fortranè¯­è¨€ç¼–ç¨‹ï¼Œæ˜¯ä¸€ç§æ”¹è¿›ã€‚</p>
</blockquote>
<p>These pioneers designed languages that they honestly werenâ€™t even sure how to write compilers for, and then did groundbreaking work inventing parsing and compiling techniques that could handle these new, big languages on those old, tiny machines.</p>
<p>Classic compiler books read like fawning hagiographies of these heroes and their tools. The cover of Compilers: Principles, Techniques, and Tools literally has a dragon labeled â€œcomplexity of compiler designâ€ being slain by a knight bearing a sword and shield branded â€œLALR parser generatorâ€ and â€œsyntax directed translationâ€. They laid it on thick.</p>
<p>A little self-congratulation is well-deserved, but the truth is you donâ€™t need to know most of that stuff to bang out a high quality parser for a modern machine. As always, I encourage you to broaden your education and take it in later, but this book omits the trophy case.</p>
<p>è¿™äº›è®¡ç®—æœºé¢†åŸŸçš„å…ˆé©±è€…ä»¬ï¼Œè®¾è®¡äº†ä»–ä»¬ç”šè‡³è¿˜ä¸çŸ¥é“å¦‚ä½•ç¼–å†™ç¼–è¯‘å™¨çš„è¯­è¨€ï¼Œä»–ä»¬æ¥ç€å‘æ˜äº†è§£æã€ç¼–è¯‘æŠ€æœ¯ï¼Œåœ¨è€æ—§çš„æœºå™¨ä¸Šå¤„ç†æ–°çš„è¯­è¨€ã€‚</p>
<p>ç»å…¸çš„ç¼–è¯‘å™¨ä¹¦ç±ï¼Œè¯»èµ·æ¥åƒæ˜¯ï¼Œè¿™äº›å…ˆé©±åŠå…¶å‘æ˜å·¥å…·çš„ä¼ è®°ã€‚ã€Šç¼–è¯‘å™¨ï¼šåŸç†ã€æŠ€æœ¯å’Œå·¥å…·ã€‹çš„å°é¢æ˜¯ä¸€æ¡é¾™ï¼Œé¾™èº«ä¸Šå†™ç€ç¼–è¯‘å™¨è®¾è®¡çš„å¤æ‚æ€§ï¼Œè¢«ä¸€ä¸ªæ‰‹æŒç›¾ç‰Œå’Œå®å‰‘çš„éª‘å£«æ€æ­»ã€‚éª‘ä¸Šç›¾ç‰Œä¸Šå†™ç€ï¼šLALRè§£æå™¨ç”Ÿæˆå™¨ï¼Œè¯­æ³•å‘å¯¼ç¿»è¯‘ï¼Œè¿™ä¸ªéå¸¸é‡è¦ã€‚</p>
<p>æœ‰ä¸€äº›è‡ªé¸£å¾—æ„æ˜¯ç†æ‰€å½“ç„¶çš„ï¼Œä½†äº‹å®æ˜¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦äº†è§£å…¶ä¸­çš„å¤§éƒ¨åˆ†å†…å®¹ï¼Œå°±å¯ä»¥ä¸ºç°ä»£æœºå™¨ï¼Œè®¾è®¡å‡ºé«˜è´¨é‡çš„è§£æå™¨ã€‚å‘ä¹‹å‰ä¸€æ ·ï¼Œæˆ‘é¼“åŠ±ä½ æ‰©å¤§å­¦ä¹ èŒƒå›´ï¼Œç„¶åæ·±å…¥ç ”ç©¶ï¼Œæœ¬ä¹¦çœç•¥å¥–æ¯æ¡ˆä¾‹ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/compiler-dragon.png?raw=true" alt="compiler-dragon" /></p>
<h2 id="ä¸€ambiguity-and-the-parsing-game"><a class="header" href="#ä¸€ambiguity-and-the-parsing-game">ä¸€ã€Ambiguity and the Parsing Game</a></h2>
<p>æ­§ä¹‰å’Œè§£æåšå¼ˆ</p>
<p>In the last chapter, I said you can â€œplayâ€ a context-free grammar like a game in order to generate strings. Parsers play that game in reverse. Given a stringâ€”a series of tokensâ€”we map those tokens to terminals in the grammar to figure out which rules could have generated that string.</p>
<p>The â€œcould haveâ€ part is interesting. Itâ€™s entirely possible to create a grammar that is ambiguous, where different choices of productions can lead to the same string. When youâ€™re using the grammar to generate strings, that doesnâ€™t matter much. Once you have the string, who cares how you got to it?</p>
<p>åœ¨ä¸Šä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åƒç©æ¸¸æˆä¸€æ ·ï¼Œé€šè¿‡ä¸Šä¸‹æ–‡æ— å…³è¯­æ³•ï¼Œç”Ÿæˆä¸€ç³»åˆ—å­—ç¬¦ä¸²ï¼Œæœ¬ç« ä¸­ï¼Œè§£æå™¨å°†åå…¶é“è€Œè¡Œä¹‹ã€‚ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆä¸€ç³»åˆ—tokenï¼‰æˆ‘ä»¬å°†è¿™äº›token æ˜ å°„åˆ°è¯­æ³•è§„åˆ™ä¸­ï¼Œç¡®å®šå“ªäº›è§„åˆ™ï¼Œå¯ä»¥ç”Ÿæˆè¿™æ ·çš„å­—ç¬¦ä¸²ã€‚</p>
<p>â€å¯èƒ½æœ‰â€œ éƒ¨åˆ†ï¼ˆæ‰¾å‡ºåˆé€‚è¯­æ³•è§„åˆ™çš„è¿‡ç¨‹ï¼‰éå¸¸æœ‰æ„æ€ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥åˆ›å»ºä¸€ä¸ªå­˜åœ¨æ­§ä¹‰çš„è¯­æ³•è§„åˆ™ï¼Œä¸åŒçš„é€‰æ‹©ï¼Œå´å¯ä»¥ç”Ÿæˆç›¸åŒçš„å­—ç¬¦ä¸²ï¼Œå½“æˆ‘ä»¬ç¡®å®šäº†è¯­æ³•è§„åˆ™åï¼Œè¿™ä¸ªè¿‡ç¨‹å°†ä¸å†é‡è¦ï¼Œä¸€æ—¦æˆ‘ä»¬æœ‰äº†å­—ç¬¦ä¸²ï¼Œæ²¡æœ‰äººä¼šåœ¨ä¹æˆ‘ä»¬æ˜¯å¦‚ä½•ç”Ÿæˆå®ƒçš„ã€‚</p>
<p>When parsing, ambiguity means the parser may misunderstand the userâ€™s code. As we parse, we arenâ€™t just determining if the string is valid Lox code, weâ€™re also tracking which rules match which parts of it so that we know what part of the language each token belongs to. Hereâ€™s the Lox expression grammar we put together in the last chapter:</p>
<p>å½“è§£ææ—¶å€™ï¼Œæ­§ä¹‰æ„å‘³ç€è§£æå™¨å¯èƒ½ä¼šè¯¯è§£ç”¨æˆ·çš„ä»£ç ã€‚åœ¨è§£ææ—¶å€™ï¼Œæˆ‘ä»¬ä¸ä»…ä»…è¦ç¡®å®šï¼Œå­—ç¬¦ä¸²æ˜¯å¦æ˜¯ï¼Œæœ‰æ•ˆçš„loxè¯­è¨€ä»£ç ï¼Œè¿˜éœ€è¦è·Ÿè¸ªå“ªäº›è¯­æ³•è§„åˆ™å’Œå­—ç¬¦ä¸²çš„å“ªäº›éƒ¨åˆ†åŒ¹é…ï¼Œä¾¿äºæˆ‘ä»¬è·å–tokenå±äºå…·ä½“çš„å“ªä¸ªéƒ¨åˆ†ï¼Œä¸‹é¢æ˜¯æˆ‘ä»¬ä¹‹å‰æ€»ç»“çš„loxè¯­æ³•è§„åˆ™</p>
<pre><code>
expression     â†’ literal
               | unary
               | binary
               | grouping ;

literal        â†’ NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot; ;
grouping       â†’ &quot;(&quot; expression &quot;)&quot; ;
unary          â†’ ( &quot;-&quot; | &quot;!&quot; ) expression ;
binary         â†’ expression operator expression ;
operator       â†’ &quot;==&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot;
               | &quot;+&quot;  | &quot;-&quot;  | &quot;*&quot; | &quot;/&quot; ;
			   
</code></pre>
<p>This is a valid string in that grammar:</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/tokens.png?raw=true" alt="tokens" /></p>
<p>But there are two ways we could have generated it. One way is:</p>
<ol>
<li>
<p>Starting at expression, pick binary.</p>
</li>
<li>
<p>For the left-hand expression, pick NUMBER, and use 6.</p>
</li>
<li>
<p>For the operator, pick &quot;/&quot;.</p>
</li>
<li>
<p>For the right-hand expression, pick binary again.</p>
</li>
<li>
<p>In that nested binary expression, pick 3 - 1.</p>
</li>
</ol>
<p>Another is:</p>
<ol>
<li>
<p>Starting at expression, pick binary.</p>
</li>
<li>
<p>For the left-hand expression, pick binary again.</p>
</li>
<li>
<p>In that nested binary expression, pick 6 / 3.</p>
</li>
<li>
<p>Back at the outer binary, for the operator, pick &quot;-&quot;.</p>
</li>
<li>
<p>For the right-hand expression, pick NUMBER, and use 1.</p>
</li>
</ol>
<p>Those produce the same strings, but not the same syntax trees:</p>
<p>ä¸‹é¢ä¸€ä¸ªåˆæ³•çš„loxä»£ç ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸¤ç§æ–¹å¼ç”Ÿæˆ, ç”Ÿæˆçš„è¯­æ³•æ ‘å¦‚ä¸‹: </p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/syntax-trees.png?raw=true" alt="syntax-trees" /></p>
<p>In other words, the grammar allows seeing the expression as (6 / 3) - 1 or 6 / (3 - 1). The binary rule lets operands nest any which way you want. That in turn affects the result of evaluating the parsed tree. The way mathematicians have addressed this ambiguity since blackboards were first invented is by defining rules for precedence and associativity.</p>
<ul>
<li>
<p>Precedence </p>
<p>determines which operator is evaluated first in an expression containing a mixture of different operators. Precedence rules tell us that we evaluate the / before the - in the above example. Operators with higher precedence are evaluated before operators with lower precedence. Equivalently, higher precedence operators are said to â€œbind tighterâ€.</p>
</li>
<li>
<p>Associativity </p>
<p>determines which operator is evaluated first in a series of the same operator. When an operator is left-associative (think â€œleft-to-rightâ€), operators on the left evaluate before those on the right. Since - is left-associative, this expression:</p>
<p>Assignment, on the other hand, is right-associative. This:</p>
</li>
</ul>
<p>æ¢å¥è¯è¯´ï¼Œè¯­æ³•è§„åˆ™ï¼Œå¯ä»¥å°† </p>
<p><code>6/3-1</code> è§†ä¸º <code>(6/3)-1</code>  æˆ–è€… <code>6/(3-1)</code></p>
<p>äºŒå‰æ ‘å…è®¸æˆ‘ä»¬æŒ‰ç…§ä»»æ„çš„æ–¹å¼åµŒå¥—ï¼Œè€Œè¿™åˆä¼šåè¿‡æ¥å½±å“ï¼Œæˆ‘ä»¬çš„è§£æè¿‡ç¨‹ï¼Œè‡ªä»é»‘æ¿è¢«å‘æ˜å‡ºæ¥ï¼Œæ•°å­¦å®¶è§£å†³è¿™ä¸ªæ­§ä¹‰çš„æ–¹å¼æ˜¯ï¼šå®šä¹‰ä¼˜å…ˆçº§ï¼Œå…³è”æ€§è§„åˆ™ã€‚</p>
<ul>
<li>
<p>ä¼˜å…ˆçº§</p>
<p>ä¼˜å…ˆçº§ç¡®å®šäº†åŒ…å«ä¸åŒè¿ç®—ç¬¦çš„è¡¨è¾¾å¼ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆè®¡ç®—å“ªä¸ªè¿ç®—ç¬¦ã€‚ä¼˜å…ˆçº§è§„åˆ™å‘ŠçŸ¥æˆ‘ä»¬ï¼Œ/ ä¼˜å…ˆäº -ï¼Œ ä¼˜å…ˆçº§é«˜çš„è¿ç®—ç¬¦å…ˆè®¡ç®—ï¼›ç­‰ä»·çš„ï¼Œä¼˜å…ˆçº§è¾ƒé«˜çš„è¿ç®—ç¬¦ï¼Œå¯ä»¥ç§°ä¸ºç»‘å®šæ›´ç´§ã€‚</p>
</li>
<li>
<p>å…³è”æ€§</p>
<p>å…³è”æ€§å†³å®šäº†åœ¨ä¸€äº›ç›¸åŒä¼˜å…ˆçº§çš„è¿ç®—ç¬¦ä¸­ï¼Œå¦‚ä½•è®¡ç®—ã€‚å½“ä¸€ä¸ªæ“ä½œç¬¦æ˜¯å·¦å…³è”çš„ï¼ˆå³ä»å·¦å¾€å³è®¡ç®—ï¼‰ï¼Œå·¦è¾¹çš„è¿ç®—ç¬¦çš„ä¼šå…ˆè¢«è®¡ç®—ï¼Œå¦‚æœæ˜¯å·¦å…³è”ï¼Œä¸‹é¢çš„è¡¨è¾¾å¼ä¸€è‡´</p>
</li>
</ul>
<pre><code>
5-3-1

</code></pre>
<pre><code>
(5-3)-1

</code></pre>
<p>èµ‹å€¼æ“ä½œæ˜¯å³å…³è”çš„ï¼Œå³ä¸‹é¢çš„è¡¨è¾¾å¼ä¸€è‡´</p>
<pre><code>a = b = c

</code></pre>
<pre><code>a = (b = c)

</code></pre>
<blockquote>
<p>While not common these days, some languages specify that certain pairs of operators have no relative precedence. That makes it a syntax error to mix those operators in an expression without using explicit grouping.</p>
<p>Likewise, some operators are non-associative. That means itâ€™s an error to use that operator more than once in a sequence. For example, Perlâ€™s range operator isnâ€™t associative, so a .. b is OK, but a .. b .. c is an error.</p>
<p>è™½ç„¶ç°åœ¨ä¸å¸¸è§ï¼Œä½†æ˜¯æœ‰ä¸€äº›è¯­è¨€ï¼Œæ²¡æœ‰æŒ‡å®šè¿ç®—ç¬¦çš„ç›¸å¯¹ä¼˜å…ˆçº§ï¼Œå¦‚æœåœ¨ä¸€ä¸ªè¡¨è¾¾å¼ä¸­åŒ…å«ä¸åŒçš„è¿ç®—ç¬¦ï¼Œå¹¶ä¸”æ²¡æœ‰ä½¿ç”¨æ˜¾ç¤ºçš„åˆ†ç»„ï¼Œè§£æå™¨ä¼šæŠ¥é”™ï¼Œè¯­æ³•é”™è¯¯ã€‚</p>
<p>åŒæ ·ï¼Œæœ‰ä¸€äº›è¿ç®—ç¬¦æ˜¯éå…³è”çš„ã€‚è¿™æ„å‘³ç€ï¼Œåœ¨ä¸€ä¸ªåºåˆ—ä¸­ï¼Œå¤šæ¬¡ä½¿ç”¨è¯¥è¿ç®—ç¬¦æ˜¯é”™è¯¯çš„ï¼Œä¸¾ä¾‹: Perlè¯­è¨€ä¸­èŒƒå›´è¿ç®—ç¬¦æ˜¯éå…³è”çš„ï¼Œå³ 
a...b æ˜¯åˆæ³•çš„ï¼Œä½†æ˜¯ a...b...c æ˜¯éæ³•çš„</p>
</blockquote>
<p>Without well-defined precedence and associativity, an expression that uses multiple operators is ambiguousâ€”it can be parsed into different syntax trees, which could in turn evaluate to different results. Weâ€™ll fix that in Lox by applying the same precedence rules as C, going from lowest to highest.</p>
<p>å¦‚æœæ²¡æœ‰å®šä¹‰è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§å’Œå…³è”æ€§ï¼Œé‚£ä¹ˆä½¿ç”¨å¤šä¸ªè¿ç®—ç¬¦çš„è¡¨è¾¾å¼å¯èƒ½ä¼šå¼•èµ·æ­§ä¹‰ã€‚è¿™æ ·çš„è¡¨è¾¾å¼ï¼Œä¼šç”Ÿæˆä¸åŒçš„è¯­æ³•æ ‘ï¼Œæ‰§è¡Œè¿™äº›ä¸åŒçš„è¯­æ³•æ ‘ï¼Œä¼šäº§ç”Ÿä¸åŒçš„ç»“æœã€‚æˆ‘ä»¬å°†åœ¨Loxè¯­è¨€ä¸­ï¼Œå®šä¹‰å’ŒCè¯­è¨€ï¼Œç›¸åŒçš„è¿ç®—ç¬¦ä¼˜å…ˆçº§ã€‚ä¸‹é¢çš„ä¼˜å…ˆçº§ï¼Œä»ä½åˆ°é«˜</p>
<table><thead><tr><th>Name</th><th>Operators</th><th>Associates</th></tr></thead><tbody>
<tr><td>Equality</td><td>== !=</td><td>Left</td></tr>
<tr><td>Comparison</td><td>&gt; &gt;= &lt; &lt;=</td><td>Left</td></tr>
<tr><td>Term</td><td>+ -</td><td>Left</td></tr>
<tr><td>Factor</td><td>* /</td><td>Left</td></tr>
<tr><td>Unary</td><td>! -</td><td>Right</td></tr>
</tbody></table>
<p>Right now, the grammar stuffs all expression types into a single expression rule. That same rule is used as the non-terminal for operands, which lets the grammar accept any kind of expression as a subexpression, regardless of whether the precedence rules allow it.</p>
<p>ç°åœ¨ï¼Œè¯­æ³•è§„åˆ™å°†æ‰€æœ‰çš„è¡¨è¾¾å¼ç±»å‹ï¼Œå¡«å……åˆ°å•ä¸ªè¡¨è¾¾å¼è§„åˆ™ä¸­ã€‚ç›¸åŒçš„è§„åˆ™ï¼Œå¯ä»¥è¢«å½“ä½œæ“ä½œæ•°çš„éç»ˆæ­¢ç¬¦ï¼Œè¿™ä½¿å¾—è¯­æ³•å¯ä»¥æ¥å—ä»»ä½•ç±»å‹çš„è¡¨è¾¾å¼å½“ä½œå­è¡¨è¾¾å¼ï¼Œè€Œä¸ç®¡ä¼˜å…ˆçº§æ˜¯å¦å…è®¸ã€‚</p>
<p>We fix that by stratifying the grammar. We define a separate rule for each precedence level.</p>
<p>æˆ‘ä»¬é€šè¿‡è¯­æ³•åˆ†å±‚æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªä¼˜å…ˆçº§å®šä¹‰äº†ä¸“é—¨çš„è§„åˆ™ã€‚</p>
<pre><code>
expression     â†’ ...
equality       â†’ ...
comparison     â†’ ...
term           â†’ ...
factor         â†’ ...
unary          â†’ ...
primary        â†’ ...

</code></pre>
<blockquote>
<p>Instead of baking precedence right into the grammar rules, some parser generators let you keep the same ambiguous-but-simple grammar and then add in a little explicit operator precedence metadata on the side in order to disambiguate.</p>
<p>æœ‰ä¸€äº›è§£æç”Ÿæˆå™¨ï¼Œæ²¡æœ‰å°†ä¼˜å…ˆçº§æ­£ç¡®çš„æ·»åŠ åˆ°è¯­æ³•è§„åˆ™ä¸­ï¼Œè€Œæ˜¯è®©ä½ ä¿æŒç›¸åŒçš„æ¨¡ç³Šä½†æ˜¯ç®€å•çš„è¯­æ³•ï¼Œç„¶ååœ¨æ—è¾¹æ·»åŠ ä¸€äº›æ˜¾å¼çš„è¿ç®—ç¬¦ä¼˜å…ˆçº§å…ƒæ•°æ®ï¼Œç”¨äºæ¶ˆé™¤æ­§ä¹‰ã€‚</p>
</blockquote>
<p>Each rule here only matches expressions at its precedence level or higher. For example, unary matches a unary expression like !negated or a primary expression like 1234. And term can match 1 + 2 but also 3 * 4 / 5. The final primary rule covers the highest-precedence formsâ€”literals and parenthesized expressions.</p>
<p>We just need to fill in the productions for each of those rules. Weâ€™ll do the easy ones first. The top expression rule matches any expression at any precedence level. Since equality has the lowest precedence, if we match that, then it covers everything.</p>
<p>ä¸Šé¢çš„è§„åˆ™ï¼Œåªä¼šåŒ¹é…ç›¸åŒæˆ–æ›´é«˜ä¼˜å…ˆçº§çš„è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼š</p>
<p>ä¸€å…ƒ ç±»å‹è¡¨è¾¾å¼å¯ä»¥åŒ¹é…ä¸€ä¸ªç›¸åŒä¼˜å…ˆçº§çš„è¡¨è¾¾å¼ !unary æˆ–è€… åƒ 1234 è¿™æ ·çš„ä¸»è¡¨è¾¾å¼</p>
<p>æœ¯è¯­è¡¨è¾¾å¼å¯ä»¥åŒ¹é… 1+2  æˆ–è€… 3*4/5 è¿™æ ·çš„è¡¨è¾¾å¼</p>
<p>æœ€åçš„è§„åˆ™ï¼Œå³å®šä¹‰äº†ä¸»è§„åˆ™æ‹¥æœ‰æœ€é«˜çš„ä¼˜å…ˆçº§ï¼Œä¸»è§„åˆ™åŒ¹é…çš„ç±»å‹ä¸ºæ–‡å­—è¡¨è¾¾å¼å’Œæ‹¬å·è¡¨è¾¾å¼</p>
<p>æˆ‘ä»¬è¿™éœ€è¦å¡«å……æ¯ä¸€ä¸ªè§„åˆ™ï¼Œè®©æˆ‘ä»¬å…ˆä»æœ€ç®€å•çš„å¼€å§‹ã€‚é¡¶çº§è¡¨è¾¾å¼å¯ä»¥åŒ¹é…ä»»ä½•ä¼˜å…ˆçº§çš„è¡¨è¾¾å¼ï¼Œå› ä¸ºç›¸ç­‰æ˜¯æœ€ä½ä¼˜å…ˆçº§çš„è¡¨è¾¾å¼ï¼Œå¦‚æœæˆ‘ä»¬åŒ¹é…åˆ°å®ƒï¼Œæˆ‘ä»¬å°†è¦†ç›–æ‰€æœ‰</p>
<pre><code>
expression     â†’ equality

</code></pre>
<blockquote>
<p>We could eliminate expression and simply use equality in the other rules that contain expressions, but using expression makes those other rules read a little better.</p>
<p>Also, in later chapters when we expand the grammar to include assignment and logical operators, weâ€™ll only need to change the production for expression instead of touching every rule that contains an expression.</p>
<p>æˆ‘ä»¬å¯ä»¥å–æ¶ˆç›¸ç­‰è¡¨è¾¾å¼ï¼Œåœ¨å…¶ä»–è¯­æ³•è§„åˆ™ä¸­ï¼ŒåŒ…å«ç­‰å¼ï¼Œä½†æ˜¯ï¼Œä½¿ç”¨ç­‰å¼è¡¨è¾¾å¼ï¼Œå¯ä»¥è®©å…¶ä»–è¯­æ³•è§„åˆ™æ›´åŠ å®¹æ˜“ç†è§£ã€‚</p>
<p>æ­¤å¤–ï¼Œåœ¨åé¢çš„ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¼šæ‰©å±•è¯­æ³•ï¼ŒåŒ…å«èµ‹å€¼ã€é€»è¾‘è¿ç®—ç¬¦ï¼Œæˆ‘ä»¬åªéœ€è¦ä¿®æ”¹ç­‰å¼è¡¨è¾¾å¼çš„å®šä¹‰ï¼Œä¸éœ€è¦ä¿®æ”¹æ¯ä¸€æ¡å…¶ä»–è¯­æ³•è§„åˆ™ã€‚</p>
</blockquote>
<p>Over at the other end of the precedence table, a primary expression contains all the literals and grouping expressions.</p>
<p>åœ¨ä¼˜å…ˆçº§è¡¨æ ¼çš„å¦å¤–ä¸€è¾¹ï¼Œä¸»è¡¨è¾¾å¼åŒ…å«æ–‡æœ¬å’Œæ‹¬å·è¡¨è¾¾å¼</p>
<pre><code>
primary        â†’ NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
               | &quot;(&quot; expression &quot;)&quot; ;

</code></pre>
<p>A unary expression starts with a unary operator followed by the operand. Since unary operators can nestâ€”!!true is a valid if weird expressionâ€”the operand can itself be a unary operator. A recursive rule handles that nicely.</p>
<p>ä¸€å…ƒè¡¨è¾¾å¼æ˜¯ä»¥ä¸€å…ƒè¿ç®—ç¬¦å¼€å§‹ï¼Œåé¢è·Ÿéšæ“ä½œæ•°ã€‚å› ä¸ºä¸€å…ƒè¿ç®—ç¬¦å¯ä»¥åµŒå¥— - ï¼</p>
<p>ä¾‹å¦‚: !true æ˜¯ä¸€ä¸ªå¥‡æ€ªä½†æ˜¯æœ‰æ•ˆçš„è¡¨è¾¾å¼ï¼Œ</p>
<p>æˆ‘ä»¬ä½¿ç”¨é€’å½’è§„åˆ™å¯ä»¥å¾ˆå¥½çš„å¤„ç†</p>
<pre><code>
unary          â†’ ( &quot;!&quot; | &quot;-&quot; ) unary ;

</code></pre>
<p>But this rule has a problem. It never terminates.</p>
<p>Remember, each rule needs to match expressions at that precedence level or higher, so we also need to let this match a primary expression.</p>
<p>ä½†æ˜¯ä¸€å…ƒè¡¨è¾¾å¼è§„åˆ™ï¼Œæœ‰ä¸ªé—®é¢˜ï¼Œå®ƒå¯èƒ½æ°¸è¿œä¸ä¼šç»ˆæ­¢ã€‚è¯·è®°ä½ï¼Œæ¯ä¸€ä¸ªè§„åˆ™åŒ¹é…ä¼˜å…ˆçº§ç›¸åŒæˆ–è€…æ›´é«˜çš„è¡¨è¾¾å¼ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åŒ¹é…ä¸»è¡¨è¾¾å¼</p>
<pre><code class="language-C">
unary          â†’ ( &quot;!&quot; | &quot;-&quot; ) unary
               | primary ;

</code></pre>
<p>That works.</p>
<p>ä¸Šé¢çš„è§„åˆ™ç”Ÿæ•ˆäº†ã€‚</p>
<p>The remaining rules are all binary operators. Weâ€™ll start with the rule for multiplication and division. Hereâ€™s a first try:</p>
<p>å…¶ä½™è§„åˆ™éƒ½æ˜¯äºŒå…ƒè¿ç®—ç¬¦ï¼Œæˆ‘ä»¬é¦–å…ˆä»ä¹˜æ³•å’Œé™¤æ³•å¼€å§‹ï¼Œä¸‹é¢æ˜¯ç¬¬ä¸€æ¬¡å°è¯•</p>
<pre><code class="language-c">
factor         â†’ factor ( &quot;/&quot; | &quot;*&quot; ) unary
               | unary ;
			   
</code></pre>
<p>The rule recurses to match the left operand. That enables the rule to match a series of multiplication and division expressions like 1 * 2 / 3. Putting the recursive production on the left side and unary on the right makes the rule left-associative and unambiguous.</p>
<p>All of this is correct, but the fact that the first symbol in the body of the rule is the same as the head of the rule means this production is left-recursive. Some parsing techniques, including the one weâ€™re going to use, have trouble with left recursion. (Recursion elsewhere, like we have in unary and the indirect recursion for grouping in primary are not a problem.)</p>
<p>è¯¥è§„åˆ™ä¼šä»¥å·¦å…³è”ï¼Œé€’å½’è°ƒç”¨ï¼Œè¿™æ ·ï¼Œè¿™æ¡è¯­æ³•è§„åˆ™ï¼Œå°†ä¼šäº§ç”Ÿä¸€ç³»åˆ—çš„ä¹˜æ³•é™¤æ³•è¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼š1*2/3</p>
<p>æˆ‘ä»¬å°†é€’å½’æ”¾åœ¨å·¦ä¾§ï¼Œä¸€å…ƒè¿ç®—è§„åˆ™æ”¾åœ¨å³ä¾§ï¼Œæ˜¯ä¸ºäº†ä½¿å¾—è¯¥è§„åˆ™å·¦å…³è”ï¼Œä»¥ç¡®ä¿è§„åˆ™æ˜¯æ˜ç¡®æ²¡æœ‰æ­§ä¹‰çš„</p>
<p>æ‰€æœ‰è¿™ä¸€åˆ‡éƒ½æ˜¯æ­£ç¡®çš„ï¼Œå½“è§„åˆ™æ­£æ–‡ä¸­çš„ç¬¬ä¸€ä¸ªç¬¦å·å’Œè§„åˆ™æ ‡é¢˜ç›¸åŒçš„æ—¶å€™ï¼Œæ„å‘³ç€è¿™ä¸ªè§„åˆ™æ˜¯å·¦é€’å½’çš„ï¼Œæœ‰ä¸€äº›è§£ææŠ€æœ¯ï¼ŒåŒ…æ‹¬æˆ‘ä»¬å°†è¦ä½¿ç”¨çš„æŠ€æœ¯ï¼Œåœ¨è§£æå·¦é€’å½’æ–¹é¢å­˜åœ¨ä¸€äº›é—®é¢˜ã€‚å…¶ä»–åœ°æ–¹çš„é€’å½’ï¼Œä¾‹å¦‚ï¼šä¸€å…ƒä¸­çš„é€’å½’ï¼Œä»¥åŠåœ¨ä¸»è¡¨è¾¾å¼ä¸­ç”¨äºåˆ†ç»„çš„é—´æ¥é€’å½’éƒ½ä¸æ˜¯é—®é¢˜</p>
<blockquote>
<p>In principle, it doesnâ€™t matter whether you treat multiplication as left- or right-associativeâ€”you get the same result either way. Alas, in the real world with limited precision, roundoff and overflow mean that associativity can affect the result of a sequence of multiplications. Consider:</p>
<p><code>print 0.1 * (0.2 * 0.3);</code></p>
<p><code>print (0.1 * 0.2) * 0.3;</code></p>
<p>In languages like Lox that use <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">IEEE 754</a> double-precision floating-point numbers, the first evaluates to 0.006, while the second yields <code>0.006000000000000001</code>.</p>
<p>Sometimes that tiny difference matters. This is a good place to learn more.</p>
<p>åŸåˆ™ä¸Šï¼Œæ— è®ºæˆ‘ä»¬å°†ä¹˜æ³•ï¼Œè®¾ç½®ä¸ºå·¦å…³è”/å³å…³è”ï¼Œç»“æœéƒ½æ˜¯ç›¸åŒçš„ï¼Œä½†å®é™…ä¸Šï¼Œåœ¨ç°å®ä¸–ç•Œä¸­ï¼Œæ•°å€¼å‹è®¡ç®—ä¼šæœ‰æº¢å‡ºå’Œèˆå…¥ï¼Œä¾‹å¦‚:</p>
<p>åœ¨Loxè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬éµå®ˆ IEEE 754åŒç²¾åº¦è§„åˆ™ï¼Œç¬¬ä¸€ä¸ªè¡¨è¾¾å¼è®¡ç®—ç»“æœæ˜¯ 0.006, ç¬¬äºŒä¸ªè¡¨è¾¾å¼è®¡ç®—ç»“æœæ˜¯ 0.006000000000000001</p>
<p>æœ‰æ—¶å€™ï¼Œè¿™ä¸ªå¾®å°çš„å·®åˆ«éå¸¸é‡è¦ï¼Œéœ€è¦æ³¨æ„</p>
</blockquote>
<p>There are many grammars you can define that match the same language. The choice for how to model a particular language is partially a matter of taste and partially a pragmatic one. This rule is correct, but not optimal for how we intend to parse it. Instead of a left recursive rule, weâ€™ll use a different one.</p>
<p>æˆ‘ä»¬å¯ä»¥å®šä¹‰è®¸å¤šè¯­æ³•ï¼Œå’ŒåŒä¸€ä¸ªè¯­è¨€ç›¸åŒ¹é…ã€‚å¦‚æœä¸ºä¸€é—¨è¯­è¨€å»ºæ¨¡ï¼Œä¸€éƒ¨åˆ†å–å†³äºç¼–ç¨‹å“å‘³ï¼Œä¸€éƒ¨åˆ†å–å†³äºåº”ç”¨ã€‚è¿™ä¸ªè§„åˆ™æ˜¯æ­£ç¡®çš„ï¼Œä½†æ˜¯ï¼Œå¯¹äºæˆ‘ä»¬å¦‚ä½•è§£æå®ƒæ¥è¯´ä¸æ˜¯æœ€ä½³çš„ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ–°çš„è§„åˆ™ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å·¦é€’å½’è§„åˆ™</p>
<pre><code class="language-c">
factor         â†’ unary ( ( &quot;/&quot; | &quot;*&quot; ) unary )* ;

</code></pre>
<p>We define a factor expression as a flat sequence of multiplications and divisions. This matches the same syntax as the previous rule, but better mirrors the code weâ€™ll write to parse Lox. We use the same structure for all of the other binary operator precedence levels, giving us this complete expression grammar:</p>
<p>æˆ‘ä»¬å°†å› å­è¡¨è¾¾å¼å®šä¹‰ä¸ºä¹˜æ³•å’Œé™¤æ³•æ··åˆçš„å¹³é¢çš„åºåˆ—ã€‚è¿™ä¸ªè§„åˆ™å’Œå‰é¢çš„è§„åˆ™ï¼ŒåŒ¹é…ç›¸åŒçš„è¯­æ³•ï¼Œä½†æ˜¯ï¼Œæ›´å¥½çš„åæ˜ äº†æˆ‘ä»¬å°†è¦ç¼–å†™çš„è§£æLoxçš„ä»£ç ã€‚æˆ‘ä»¬å¯¹æ‰€æœ‰çš„å…¶ä»–äºŒå…ƒè¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼Œä½¿ç”¨ç›¸åŒç»“æ„ï¼Œä»è€Œï¼Œæˆ‘ä»¬å°†è·å¾—å®Œæ•´çš„è¡¨è¾¾å¼è¯­æ³•</p>
<pre><code class="language-C">
expression -&gt; equality;

equality -&gt; comparison (( &quot;!=&quot; | &quot;==&quot; ) comparison )* ;

comparison -&gt; term ( ( &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; ) term)* ;

term           â†’ factor ( ( &quot;-&quot; | &quot;+&quot; ) factor )* ;

factor         â†’ unary ( ( &quot;/&quot; | &quot;*&quot; ) unary )* ;

unary          â†’ ( &quot;!&quot; | &quot;-&quot; ) unary
	           | primary ;
			   
primary        â†’ NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
	           | &quot;(&quot; expression &quot;)&quot; ;
			   
</code></pre>
<p>This grammar is more complex than the one we had before, but in return we have eliminated the previous oneâ€™s ambiguity. Itâ€™s just what we need to make a parser.</p>
<p>ä¸Šé¢çš„è¯­æ³•è§„åˆ™ï¼Œæ¯”æˆ‘ä»¬ä¹‹å‰çš„è¯­æ³•è§„åˆ™æ›´åŠ å¤æ‚ï¼Œä½†æ˜¯ä½œä¸ºå›æŠ¥ï¼Œæˆ‘ä»¬æ¶ˆé™¤äº†ä¹‹å‰çš„æ­§ä¹‰ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„è§£æå™¨ã€‚</p>
<h2 id="äºŒrecursive-descent-parsing"><a class="header" href="#äºŒrecursive-descent-parsing">äºŒã€Recursive Descent Parsing</a></h2>
<p>é€’å½’ä¸‹é™åˆ†æ</p>
<p>There is a whole pack of parsing techniques whose names are mostly combinations of â€œLâ€ and â€œRâ€â€”LL(k), LR(1), LALRâ€”along with more exotic beasts like parser combinators, Earley parsers, the shunting yard algorithm, and packrat parsing. For our first interpreter, one technique is more than sufficient: recursive descent.</p>
<p>Recursive descent is the simplest way to build a parser, and doesnâ€™t require using complex parser generator tools like Yacc, Bison or ANTLR. All you need is straightforward handwritten code. Donâ€™t be fooled by its simplicity, though. Recursive descent parsers are fast, robust, and can support sophisticated error handling. In fact, GCC, V8 (the JavaScript VM in Chrome), Roslyn (the C# compiler written in C#) and many other heavyweight production language implementations use recursive descent. It rocks.</p>
<p>Recursive descent is considered a top-down parser because it starts from the top or outermost grammar rule (here expression) and works its way down into the nested subexpressions before finally reaching the leaves of the syntax tree. This is in contrast with bottom-up parsers like LR that start with primary expressions and compose them into larger and larger chunks of syntax.</p>
<p>æœ‰ä¸€æ•´å¥—çš„è§£ææŠ€æœ¯ï¼Œå…¶åç§°å¤§å¤šæ˜¯L R çš„ç»„åˆâ€”â€”<a href="https://en.wikipedia.org/wiki/LL_parser">LL(k)</a> , <a href="https://en.wikipedia.org/wiki/LR_parser">LR(1)</a> , <a href="https://en.wikipedia.org/wiki/LALR_parser">LALR</a>, æ­¤å¤–ï¼Œè¿˜æœ‰ä¸€äº›æ›´å¥‡ç‰¹çš„ç»„åˆï¼Œ<a href="https://en.wikipedia.org/wiki/Parser_combinator">è¯­æ³•åˆ†æç»„åˆå­ parser combinators</a>, <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parser</a>, <a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95">è°ƒåº¦åœºç®—æ³• the shunting yard algorithm</a>, <a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E6%96%87%E6%B3%95">è§£æè¡¨è¾¾æ–‡æ³• packrat parsing</a>ã€‚ ä½†æ˜¯å¯¹äºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªè§£æå™¨ï¼Œä½¿ç”¨ä¸€ç§æŠ€å·§å°±è¶³å¤Ÿäº†: é€’å½’ä¸‹é™åˆ†æ</p>
<p>é€’å½’ä¸‹é™æ˜¯æ„é€ è§£æå™¨çš„æœ€ç®€å•æ–¹æ³•ï¼Œè€Œä¸”æˆ‘ä»¬ä¸éœ€è¦ä½¿ç”¨ yacc, Bison, ANTLR è¿™æ ·çš„ç”Ÿæˆå™¨å·¥å…·ã€‚æˆ‘ä»¬éœ€è¦çš„ä»…ä»…æ˜¯ç®€å•çš„æ‰‹å†™ä»£ç ï¼Œä½†æ˜¯ï¼Œä¸è¦è¢«å®ƒçš„ç®€å•æ‰€è¿·æƒ‘ã€‚é€’å½’ä¸‹é™çš„è§£æå™¨ï¼Œé€Ÿåº¦å¿«ï¼Œä»£ç å¥å£®ï¼Œå¯ä»¥æ”¯æŒå¤æ‚çš„é”™è¯¯å¤„ç†ã€‚äº‹å®ä¸Šï¼Œå¾ˆå¤šé‡é‡çº§çš„è§£æå™¨ï¼Œéƒ½æ˜¯ç”¨é€’å½’ä¸‹é™åˆ†æï¼Œä¾‹å¦‚ï¼šGCCï¼Œ V8ï¼ˆchromeä¸­JavaScriptçš„VMï¼‰ï¼ŒRoslynï¼ˆC#ç¼–å†™çš„C#ç¼–è¯‘å™¨ï¼‰</p>
<p>é€’å½’ä¸‹é™è¢«è®¤ä¸ºæ˜¯ä¸€ç§è‡ªé¡¶å‘ä¸‹çš„è§£æå™¨ï¼Œå› ä¸ºå®ƒæ˜¯ä»æœ€ä¸Šé¢æˆ–è€…æœ€å¤–é¢çš„è¯­æ³•è§„åˆ™ï¼ˆä¸Šæ–‡ä¸­çš„ expressionè§„åˆ™ï¼‰å¼€å§‹ï¼Œä¸€ç›´å‘ä¸‹åˆ°åµŒå¥—çš„å­è¡¨è¾¾å¼ï¼Œæœ€ååˆ°è¾¾ï¼Œè¯­æ³•æ ‘çš„å¶å­èŠ‚ç‚¹ï¼Œè¿™ä¸è‡ªåº•å‘ä¸Šçš„è§£æå™¨ï¼Œå½¢æˆå¯¹æ¯”ã€‚ä¾‹å¦‚ï¼šè‡ªåº•å‘ä¸Šçš„è§£æå™¨LRï¼Œä¼šä»æœ€åº•å±‚çš„ primaryå¼€å§‹ï¼Œç„¶åï¼Œä¸€ç›´ç»„åˆå­è¡¨è¾¾å¼ï¼Œè¯­æ³•å—è¶Šæ¥è¶Šå¤§ã€‚</p>
<blockquote>
<p>Itâ€™s called â€œrecursive descentâ€ because it walks down the grammar. Confusingly, we also use direction metaphorically when talking about â€œhighâ€ and â€œlowâ€ precedence, but the orientation is reversed. In a top-down parser, you reach the lowest-precedence expressions first because they may in turn contain subexpressions of higher precedence.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/direction.png?raw=true" alt="direction" /></p>
<p>CS people really need to get together and straighten out their metaphors. Donâ€™t even get me started on which direction a stack grows or why trees have their roots on top.</p>
<p>è¿™ç§è§£ææŠ€æœ¯ï¼Œè¢«ç§°ä¸ºé€’å½’ä¸‹é™ï¼Œå› ä¸ºå®ƒéµå¾ªè¿™è¯­æ³•ï¼Œä»¤äººå›°æƒ‘çš„æ˜¯ï¼Œå½“æˆ‘ä»¬è°ˆè®ºä¼˜å…ˆçº§çš„é«˜ä½æ—¶å€™ï¼Œæˆ‘ä»¬ä¹Ÿä¼šä½¿ç”¨æ–¹å‘æ¥æ¯”å–»ï¼Œä½†æ˜¯æ–¹å‘ç›¸åã€‚åœ¨è‡ªä¸Šè€Œä¸‹çš„è§£æå™¨ä¸­ï¼Œæˆ‘ä»¬å°†é¦–å…ˆåˆ°è¾¾ä¼˜å…ˆçº§æœ€ä½çš„è¡¨è¾¾å¼ï¼Œå› ä¸ºä¼˜å…ˆçº§ä½çš„è¡¨è¾¾å¼ä¸­ï¼Œå¯èƒ½åŒ…å«ç€ä¼˜å…ˆçº§è¾ƒé«˜çš„å­è¡¨è¾¾å¼</p>
<p>è®¡ç®—æœºç§‘å­¦é¢†åŸŸï¼ŒçœŸçš„éœ€è¦ç»Ÿä¸€ä¸€ä¸‹è¡¨è¿°ã€‚ç”šè‡³ï¼Œä¸è¦è®©æˆ‘ä¸€å¼€å§‹åœ¨äº†è§£è¯­æ³•æ ‘æ–¹å‘æ—¶å€™ï¼Œå°±å›°æƒ‘ï¼Œä¸ºä»€ä¹ˆæ ‘æ ¹åœ¨æœ€ä¸Šé¢ã€‚</p>
</blockquote>
<p>A recursive descent parser is a literal translation of the grammarâ€™s rules straight into imperative code. Each rule becomes a function. The body of the rule translates to code roughly like:</p>
<table><thead><tr><th>Grammar notation</th><th>Code representation</th></tr></thead><tbody>
<tr><td>Terminal</td><td>Code to match and consume a token</td></tr>
<tr><td>Nonterminal</td><td>Call to that ruleâ€™s function</td></tr>
<tr><td></td><td></td></tr>
<tr><td>* or +</td><td>while or for loop</td></tr>
<tr><td>?</td><td>if statement</td></tr>
</tbody></table>
<p>The descent is described as â€œrecursiveâ€ because when a grammar rule refers to itselfâ€”directly or indirectlyâ€”that translates to a recursive function call.</p>
<p>é€’å½’ä¸‹é™è§£æå™¨æ˜¯å°†è¯­æ³•è§„åˆ™ç›´æ¥ç¿»è¯‘ä¸ºå‘½ä»¤å¼ä»£ç çš„ç›´è¯‘ï¼Œæ¯ä¸ªè§„åˆ™éƒ½æˆä¸ºä¸€ä¸ªå‡½æ•°ï¼Œè§„åˆ™çš„è½¬æ¢å¯ä»¥å‚è€ƒï¼š</p>
<p>ä¸‹é™å°†è¢«æè¿°ä¸ºâ€œé€’å½’â€ï¼Œå› ä¸ºå½“è¯­æ³•è§„åˆ™ç›´æ¥æˆ–è€…é—´æ¥çš„å¼•ç”¨è‡ªèº«æ—¶å€™ï¼Œå®ƒä¼šè½¬åŒ–ä¸ºé€’å½’å‡½æ•°è°ƒç”¨</p>
<h3 id="21-the-parser-class"><a class="header" href="#21-the-parser-class">2.1 The parser class</a></h3>
<p>è§£æç±»</p>
<p>Each grammar rule becomes a method inside this new class:</p>
<p>æ¯ä¸ªè¯­æ³•è§„åˆ™éƒ½ä¼šå˜ä¸ºè§£æç±»ä¸­çš„ä¸€ä¸ªæ–¹æ³•</p>
<pre><code class="language-java">
// lox/Parser.java, create new file


package com.craftinginterpreters.lox;

import java.util.List;

import static com.craftinginterpreters.lox.TokenType.*;

class Parser {
  private final List&lt;Token&gt; tokens;
  private int current = 0;

  Parser(List&lt;Token&gt; tokens) {
    this.tokens = tokens;
  }
}

</code></pre>
<p>Like the scanner, the parser consumes a flat input sequence, only now weâ€™re reading tokens instead of characters. We store the list of tokens and use current to point to the next token eagerly waiting to be parsed.</p>
<p>å’Œæ‰«æå™¨ä¸€æ ·ï¼Œè§£æå™¨ä½¿ç”¨è¾“å…¥çš„åºåˆ—ï¼Œåªä¸è¿‡æˆ‘ä»¬ä»æ‰«æå™¨çš„å­—ç¬¦åºåˆ—ï¼Œå˜ä¸ºäº†è§£æå™¨çš„tokenåºåˆ—ï¼Œåœ¨ç±»ä¸­ï¼Œæˆ‘ä»¬ä¼šå­˜å‚¨ tokenåºåˆ—ï¼Œå¹¶ä¸”ä½¿ç”¨ current, è¡¨ç¤ºä¸‹ä¸€ä¸ªç­‰å¾…è§£æçš„token</p>
<p>Weâ€™re going to run straight through the expression grammar now and translate each rule to Java code. The first rule, expression, simply expands to the equality rule, so thatâ€™s straightforward.</p>
<p>ç°åœ¨ï¼Œæˆ‘ä»¬å°†ç›´æ¥è¿è¡Œè¡¨è¾¾å¼è¯­æ³•ï¼Œå¹¶å°†æ¯ä¸ªè¯­æ³•è§„åˆ™è½¬ä¸ºJava ä»£ç ï¼Œç¬¬ä¸€æ¡è§„åˆ™ï¼Œè¡¨è¾¾å¼ï¼Œç®€å•çš„æ‰©å±•ä¸ºç­‰å¼è§„åˆ™ï¼Œæ‰€ä»¥è¿™ä¸ªéå¸¸ç®€å•</p>
<pre><code class="language-java">
// lox/Parser.java, add after Parser()

  private Expr expression() {
    return equality();
  }
  
</code></pre>
<p>Each method for parsing a grammar rule produces a syntax tree for that rule and returns it to the caller. When the body of the rule contains a nonterminalâ€”a reference to another ruleâ€”we call that other ruleâ€™s method.</p>
<p>The rule for equality is a little more complex.</p>
<p>æ¯ä¸€ä¸ªè¯­æ³•è§„åˆ™è§£ææ–¹æ³•ï¼Œéƒ½ä¸ºè¯¥è¯­æ³•è§„åˆ™ç”Ÿæˆä¸€ä¸ªè¯­æ³•æ ‘ï¼Œå¹¶ä¸”å°†è¯­æ³•æ ‘ï¼Œè¿”å›ç»™è°ƒç”¨è€…ï¼Œå½“è§„åˆ™ä¸­åŒ…å«æœ‰ä¸€ä¸ªéç»ˆæ­¢ç¬¦æ—¶å€™â€”â€”å¯¹å¦ä¸€ä¸ªè§„åˆ™çš„å¼•ç”¨ï¼Œæˆ‘ä»¬å°†è°ƒç”¨å¦å¤–ä¸€ä¸ªè§„åˆ™ã€‚</p>
<blockquote>
<p>This is why left recursion is problematic for recursive descent. The function for a left-recursive rule immediately calls itself, which calls itself again, and so on, until the parser hits a stack overflow and dies.</p>
<p>è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå·¦é€’å½’ï¼Œå¯¹äºé€’å½’ä¸‹é™æ˜¯æœ‰é—®é¢˜çš„åŸå› ï¼Œå·¦é€’å½’è¯­æ³•è§„åˆ™ï¼Œå°†ä¼šç«‹å³è°ƒç”¨è‡ªèº«ï¼Œç„¶åä¸€ç›´æ— é™å¾ªç¯ï¼Œç›´åˆ°è§£æå™¨é‡åˆ°å †æ ˆæº¢å‡ºï¼Œç¨‹åºå´©æºƒ</p>
</blockquote>
<p>ä¸‹é¢ç­‰å¼çš„è§„åˆ™æœ‰äº›å¤æ‚</p>
<pre><code>
equality       â†’ comparison ( ( &quot;!=&quot; | &quot;==&quot; ) comparison )* ;

</code></pre>
<p>In Java, that becomes:</p>
<p>ä½¿ç”¨ Javaå®ç°ï¼Œå˜ä¸ºï¼š</p>
<pre><code class="language-java">
// lox/Parser.java, add after expression()

  private Expr equality() {
    Expr expr = comparison();

    while (match(BANG_EQUAL, EQUAL_EQUAL)) {
      Token operator = previous();
      Expr right = comparison();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }


</code></pre>
<p>Letâ€™s step through it. The first comparison nonterminal in the body translates to the first call to comparison() in the method. We take that result and store it in a local variable.</p>
<p>Then, the ( ... )* loop in the rule maps to a while loop. We need to know when to exit that loop. We can see that inside the rule, we must first find either a != or == token. So, if we donâ€™t see one of those, we must be done with the sequence of equality operators. We express that check using a handy match() method.</p>
<p>è®©æˆ‘ä»¬é€ä¸€äº†è§£ï¼Œè¯­æ³•è§„åˆ™ä¸­çš„ comparison éç»ˆæ­¢ç¬¦ï¼Œå°†å˜ä¸ºè§£æç±»ä¸­çš„ä¸€ä¸ªæ–¹æ³•â€”â€” comparison(), æˆ‘ä»¬å°†è°ƒç”¨ comparison() ï¼Œå¹¶ä¸”è¿”å›ç»“æœï¼Œå­˜å‚¨åœ¨å±€éƒ¨å˜é‡ä¸­ã€‚</p>
<p>æ¥ä¸‹æ¥ï¼Œè¯­æ³•è§„åˆ™ä¸­çš„ ( ... ) * å¾ªç¯å°†å˜ä¸ºJavaä»£ç ä¸­çš„ while å¾ªç¯ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“ä»€ä¹ˆæ—¶å€™ï¼Œé€€å‡ºå¾ªç¯ï¼Œä»è¯­æ³•è§„åˆ™ä¸­ï¼Œå¯ä»¥å‘ç°ï¼Œæˆ‘ä»¬éœ€è¦å…ˆæ‰¾åˆ°ä¸€ä¸ª != æˆ–è€…  == çš„ token, æ‰€ä»¥ï¼Œå¦‚æœæˆ‘ä»¬çœ‹ä¸åˆ° == æˆ–è€… != , æˆ‘ä»¬å¿…é¡»å¯¹ç­‰å¼è¿ç®—ç¬¦åºåˆ—è¿›è¡Œå¤„ç†ï¼Œæˆ‘ä»¬å°†ç®€å•çš„ä½¿ç”¨ä¸€ä¸ªmatch() å‡½æ•°ï¼Œå®ç°è¯¥æ£€æŸ¥</p>
<pre><code class="language-java">
// lox/Parser.java, add after equality()

  private boolean match(TokenType... types) {
    for (TokenType type : types) {
      if (check(type)) {
        advance();
        return true;
      }
    }

    return false;
  }
  
</code></pre>
<p>This checks to see if the current token has any of the given types. If so, it consumes the token and returns true. Otherwise, it returns false and leaves the current token alone. The match() method is defined in terms of two more fundamental operations.</p>
<p>The check() method returns true if the current token is of the given type. Unlike match(), it never consumes the token, it only looks at it.</p>
<p>The advance() method consumes the current token and returns it, similar to how our scannerâ€™s corresponding method crawled through characters.</p>
<p>These methods bottom out on the last handful of primitive operations.</p>
<p>è¿™ä¸ªmatch()å‡½æ•°ï¼Œå°†æ£€æŸ¥å½“å‰çš„tokenï¼Œæ˜¯å¦æ˜¯å‚æ•°ä¸­çš„tokenç±»å‹ï¼Œå¦‚æœå½“å‰tokenæ»¡è¶³ç»™å®šçš„ç±»å‹ï¼Œå°†è¿”å› true, å¦åˆ™ï¼Œå°†è¿”å›falseï¼Œå¹¶ä¸”ä¿ç•™åœ¨å½“å‰çš„ä½ç½®ï¼Œmatch() å‡½æ•°ä¸­ï¼Œå°†ä¼šè°ƒç”¨å…¶ä»–ä¸¤ä¸ªå‡½æ•° check() , advance()</p>
<p>å¦‚æœå½“å‰çš„tokenç¬¦åˆç»™å®šçš„ tokenç±»å‹ï¼Œcheck() æ–¹æ³•å°†è¿”å›trueï¼Œ ä¸match() æ–¹æ³•ä¸ä¸€æ ·ï¼Œcheck()æ–¹æ³•ï¼Œä¸ä¼šå‰ç§»tokenï¼ˆåŠå‘ç°æ»¡è¶³æ¡ä»¶åï¼Œcurrentå‰ç§»ä¸€ä½ï¼‰ï¼Œåªä¼šæ£€æŸ¥tokenç±»å‹</p>
<p>advance() æ–¹æ³•ä½¿ç”¨currentä½ç½®çš„tokenï¼Œå¹¶ä¸”è¿”å›ï¼Œç±»ä¼¼äºæˆ‘ä»¬åœ¨æ‰«æå™¨ä¸­ï¼Œå¯¹åº”çš„å­—ç¬¦çº§åˆ«çš„ advance() æ–¹æ³•</p>
<p>advance() æ–¹æ³•ï¼Œå°†ä¼šä½¿ç”¨åˆ°ä¸‹é¢çš„åŸºæœ¬æ–¹æ³•</p>
<pre><code class="language-java">
// lox/Parser.java, add after match()

  private boolean check(TokenType type) {
    if (isAtEnd()) return false;
    return peek().type == type;
  }


</code></pre>
<pre><code class="language-java">
// lox/Parser.java, add after check()

  private Token advance() {
    if (!isAtEnd()) current++;
    return previous();
  }


</code></pre>
<pre><code class="language-java">
// lox/Parser.java, add after advance()

  private boolean isAtEnd() {
    return peek().type == EOF;
  }

  private Token peek() {
    return tokens.get(current);
  }

  private Token previous() {
    return tokens.get(current - 1);
  }


</code></pre>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/parse-fun.png?raw=true" alt="func" /></p>
<p>isAtEnd() checks if weâ€™ve run out of tokens to parse. peek() returns the current token we have yet to consume, and previous() returns the most recently consumed token. The latter makes it easier to use match() and then access the just-matched token.</p>
<p>isAtEnd() æ–¹æ³•ï¼Œæ£€æŸ¥tokenæ˜¯å¦å·²ç»ä½¿ç”¨å®Œï¼Œpeek(ï¼‰ è¿”å›currentä½ç½®çš„tokenï¼Œprevious() è¿”å›æœ€è¿‘ä½¿ç”¨çš„tokenï¼Œprevious() æ–¹æ³•ï¼Œè®© match() å‡½æ•°æ›´åŠ å®¹æ˜“ï¼Œè®¿é—®åŒ¹é…çš„token</p>
<p>Thatâ€™s most of the parsing infrastructure we need. Where were we? Right, so if we are inside the while loop in equality(), then we know we have found a != or == operator and must be parsing an equality expression.</p>
<p>We grab the matched operator token so we can track which kind of equality expression we have. Then we call comparison() again to parse the right-hand operand. We combine the operator and its two operands into a new Expr.Binary syntax tree node, and then loop around. For each iteration, we store the resulting expression back in the same expr local variable. As we zip through a sequence of equality expressions, that creates a left-associative nested tree of binary operator nodes.</p>
<p>è¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦ä½¿ç”¨çš„å¤§éƒ¨åˆ†çš„ï¼Œè§£æåŸºç¡€ç»“æ„ï¼Œæˆ‘ä»¬åœ¨å“ªé‡Œï¼Ÿå¦‚æœæˆ‘ä»¬åœ¨ equality() æ–¹æ³•çš„whileå¾ªç¯ä¸­ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦æ‰¾åˆ° != æˆ–è€… == è¿ç®—ç¬¦ï¼Œå¹¶ä¸”å¿…é¡»è§£æç­‰å¼è¡¨è¾¾å¼ã€‚</p>
<p>æˆ‘ä»¬å°†è·å–åŒ¹é…åˆ°çš„è¿ç®—ç¬¦tokenï¼ˆ == æˆ–è€… != ), ä»¥ä¾¿è·Ÿè¸ªæˆ‘ä»¬æ‹¥æœ‰å“ªç§ç­‰å¼è¡¨è¾¾å¼ï¼Œç„¶åï¼Œæˆ‘ä»¬å°†å†æ¬¡è°ƒç”¨ comparison() æ–¹æ³•ï¼Œæ¥è§£æå³è¾¹çš„æ“ä½œæ•°ï¼Œæˆ‘ä»¬å°†ä¸¤ä¸ªæ“ä½œæ•°å’Œè¿ç®—ç¬¦ï¼Œç»„åˆä¸ºä¸€ä¸ªæ–°çš„äºŒå…ƒè¡¨è¾¾å¼è¯­æ³•æ ‘ï¼Œç„¶åï¼Œå¾ªç¯ï¼Œå¯¹äºæ¯ä¸€æ¬¡è¿­ä»£ï¼Œæˆ‘ä»¬éƒ½å°†ç»“æœä¿å­˜åœ¨ç›¸åŒçš„expr å±€éƒ¨å˜é‡ä¸­ï¼Œ</p>
<p>å½“æˆ‘ä»¬åˆ›å»ºä¸€ç³»åˆ—çš„ç­‰å¼è¡¨è¾¾å¼æ—¶å€™ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦èŠ‚ç‚¹çš„å·¦å…³è”åµŒå¥—æ ‘ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/sequence.png?raw=true" alt="sequence" /></p>
<blockquote>
<p>Parsing a == b == c == d == e. For each iteration, we create a new binary expression using the previous one as the left operand.</p>
<p>è§£æ a == b == c == d == e, æˆ‘ä»¬æ¯ä¸€æ¬¡éƒ½ä¼šä½¿ç”¨å‰ä¸€ä¸ªè®¡ç®—ç»“æœï¼Œå½“ä½œåé¢çš„äºŒå…ƒè¡¨è¾¾å¼çš„å·¦å€¼ï¼Œä¾‹å¦‚ï¼šæˆ‘ä»¬å…ˆè®¡ç®— a == bï¼Œå°†ç»“æœå½“ä½œ x == c ä¸­çš„ x</p>
</blockquote>
<p>The parser falls out of the loop once it hits a token thatâ€™s not an equality operator. Finally, it returns the expression. Note that if the parser never encounters an equality operator, then it never enters the loop. In that case, the equality() method effectively calls and returns comparison(). In that way, this method matches an equality operator or anything of higher precedence.</p>
<p>ä¸€æ—¦è§£æå™¨ç¢°åˆ°ä¸æ˜¯ç­‰å¼è¿ç®—ç¬¦çš„tokenï¼Œ å®ƒå°±ä¼šé€€å‡ºå¾ªç¯ï¼Œæœ€åï¼Œè§£æå™¨ä¼šè¿”å›è¡¨è¾¾å¼ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœè§£æå™¨æ²¡æœ‰é‡åˆ°ç­‰å¼è¿ç®—ç¬¦ï¼Œå®ƒæ°¸è¿œä¸ä¼šè¿›å…¥å¾ªç¯ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œequaility() å‡½æ•°ï¼Œè°ƒç”¨ä¼šè¿”å› comparison(). é€šè¿‡ä¸Šé¢çš„æ–¹å¼ï¼Œæ­¤æ–¹æ³•å°†ä¼šåŒ¹é…ç›¸ç­‰è¿ç®—ç¬¦ï¼Œæˆ–è€…ä»»ä½•ä¼˜å…ˆçº§è¾ƒé«˜çš„è¿ç®—ç¬¦ã€‚</p>
<p>Moving on to the next ruleâ€‰.â€‰.â€‰. </p>
<pre><code>
comparison     â†’ term ( ( &quot;&gt;&quot; | &quot;&gt;=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; ) term )* ;

</code></pre>
<p>Translated to Java:</p>
<pre><code class="language-java">
// lox/Parser.java add after equality()

  private Expr comparison() {
    Expr expr = term();

    while (match(GREATER, GREATER_EQUAL, LESS, LESS_EQUAL)) {
      Token operator = previous();
      Expr right = term();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }
  
</code></pre>
<p>The grammar rule is virtually identical to equality and so is the corresponding code. The only differences are the token types for the operators we match, and the method we call for the operandsâ€”now term() instead of comparison(). The remaining two binary operator rules follow the same pattern.</p>
<p>ç»§ç»­è¿›è¡Œä¸‹ä¸ªè¯­æ³•è§„åˆ™</p>
<p>è¯­æ³•è§„åˆ™å®é™…ç­‰åŒäºç›¸ç­‰è¡¨è¾¾å¼ï¼Œç›¸åº”çš„ä»£ç ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æˆ‘ä»¬åŒ¹é…çš„è¿ç®—ç¬¦tokençš„ç±»å‹ï¼Œä»¥åŠï¼Œæˆ‘ä»¬ä¸ºäº†æ“ä½œæ•°è°ƒç”¨çš„æ–¹æ³•æ˜¯ term() è€Œä¸æ˜¯ comparison() , å¦å¤–çš„ä¸¤ä¸ªäºŒå…ƒè¿ç®—ç¬¦è§„åˆ™ï¼Œéµå¾ªç›¸åŒçš„æ¨¡å¼</p>
<blockquote>
<p>If you wanted to do some clever Java 8, you could create a helper method for parsing a left-associative series of binary operators given a list of token types, and an operand method handle to simplify this redundant code.</p>
<p>å¦‚æœä¸æƒ³ä¸€ç›´è¿™æ ·æ„é€ å‡½æ•°ï¼Œå¯ä»¥é€šè¿‡ä¸€ä¸ªhelperå‡½æ•°ï¼Œç”Ÿæˆå¯¹åº”çš„è§£ææ–¹æ³•</p>
</blockquote>
<p>In order of precedence, first addition and subtraction:</p>
<p>æŒ‰ç…§è¿ç®—ä¼˜å…ˆçº§ï¼Œé¦–å…ˆè€ƒè™‘åŠ æ³•å’Œå‡æ³•è¿ç®—</p>
<pre><code class="language-java">
// lox/Parser.java add after comparison()

  private Expr term() {
    Expr expr = factor();

    while (match(MINUS, PLUS)) {
      Token operator = previous();
      Expr right = factor();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }
  
</code></pre>
<p>And finally, multiplication and division:</p>
<p>æœ€åï¼Œè€ƒè™‘ä¹˜æ³•å’Œé™¤æ³•</p>
<pre><code class="language-java">
//lox/Parser.java add after term()

 private Expr factor() {
    Expr expr = unary();

    while (match(SLASH, STAR)) {
      Token operator = previous();
      Expr right = unary();
      expr = new Expr.Binary(expr, operator, right);
    }

    return expr;
  }
  
</code></pre>
<p>Thatâ€™s all of the binary operators, parsed with the correct precedence and associativity. Weâ€™re crawling up the precedence hierarchy and now weâ€™ve reached the unary operators.</p>
<p>è¿™å°±æ˜¯æ‰€æœ‰çš„äºŒå…ƒè¿ç®—ç¬¦ï¼Œä»¥æ­£ç¡®çš„ä¼˜å…ˆçº§å’Œå…³è”æ€§è§£æï¼Œæˆ‘ä»¬æ­£åœ¨å¾€ä¼˜å…ˆçº§æ›´é«˜çš„è¿ç®—ç¬¦è¿›è¡Œè§£æï¼Œä¸‹ä¸€æ­¥ï¼Œæˆ‘ä»¬å°†è§£æä¸€å…ƒè¿ç®—ç¬¦</p>
<pre><code>
unary          â†’ ( &quot;!&quot; | &quot;-&quot; ) unary
               | primary ;
			   
</code></pre>
<p>The code for this is a little different.</p>
<p>ä»£ç çœ‹èµ·æ¥æœ‰ç‚¹ä¸ä¸€æ ·</p>
<pre><code class="language-java">
// lox/Parser.java, add after factor()

  private Expr unary() {
    if (match(BANG, MINUS)) {
      Token operator = previous();
      Expr right = unary();
      return new Expr.Unary(operator, right);
    }

    return primary();
  }
  
</code></pre>
<p>Again, we look at the current token to see how to parse. If itâ€™s a ! or -, we must have a unary expression. In that case, we grab the token and then recursively call unary() again to parse the operand. Wrap that all up in a unary expression syntax tree and weâ€™re done.</p>
<p>æˆ‘ä»¬æŸ¥çœ‹å½“å‰çš„ tokenï¼Œåˆ¤æ–­å¦‚ä½•è§£æï¼› å¦‚æœå½“å‰çš„ token æ˜¯ ï¼æˆ–è€… - ç­‰ä¸€å…ƒè¿ç®—ç¬¦ï¼Œæˆ‘ä»¬å°†è·å¾—ä¸€ä¸ªä¸€å…ƒè¡¨è¾¾å¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬é€šè¿‡ previous() è·å–æ“ä½œç¬¦ï¼Œè¿˜éœ€è¦é€šè¿‡å†æ¬¡è°ƒç”¨ unary() è·å–ä¸€å…ƒè¿ç®—ç¬¦çš„å³å€¼ï¼Œå³æ“ä½œæ•°ã€‚ç„¶åï¼Œæˆ‘ä»¬å°†è·å–åˆ°ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦è¯­æ³•æ ‘ã€‚</p>
<blockquote>
<p>The fact that the parser looks ahead at upcoming tokens to decide how to parse puts recursive descent into the category of predictive parsers.</p>
<p>äº‹å®ä¸Šï¼Œè§£æå™¨ä¼šæå‰æŸ¥çœ‹å½“å‰ä½ç½®çš„tokenï¼Œå†³å®šå¦‚ä½•æ¥ä¸‹æ¥çš„è§£ææµç¨‹ï¼Œé€’å½’ä¸‹é™ç”±æ­¤è¢«å½’ç±»ä¸ºï¼Œé¢„æµ‹è§£æå™¨çš„èŒƒç•´ã€‚</p>
</blockquote>
<p>Otherwise, we must have reached the highest level of precedence, primary expressions.</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°†è¿›å…¥ä¸»è¡¨è¾¾å¼çš„è§£ææ–¹æ³•ï¼Œä¸»è¡¨è¾¾å¼æ˜¯ä¼˜å…ˆçº§æœ€é«˜çš„è¡¨è¾¾å¼</p>
<pre><code>
primary        â†’ NUMBER | STRING | &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
               | &quot;(&quot; expression &quot;)&quot; ;
			   
</code></pre>
<p>Most of the cases for the rule are single terminals, so parsing is straightforward.</p>
<p>è¿™ä¸ªè¡¨è¾¾å¼çš„å¤§å¤šæ•°æƒ…å†µï¼Œæ˜¯ä¸€ä¸ªå•ç»ˆç»“ç¬¦ï¼Œå› æ­¤è§£ææ–¹æ³•å¾ˆç®€å•ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, add after unary()

 private Expr primary() {
    if (match(FALSE)) return new Expr.Literal(false);
    if (match(TRUE)) return new Expr.Literal(true);
    if (match(NIL)) return new Expr.Literal(null);

    if (match(NUMBER, STRING)) {
      return new Expr.Literal(previous().literal);
    }

    if (match(LEFT_PAREN)) {
      Expr expr = expression();
      consume(RIGHT_PAREN, &quot;Expect ')' after expression.&quot;);
      return new Expr.Grouping(expr);
    }
  }
  
</code></pre>
<p>The interesting branch is the one for handling parentheses. After we match an opening ( and parse the expression inside it, we must find a ) token. If we donâ€™t, thatâ€™s an error.</p>
<p>æœ‰è¶£çš„åˆ†æ”¯æ˜¯å¤„ç†æ‹¬å·çš„åˆ†æ”¯ï¼Œåœ¨åŒ¹é…åˆ°ä¸€ä¸ªå·¦æ‹¬å·åï¼Œæˆ‘ä»¬å¿…é¡»æ‰¾åˆ°ä¸€ä¸ªå¯¹åº”çš„æ‹¬å·ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„æ‹¬å·ï¼Œè§£æå°†æŠ¥é”™ã€‚</p>
<h2 id="ä¸‰syntax-errors"><a class="header" href="#ä¸‰syntax-errors">ä¸‰ã€Syntax Errors</a></h2>
<p>è¯­æ³•é”™è¯¯</p>
<p>A parser really has two jobs:</p>
<ol>
<li>
<p>Given a valid sequence of tokens, produce a corresponding syntax tree.</p>
</li>
<li>
<p>Given an invalid sequence of tokens, detect any errors and tell the user about their mistakes.</p>
</li>
</ol>
<p>è§£æå™¨å®é™…ä¸Šæœ‰ä¸¤é¡¹ä»»åŠ¡ï¼Œ</p>
<ol>
<li>
<p>ç»™å®šä¸€ä¸ªåˆæ³•æœ‰æ•ˆ token åºåˆ—ï¼Œç”Ÿæˆä¸€ä¸ªè¯­æ³•æ ‘</p>
</li>
<li>
<p>ç»™å®šä¸€ä¸ªéæ³•çš„ token åºåˆ—ï¼Œæ£€æµ‹é”™è¯¯ï¼Œå¹¶ä¸”é€šçŸ¥ç”¨æˆ·è¯¦ç»†é”™è¯¯</p>
</li>
</ol>
<p>Donâ€™t underestimate how important the second job is! In modern IDEs and editors, the parser is constantly reparsing codeâ€”often while the user is still editing itâ€”in order to syntax highlight and support things like auto-complete. That means it will encounter code in incomplete, half-wrong states all the time.</p>
<p>When the user doesnâ€™t realize the syntax is wrong, it is up to the parser to help guide them back onto the right path.  The way it reports errors is a large part of your languageâ€™s user interface. Good syntax error handling is hard. By definition, the code isnâ€™t in a well-defined state, so thereâ€™s no infallible way to know what the user meant to write. The parser canâ€™t read your mind.</p>
<p>ä¸è¦ä½ä¼°ç¬¬äºŒä¸ªä»»åŠ¡çš„é‡è¦æ€§ï¼Œè§£æå™¨ç»å¸¸åœ¨ç”¨æˆ·åœ¨ç”¨æˆ·ä»åœ¨ç¼–è¾‘ä»£ç æ—¶å€™ï¼ŒåŒæ­¥åˆ†æä»£ç ï¼Œç”¨äºæ”¯æŒä»£ç é«˜äº®å’Œè‡ªåŠ¨è¡¥å…¨åŠŸèƒ½ã€‚è¿™æ„å‘³ç€ï¼Œåˆ†æçš„ä»£ç å°†å§‹ç»ˆå¤„äºä¸å®Œæ•´ã€åŠé”™è¯¯çŠ¶æ€çš„ä»£ç ã€‚</p>
<p>å½“ç”¨æˆ·è¿˜æ²¡æœ‰æ³¨æ„åˆ°è¯­æ³•é”™è¯¯æ—¶å€™ï¼Œè§£æå™¨å°†å¸®åŠ©ä»–ä»¬è¿”å›æ­£ç¡®çš„è¯­æ³•ï¼Œè¯­æ³•é”™è¯¯çš„æç¤ºï¼Œæ˜¯IDE ç”¨æˆ·ç•Œé¢çš„å¾ˆå¤§ä¸€éƒ¨åˆ†ï¼Œé€šå¸¸å¾ˆå¥½çš„å¤„ç†æŠ¥é”™æ˜¯ä¸€é¡¹è‰°éš¾çš„ä»»åŠ¡ï¼Œæ ¹æ®å®šä¹‰ï¼Œä»£ç æ²¡æœ‰å¤„äºå®šä¹‰è‰¯å¥½çš„çŠ¶æ€ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬æ²¡æœ‰å¯é çš„æ–¹å¼ï¼Œè·çŸ¥ç”¨æˆ·å°†è¦è¾“å…¥ä»€ä¹ˆï¼Œæ¯•ç«Ÿï¼Œè§£æå™¨æ— æ³•è·çŸ¥ç”¨æˆ·çš„æ€æƒ³ã€‚</p>
<blockquote>
<p>Not yet at least. With the way things are going in machine learning these days, who knows what the future will bring?</p>
<p>è‡³å°‘ç°åœ¨è¿˜æ²¡æœ‰ï¼Œéšç€æœºå™¨å­¦ä¹ çš„å‘å±•ï¼Œæˆ‘ä»¬å¹¶ä¸çŸ¥é“æœªæ¥ä¼šå˜æˆä»€ä¹ˆæ ·ï¼ŸğŸ¶</p>
</blockquote>
<p>There are a couple of hard requirements for when the parser runs into a syntax error. A parser must:</p>
<ul>
<li>
<p><strong>Detect and report the error.</strong></p>
<p>If it doesnâ€™t detect the error and passes the resulting malformed syntax tree on to the interpreter, all manner of horrors may be summoned.</p>
</li>
<li>
<p><strong>Avoid crashing or hanging.</strong></p>
<p>Syntax errors are a fact of life, and language tools have to be robust in the face of them. Segfaulting or getting stuck in an infinite loop isnâ€™t allowed. While the source may not be valid code, itâ€™s still a valid input to the parser because users use the parser to learn what syntax is allowed.</p>
</li>
</ul>
<p>å½“è§£æå™¨é‡åˆ°è¯­æ³•é”™è¯¯æ—¶å€™ï¼Œæœ‰å‡ ä¸ªç¡¬æ€§è¦æ±‚ï¼Œ</p>
<ul>
<li>
<p>æ£€æµ‹å¹¶ä¸”æŠ¥å‘Šé”™è¯¯ï¼Œ</p>
<p>å¦‚æœæ²¡æœ‰åŠæ—¶æ£€æµ‹åˆ°é”™è¯¯ï¼Œå¹¶ä¸”æŠ¥å‘Šé”™è¯¯ï¼Œè€Œæ˜¯å°†é”™è¯¯æ ¼å¼çš„è¯­æ³•æ ‘è¿”å›ç»™è§£æå™¨ï¼Œé‚£ä¹ˆå¯èƒ½å¼•å‘å„ç§å„æ ·çš„æŠ¥é”™ã€‚</p>
</li>
<li>
<p>é¿å…ç¨‹åºæŒ‚èµ·æˆ–è€…å´©æºƒ</p>
<p>è¯­æ³•é”™è¯¯æ˜¯ç”Ÿæ´»ä¸­çš„ä¸€ä¸ªäº‹å®ï¼Œé¢å¯¹è¿™äº›é”™è¯¯ï¼Œè¯­è¨€è§£æå™¨å¿…é¡»æ˜¯å¥å£®çš„ï¼Œä¸èƒ½å‡ºç° <a href="https://zh.wikipedia.org/zh-cn/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4">å­˜å‚¨å™¨æ®µé”™è¯¯</a> æˆ–è€…æ— é™å¾ªç¯ã€‚è™½ç„¶ï¼Œæºä»£ç ä¸æ˜¯æœ‰æ•ˆçš„ä»£ç ï¼Œä½†æ˜¯å®ƒä»ç„¶æ˜¯è§£æå™¨çš„æœ‰æ•ˆè¾“å…¥ï¼Œå› ä¸ºç”¨æˆ·é€šè¿‡è§£æå™¨äº†è§£åˆ°å“ªäº›è¯­æ³•æ˜¯å…è®¸çš„ã€‚</p>
</li>
</ul>
<p>Those are the table stakes if you want to get in the parser game at all, but you really want to raise the ante beyond that. A decent parser should:</p>
<ul>
<li>
<p>**Be fast. **</p>
<p>Computers are thousands of times faster than they were when parser technology was first invented. The days of needing to optimize your parser so that it could get through an entire source file during a coffee break are over. But programmer expectations have risen as quickly, if not faster. They expect their editors to reparse files in milliseconds after every keystroke.</p>
</li>
<li>
<p>**Report as many distinct errors as there are. **</p>
<p>Aborting after the first error is easy to implement, but itâ€™s annoying for users if every time they fix what they think is the one error in a file, a new one appears. They want to see them all.</p>
</li>
<li>
<p><strong>Minimize cascaded errors.</strong></p>
<p>Once a single error is found, the parser no longer really knows whatâ€™s going on. It tries to get itself back on track and keep going, but if it gets confused, it may report a slew of ghost errors that donâ€™t indicate other real problems in the code. When the first error is fixed, those phantoms disappear, because they reflect only the parserâ€™s own confusion. Cascaded errors are annoying because they can scare the user into thinking their code is in a worse state than it is.</p>
</li>
</ul>
<p>The last two points are in tension. We want to report as many separate errors as we can, but we donâ€™t want to report ones that are merely side effects of an earlier one.</p>
<p>ä¸Šé¢ä¸¤ç‚¹æ˜¯å…¥å±€è§£æå™¨æ¸¸æˆçš„åŸºæœ¬æ¡ä»¶ï¼Œä½†æ˜¯ï¼Œå¦‚æœä½ æƒ³æé«˜è‡ªå·±çš„ç­¹ç ï¼Œä¸€ä¸ªæ›´å¥½çš„è§£æå™¨åº”è¯¥:</p>
<ul>
<li>
<p>ç¼–è¯‘æ›´å¿« </p>
<p>è®¡ç®—æœºçš„è¿è¡Œé€Ÿåº¦ï¼Œæ¯”è§£æå™¨æŠ€æœ¯ï¼Œé¦–æ¬¡å‘æ˜çš„æ—¶å€™ï¼Œå¿«äº†æ•°åƒå€ã€‚éœ€è¦ä¼˜åŒ–è§£æå™¨ç¼–è¯‘é€Ÿåº¦ï¼Œéœ€è¦å–å®Œä¸€æ•´æ¯å’–å•¡æ‰èƒ½ç¼–è¯‘å®Œæˆçš„æ—¥å­ï¼Œå·²ç»è¿‡å»äº†ã€‚ä½†æ˜¯ï¼Œç¨‹åºå‘˜çš„æœŸæœ›å€¼ä¹Ÿåœ¨ä¸æ–­å˜é«˜ï¼Œä»–ä»¬å¸Œæœ›åœ¨æ¯«ç§’å†…é‡æ–°ç¼–è¯‘æºç ã€‚</p>
</li>
<li>
<p>æŠ¥å‘Šå°½å¯èƒ½å¤šçš„æ˜æ˜¾é”™è¯¯</p>
<p>åœ¨å‘ç°ç¬¬ä¸€ä¸ªé”™è¯¯æ—¶å€™ï¼Œé©¬ä¸Šç»ˆæ­¢è§£æå™¨ï¼Œå¾ˆå®¹æ˜“å®ç°ï¼Œä½†æ˜¯ï¼Œå¦‚æœç”¨æˆ·æ¯æ¬¡åªèƒ½å‘ç°ä»£ç ä¸­çš„ä¸€ä¸ªé”™è¯¯ï¼Œä¸€æ¬¡æ¬¡çš„é‡æ–°ä¿®æ”¹ï¼Œä¼šç»™ç”¨æˆ·å¾ˆä¸å¥½çš„ä½“éªŒï¼Œä»–ä»¬å¸Œæœ›ä¸€æ¬¡å‘ç°æ‰€æœ‰çš„æ˜æ˜¾é”™è¯¯ã€‚</p>
</li>
<li>
<p>æœ€å°åŒ–çº§è”é”™è¯¯</p>
<p>ä¸€æ—¦å‘ç°äº†ä¸€ä¸ªé”™è¯¯ï¼Œè§£æå™¨ä¸å†çœŸçš„çŸ¥é“ï¼Œå‘ç”Ÿäº†ä»€ä¹ˆã€‚è§£æå™¨è¯•å›¾è®©è§£æå›åˆ°æ­£è½¨ï¼Œå¹¶ä¸”ç»§ç»­è§£æï¼Œä½†æ˜¯å¦‚æœå®ƒæ— æ³•å‰è¿›ï¼Œå¯èƒ½ä¼šå‘ç°å¤§é‡çš„å…³è”é”™è¯¯ï¼Œè¿™äº›é”™è¯¯å¹¶ä¸è¡¨ç¤ºï¼Œè¿™äº›é”™è¯¯å¤„æ˜¯çœŸæ­£çš„é—®é¢˜æ‰€åœ¨ã€‚å½“ç¬¬ä¸€ä¸ªé”™è¯¯è¢«å‘ç°å¹¶ä¸”ä¿®å¤åï¼Œå¤§é‡çš„å…³è”é”™è¯¯å°†ä¼šæ¶ˆå¤±ï¼Œå› ä¸ºå®ƒä»¬ä¸æ˜¯çœŸçš„é”™è¯¯ã€‚çº§è”é”™è¯¯éå¸¸çƒ¦äººï¼Œå› ä¸ºï¼Œå®¢æˆ·é€šå¸¸ä¼šè®¤ä¸ºï¼Œè‡ªå·±çš„ä»£ç çŠ¶æ€æ¯”å®é™…æƒ…å†µå·®å¤šäº†ã€‚</p>
</li>
</ul>
<p>åé¢çš„ä¸¤ç‚¹è¦æ±‚ï¼Œæœ‰ä¸€å®šçš„ç«äº‰å…³ç³»ã€‚æˆ‘ä»¬æ—¢å¸Œæœ›ï¼ŒæŠ¥å‘Šå°½å¯èƒ½å¤šçš„æ˜æ˜¾é”™è¯¯ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬ä¹Ÿå¸Œæœ›ï¼ŒæŠ¥å‘Šå°½å¯èƒ½å°‘çš„å…³è”é”™è¯¯ã€‚</p>
<p>The way a parser responds to an error and keeps going to look for later errors is called error recovery. This was a hot research topic in the â€™60s. Back then, youâ€™d hand a stack of punch cards to the secretary and come back the next day to see if the compiler succeeded. With an iteration loop that slow, you really wanted to find every single error in your code in one pass.</p>
<p>Today, when parsers complete before youâ€™ve even finished typing, itâ€™s less of an issue. Simple, fast error recovery is fine.</p>
<p>è§£æå™¨å“åº”é”™è¯¯ï¼Œå¹¶ä¸”ç»§ç»­æŸ¥æ‰¾åç»­é”™è¯¯çš„æ–¹å¼ï¼Œç§°ä¸ºé”™è¯¯æ¢å¤ã€‚è¿™æ˜¯60å¹´ä»£çš„çƒ­é—¨ç ”ç©¶è¯¾é¢˜ã€‚åœ¨é‚£ä¸ªå¹´ä»£ï¼Œä½ ä¼šæŠŠä¸€å ç©¿å­”å¡çº¸ï¼Œäº¤ç»™ç›¸å…³äººå‘˜ï¼Œç„¶åï¼Œåœ¨ç¬¬äºŒå¤©ï¼Œå»æŸ¥çœ‹ç¼–è¯‘å™¨æ˜¯å¦æ‰§è¡ŒæˆåŠŸã€‚ç”±äºè¿­ä»£å¾ªç¯å¦‚ä½•ç¼“æ…¢ï¼Œæˆ‘ä»¬å¸Œæœ›åœ¨ä¸€æ¬¡ç¼–è¯‘ä¸­å‘ç°å°½å¯èƒ½å®Œæ•´çš„é”™è¯¯ã€‚</p>
<p>ä»Šå¤©ï¼Œè§£æå™¨é€šå¸¸åœ¨ä½ è¿˜æ²¡æœ‰ç¼–è¾‘å®Œæˆï¼Œå°±å·²ç»å®Œæˆè§£æï¼Œé—®é¢˜ä¸æ˜¯å¾ˆå¤§ï¼Œç®€å•ã€å¿«é€Ÿçš„é”™è¯¯æ¢å¤æ›´å¥½ã€‚</p>
<h3 id="31-panic-mode-error-recovery"><a class="header" href="#31-panic-mode-error-recovery">3.1 Panic mode error recovery</a></h3>
<p>ææ…Œæ¨¡å¼é”™è¯¯æ¢å¤</p>
<blockquote>
<p>You know you want to push it.</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/panic.png?raw=true" alt="panic" /></p>
<p>ä½ æƒ³è¦æŒ‰ä¸‹å®ƒ ğŸ˜„</p>
</blockquote>
<p>Of all the recovery techniques devised in yesteryear, the one that best stood the test of time is calledâ€”somewhat alarminglyâ€”panic mode. As soon as the parser detects an error, it enters panic mode. It knows at least one token doesnâ€™t make sense given its current state in the middle of some stack of grammar productions.</p>
<p>Before it can get back to parsing, it needs to get its state and the sequence of forthcoming tokens aligned such that the next token does match the rule being parsed. This process is called synchronization.</p>
<p>To do that, we select some rule in the grammar that will mark the synchronization point. The parser fixes its parsing state by jumping out of any nested productions until it gets back to that rule. Then it synchronizes the token stream by discarding tokens until it reaches one that can appear at that point in the rule.</p>
<p>Any additional real syntax errors hiding in those discarded tokens arenâ€™t reported, but it also means that any mistaken cascaded errors that are side effects of the initial error arenâ€™t falsely reported either, which is a decent trade-off.</p>
<p>The traditional place in the grammar to synchronize is between statements. We donâ€™t have those yet, so we wonâ€™t actually synchronize in this chapter, but weâ€™ll get the machinery in place for later.</p>
<p>åœ¨è¿‡å»å‘æ˜çš„æ‰€æœ‰é”™è¯¯æ¢å¤æŠ€æœ¯ä¸­ï¼Œæœ€ç¦å¾—èµ·æ—¶é—´è€ƒéªŒçš„æ˜¯ææ…Œæ¨¡å¼çš„é”™è¯¯æ¢å¤æŠ€æœ¯ã€‚ä¸€æ—¦è§£æå™¨æ£€æµ‹åˆ°é”™è¯¯ï¼Œå®ƒå°†è¿›å…¥åˆ°ææ…Œæ¨¡å¼ï¼Œå®ƒçŸ¥é“è‡³å°‘æœ‰ä¸€ä¸ª tokenï¼Œæ²¡æœ‰å®é™…æ„ä¹‰ï¼Œå½“æˆ‘ä»¬éœ€è¦è·å–è¯­æ³•ç”Ÿæˆçš„å †æ ˆä¸­çš„å½“å‰çŠ¶æ€ã€‚</p>
<p>åœ¨è¿”å›è§£æä¹‹å‰ï¼Œå®ƒéœ€è¦è·å–å…¶çŠ¶æ€ï¼Œå¹¶ä¸”å’Œå³å°†è§£æçš„ tokenåºåˆ—å¯¹é½ï¼Œä»¥ä¾¿ä¸‹ä¸€ä¸ªtoken å’Œå½“å‰çš„è§£æè§„åˆ™åŒ¹é…ï¼Œè¿™ä¸ªè¿‡ç¨‹ç§°ä¹‹ä¸ºåŒæ­¥ã€‚</p>
<p>ä¸ºæ­¤ï¼Œæˆ‘ä»¬åœ¨è¯­æ³•ä¸­ï¼Œé€‰æ‹©ä¸€äº›è§„åˆ™ï¼Œæ¥æ ‡è®°åŒæ­¥ç‚¹ã€‚è§£æå™¨ï¼Œè‚¯èƒ½ä¼šè·³å‡ºä¸€äº›åµŒå¥—å¾ªç¯ï¼Œç”¨äºæ¢å¤å…¶è§£æçŠ¶æ€ï¼Œç›´åˆ°è¿”å›è¯¥è§£æè§„åˆ™ã€‚ç„¶åï¼Œè§£æå™¨é€šè¿‡ä¸¢å¼ƒtokenï¼Œæ¥åŒæ­¥token æµï¼Œç›´åˆ°å®ƒåˆ°è¾¾å¯ä»¥å‡ºç°åœ¨è§„åˆ™ä¸­çš„é‚£ä¸ªç‚¹ã€‚</p>
<p>éšè—åœ¨è¿™äº›è¢«ä¸¢å¼ƒçš„tokenä¸­çš„ï¼Œä»»ä½•å…¶ä»–çœŸå®çš„é”™è¯¯éƒ½ä¸ä¼šè¢«æŠ¥å‘Šï¼Œè¿™ä¹Ÿæ„å¤–ç€ï¼Œä»»ä½•é”™è¯¯çš„çº§è”é”™è¯¯ï¼ˆåˆå§‹é”™è¯¯çš„å‰¯ä½œç”¨ï¼‰ä¹Ÿä¸ä¼šè¢«é”™è¯¯æŠ¥å‘Šï¼Œè¿™æ˜¯ä¸€ä¸ªä¸é”™çš„æƒè¡¡ã€‚</p>
<p>è¯­æ³•ä¸­çš„ä¼ ç»ŸåŒæ­¥ä½ç½®ï¼Œæ˜¯è¯­å¥ä¹‹é—´ã€‚æˆ‘ä»¬è¿˜æ²¡æœ‰æ¶‰åŠåˆ°ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä¸ä¼šåœ¨æœ¬ç« ä¸­å®ç°åŒæ­¥ï¼Œä½†æ˜¯åé¢ç« èŠ‚ä¼šå®ç°ã€‚</p>
<h3 id="32-entering-panic-mode"><a class="header" href="#32-entering-panic-mode">3.2 Entering panic mode</a></h3>
<p>è¿›å…¥ææ…Œæ¨¡å¼</p>
<p>Back before we went on this side trip around error recovery, we were writing the code to parse a parenthesized expression. After parsing the expression, the parser looks for the closing ) by calling consume(). Here, finally, is that method:</p>
<p>åœ¨æˆ‘ä»¬è®¨è®ºé”™è¯¯æ¢å¤ä¹‹å‰ï¼Œæˆ‘ä»¬çš„è§£æå™¨æ­£åœ¨ï¼Œç¼–å†™ä»£ç è§£æå¸¦æ‹¬å·çš„è¡¨è¾¾å¼ã€‚è§£æè¡¨è¾¾å¼ä»¥åï¼Œæˆ‘ä»¬é€šè¿‡è°ƒç”¨ consume()æ–¹æ³•ï¼Œæ¥æŸ¥æ‰¾åé¢çš„ ï¼‰ï¼Œæœ€åçš„æ–¹æ³•å¦‚ä¸‹ï¼š</p>
<pre><code class="language-java">
// lox/Parser.java, add after match()

  private Token consume(TokenType type, String message) {
    if (check(type)) return advance();

    throw error(peek(), message);
  }
  
</code></pre>
<p>Itâ€™s similar to match() in that it checks to see if the next token is of the expected type. If so, it consumes the token and everything is groovy. If some other token is there, then weâ€™ve hit an error. We report it by calling this:</p>
<p>consume() æ–¹æ³•å’Œmatch() æ–¹æ³•ç±»ä¼¼ï¼Œå®ƒä»¬éƒ½ä¼šæ£€æŸ¥å½“å‰ token æ˜¯å¦æ˜¯é¢„æœŸçš„ç±»å‹ï¼Œå¦‚æœæ˜¯åˆé€‚çš„ç±»å‹ï¼Œconsume() æ–¹æ³•ä¼šæ¶ˆè€—ä¸€ä¸ªä½ç½®ï¼Œä¸€åˆ‡éƒ½ä¼šæ­£å¸¸è¿è¡Œã€‚å¦‚æœä¸æ˜¯åˆé€‚çš„ç±»å‹ï¼Œå°†ä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯</p>
<pre><code class="language-java">
// lox/Parser.java, add after previous()

  private ParseError error(Token token, String message) {
    Lox.error(token, message);
    return new ParseError();
  }
  
</code></pre>
<p>First, that shows the error to the user by calling:</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬é€šè¿‡è°ƒç”¨ä¸‹é¢æ–¹æ³•ï¼Œå‘ç”¨æˆ·æŠ¥å‘Šé”™è¯¯</p>
<pre><code class="language-java">
// lox/Lox.java, add after report()

  static void error(Token token, String message) {
    if (token.type == TokenType.EOF) {
      report(token.line, &quot; at end&quot;, message);
    } else {
      report(token.line, &quot; at '&quot; + token.lexeme + &quot;'&quot;, message);
    }
  }
  
</code></pre>
<p>This reports an error at a given token. It shows the tokenâ€™s location and the token itself. This will come in handy later since we use tokens throughout the interpreter to track locations in code.</p>
<p>è¿™ä¸ªæ–¹æ³•ï¼Œå°†æŠ¥å‘Šç»™å®štoken çš„å…·ä½“é”™è¯¯ï¼Œå®ƒå°†ä¼šæŠ¥å‘Štoken çš„ä½ç½®å’Œtoken çš„å­—ç¬¦å€¼ï¼Œè¿™å°†åœ¨ä»¥åæ´¾ä¸Šç”¨åœºï¼Œå› ä¸ºæˆ‘ä»¬åœ¨è¿™ä¸ªè§£é‡Šå™¨ä¸­ï¼Œä½¿ç”¨tokenæ¥å®šä½è¿½è¸ªä»£ç çš„ä½ç½®</p>
<p>After we report the error, the user knows about their mistake, but what does the parser do next? Back in error(), we create and return a ParseError, an instance of this new class:</p>
<p>åœ¨æˆ‘ä»¬æŠ¥å‘Šäº†é”™è¯¯åï¼Œç”¨æˆ·çŸ¥é“äº†ä»–ä»¬ä»£ç ä¸­çš„é”™è¯¯ï¼Œä½†æ˜¯ï¼Œæ¥ä¸‹æ¥ï¼Œè§£æå™¨å°†å¦‚ä½•è¿è¡Œå‘¢ï¼Ÿå›åˆ°error() æ–¹æ³•ï¼Œæˆ‘ä»¬å°†åˆ›å»ºå¹¶ä¸”è¿”å›ä¸€ä¸ªæ–°çš„ç±»å®ä¾‹ï¼ŒParseError()</p>
<pre><code class="language-java">
// lox/Parser.java, nest inside class Parser


class Parser {
  private static class ParseError extends RuntimeException {}

  private final List&lt;Token&gt; tokens;
  
</code></pre>
<p>This is a simple sentinel class we use to unwind the parser.  The error() method returns the error instead of throwing it because we want to let the calling method inside the parser decide whether to unwind or not.  Some parse errors occur in places where the parser isnâ€™t likely to get into a weird state and we donâ€™t need to synchronize. In those places, we simply report the error and keep on truckinâ€™.</p>
<p>For example, Lox limits the number of arguments you can pass to a function. If you pass too many, the parser needs to report that error, but it can and should simply keep on parsing the extra arguments instead of freaking out and going into panic mode.</p>
<p>è¿™æ˜¯ä¸€ä¸ªç®€å•çš„å“¨å…µç±»ï¼Œç”¨äºå±•å¼€è§£æå™¨ã€‚error() æ–¹æ³•å°†è¿”å›é”™è¯¯ï¼Œè€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºï¼Œæˆ‘ä»¬å¸Œæœ›è®©è§£æå™¨å†…éƒ¨çš„è°ƒç”¨æ–¹æ³•å†³å®šæ˜¯å¦å±•å¼€ã€‚æœ‰ä¸€äº›è§£æé”™è¯¯ï¼Œå‘ç”Ÿåœ¨è§£æå™¨ä¸å¤ªå¯èƒ½è¿›å…¥å¥‡æ€ªçŠ¶æ€ï¼Œå¹¶ä¸”ä¹Ÿä¸éœ€è¦æˆ‘ä»¬åŒæ­¥çš„åœ°æ–¹ï¼Œåœ¨è¿™äº›åœ°æ–¹ï¼Œæˆ‘ä»¬åªéœ€è¦æŠ¥å‘Šé”™è¯¯ï¼Œå¹¶ä¸”ç»§ç»­è¿è¡Œã€‚</p>
<p>ä¸¾ä¾‹ï¼Œå¦‚æœLox é™åˆ¶äº†å‡½æ•°å¯ä»¥ä¼ å‚çš„ä¸ªæ•°ï¼Œå¦‚æœä½ ä¼ é€’äº†å¤ªå¤šçš„å‚æ•°ï¼Œè§£æå™¨éœ€è¦æŠ¥å‘Šè¯¥é”™è¯¯ï¼Œä½†æ˜¯ï¼Œè§£æå™¨ï¼Œæ¥ä¸‹æ¥åº”è¯¥è§£æé¢å¤–çš„å‚æ•°ï¼Œè€Œä¸æ˜¯é©¬ä¸Šè¿›å…¥ææ…Œæ¨¡å¼</p>
<blockquote>
<p>Another way to handle common syntax errors is with error productions. You augment the grammar with a rule that successfully matches the erroneous syntax. The parser safely parses it but then reports it as an error instead of producing a syntax tree.</p>
<p>For example, some languages have a unary + operator, like +123, but Lox does not. Instead of getting confused when the parser stumbles onto a + at the beginning of an expression, we could extend the unary rule to allow it.</p>
<pre><code>unary â†’ ( &quot;!&quot; | &quot;-&quot; | &quot;+&quot; ) unary
     | primary ;
</code></pre>
<p>This lets the parser consume + without going into panic mode or leaving the parser in a weird state.</p>
<p>Error productions work well because you, the parser author, know how the code is wrong and what the user was likely trying to do. That means you can give a more helpful message to get the user back on track, like, â€œUnary â€˜+â€™ expressions are not supported.â€ Mature parsers tend to accumulate error productions like barnacles since they help users fix common mistakes.</p>
<p>å¦å¤–ä¸€ç§å¤„ç†å¸¸è§è¯­æ³•é”™è¯¯çš„æŠ¥é”™æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æˆåŠŸåŒ¹é…é”™è¯¯è¯­æ³•çš„è§„åˆ™æ¥æ‰©å……è¯­æ³•ï¼Œè§£æå™¨å®‰å…¨çš„è§£æå®ƒï¼Œä½†æ˜¯éšåï¼Œæˆ‘ä»¬å°†å…¶æŠ¥å‘Šä¸ºé”™è¯¯ï¼Œè€Œä¸æ˜¯ç”Ÿæˆè¯­æ³•æ ‘ã€‚</p>
<p>ä¸¾ä¸ªä¾‹å­ï¼Œæœ‰äº›è¯­è¨€ï¼Œæ”¯æŒä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦ +ï¼Œä¾‹å¦‚ï¼š +123ï¼Œ ä½†æ˜¯Loxè¯­è¨€æ²¡æœ‰ã€‚æ‰€ä»¥ï¼Œå½“è§£æå™¨åœ¨è¡¨è¾¾å¼çš„å¼€å§‹ï¼Œé‡åˆ°ä¸€ä¸ª+æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥æ‰©å……è¯­æ³•è§„åˆ™ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„ä¸€å…ƒè¿ç®—ç¬¦ï¼Œè€Œä¸æ˜¯è§£ææŠ¥é”™ã€‚</p>
<p>è¿™æ ·ï¼Œè§£æå™¨å¯ä»¥æ­£å¸¸è§£æ+ï¼Œä¸ä¼šè¿›å…¥åˆ°ææ…Œæ¨¡å¼ï¼Œæˆ–è€…è§£æå™¨å‡ºç°å¥‡æ€ªçš„çŠ¶æ€ã€‚</p>
<p>é”™è¯¯ç”Ÿæˆå·¥ä½œçš„å¾ˆå¥½ï¼Œå› ä¸ºä½œä¸ºè§£æå™¨çš„ä½œè€…ï¼Œæˆ‘ä»¬çŸ¥é“ä»£ç æ˜¯å¦‚ä½•äº§ç”Ÿé”™è¯¯çš„ï¼Œä»¥åŠç”¨æˆ·å¯èƒ½æƒ³è¦åšä»€ä¹ˆã€‚è¿™æ„å‘³ç€ï¼Œä½ å¯èƒ½ç»™å‡ºæ›´åŠ æœ‰ç”¨çš„ä¿¡æ¯ï¼Œè®©ç”¨æˆ·æ›´å¥½çš„ä¿®æ”¹é”™è¯¯ï¼Œä¾‹å¦‚ï¼šä¸æ”¯æŒä¸€å…ƒè¿ç®—ç¬¦ +ï¼Œ æˆç†Ÿçš„è§£æå™¨ï¼Œå€¾å‘äºåƒè—¤å£¶ä¸€æ ·ç§¯ç´¯é”™è¯¯ï¼Œå› ä¸ºï¼Œå®ƒå¯ä»¥è®©ç”¨æˆ·æ›´å¥½çš„ä¿®å¤å¸¸è§é”™è¯¯ã€‚</p>
</blockquote>
<p>In our case, though, the syntax error is nasty enough that we want to panic and synchronize. Discarding tokens is pretty easy, but how do we synchronize the parserâ€™s own state?</p>
<p>ç„¶è€Œï¼Œåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¯­æ³•é”™è¯¯éå¸¸ä¸¥é‡ï¼Œä»¥è‡³äºæˆ‘ä»¬æƒ³è¦è¿›å…¥ææ…Œæ¨¡å¼ï¼Œå¹¶ä¸”åŒæ­¥ã€‚ä¸¢å¼ƒtokenéå¸¸ç®€å•ï¼Œä½†æ˜¯æˆ‘ä»¬å¦‚ä½•åŒæ­¥è§£æå™¨è‡ªå·±çš„çŠ¶æ€å‘¢ï¼Ÿ</p>
<h3 id="33-synchronizing-a-recursive-descent-parser"><a class="header" href="#33-synchronizing-a-recursive-descent-parser">3.3 Synchronizing a recursive descent parser</a></h3>
<p>åŒæ­¥é€’å½’ä¸‹é™è§£æå™¨</p>
<p>With recursive descent, the parserâ€™s stateâ€”which rules it is in the middle of recognizingâ€”is not stored explicitly in fields. Instead, we use Javaâ€™s own call stack to track what the parser is doing. Each rule in the middle of being parsed is a call frame on the stack. In order to reset that state, we need to clear out those call frames.</p>
<p>The natural way to do that in Java is exceptions. When we want to synchronize, we throw that ParseError object. Higher up in the method for the grammar rule we are synchronizing to, weâ€™ll catch it. Since we synchronize on statement boundaries, weâ€™ll catch the exception there. After the exception is caught, the parser is in the right state. All thatâ€™s left is to synchronize the tokens.</p>
<p>é€šè¿‡é€’å½’ä¸‹é™ï¼Œè§£æå™¨åœ¨è¯†åˆ«è¿‡ç¨‹ä¸­çš„çŠ¶æ€ä¸ä¼šæ˜¾ç¤ºå­˜å‚¨åœ¨å­—æ®µä¸­ï¼Œç›¸åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨Javaè‡ªå·±çš„å †æ ˆæ¥è·Ÿè¸ªè§£æå™¨ï¼Œæ­£åœ¨åšä»€ä¹ˆã€‚æ­£åœ¨è§£æçš„æ¯ä¸€ä¸ªè§„åˆ™ï¼Œéƒ½æ˜¯å †æ ˆä¸Šçš„è°ƒç”¨å¸§ã€‚ä¸ºäº†é‡ç½®è¯¥çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦æ¸…é™¤è¿™äº›è°ƒç”¨å¸§ã€‚</p>
<p>åœ¨Javaä¸­ï¼Œè¿™æ ·åšçš„è‡ªç„¶æ˜¯ä½¿ç”¨ Exceptionï¼Œå½“æˆ‘ä»¬æƒ³è¦åŒæ­¥æ—¶å€™ï¼Œæˆ‘ä»¬å°†æŠ›å‡º ParseErrorå¯¹è±¡ã€‚åœ¨æˆ‘ä»¬æƒ³è¦åŒæ­¥çš„è¯­æ³•è§„åˆ™ï¼Œå¯¹åº”çš„æ–¹æ³•çš„ä¸Šå±‚ï¼Œæˆ‘ä»¬å°†ä¼šæ•æ‰åˆ° ParseErrorå¯¹è±¡ã€‚å› ä¸ºæˆ‘ä»¬åœ¨è¯­å¥çš„è¾¹ç•Œå¤„åŒæ­¥ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å°†ä¼šåœ¨é‚£é‡Œï¼Œæ•è·åˆ°å¼‚å¸¸ã€‚æ•è·åˆ°å¼‚å¸¸åï¼Œè§£æå™¨å°†è¿›å…¥æ­£å¸¸çš„çŠ¶æ€ï¼Œå‰©ä¸‹çš„å°±æ˜¯åŒæ­¥tokenã€‚</p>
<p>We want to discard tokens until weâ€™re right at the beginning of the next statement. That boundary is pretty easy to spotâ€”itâ€™s one of the main reasons we picked it. After a semicolon, weâ€™re probably finished with a statement. Most statements start with a keywordâ€”for, if, return, var, etc. When the next token is any of those, weâ€™re probably about to start a statement.</p>
<p>æˆ‘ä»¬å¸Œæœ›åœ¨è§£æä¸‹ä¸€æ¡è¯­å¥ä¹‹å‰ï¼Œä¸¢å¼ƒtokenã€‚è¿™ä¸ªè¾¹ç•Œéå¸¸å®¹æ˜“è¢«å‘ç°ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä½¿ç”¨å®ƒçš„ä¸»è¦åŸå› ã€‚åˆ†å·ä¹‹åï¼Œæˆ‘ä»¬å¯èƒ½å®Œæˆäº†ä¸€ä¸ªè¯­å¥ã€‚å¤§å¤šæ•°çš„è¯­æ³•ï¼Œä»¥ <code>for if return var </code>ç­‰tokenå¼€å§‹ï¼Œå¦‚æœä¸‹ä¸€ä¸ªè§£æçš„tokenæ˜¯å…¶ä¸­ä¹‹ä¸€ï¼Œé‚£ä¹ˆï¼Œå¾ˆå¯èƒ½æˆ‘ä»¬å°†å¼€å§‹ä¸€ä¸ªè¯­å¥ã€‚</p>
<blockquote>
<p>I say â€œprobablyâ€ because we could hit a semicolon separating clauses in a for loop. Our synchronization isnâ€™t perfect, but thatâ€™s OK. Weâ€™ve already reported the first error precisely, so everything after that is kind of â€œbest effortâ€.</p>
<p>æˆ‘è¯´å¯èƒ½ï¼Œæ˜¯å› ä¸ºï¼Œæˆ‘ä»¬å¯ä»¥åœ¨for å¾ªç¯ä¸­ï¼Œä½¿ç”¨åˆ†å·ï¼Œåˆ†éš”å­—å¥ï¼Œæˆ‘ä»¬çš„åŒæ­¥å¹¶ä¸å®Œç¾ï¼Œè€½æ²¡æœ‰å…³ç³»ï¼Œæˆ‘ä»¬å·²ç»å‡†ç¡®çš„æŠ¥å‘Šäº†ç¬¬ä¸€ä¸ªé”™è¯¯ã€‚æ‰€ä»¥ï¼Œä¹‹åçš„éƒ½æ˜¯å°½åŠ›è€Œä¸ºã€‚</p>
</blockquote>
<p>This method encapsulates that logic:</p>
<p>ä¸‹é¢çš„æ–¹æ³•å°è£…äº†è¯¥é€»è¾‘ã€‚</p>
<pre><code class="language-java">
  private void synchronize() {
    advance();

    while (!isAtEnd()) {
      if (previous().type == SEMICOLON) return;

      switch (peek().type) {
        case CLASS:
        case FUN:
        case VAR:
        case FOR:
        case IF:
        case WHILE:
        case PRINT:
        case RETURN:
          return;
      }

      advance();
    }
  }

</code></pre>
<p>It discards tokens until it thinks it has found a statement boundary. After catching a ParseError, weâ€™ll call this and then we are hopefully back in sync. When it works well, we have discarded tokens that would have likely caused cascaded errors anyway, and now we can parse the rest of the file starting at the next statement.</p>
<p>Alas, we donâ€™t get to see this method in action, since we donâ€™t have statements yet. Weâ€™ll get to that in a couple of chapters. For now, if an error occurs, weâ€™ll panic and unwind all the way to the top and stop parsing. Since we can parse only a single expression anyway, thatâ€™s no big loss.</p>
<p>ä¸€ç›´åˆ°æˆ‘ä»¬æ‰¾åˆ°äº†è¯­å¥è¾¹ç•Œï¼Œæˆ‘ä»¬æ‰ä¼šä¸¢æ‰tokenï¼Œåœ¨æ•è·åˆ° ParseErrorå¯¹è±¡åï¼Œæˆ‘ä»¬å°†è°ƒç”¨æ­¤å‡½æ•°ï¼Œç„¶åï¼Œæˆ‘ä»¬æœ‰å¸Œæœ›èƒ½æ¢å¤åŒæ­¥ã€‚å½“å®ƒå¯ä»¥æ­£å¸¸å·¥ä½œçš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¸¢å¼ƒäº†å¯èƒ½ä¼šå¯¼è‡´çº§è”é”™è¯¯çš„tokenï¼Œç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸‹ä¸€æ¡è¯­å¥ï¼Œå¼€å§‹è§£ææ–‡ä»¶çš„å‰©ä½™éƒ¨åˆ†ã€‚</p>
<p>ä½†æ˜¯ï¼Œæˆ‘ä»¬è¿˜æ˜¯æ²¡æœ‰çœ‹åˆ°è¿™ç§æ–¹æ³•çš„å®é™…åº”ç”¨ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰è¯­å¥ã€‚æˆ‘ä»¬å°†åœ¨ä¸‹é¢çš„ç« èŠ‚ä¸­ï¼Œæ¥ç€è®¨è®ºã€‚ç°åœ¨ï¼Œå¦‚æœé‡åˆ°è§£æé”™è¯¯ï¼Œæˆ‘ä»¬å°†ä¼šç«‹å³è¿›å…¥ææ…Œæ¨¡å¼ï¼Œå¹¶ä¸”ä¸€ç›´å±•å¼€åˆ°é¡¶ç«¯ï¼Œåœæ­¢è§£æã€‚å› ä¸ºï¼Œå½“å‰æˆ‘ä»¬æœ€å¤šåªä¼šè§£æä¸€ä¸ªè¡¨è¾¾å¼è¯­å¥ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ä»€ä¹ˆå¤§çš„æŸå¤±ã€‚</p>
<h3 id="34-wiring-up-the-parser"><a class="header" href="#34-wiring-up-the-parser">3.4 Wiring up the Parser</a></h3>
<p>è¿æ¥è§£æå™¨</p>
<p>We are mostly done parsing expressions now. There is one other place where we need to add a little error handling. As the parser descends through the parsing methods for each grammar rule, it eventually hits primary(). If none of the cases in there match, it means we are sitting on a token that canâ€™t start an expression. We need to handle that error too.</p>
<p>æˆ‘ä»¬ç°åœ¨åŸºæœ¬ä¸Šï¼Œå®Œæˆäº†è§£æè¡¨è¾¾å¼ï¼Œä½†æ˜¯ï¼Œè¿˜æœ‰ä¸€ä¸ªåœ°æ–¹éœ€è¦æ·»åŠ é”™è¯¯å¤„ç†ã€‚å½“è§£æå™¨é€šè¿‡æ¯ä¸€ä¸ªè¯­æ³•è§„åˆ™å¯¹åº”çš„æ–¹æ³•ï¼Œé€’å½’ä¸‹é™æ—¶å€™ï¼Œå®ƒæœ€ç»ˆå°†åˆ°è¾¾ primary() æ–¹æ³•ã€‚å¦‚æœprimary() ä¸­æ‰€æœ‰çš„æƒ…å†µéƒ½æ— æ³•åŒ¹é…ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¤„äºä¸€ä¸ªæ— æ³•è§£æçš„tokenï¼Œæˆ‘ä»¬åŒæ ·éœ€è¦å¤„ç†è¿™ç§é”™è¯¯ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, in primary()

    private Expr primary() {
        if (match(FALSE))
            return new Expr.Literal(false);
        if (match(TRUE))
            return new Expr.Literal(true);
        if (match(NIL))
            return new Expr.Literal(null);

        if (match(NUMBER, STRING)) {
            return new Expr.Literal(previous().literal);
        }
        if (match(LEFT_PAREN)) {
            Expr expr = expression();
            consume(RIGHT_PAREN, &quot;Expect ')' after expression.&quot;);
            return new Expr.Grouping(expr);
        }

        throw error(peek(), &quot;Expect expression.&quot;);
    }
	
</code></pre>
<p>With that, all that remains in the parser is to define an initial method to kick it off. That method is called, naturally enough, parse().</p>
<p>ç°åœ¨ï¼Œè§£æå™¨ä¸­å‰©ä¸‹çš„å°±æ˜¯ï¼Œå®šä¹‰ä¸€ä¸ªå¯åŠ¨æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•è‡ªç„¶è¢«å‘½åä¸º parse().</p>
<pre><code class="language-java">
// lox/Parser.java, add after Parser()

  Expr parse() {
    try {
      return expression();
    } catch (ParseError error) {
      return null;
    }
  }
  
</code></pre>
<p>Weâ€™ll revisit this method later when we add statements to the language. For now, it parses a single expression and returns it. We also have some temporary code to exit out of panic mode. Syntax error recovery is the parserâ€™s job, so we donâ€™t want the ParseError exception to escape into the rest of the interpreter.</p>
<p>When a syntax error does occur, this method returns null. Thatâ€™s OK. The parser promises not to crash or hang on invalid syntax, but it doesnâ€™t promise to return a usable syntax tree if an error is found. As soon as the parser reports an error, hadError gets set, and subsequent phases are skipped.</p>
<p>Finally, we can hook up our brand new parser to the main Lox class and try it out. We still donâ€™t have an interpreter, so for now, weâ€™ll parse to a syntax tree and then use the AstPrinter class from the last chapter to display it.</p>
<p>å½“æˆ‘ä»¬åœ¨è¯­è¨€ä¸­æ·»åŠ äº†è¯­å¥åï¼Œæˆ‘ä»¬è¿˜å°†é‡æ–°è®¨è®ºè¿™ä¸ªæ–¹æ³•ã€‚ç°åœ¨ï¼Œå®ƒåªæ˜¯è§£æè¡¨è¾¾å¼å¹¶ä¸”è¿”å›ã€‚æˆ‘ä»¬è¿˜æœ‰ä¸€äº›ä¸´æ—¶ä»£ç ï¼Œå¯ä»¥é€€å‡ºææ…Œæ¨¡å¼ã€‚è¯­æ³•é”™è¯¯æ¢å¤æ˜¯è§£æå™¨çš„å·¥ä½œï¼Œå› æ­¤æˆ‘ä»¬ä¸å¸Œæœ›ParseError å¯¹è±¡é€ƒé€¸åˆ°ï¼Œè§£é‡Šå™¨çš„å…¶ä»–éƒ¨åˆ†ã€‚</p>
<p>å½“å‡ºç°è¯­æ³•é”™è¯¯æ—¶å€™ï¼Œparse() æ–¹æ³•è¿”å› nullï¼Œæ²¡å…³ç³»ï¼Œè§£æå™¨ï¼Œæ‰¿è¯ºå½“é‡åˆ°è¯­æ³•é”™è¯¯æ—¶å€™ï¼Œä¸ä¼šå¼•å‘å´©æºƒæˆ–è€…æŒ‚èµ·ï¼Œä½†æ˜¯ï¼Œå¦‚æœå‘ç°äº†è¯­æ³•é”™è¯¯ï¼Œå®ƒä¸ä¼šè¿”å›ä¸€ä¸ªè¯­æ³•æ ‘ã€‚ä¸€æ—¦è§£æå™¨æŠ¥é”™ï¼Œå°±ä¼šè®¾ç½® hadError, å¹¶ä¸”ä¼šè·³è¿‡åç»­é˜¶æ®µã€‚</p>
<p>æœ€åï¼Œæˆ‘ä»¬å°†æŠŠå…¨æ–°çš„è§£æå™¨ï¼Œè¿æ¥åˆ°ä¸»Loxç±»ä¸Šï¼Œè¿›è¡Œå°è¯•ã€‚æˆ‘ä»¬ä»ç„¶æ²¡æœ‰å®Œæˆè§£é‡Šå™¨ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬çš„è§£æç»“æœæ˜¯è¯­æ³•æ ‘ï¼Œç„¶åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ä¸Šä¸€ç« ä¸­çš„ AstPrinter ç±»ï¼Œå±•ç¤ºè¯­æ³•æ ‘ã€‚</p>
<p>Delete the old code to print the scanned tokens and replace it with this:</p>
<p>åˆ é™¤æ‰“å°token çš„æ—§ä»£ç ï¼Œæ›¿æ¢ä¸ºæ–°çš„è§£æå™¨</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 5 lines


    List&lt;Token&gt; tokens = scanner.scanTokens();
    Parser parser = new Parser(tokens);
    Expr expression = parser.parse();

    // Stop if there was a syntax error.
    if (hadError) return;

    System.out.println(new AstPrinter().print(expression));
  }
  
</code></pre>
<p>Congratulations, you have crossed the threshold! That really is all there is to handwriting a parser. Weâ€™ll extend the grammar in later chapters with assignment, statements, and other stuff, but none of that is any more complex than the binary operators we tackled here.</p>
<p>æ­å–œğŸ‰ï¼Œä½ å·²ç»è·¨è¿‡äº†é—¨æ§›ï¼Œè¿™å°±æ˜¯ç¼–å†™è§£æå™¨çš„å…¨éƒ¨å†…å®¹ã€‚æˆ‘ä»¬å°†åœ¨åé¢çš„ç« èŠ‚ä¸­ï¼Œç”¨èµ‹å€¼ã€è¯­å¥ï¼Œå…¶ä»–çš„ä¸œè¥¿ï¼Œæ¥æ‰©å±•è¯­æ³•ã€‚ä½†æ˜¯ï¼Œè¿™äº›éƒ½æ²¡æœ‰æœ¬ç« è®¨è®ºçš„äºŒå…ƒè¿ç®—ç¬¦ï¼Œæ›´åŠ å¤æ‚ã€‚</p>
<blockquote>
<p>It is possible to define a more complex grammar than Loxâ€™s thatâ€™s difficult to parse using recursive descent. Predictive parsing gets tricky when you may need to look ahead a large number of tokens to figure out what youâ€™re sitting on.</p>
<p>In practice, most languages are designed to avoid that. Even in cases where they arenâ€™t, you can usually hack around it without too much pain. If you can parse C++ using recursive descentâ€”which many C++ compilers doâ€”you can parse anything.</p>
<p>æœ‰å¯èƒ½å®šä¸€ä¸ªæ¯”Loxæ›´åŠ å¤æ‚çš„è¯­æ³•ï¼Œä½¿ç”¨é€’å½’ä¸‹é™æŠ€æœ¯å¾ˆéš¾è§£æï¼Œå½“ä½ å¯èƒ½éœ€è¦æå‰æŸ¥çœ‹å¤§é‡çš„tokenï¼Œç”¨æ¥ç¡®å®šä½ çš„æ‰€åœ¨ä½ç½®æ—¶å€™ï¼Œé¢„æµ‹æ€§è§£æå˜å¾—å¾ˆæ£˜æ‰‹ã€‚</p>
<p>å®é™…ä¸Šï¼Œå¤§å¤šæ•°çš„è¯­è¨€éƒ½æ˜¯ä¸ºäº†é¿å…è¿™ç§åœºæ™¯ã€‚å³ä½¿æ— æ³•é¿å…çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥ç»•è¿‡å®ƒï¼Œè€Œä¸ä¼šå¤ªç—›è‹¦ã€‚å¦‚æœä½ å¯ä»¥ç”¨é€’å½’ä¸‹é™æŠ€æœ¯è§£æC++ï¼Œåƒè®¸å¤šC++è§£æå™¨é‚£æ ·åšçš„ï¼Œé‚£ä¹ˆï¼Œä½ å°†å¯ä»¥è§£æä»»æ„çš„è¯­è¨€ã€‚</p>
</blockquote>
<p>Fire up the interpreter and type in some expressions. See how it handles precedence and associativity correctly? Not bad for less than 200 lines of code.</p>
<p>å¯åŠ¨è§£é‡Šå™¨ï¼Œå¹¶ä¸”è¾“å‡ºä¸€äº›è¡¨è¾¾å¼ï¼Œçœ‹çœ‹æˆ‘ä»¬çš„è§£é‡Šå™¨ï¼Œæ˜¯å¦‚ä½•å¤„ç†ä¼˜å…ˆçº§å’Œçº§è”çš„ï¼Œå¯¹ä¸€ä¸ªå°‘äº200è¡Œçš„ä»£ç çš„è§£é‡Šå™¨æ¥è¯´ï¼Œè¿˜ç®—æ˜¯ä¸é”™äº†ã€‚</p>
<h2 id="å››ä¹ é¢˜"><a class="header" href="#å››ä¹ é¢˜">å››ã€ä¹ é¢˜</a></h2>
<ol>
<li>
<p>In C, a block is a statement form that allows you to pack a series of statements where a single one is expected. The comma operator is an analogous syntax for expressions. A comma-separated series of expressions can be given where a single expression is expected (except inside a function callâ€™s argument list). At runtime, the comma operator evaluates the left operand and discards the result. Then it evaluates and returns the right operand.</p>
<p>Add support for comma expressions. Give them the same precedence and associativity as in C. Write the grammar, and then implement the necessary parsing code.</p>
</li>
<li>
<p>Likewise, add support for the C-style conditional or â€œternaryâ€ operator ?:. What precedence level is allowed between the ? and :? Is the whole operator left-associative or right-associative?</p>
</li>
<li>
<p>Add error productions to handle each binary operator appearing without a left-hand operand. In other words, detect a binary operator appearing at the beginning of an expression. Report that as an error, but also parse and discard a right-hand operand with the appropriate precedence.</p>
</li>
</ol>
<hr />
<ol>
<li>
<p>åœ¨Cè¯­è¨€ä¸­ï¼Œä»£ç å—ä¹Ÿæ˜¯ä¸€ç§è¯­å¥å½¢å¼ï¼Œå®ƒå…è®¸æˆ‘ä»¬å°†å¤šè¡Œä»£ç æ‰“åŒ…åˆ°ä¸€ä¸ªåªéœ€è¦ä¸€ä¸ªè¯­å¥çš„åœ°æ–¹ï¼Œ<a href="https://en.wikipedia.org/wiki/Comma_operator">é€—å·è¿ç®—ç¬¦</a>æ˜¯è¡¨è¾¾å¼çš„ç±»ä¼¼è¯­æ³•ï¼Œä¾‹å¦‚: <code>int a=1, b=2, c=3, i=0;</code>, åœ¨éœ€è¦å•ä¸ªè¡¨è¾¾å¼çš„åœ°æ–¹ï¼ˆå‡½æ•°è°ƒç”¨çš„å‚æ•°åˆ—è¡¨é™¤å¤–ï¼‰ï¼Œå¯ä»¥ç»™å‡ºé€—å·åˆ†éš”çš„è¡¨è¾¾å¼ç³»åˆ—ã€‚åœ¨è¿è¡Œæ—¶å€™ï¼Œé€—å·è¿ç®—ç¬¦ï¼Œè®¡ç®—å·¦æ“ä½œæ•°ï¼Œç„¶åä¸¢å¼ƒç»“æœï¼Œç„¶åè®¡ç®—å¹¶ä¸”è¿”å›å³æ“ä½œæ•°ã€‚</p>
<p>æ·»åŠ å¯¹äºé€—å·è¡¨è¾¾å¼çš„æ”¯æŒï¼Œç„¶åèµ‹äºˆå®ƒå’ŒC è¯­è¨€ä¸­ç›¸åŒçš„ä¼˜å…ˆçº§å’Œå…³è”æ€§ã€‚ç¼–å†™è¯­æ³•ï¼Œç„¶åå®ç°ï¼Œå¯¹åº”çš„è§£ææ–¹æ³•ã€‚</p>
</li>
<li>
<p>åŒæ ·çš„ï¼Œæ·»åŠ å¯¹äºä¸‰å…ƒè¿ç®—ç¬¦ <code>?:</code>çš„æ”¯æŒï¼Œ ? å’Œ : ä¹‹é—´æ˜¯ä»€ä¹ˆæ ·çš„å…³è”æ€§å‘¢ï¼Ÿæ•´ä¸ªä¸‰å…ƒè¿ç®—ç¬¦æ˜¯å·¦å…³è”è¿˜æ˜¯å³å…³è”çš„å‘¢ï¼Ÿ</p>
</li>
<li>
<p>æ·»åŠ é”™è¯¯å¤„ç†ï¼Œå¤„ç†æ¯ä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦ï¼Œæ²¡æœ‰å‡ºç°å·¦æ“ä½œæ•°ã€‚æ¢å¥è¯ï¼Œå°±æ˜¯ï¼Œæ£€æŸ¥æ¯ä¸€ä¸ªå‡ºç°åœ¨è¡¨è¾¾å¼å¼€å§‹çš„äºŒå…ƒè¿ç®—ç¬¦ï¼Œå°†å…¶æŠ¥å‘Šä¸ºé”™è¯¯ï¼Œä½†æ˜¯è¿˜è¦ç»§ç»­åˆ†æå¹¶ä¸”ä¸¢å¼ƒå…·æœ‰é€‚å½“ä¼˜å…ˆçº§çš„å³æ“ä½œæ•°ã€‚</p>
</li>
</ol>
<h2 id="äº”design-note-logic-versus-history"><a class="header" href="#äº”design-note-logic-versus-history">äº”ã€DESIGN NOTE: LOGIC VERSUS HISTORY</a></h2>
<p>è®¾è®¡è¯´æ˜ï¼šé€»è¾‘å’Œå†å²</p>
<p>Letâ€™s say we decide to add bitwise &amp; and | operators to Lox. Where should we put them in the precedence hierarchy? Câ€”and most languages that follow in Câ€™s footstepsâ€”place them below ==. This is widely considered a mistake because it means common operations like testing a flag require parentheses.</p>
<p>å‡è®¾æˆ‘ä»¬å†³å®šæ·»åŠ ä½è¿ç®—ç¬¦ï¼Œ&amp; å’Œ ï½œï¼Œ æˆ‘ä»¬åº”è¯¥æŠŠå®ƒä»¬æ”¾åœ¨ä¼˜å…ˆçº§ä¸­çš„å“ªä¸ªä½ç½®å‘¢ï¼ŸCè¯­è¨€å’Œå¤§éƒ¨åˆ†ç´§éšCè„šæ­¥çš„è¯­è¨€ä¸­ï¼Œä½è¿ç®—éƒ½åœ¨ == è¿ç®—ç¬¦ä¹‹ä¸‹ï¼Œè¿™è¢«å¹¿æ³›è®¤ä¸ºæ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œå› ä¸ºï¼Œå¦‚æœä½è¿ç®—ç¬¦ä¼˜å…ˆçº§ä½äº ==ï¼Œä¸‹é¢çš„æµ‹è¯•è¡¨è¾¾å¼éœ€è¦æ·»åŠ æ‹¬å·</p>
<pre><code>
if (flags &amp; FLAG_MASK == SOME_FLAG) { ... } // Wrong.
if ((flags &amp; FLAG_MASK) == SOME_FLAG) { ... } // Right.

</code></pre>
<p>Should we fix this for Lox and put bitwise operators higher up the precedence table than C does? There are two strategies we can take.</p>
<p>You almost never want to use the result of an == expression as the operand to a bitwise operator. By making bitwise bind tighter, users donâ€™t need to parenthesize as often. So if we do that, and users assume the precedence is chosen logically to minimize parentheses, theyâ€™re likely to infer it correctly.</p>
<p>This kind of internal consistency makes the language easier to learn because there are fewer edge cases and exceptions users have to stumble into and then correct. Thatâ€™s good, because before users can use our language, they have to load all of that syntax and semantics into their heads. A simpler, more rational language makes sense.</p>
<p>But, for many users there is an even faster shortcut to getting our languageâ€™s ideas into their wetwareâ€”use concepts they already know. Many newcomers to our language will be coming from some other language or languages. If our language uses some of the same syntax or semantics as those, there is much less for the user to learn (and unlearn).</p>
<p>This is particularly helpful with syntax. You may not remember it well today, but way back when you learned your very first programming language, code probably looked alien and unapproachable. Only through painstaking effort did you learn to read and accept it. If you design a novel syntax for your new language, you force users to start that process all over again.</p>
<p>Taking advantage of what users already know is one of the most powerful tools you can use to ease adoption of your language. Itâ€™s almost impossible to overestimate how valuable this is. But it faces you with a nasty problem: What happens when the thing the users all know kind of sucks? Câ€™s bitwise operator precedence is a mistake that doesnâ€™t make sense. But itâ€™s a familiar mistake that millions have already gotten used to and learned to live with.</p>
<p>æˆ‘ä»¬æ˜¯å¦åº”è¯¥åœ¨Loxè¯­è¨€ä¸­ï¼Œä¿®å¤è¿™ä¸ªé”™è¯¯ï¼Œå°†ä½è¿ç®—ç¬¦ä¼˜å…ˆçº§è®¾ç½®æ›´é«˜ï¼Œè€Œä¸æ˜¯Cè¯­è¨€ä¸­çš„ä¼˜å…ˆçº§ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡å–ä¸¤ç§ç­–ç•¥ï¼š</p>
<p>å› ä¸ºï¼Œæˆ‘ä»¬å‡ ä¹ä¸ä¼šæƒ³å°† == è¡¨è¾¾å¼çš„ç»“æœå½“ä½œä½è¿ç®—ç¬¦çš„æ“ä½œæ•°ï¼Œé€šè¿‡è®¾ç½®æ›´é«˜çš„ä½è¿ç®—ç¬¦ä¼˜å…ˆçº§ï¼Œç”¨æˆ·ä¸éœ€è¦ç»å¸¸æ·»åŠ  æ‹¬å·ï¼Œå› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬è¿™æ ·åšï¼Œå¹¶ä¸”ç”¨æˆ·å‡è®¾ä¼˜å…ˆé¡ºåºæ˜¯é€»è¾‘é€‰æ‹©çš„ï¼Œä»¥æœ€å°åŒ–æ‹¬å·ï¼Œé‚£ä¹ˆä»–ä»¬å¾ˆå¯èƒ½ä¼šæ­£ç¡®æ¨æ–­ã€‚</p>
<p>è¿™ç§å†…éƒ¨ä¸€è‡´æ€§ï¼Œä½¿å¾—è¯­è¨€æ›´åŠ å®¹æ˜“å­¦ä¹ ï¼Œå› ä¸ºç”¨æˆ·å¶ç„¶å‘ç°çš„è¾¹ç¼˜æƒ…å†µå’Œå¼‚å¸¸æ›´å°‘ã€‚è¿™å¾ˆå¥½ï¼Œå› ä¸ºåœ¨ç”¨æˆ·ä½¿ç”¨æˆ‘ä»¬çš„è¯­è¨€ä¹‹å‰ï¼Œæˆ‘ä»¬å¿…é¡»å°†è¿™äº›è¯­æ³•å’Œè¯­ä¹‰åŠ è½½åˆ°å¤§è„‘ä¸­ã€‚æ›´ç®€å•ï¼Œæ›´ç†æ€§çš„è¯­è¨€æ˜¯æœ‰æ„ä¹‰çš„</p>
<p>ä½†æ˜¯ï¼Œå¯¹äºè®¸å¤šç”¨æˆ·æ¥è¯´ï¼Œæœ‰ä¸€æ¡æ·å¾„å¯ä»¥å°†æˆ‘ä»¬çš„è¯­è¨€ç†å¿µï¼Œèå…¥åˆ°ä»–ä»¬å·²ç»ç†Ÿæ‚‰çš„å…¶ä»–è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬è¯­è¨€çš„ä½¿ç”¨è€…ï¼Œé€šå¸¸ç†Ÿæ‚‰å…¶ä»–è¯­è¨€ï¼Œå¦‚æœæˆ‘ä»¬çš„è¯­è¨€ä¸­ä½¿ç”¨äº†ä¸€äº›ä¸å¸¸è§è¯­è¨€ç›¸åŒçš„è¯­æ³•æˆ–è€…è¯­ä¹‰ï¼Œé‚£ä¹ˆä»–ä»¬å°†éœ€è¦å­¦ä¹ çš„ä¸œè¥¿å°†æ›´å°‘ã€‚</p>
<p>è¿™å¯¹äºè¯­æ³•ç‰¹åˆ«æœ‰ç”¨ï¼Œç°åœ¨ï¼Œä½ å¯èƒ½ä¸å¤ªè®°å¾—äº†ï¼Œä½†æ˜¯æ—©åœ¨ä½ å­¦ä¹ ç¬¬ä¸€é—¨ç¼–ç¨‹è¯­è¨€çš„æ—¶å€™ï¼Œä»£ç å¯èƒ½çœ‹èµ·æ¥å¾ˆé™Œç”Ÿï¼Œå¾ˆéš¾æ¥è¿‘ï¼Œåªæœ‰é€šè¿‡è‰°è‹¦çš„åŠªåŠ›ï¼Œä½ æ‰èƒ½å­¦ä¼šé˜…è¯»å’Œæ¥å—å®ƒï¼Œå¦‚æœä½ ä¸ºä½ çš„æ–°è¯­è¨€ï¼Œè®¾è®¡äº†ä¸€ä¸ªæ–°é¢–çš„è¯­æ³•ï¼Œä½ å®é™…ä¸Šï¼Œåœ¨å¼ºè¿«ç”¨æˆ·é‡æ–°å¼€å§‹è¿™ä¸ªè¿‡ç¨‹ã€‚</p>
<p>åˆ©ç”¨ç”¨æˆ·å·²ç»çŸ¥é“çš„çŸ¥è¯†ï¼Œæ˜¯ä½ ç®€åŒ–è¯­è¨€ï¼Œå¯ä»¥é‡‡ç”¨çš„æœ€å¼ºå¤§çš„å·¥å…·ä¹‹ä¸€ã€‚å‡ ä¹ä¸å¯èƒ½é«˜ä¼°å®ƒçš„ä»·å€¼ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬ä¼šé¢ä¸´ä¸€ä¸ªæ£˜æ‰‹çš„é—®é¢˜ï¼šå½“ç”¨æˆ·éƒ½çŸ¥é“ï¼ŒæŸä¸ªä¸œè¥¿æ¯”è¾ƒç³Ÿç³•æ—¶ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆå‘¢ï¼ŸCçš„ä½è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ï¼Œæ˜¯ä¸€ä¸ªæ²¡æœ‰æ„ä¹‰çš„é”™è¯¯ï¼Œæ•°ç™¾ä¸‡äººå·²ç»ä¹ æƒ¯äº†è¿™ä¸ªé”™è¯¯ã€‚</p>
<p>Do you stay true to your languageâ€™s own internal logic and ignore history? Do you start from a blank slate and first principles? Or do you weave your language into the rich tapestry of programming history and give your users a leg up by starting from something they already know?</p>
<p>There is no perfect answer here, only trade-offs. You and I are obviously biased towards liking novel languages, so our natural inclination is to burn the history books and start our own story.</p>
<p>In practice, itâ€™s often better to make the most of what users already know. Getting them to come to your language requires a big leap. The smaller you can make that chasm, the more people will be willing to cross it. But you canâ€™t always stick to history, or your language wonâ€™t have anything new and compelling to give people a reason to jump over.</p>
<p>ä½ æ˜¯å¦è¦åšæŒé€»è¾‘æ­£ç¡®ï¼Œå¿½ç•¥å†å²é—ç•™é—®é¢˜ã€‚ä½ æ˜¯ä»ä¸€å¼ ç™½æ¿å’Œç¬¬ä¸€åŸåˆ™å¼€å§‹çš„å—ï¼Ÿæˆ–è€…ä½ æ˜¯æŠŠè‡ªå·±çš„è¯­è¨€ï¼Œèå…¥åˆ°ç¼–ç¨‹è¯­è¨€çš„å†å²ä¸­å‘¢ï¼Ÿä»ç”¨æˆ·å·²ç»çŸ¥é“çš„ä¸œè¥¿å¼€å§‹ï¼Œç»™ä»–ä»¬ä¸€ä¸ªå¸®åŠ©ï¼Ÿ</p>
<p>è¿™é‡Œæ²¡æœ‰å®Œç¾çš„ç­”æ¡ˆï¼Œåªæœ‰æƒè¡¡ï¼Œå¯¹æˆ‘è€Œè¨€ï¼Œæ›´åŠ å–œæ¬¢æ–°é¢–çš„è¯­è¨€ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å°†è‡ªç„¶çš„çƒ§æ‰å†å²ä¹¦ï¼Œå¼€å§‹æˆ‘ä»¬è‡ªå·±çš„æ•…äº‹</p>
<p>å®é™…ä¸Šï¼Œæœ€å¥½æ˜¯å……åˆ†åˆ©ç”¨ç”¨æˆ·å·²æœ‰çŸ¥è¯†ï¼Œè®©ä»–ä»¬é€‚åº”ä½ çš„è¯­è¨€æ˜¯ä¸€ä¸ªå·¨å¤§çš„é£è·ƒï¼Œä½ è¶Šæ˜¯ç¼©å°è¿™ä¸ªé¸¿æ²Ÿï¼Œäººä»¬è¶Šæ˜¯æœ‰å¯èƒ½è·¨è¿‡å®ƒã€‚ä½†æ˜¯ï¼Œä½ ä¹Ÿä¸èƒ½æ€»æ˜¯åšæŒå†å²ï¼Œå¦åˆ™ä½ çš„è¯­è¨€ä¸ä¼šæœ‰ä»»ä½•åˆ›æ–°ï¼Œè®©äººä»¬æƒ³è¦è·³è¿‡é¸¿æ²Ÿã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è®¡ç®—è¡¨è¾¾å¼"><a class="header" href="#è®¡ç®—è¡¨è¾¾å¼">è®¡ç®—è¡¨è¾¾å¼</a></h1>
<blockquote>
<p>You are my creator, but I am your master; Obey!</p>
<p>ä½ æ˜¯æˆ‘çš„åˆ›é€ è€…ï¼Œä½†æˆ‘æ˜¯ä½ çš„ä¸»äººï¼Œæœä»å§ï¼</p>
<p align="right">â€”â€” Mary Shelley, Frankenstein ç›ä¸½.é›ªè±çš„ã€Šç§‘å­¦æ€ªäººã€‹ </p>
</blockquote>
<p>If you want to properly set the mood for this chapter, try to conjure up a thunderstorm, one of those swirling tempests that likes to yank open shutters at the climax of the story. Maybe toss in a few bolts of lightning. In this chapter, our interpreter will take breath, open its eyes, and execute some code.</p>
<p>å¦‚æœä½ æƒ³è¦ä¸ºè¿™ä¸€ç« æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„è®¾å®šæ°›å›´ï¼Œè¯•ç€æƒ³è±¡ä¸€åœºé›·é›¨ï¼Œä¸€åœºå–œæ¬¢åœ¨æ•…äº‹é«˜æ½®æ—¶å€™ï¼Œå¹å¼€ç™¾å¶çª—çš„æ—‹è½¬é£æš´ï¼Œä¹Ÿè®¸è¿˜ä¼šæ‰”å‡ºå‡ ä¸ªé—ªç”µï¼Œå“ˆå“ˆã€‚åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨å°†å±ä½å‘¼å¸ï¼Œçå¼€çœ¼ç›ï¼Œæ‰§è¡Œä¸€äº›ä»£ç ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/lightning.png?raw=true" alt="lightning" /></p>
<blockquote>
<p>A decrepit Victorian mansion is optional, but adds to the ambiance.</p>
<p>ä¸€åº§ç ´æ—§çš„ç»´å¤šåˆ©äºšå¼è±ªå®…æ˜¯å¯é€‰çš„ï¼Œä½†æ˜¯å¢åŠ äº†æ°›å›´ã€‚</p>
</blockquote>
<p>There are all manner of ways that language implementations make a computer do what the userâ€™s source code commands. They can compile it to machine code, translate it to another high-level language, or reduce it to some bytecode format for a virtual machine to run. For our first interpreter, though, we are going to take the simplest, shortest path and execute the syntax tree itself.</p>
<p>è®©è®¡ç®—æœºæ‰§è¡Œç”¨æˆ·æºä»£ç çš„ï¼Œè¯­è¨€å®ç°æ–¹å¼å¤šç§å¤šæ ·ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶ç¼–è¯‘ä¸ºæœºå™¨ç ï¼Œå°†å…¶ç¿»è¯‘ä¸ºå¦å¤–ä¸€é—¨é«˜çº§è¯­è¨€ï¼Œæˆ–è€…å°†å…¶ç®€åŒ–ä¸ºæŸç§å­—èŠ‚ç æ ¼å¼ï¼Œä»¥ä¾›è™šæ‹Ÿæœºè¿è¡Œï¼Œç„¶è€Œï¼Œå¯¹äºæˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªè§£é‡Šå™¨ï¼Œæˆ‘ä»¬å°†é‡‡ç”¨æœ€ç®€å•ï¼Œæœ€çŸ­çš„è·¯å¾„ï¼Œæ‰§è¡Œè¯­æ³•æ ‘æœ¬èº«ã€‚</p>
<p>Right now, our parser only supports expressions. So, to â€œexecuteâ€ code, we will evaluate an expression and produce a value. For each kind of expression syntax we can parseâ€”literal, operator, etc.â€”we need a corresponding chunk of code that knows how to evaluate that tree and produce a result. That raises two questions:</p>
<ol>
<li>
<p>What kinds of values do we produce?</p>
</li>
<li>
<p>How do we organize those chunks of code?</p>
</li>
</ol>
<p>Taking them on one at a timeâ€‰.â€‰.â€‰. </p>
<p>å½“å‰ï¼Œæˆ‘ä»¬çš„è§£æå™¨åªæ”¯æŒè§£æè¡¨è¾¾å¼ï¼Œæ‰€ä»¥ï¼Œæ‰§è¡Œä»£ç ï¼Œè¡¨ç¤ºæˆ‘ä»¬å°†è®¡ç®—è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ç”Ÿæˆå€¼ã€‚å¯¹äºæ¯ä¸€ç§è¡¨è¾¾å¼è¯­æ³•ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥è§£ææ–‡å­—ã€è¿ç®—ç¬¦ç­‰ç­‰ï¼Œæˆ‘ä»¬éœ€è¦ä¸€æ®µç›¸åº”çš„ä»£ç ï¼ŒçŸ¥é“å¦‚ä½•è®¡ç®—è¯­æ³•æ ‘ï¼Œå¹¶ä¸”è¿”å›è®¡ç®—ç»“æœã€‚è¿™å¼•å‘äº†ä¸¤ä¸ªé—®é¢˜ï¼š</p>
<ol>
<li>
<p>æˆ‘ä»¬å°†è®¡ç®—å‡ºä»€ä¹ˆå€¼</p>
</li>
<li>
<p>æˆ‘ä»¬å¦‚ä½•ç»„ç»‡ä»£ç </p>
</li>
</ol>
<p>è®©æˆ‘ä»¬ä¸€ä¸ªä¸ªè§£å†³é—®é¢˜ã€‚</p>
<h2 id="ä¸€representing-values"><a class="header" href="#ä¸€representing-values">ä¸€ã€Representing Values</a></h2>
<p>è¡¨ç¤ºè®¡ç®—å€¼</p>
<p>In Lox, values are created by literals, computed by expressions, and stored in variables. The user sees these as Lox objects, but they are implemented in the underlying language our interpreter is written in. That means bridging the lands of Loxâ€™s dynamic typing and Javaâ€™s static types. A variable in Lox can store a value of any (Lox) type, and can even store values of different types at different points in time. What Java type might we use to represent that?</p>
<p>åœ¨Loxä¸­ï¼Œå€¼ç”±æ–‡å­—åˆ›å»ºï¼Œè¡¨è¾¾å¼è®¡ç®—ï¼Œä¿å­˜åœ¨å˜é‡ä¸­ã€‚ç”¨æˆ·å°†è®¡ç®—å€¼å½“ä½œLoxä¸­çš„å¯¹è±¡ï¼Œä½†æ˜¯å®ƒä»¬æ˜¯ç”±è§£é‡Šå™¨åº•å±‚ç¼–å†™è¯­è¨€å®ç°çš„ã€‚è¿™æ„å‘³ç€ï¼Œæˆ‘ä»¬åœ¨LoxåŠ¨æ€è¯­è¨€å’ŒJavaé™æ€è¯­è¨€ä¹‹é—´ï¼Œæ­å»ºäº†ä¸€åº§æ¡¥æ¢ã€‚Loxä¸­çš„å˜é‡å¯ä»¥ä¿å­˜ä»»ä½•Loxç±»å‹çš„å€¼ï¼Œç”šè‡³å¯ä»¥åœ¨ä¸åŒçš„æ—¶é—´ç‚¹å­˜å‚¨ä¸åŒçš„ç±»å‹çš„æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨Javaä¸­çš„ä»€ä¹ˆç±»å‹è¡¨ç¤ºå‘¢ï¼Ÿ</p>
<blockquote>
<p>Here, Iâ€™m using â€œvalueâ€ and â€œobjectâ€ pretty much interchangeably.</p>
<p>Later in the C interpreter weâ€™ll make a slight distinction between them, but thatâ€™s mostly to have unique terms for two different corners of the implementationâ€”in-place versus heap-allocated data. From the userâ€™s perspective, the terms are synonymous.</p>
<p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠ value å’Œ objectå½“ä½œç›¸åŒçš„ä¸œè¥¿</p>
<p>ç¨åï¼Œåœ¨Cè§£é‡Šå™¨ä¸­ï¼Œæˆ‘ä»¬å°†å¯¹å®ƒä»¬è¿›è¡Œç»†å¾®çš„åŒºåˆ†ï¼Œä½†æ˜¯ï¼Œè¿™åªæ˜¯ä¸ºäº†ä½¿å¾—ä¸¤ç§ä¸åŒçš„å®ç°æ–¹å¼ï¼ˆæ ˆåˆ†é…ã€å †åˆ†é…ï¼‰ï¼Œæœ‰ä¸åŒçš„å”¯ä¸€æœ¯è¯­ï¼Œä»ç”¨æˆ·çš„è§’åº¦ï¼Œå®ƒä»¬æ˜¯åŒä¸€å«ä¹‰ã€‚</p>
</blockquote>
<p>Given a Java variable with that static type, we must also be able to determine which kind of value it holds at runtime. When the interpreter executes a + operator, it needs to tell if it is adding two numbers or concatenating two strings. Is there a Java type that can hold numbers, strings, Booleans, and more? Is there one that can tell us what its runtime type is? There is! Good old java.lang.Object.</p>
<p>ç»™å®šä¸€ä¸ªå…·æœ‰é™æ€ç±»å‹çš„Javaå˜é‡ï¼Œæˆ‘ä»¬è¿˜å¿…é¡»èƒ½å¤Ÿç¡®å®šå®ƒåœ¨è¿è¡Œæ—¶å€™ï¼ŒæŒæœ‰å“ªç§ç±»å‹çš„å€¼ã€‚å½“è§£é‡Šå™¨æ‰§è¡Œ+ è¿ç®—æ—¶å€™ï¼Œå®ƒéœ€è¦åˆ¤æ–­æ˜¯ä¸¤ä¸ªæ•°å­—çš„åŠ æ³•ï¼Œè¿˜æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²çš„è¿æ¥ã€‚æ˜¯å¦æœ‰ä¸€ç§Javaç±»å‹ï¼Œå¯ä»¥ä¿å­˜æ•°å­—ã€å­—ç¬¦ä¸²ã€å¸ƒå°”å€¼ç­‰ï¼Œæœ‰æ²¡æœ‰ä¸€ä¸ªå¯ä»¥å‘ŠçŸ¥æˆ‘ä»¬è¿è¡Œæ—¶å€™ï¼Œæ˜¯ä»€ä¹ˆç±»å‹çš„Javaç±»å‹ï¼Œå½“ç„¶æœ‰ï¼Œå®ƒå°±æ˜¯Javaä¸­çš„ Objectç±»å‹ã€‚</p>
<p>In places in the interpreter where we need to store a Lox value, we can use Object as the type. Java has boxed versions of its primitive types that all subclass Object, so we can use those for Loxâ€™s built-in types:</p>
<p>åœ¨è§£é‡Šå™¨ä¸­ï¼Œéœ€è¦ä¿å­˜Loxå€¼çš„åœ°æ–¹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Objectå½“ä½œç±»å‹ï¼ŒJavaæœ‰å…¶æ‰€æœ‰åŸå§‹ç±»å‹ï¼Œå¯¹åº”çš„Objectå­ç±»ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å°†å®ƒä»¬å½“ä½œLoxè¯­è¨€çš„å†…ç½®ç±»å‹ã€‚</p>
<table><thead><tr><th>Lox Type</th><th>Java representation</th></tr></thead><tbody>
<tr><td>Any Lox value</td><td>Object</td></tr>
<tr><td>nil</td><td>null</td></tr>
<tr><td>Boolean</td><td>Boolean</td></tr>
<tr><td>number</td><td>double</td></tr>
<tr><td>string</td><td>String</td></tr>
</tbody></table>
<p>Given a value of static type Object, we can determine if the runtime value is a number or a string or whatever using Javaâ€™s built-in instanceof operator. In other words, the JVMâ€™s own object representation conveniently gives us everything we need to implement Loxâ€™s built-in types. Weâ€™ll have to do a little more work later when we add Loxâ€™s notions of functions, classes, and instances, but Object and the boxed primitive classes are sufficient for the types we need right now.</p>
<p>ç»™å®šä¸€ä¸ªé™æ€ç±»å‹çš„å¯¹è±¡ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨Javaå†…ç½®çš„ instanceof æ“ä½œç¬¦ï¼Œæ¥ç¡®å®šè¿è¡Œæ—¶å€™ï¼Œè¯¥å¯¹è±¡çš„å€¼æ˜¯æ•°å­—ã€å­—ç¬¦ä¸²è¿˜æ˜¯å…¶ä»–ä»€ä¹ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒJVMè‡ªå·±çš„å¯¹è±¡è¡¨ç¤ºï¼Œå¯ä»¥æ–¹ä¾¿çš„ä¸ºæˆ‘ä»¬æä¾›å®ç°Lox å†…ç½®ç±»å‹çš„ä¸€åˆ‡ã€‚ç¨åï¼Œå½“æˆ‘ä»¬æ·»åŠ Loxçš„å‡½æ•°ã€ç±»ã€å®ä¾‹æ—¶å€™ï¼Œæˆ‘ä»¬å°†éœ€è¦åšæ›´å¤šçš„å·¥ä½œï¼Œä½†æ˜¯ï¼ŒObject å’Œ å°è£…çš„åŸå§‹ç±»ï¼Œå¯¹äºæˆ‘ä»¬éœ€è¦çš„ç±»å‹å·²ç»è¶³å¤Ÿäº†ã€‚</p>
<blockquote>
<p>Another thing we need to do with values is manage their memory, and Java does that too. A handy object representation and a really nice garbage collector are the main reasons weâ€™re writing our first interpreter in Java.</p>
<p>å¯¹äºå€¼ï¼Œæˆ‘ä»¬éœ€è¦åšçš„ä¸€ä»¶äº‹æƒ…æ˜¯ï¼Œç®¡ç†å®ƒä»¬çš„å†…å­˜ï¼ŒJavaä¹Ÿè¿™æ ·åšï¼Œæ–¹ä¾¿çš„å¯¹è±¡è¡¨ç¤ºå’Œéå¸¸å¥½çš„åƒåœ¾å›æ”¶ï¼Œæ˜¯æˆ‘ä»¬ç”¨Javaç¼–å†™ç¬¬ä¸€ä¸ªè§£é‡Šå™¨çš„ä¸»è¦åŸå› </p>
</blockquote>
<h2 id="äºŒevaluating-expressions"><a class="header" href="#äºŒevaluating-expressions">äºŒã€Evaluating Expressions</a></h2>
<p>è®¡ç®—è¡¨è¾¾å¼</p>
<p>Next, we need blobs of code to implement the evaluation logic for each kind of expression we can parse. We could stuff that code into the syntax tree classes in something like an interpret() method. In effect, we could tell each syntax tree node, â€œInterpret thyselfâ€. This is the Gang of Fourâ€™s Interpreter design pattern. Itâ€™s a neat pattern, but like I mentioned earlier, it gets messy if we jam all sorts of logic into the tree classes.</p>
<p>Instead, weâ€™re going to reuse our groovy Visitor pattern. In the previous chapter, we created an AstPrinter class. It took in a syntax tree and recursively traversed it, building up a string which it ultimately returned. Thatâ€™s almost exactly what a real interpreter does, except instead of concatenating strings, it computes values.</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦å†™ä»£ç ï¼Œå®ç°æˆ‘ä»¬å¯ä»¥è§£æçš„æ¯ä¸€ç§è¡¨è¾¾å¼çš„æ±‚å€¼é€»è¾‘ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ç±»ä¼¼äº interpret()æ–¹æ³•çš„æ–¹å¼ï¼Œå°†ä»£ç å¡«å†™åˆ°è¯­æ³•æ ‘ç±»ä¸­ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å‘Šè¯‰æ¯ä¸€ä¸ªè¯­æ³•æ ‘èŠ‚ç‚¹ï¼Œè§£é‡Šè‡ªå·±ã€‚è¿™æ˜¯è®¾è®¡æ¨¡å¼ä¹¦ç±ä¸­çš„<a href="https://en.wikipedia.org/wiki/Interpreter_pattern">è§£æå™¨æ¨¡å¼</a>, è¿™æ˜¯ä¸€ä¸ªæ•´æ´çš„æ¨¡å¼ï¼Œä½†æ˜¯ï¼Œæ­£å¦‚æˆ‘å‰é¢æåˆ°çš„ï¼Œå¦‚æœæˆ‘ä»¬æŠŠå„ç§é€»è¾‘éƒ½å¡åˆ°è¯­æ³•æ ‘ç±»ä¸­ï¼Œå°±ä¼šå˜å¾—éå¸¸æ··ä¹±ã€‚</p>
<p>ç›¸åï¼Œæˆ‘ä»¬å°†ä½¿ç”¨æ›´åŠ å¸¸è§„çš„è®¿é—®è€…æ¨¡å¼ï¼Œåœ¨å…ˆå‰ç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ª AstPrinterç±»ï¼Œå®ƒæ¥å—ä¸€ä¸ªè¯­æ³•æ ‘ï¼Œç„¶åé€’å½’éå†å®ƒï¼Œæ„å»ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”æœ€ç»ˆè¿”å›è¿™ä¸ªå­—ç¬¦ä¸²ã€‚è¿™å‡ ä¹æ˜¯ï¼ŒçœŸæ­£çš„è§£é‡Šå™¨æ‰€åšçš„ï¼Œåªæ˜¯å®ƒä¸æ˜¯è¿æ¥å­—ç¬¦ä¸²ï¼Œè€Œæ˜¯è®¡ç®—å€¼ã€‚</p>
<p>We start with a new class.</p>
<p>æˆ‘ä»¬æ–°å»ºä¸€ä¸ªç±»</p>
<pre><code class="language-java">
// lox/Interpreter.java, create new file

package com.craftinginterpreters.lox;

class Interpreter implements Expr.Visitor&lt;Object&gt; {
}

</code></pre>
<p>The class declares that itâ€™s a visitor. The return type of the visit methods will be Object, the root class that we use to refer to a Lox value in our Java code. To satisfy the Visitor interface, we need to define visit methods for each of the four expression tree classes our parser produces. Weâ€™ll start with the simplestâ€‰.â€‰.â€‰. </p>
<p>Interpreterç±»ï¼Œå£°æ˜äº†å®ƒæ˜¯è®¿é—®è€…ï¼Œè®¿é—®æ–¹æ³•çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªobjectç±»å‹ï¼Œè¿™æ˜¯æˆ‘ä»¬Javaä»£ç ä¸­ç”¨æ¥å¼•ç”¨Loxå€¼çš„æ ¹ç±»ã€‚ä¸ºäº†æ»¡è¶³Visitoræ¥å£ï¼Œæˆ‘ä»¬éœ€è¦ä¸ºè§£æå™¨ç”Ÿæˆçš„4ä¸ªè¡¨è¾¾å¼æ ‘ç±»ä¸­çš„æ¯ä¸€ä¸ªå®šä¹‰è®¿é—®æ–¹æ³•ï¼Œè®©æˆ‘ä»¬ä»æœ€ç®€å•çš„å¼€å§‹...</p>
<h3 id="21-evaluating-literals"><a class="header" href="#21-evaluating-literals">2.1 Evaluating literals</a></h3>
<p>è®¡ç®—æ–‡æœ¬</p>
<p>The leaves of an expression treeâ€”the atomic bits of syntax that all other expressions are composed ofâ€”are literals. Literals are almost values already, but the distinction is important. A literal is a bit of syntax that produces a value. A literal always appears somewhere in the userâ€™s source code. Lots of values are produced by computation and donâ€™t exist anywhere in the code itself. Those arenâ€™t literals. A literal comes from the parserâ€™s domain. Values are an interpreter concept, part of the runtimeâ€™s world.</p>
<p>è¡¨è¾¾å¼è¯­æ³•æ ‘çš„å¶å­ï¼Œæ‰€æœ‰å…¶ä»–è¡¨è¾¾å¼ç»„æˆçš„è¯­æ³•ï¼Œéƒ½æ˜¯åŸå­æ€§çš„æ–‡æœ¬ã€‚æ–‡æœ¬å‡ ä¹å·²ç»æ˜¯å€¼äº†ï¼Œä½†æ˜¯åŒºåˆ†ä¹Ÿå¾ˆé‡è¦ã€‚æ–‡æœ¬ä¹Ÿæ˜¯ä¸€ä¸ªäº§ç”Ÿå€¼çš„è¯­æ³•ï¼Œæ–‡æœ¬æ€»æ˜¯å‡ºç°åœ¨ç”¨æˆ·æºä»£ç ä¸­çš„æŸä¸ªä½ç½®ï¼Œå¾ˆå¤šå€¼éƒ½æ˜¯é€šè¿‡è®¡ç®—äº§ç”Ÿçš„ï¼Œå¹¶ä¸”ä¸å­˜åœ¨äºä»£ç çš„ä»»ä½•åœ°æ–¹ï¼Œå®ƒä»¬ä¸æ˜¯æ–‡æœ¬ï¼Œæ–‡æœ¬æ¥è‡ªè§£æå™¨çš„ä½œç”¨åŸŸï¼Œå€¼æ˜¯ä¸€ä¸ªè§£é‡Šå™¨æ¦‚å¿µï¼Œæ˜¯è¿è¡Œæ—¶çš„ä¸€éƒ¨åˆ†ã€‚</p>
<blockquote>
<p>In the next chapter, when we implement variables, weâ€™ll add identifier expressions, which are also leaf nodes.</p>
<p>åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œå½“æˆ‘ä»¬å®ç°å˜é‡æ—¶å€™ï¼Œæˆ‘ä»¬å°†æ·»åŠ æ ‡è¯†ç¬¦è¡¨è¾¾å¼ï¼Œå®ƒä»¬ä¹Ÿæ˜¯å¶èŠ‚ç‚¹ã€‚</p>
</blockquote>
<p>So, much like we converted a literal token into a literal syntax tree node in the parser, now we convert the literal tree node into a runtime value. That turns out to be trivial.</p>
<p>å› æ­¤ï¼Œå°±åƒæˆ‘ä»¬åœ¨è§£æå™¨ä¸­ï¼Œå°†æ–‡æœ¬ tokenè½¬å˜ä¸ºæ–‡æœ¬è¯­æ³•æ ‘èŠ‚ç‚¹ä¸€æ ·ï¼Œç°åœ¨æˆ‘ä»¬å°†æ–‡æœ¬è¯­æ³•æ ‘èŠ‚ç‚¹ï¼Œè½¬å˜ä¸ºè¿è¡Œæ—¶å€¼ï¼Œè½¬å˜æ˜¯éå¸¸ç®€å•çš„</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

  @Override
  public Object visitLiteralExpr(Expr.Literal expr) {
    return expr.value;
  }
  
</code></pre>
<p>We eagerly produced the runtime value way back during scanning and stuffed it in the token. The parser took that value and stuck it in the literal tree node, so to evaluate a literal, we simply pull it back out.</p>
<p>æˆ‘ä»¬åœ¨æ‰«æé˜¶æ®µç”Ÿæˆäº†è¿è¡Œæ—¶å€™å€¼ï¼Œå¹¶ä¸”å°†å®ƒå¡«å……åˆ°tokenä¸­ï¼Œè§£æå™¨è·å–åˆ°è¯¥å€¼ï¼Œå¹¶ä¸”å°†å…¶å›ºå®šåœ¨æ–‡æœ¬æ ‘èŠ‚ç‚¹ä¸­ï¼Œå› æ­¤ï¼Œæ¥ä¸‹æ¥æƒ³è¦è®¡ç®—æ–‡æœ¬ï¼Œæˆ‘ä»¬åªéœ€è¦å°†å…¶æ‹‰å‡ºæ¥å°±å¯ä»¥äº†ã€‚</p>
<h3 id="22-evaluating-parentheses"><a class="header" href="#22-evaluating-parentheses">2.2 Evaluating parentheses</a></h3>
<p>è®¡ç®—æ‹¬å·</p>
<p>The next simplest node to evaluate is groupingâ€”the node you get as a result of using explicit parentheses in an expression.</p>
<p>æ¥ä¸‹æ¥è¦å¤„ç†çš„èŠ‚ç‚¹ï¼Œæœ€ç®€å•ï¼Œæˆ‘ä»¬åªéœ€è¦æ˜¾ç¤ºçš„ç”¨æ‹¬å·ï¼Œå°†è·å–åˆ°çš„èŠ‚ç‚¹è¿›è¡Œåˆ†ç»„</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

 @Override
  public Object visitGroupingExpr(Expr.Grouping expr) {
    return evaluate(expr.expression);
  }
  
</code></pre>
<p>A grouping node has a reference to an inner node for the expression contained inside the parentheses. To evaluate the grouping expression itself, we recursively evaluate that subexpression and return it.</p>
<p>ä¸€ä¸ªåˆ†ç»„èŠ‚ç‚¹ï¼ŒåŒ…å«æœ‰å¯¹äºå†…éƒ¨è¡¨è¾¾å¼èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œä¸ºäº†è®¡ç®—è¡¨è¾¾å¼æœ¬èº«ï¼Œæˆ‘ä»¬éœ€è¦é€’å½’çš„è®¡ç®—å­è¡¨è¾¾å¼ï¼Œå¹¶ä¸”è¿”å›ç»“æœ</p>
<p>We rely on this helper method which simply sends the expression back into the interpreterâ€™s visitor implementation:</p>
<p>æˆ‘ä»¬å°†ä¾èµ–è¿™ä¸ªå¸®åŠ©æ–¹æ³•ï¼Œå®ƒåªéœ€è¦å°†è¡¨è¾¾å¼å‘é€å›è§£é‡Šå™¨çš„è®¿é—®è€…æ¨¡å¼å®ç°</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

  private Object evaluate(Expr expr) {
    return expr.accept(this);
  }
  
</code></pre>
<blockquote>
<p>Some parsers donâ€™t define tree nodes for parentheses. Instead, when parsing a parenthesized expression, they simply return the node for the inner expression. We do create a node for parentheses in Lox because weâ€™ll need it later to correctly handle the left-hand sides of assignment expressions.</p>
<p>æœ‰ä¸€äº›è§£æå™¨ä¸ä¼šä¸ºæ‹¬å·å®šä¹‰æ ‘èŠ‚ç‚¹ï¼Œç›¸åï¼Œå½“é‡åˆ°å¸¦æ‹¬å·çš„è¡¨è¾¾å¼æ—¶å€™ï¼Œå®ƒä»¬åªä¼šè¿”å›å†…éƒ¨è¡¨è¾¾å¼çš„èŠ‚ç‚¹ï¼Œæˆ‘ä»¬ç¡®å®ä¸ºLoxè¯­è¨€ä¸­ä¸ºæ‹¬å·åˆ›å»ºäº†ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå› ä¸ºç¨åï¼Œæˆ‘ä»¬å°†ç”¨åˆ°å®ƒï¼Œæ¥æ­£ç¡®å¤„ç†èµ‹å€¼è¡¨è¾¾å¼çš„å·¦ä¾§ã€‚</p>
</blockquote>
<h2 id="23-evaluating-unary-expressions"><a class="header" href="#23-evaluating-unary-expressions">2.3 Evaluating unary expressions</a></h2>
<p>è®¡ç®—ä¸€å…ƒè¡¨è¾¾å¼</p>
<p>Like grouping, unary expressions have a single subexpression that we must evaluate first. The difference is that the unary expression itself does a little work afterwards.</p>
<p>å’Œåˆ†ç»„ä¸€æ ·ï¼Œä¸€å…ƒè¡¨è¾¾å¼ï¼Œæœ‰ä¸€ä¸ªå­è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦å…ˆè¿›è¡Œè®¡ç®—ï¼Œä¸åŒäºåˆ†ç»„ï¼Œæˆ‘ä»¬åœ¨ä¸€å…ƒè¡¨è¾¾å¼è®¡ç®—ç»“æœåï¼Œåˆåšäº†ä¸€äº›å·¥ä½œã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitLiteralExpr()

  @Override
  public Object visitUnaryExpr(Expr.Unary expr) {
    Object right = evaluate(expr.right);

    switch (expr.operator.type) {
      case MINUS:
        return -(double)right;
    }

    // Unreachable.
    return null;
  }
  
</code></pre>
<p>First, we evaluate the operand expression. Then we apply the unary operator itself to the result of that. There are two different unary expressions, identified by the type of the operator token.</p>
<p>Shown here is -, which negates the result of the subexpression. The subexpression must be a number. Since we donâ€™t statically know that in Java, we cast it before performing the operation. This type cast happens at runtime when the - is evaluated. Thatâ€™s the core of what makes a language dynamically typed right there.</p>
<p>é¦–å…ˆï¼Œæˆ‘ä»¬è®¡ç®—å†…éƒ¨çš„æ“ä½œæ•°è¡¨è¾¾å¼ï¼Œç„¶åï¼Œæˆ‘ä»¬å°†ä¸€å…ƒè¿ç®—ç¬¦æœ¬èº«åº”ç”¨äºè®¡ç®—ç»“æœï¼Œæœ‰ä¸¤ä¸ªä¸åŒçš„ä¸€å…ƒè¿ç®—ç¬¦ï¼Œæ˜¯ç”±è¿ç®—ç¬¦tokençš„ç±»å‹å†³å®šçš„</p>
<p>ä¸Šé¢å±•ç¤ºçš„æ˜¯ -ï¼Œ å®ƒè¡¨ç¤ºå­è¡¨è¾¾å¼ç»“æœçš„è´Ÿå€¼ï¼Œå­è¡¨è¾¾å¼çš„ç»“æœå¿…é¡»æ˜¯æ•°å€¼ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨Javaä¸­ä¸çŸ¥é“è¿™ä¸€ç‚¹ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åœ¨è¿›è¡Œæ“ä½œä¹‹å‰ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œå½“è®¡ç®— - è¿ç®—æ—¶å€™ï¼Œæ­¤ç±»å‹è½¬æ¢åœ¨è¿è¡Œæ—¶å€™å‘ç”Ÿï¼Œè¿™æ­£æ˜¯åŠ¨æ€ç±»å‹è¯­è¨€çš„æ ¸å¿ƒæ‰€åœ¨ã€‚</p>
<blockquote>
<p>Youâ€™re probably wondering what happens if the cast fails. Fear not, weâ€™ll get into that soon.</p>
<p>ä½ å¯èƒ½æƒ³è¦çŸ¥é“å¦‚æœç±»å‹è½¬æ¢å¤±è´¥ï¼Œä¼šæœ‰ä»€ä¹ˆç»“æœï¼Œæˆ‘ä»¬é©¬ä¸Šå°±ä¼šä»‹ç»</p>
</blockquote>
<p>You can start to see how evaluation recursively traverses the tree. We canâ€™t evaluate the unary operator itself until after we evaluate its operand subexpression. That means our interpreter is doing a post-order traversalâ€”each node evaluates its children before doing its own work.</p>
<p>ä½ å¯ä»¥å¼€å§‹çœ‹åˆ°ï¼Œæ±‚å€¼å¦‚ä½•é€’å½’éå†æ ‘ï¼Œåœ¨è®¡ç®—ä¸€å…ƒè¡¨è¾¾å¼çš„å³è¾¹å­è¡¨è¾¾å¼ä¹‹å‰ï¼Œæˆ‘ä»¬æ— æ³•è®¡ç®—ä¸€å…ƒè¡¨è¾¾å¼çš„å€¼ï¼Œè¿™æ„å¤–ç€æˆ‘ä»¬çš„è§£é‡Šå™¨å°†è¿›è¡Œä¸€ä¸ªååºéå†â€”â€”æ‰§è¡Œè‡ªå·±æœ¬èº«ä¹‹å‰ï¼Œå…ˆå¯¹è‡ªå·±çš„å­èŠ‚ç‚¹è¿›è¡Œè®¡ç®—</p>
<p>The other unary operator is logical not.</p>
<p>è¿˜æœ‰ä¸€ä¸ªä¸€å…ƒè¿ç®—ç¬¦æ˜¯ å¸ƒå°”é</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitUnaryExpr()

    switch (expr.operator.type) {
      case BANG:
        return !isTruthy(right);
      case MINUS:
	  
</code></pre>
<p>The implementation is simple, but what is this â€œtruthyâ€ thing about? We need to make a little side trip to one of the great questions of Western philosophy: What is truth?</p>
<p>å®ç°éå¸¸ç®€å•ï¼Œä½†æ˜¯&quot;çœŸå®â€œ æ˜¯ä»€ä¹ˆä¸œè¥¿å‘¢ï¼Ÿæˆ‘ä»¬éœ€è¦å¯¹è¥¿æ–¹å“²å­¦çš„ä¸€ä¸ªé‡å¤§é—®é¢˜åšä¸€ä¸ªå°å°çš„æ—è§‚è€…â€”â€”ä»€ä¹ˆæ˜¯çœŸç†ï¼Ÿ</p>
<h3 id="24-truthiness-and-falsiness"><a class="header" href="#24-truthiness-and-falsiness">2.4 Truthiness and falsiness</a></h3>
<p>çœŸå®å’Œè™šå‡</p>
<p>OK, maybe weâ€™re not going to really get into the universal question, but at least inside the world of Lox, we need to decide what happens when you use something other than true or false in a logic operation like ! or any other place where a Boolean is expected.</p>
<p>We could just say itâ€™s an error because we donâ€™t roll with implicit conversions, but most dynamically typed languages arenâ€™t that ascetic. Instead, they take the universe of values of all types and partition them into two sets, one of which they define to be â€œtrueâ€, or â€œtruthfulâ€, or (my favorite) â€œtruthyâ€, and the rest which are â€œfalseâ€ or â€œfalseyâ€. This partitioning is somewhat arbitrary and gets weird in a few languages.</p>
<p>å¥½å§ï¼Œä¹Ÿè®¸æˆ‘ä»¬ä¸ä¼šå»æ€è€ƒè¿™ä¸ªé‡å¤§çš„å“²å­¦é—®é¢˜ï¼Œä½†æ˜¯ï¼Œè‡³å°‘åœ¨Loxçš„ä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰å½“ æˆ‘ä»¬ä½¿ç”¨é true/falseè¿™æ ·çš„é€»è¾‘å€¼ï¼Œå’Œé€»è¾‘è¿ç®—ç¬¦ ï¼ï¼Œè®¡ç®—æ—¶å€™ï¼Œå°†ä¼šå¾—åˆ°ä»€ä¹ˆå‘¢ï¼Ÿæˆ–è€…å…¶ä»–éœ€è¦æä¾›ä¸€ä¸ªé€»è¾‘å€¼çš„åœ°æ–¹</p>
<p>æˆ‘ä»¬å¯ä»¥å®šä¹‰ï¼Œä¸æ”¯æŒå…¶ä»–ç±»å‹çš„é€»è¾‘éè¿ç®—ï¼Œå› ä¸ºæˆ‘ä»¬ä¸æ”¯æŒéšå¼è½¬æ¢ï¼Œä½†æ˜¯ï¼Œå¤§å¤šæ•°çš„åŠ¨æ€è¯­è¨€æ²¡æœ‰è¿™ä¹ˆä¸¥æ ¼çš„é™åˆ¶ï¼Œç›¸åï¼Œæˆ‘ä»¬ä¼šå°†æ‰€æœ‰ç±»å‹çš„å€¼åˆ†ä¸ºä¸¤ç»„ï¼Œå…¶ä¸­ä¸€ç»„å®šä¹‰ä¸ºçœŸï¼Œå¦å¤–ä¸€ç»„å®šä¹‰ä¸ºå‡ï¼Œè¿™ç§åˆ†åŒºæ¯”è¾ƒéšæ„ï¼Œåœ¨ä¸€äº›è¯­è¨€ä¸­ä¼šå˜å¾—æœ‰äº›å¥‡æ€ªã€‚</p>
<blockquote>
<p>In JavaScript, strings are truthy, but empty strings are not. Arrays are truthy but empty arrays areâ€‰.â€‰.â€‰. also truthy. The number 0 is falsey, but the string &quot;0&quot; is truthy.</p>
<p>In Python, empty strings are falsey like in JS, but other empty sequences are falsey too.</p>
<p>In PHP, both the number 0 and the string &quot;0&quot; are falsey. Most other non-empty strings are truthy.</p>
<p>Get all that?</p>
<p>åœ¨JavaScript ä¸­ï¼Œå­—ç¬¦ä¸²æ˜¯trueï¼Œç©ºå­—ç¬¦ä¸²æ˜¯falseï¼Œæ•°ç»„æ˜¯trueï¼Œä½†æ˜¯ç©ºæ•°ç»„ä¹Ÿæ˜¯trueï¼ŒğŸ˜„ï¼Œæ•°å­—0æ˜¯falseï¼Œä½†æ˜¯å­—ç¬¦ä¸²&quot;0&quot;æ˜¯true</p>
<p>åœ¨Pythonä¸­ï¼Œç©ºå­—ç¬¦ä¸²å’ŒJSç›¸ä¼¼ï¼Œä½†æ˜¯å…¶ä»–ç©ºåºåˆ—ä¹Ÿæ˜¯ false</p>
<p>åœ¨PHPä¸­ï¼Œæ— è®ºæ•°å­—0è¿˜æ˜¯å­—ç¬¦ä¸² &quot;0&quot; éƒ½æ˜¯falseï¼Œå¤§å¤šæ•°å…¶ä»–éç©ºå­—ç¬¦ä¸²éƒ½æ˜¯true</p>
<p>æ˜ç™½äº†å—ï¼Ÿ</p>
</blockquote>
<p>Lox follows Rubyâ€™s simple rule: false and nil are falsey, and everything else is truthy. We implement that like so:</p>
<p>Loxå€Ÿé‰´äº†Rubyä¸­çš„ç®€å•åˆ¤æ–­æ–¹æ³•ï¼Œfalseå’Œ nil æ˜¯è™šå‡çš„ï¼Œå…¶ä»–éƒ½æ˜¯çœŸå®çš„</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitUnaryExpr()

  private boolean isTruthy(Object object) {
    if (object == null) return false;
    if (object instanceof Boolean) return (boolean)object;
    return true;
  }
  
</code></pre>
<h3 id="25-evaluating-binary-operators"><a class="header" href="#25-evaluating-binary-operators">2.5 Evaluating binary operators</a></h3>
<p>è®¡ç®—äºŒå…ƒè¿ç®—ç¬¦</p>
<p>On to the last expression tree class, binary operators. Thereâ€™s a handful of them, and weâ€™ll start with the arithmetic ones.</p>
<p>æœ€åä¸€ä¸ªè¡¨è¾¾å¼è®¡ç®—ï¼ŒäºŒå…ƒè¿ç®—ç¬¦ï¼Œæˆ‘ä»¬å°†å…ˆä»ç®—æœ¯è¿ç®—ç¬¦å¼€å§‹</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after evaluate()

  @Override
  public Object visitBinaryExpr(Expr.Binary expr) {
    Object left = evaluate(expr.left);
    Object right = evaluate(expr.right); 

    switch (expr.operator.type) {
      case MINUS:
        return (double)left - (double)right;
      case SLASH:
        return (double)left / (double)right;
      case STAR:
        return (double)left * (double)right;
    }

    // Unreachable.
    return null;
  }
  
</code></pre>
<blockquote>
<p>Did you notice we pinned down a subtle corner of the language semantics here? In a binary expression, we evaluate the operands in left-to-right order. If those operands have side effects, that choice is user visible, so this isnâ€™t simply an implementation detail.</p>
<p>If we want our two interpreters to be consistent (hint: we do), weâ€™ll need to make sure clox does the same thing.</p>
<p>ä½ æ˜¯å¦æ³¨æ„åˆ°ï¼Œæˆ‘ä»¬è¿™é‡Œäº†ä¸€ä¸ªè¯­è¨€è¯­ä¹‰çš„ä¸€ä¸ªè§’è½ï¼Œåœ¨äºŒå…ƒè¡¨è¾¾å¼ä¸­ï¼Œæˆ‘ä»¬ä¼šä»å·¦åˆ°å³è®¡ç®—æ“ä½œæ•°ï¼Œå¦‚æœè¿™äº›æ“ä½œæ•°æœ‰å‰¯ä½œç”¨ï¼Œç”¨æˆ·å¯ä»¥çœ‹åˆ°è¿™äº›é€‰é¡¹ï¼Œå› æ­¤ï¼Œè¿™ä¸ä»…ä»…æ˜¯ä¸€ä¸ªå®ç°ç»†èŠ‚</p>
<p>å¦‚æœä½ å¸Œæœ›æˆ‘ä»¬çš„ä¸¤ä¸ªè§£é‡Šå™¨ä¿æŒä¸€è‡´ï¼Œï¼ˆæˆ‘ä»¬çœŸçš„åšåˆ°äº†ï¼‰ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿cLoxè§£é‡Šå™¨ï¼Œå®ç°ç›¸åŒçš„æ“ä½œ</p>
</blockquote>
<p>I think you can figure out whatâ€™s going on here. The main difference from the unary negation operator is that we have two operands to evaluate.</p>
<p>I left out one arithmetic operator because itâ€™s a little special.</p>
<p>æˆ‘è®¤ä¸ºï¼Œä½ åº”è¯¥å¯ä»¥å¼„æ¸…æ¥šè¿™é‡Œå‘ç”Ÿäº†ä»€ä¹ˆï¼Œä¸ä¸€å…ƒå¦å®šæ“ä½œç¬¦ä¸åŒçš„æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦è®¡ç®—å·¦/å³ä¸¤ä¸ªæ“ä½œæ•°</p>
<p>æˆ‘é—æ¼äº†ä¸€ä¸ªç®—æœ¯è¿ç®—ç¬¦ï¼Œå› ä¸ºå®ƒæœ‰äº›ç‰¹æ®Š</p>
<pre><code class="language-java">

// lox/Interpreter.java, in visitBinaryExpr()

    switch (expr.operator.type) {
      case MINUS:
        return (double)left - (double)right;
      case PLUS:
        if (left instanceof Double &amp;&amp; right instanceof Double) {
          return (double)left + (double)right;
        } 

        if (left instanceof String &amp;&amp; right instanceof String) {
          return (String)left + (String)right;
        }

        break;
      case SLASH:
	  
</code></pre>
<p>The + operator can also be used to concatenate two strings. To handle that, we donâ€™t just assume the operands are a certain type and cast them, we dynamically check the type and choose the appropriate operation. This is why we need our object representation to support instanceof.</p>
<ul>
<li>è¿ç®—ç¬¦ï¼Œå¯ä»¥ç”¨äºè¿æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œä¸ºäº†å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸åªæ˜¯å‡è®¾æ“ä½œæ•°æ˜¯æŸä¸ªç±»å‹ï¼Œå¹¶ä¸”è¿›è¡Œç±»å‹è½¬æ¢ï¼Œè€Œæ˜¯åŠ¨æ€æ£€æŸ¥ç±»å‹ï¼Œå¹¶ä¸”è¿›è¡Œé€‚å½“çš„æ“ä½œï¼Œè¿™å°±æ˜¯æˆ‘ä»¬ä¸ºä»€ä¹ˆéœ€è¦å¯¹è±¡æ”¯æŒ instanceof</li>
</ul>
<blockquote>
<p>We could have defined an operator specifically for string concatenation. Thatâ€™s what Perl (.), Lua (..), Smalltalk (,), Haskell (++), and others do.</p>
<p>I thought it would make Lox a little more approachable to use the same syntax as Java, JavaScript, Python, and others. This means that the + operator is overloaded to support both adding numbers and concatenating strings. Even in languages that donâ€™t use + for strings, they still often overload it for adding both integers and floating-point numbers.</p>
<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªå­—ç¬¦ä¸²è¿æ¥çš„è¿ç®—ç¬¦ï¼Œè¿™ä¹Ÿæ˜¯ Perl(.) Lua(..) Smalltalk(,) Haskell(++) ç­‰è¯­è¨€æ‰€åšçš„</p>
<p>æˆ‘è®¤ä¸ºä½¿ç”¨å’ŒJava/JS/Pythonä¸€æ ·çš„è¯­æ³•ï¼Œä¼šè®©Loxæ›´åŠ å®¹æ˜“æ¥è¿‘ï¼Œè¿™æ„å‘³ç€ + è¿ç®—ç¬¦è¢«é‡è½½ï¼Œç”¨äºæ”¯æŒæ•°å­—çš„åŠ æ³•å’Œå­—ç¬¦ä¸²çš„è¿æ¥ï¼Œå³ä½¿åœ¨ä¸ä½¿ç”¨ + è¿æ¥å­—ç¬¦ä¸²çš„è¯­è¨€ä¸­ï¼Œå®ƒä»¬ä»ç„¶åœ¨è®¡ç®—æ•´æ•°å’Œæµ®ç‚¹æ•°åŠ æ³•è¿ç®—æ—¶ï¼Œé‡è½½ã€‚</p>
</blockquote>
<p>Next up are the comparison operators.</p>
<p>æ¥ä¸‹æ¥æ˜¯æ¯”è¾ƒè¿ç®—ç¬¦</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitBinaryExpr()

    switch (expr.operator.type) {
      case GREATER:
        return (double)left &gt; (double)right;
      case GREATER_EQUAL:
        return (double)left &gt;= (double)right;
      case LESS:
        return (double)left &lt; (double)right;
      case LESS_EQUAL:
        return (double)left &lt;= (double)right;
      case MINUS:
	  
</code></pre>
<p>They are basically the same as arithmetic. The only difference is that where the arithmetic operators produce a value whose type is the same as the operands (numbers or strings), the comparison operators always produce a Boolean.</p>
<p>å®ƒä»¬å’Œç®—æœ¯è¿ç®—ç¬¦ä¸€æ ·ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯ï¼Œç®—æœ¯è¿ç®—ç¬¦çš„è®¡ç®—ç»“æœæ€»æ˜¯å’Œæ“ä½œæ•°ç±»å‹ç›¸åŒï¼ˆæ•°å€¼æˆ–è€…stringï¼‰ï¼Œè€Œæ¯”è¾ƒè¿ç®—ç¬¦ç»“æœæ€»æ˜¯å¸ƒå°”å€¼</p>
<p>The last pair of operators are equality.</p>
<p>æœ€åï¼Œä¸€ä¸ªäºŒå…ƒè¿ç®—ç¬¦æ˜¯ ç›¸ç­‰åˆ¤æ–­</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitBinaryExpr()

  case BANG_EQUAL: return !isEqual(left, right);
  case EQUAL_EQUAL: return isEqual(left, right);
</code></pre>
<p>Unlike the comparison operators which require numbers, the equality operators support operands of any type, even mixed ones. You canâ€™t ask Lox if 3 is less than &quot;three&quot;, but you can ask if itâ€™s equal to it.</p>
<p>ä¸éœ€è¦æ•°å­—çš„æ¯”è¾ƒè¿ç®—ç¬¦ä¸åŒï¼Œç›¸ç­‰è¿ç®—ç¬¦æ”¯æŒæ‰€æœ‰ç±»å‹çš„æ“ä½œæ•°ï¼Œç”šè‡³æ˜¯æ··åˆæ“ä½œæ•°ï¼Œä½ ä¸èƒ½é—®Loxè¯­è¨€ï¼Œ3æ˜¯å¦å°äº &quot;three&quot;, ä½†æ˜¯ä½ å¯ä»¥é—®Loxè¯­è¨€ï¼Œ3 æ˜¯å¦ç­‰äº &quot;three&quot;</p>
<blockquote>
<p>Spoiler alert: itâ€™s not.</p>
<p>å‰§é€æé†’ï¼Œä¸æ˜¯</p>
</blockquote>
<p>Like truthiness, the equality logic is hoisted out into a separate method.</p>
<p>å’Œ isTruthy() å‡½æ•°ä¸€æ ·ï¼ŒisEqual() å‡½æ•°ä¹Ÿæ˜¯ä¸€ä¸ªå•ç‹¬çš„æ–¹æ³•</p>
<pre><code>
// lox/Interpreter.java, add after isTruthy()

 private boolean isEqual(Object a, Object b) {
    if (a == null &amp;&amp; b == null) return true;
    if (a == null) return false;

    return a.equals(b);
  }
  
</code></pre>
<p>This is one of those corners where the details of how we represent Lox objects in terms of Java matter. We need to correctly implement Loxâ€™s notion of equality, which may be different from Javaâ€™s.</p>
<p>Fortunately, the two are pretty similar. Lox doesnâ€™t do implicit conversions in equality and Java does not either. We do have to handle nil/null specially so that we donâ€™t throw a NullPointerException if we try to call equals() on null. Otherwise, weâ€™re fine. Javaâ€™s equals() method on Boolean, Double, and String have the behavior we want for Lox.</p>
<p>è¿™æ˜¯æˆ‘ä»¬å¦‚ä½•ç”¨Javaå®ç°Lox å¯¹è±¡çš„ç»†èŠ‚æ‰€åœ¨çš„è§’è½ä¹‹ä¸€ï¼Œæˆ‘ä»¬éœ€è¦æ­£ç¡®çš„å®ç°Lox è¯­è¨€çš„ç›¸ç­‰æ¦‚å¿µï¼Œè¿™å¯èƒ½å’ŒJava ä¸ä¸€æ ·ã€‚</p>
<p>å¹¸è¿çš„æ˜¯ï¼Œä¸¤è€…éå¸¸ç›¸ä¼¼ï¼ŒLoxä¸ä¼šå¯¹ç­‰å¼ä¸­çš„éšå¼è½¬æ¢ï¼ŒJavaä¹Ÿä¸åšè½¬æ¢ï¼Œæˆ‘ä»¬å¿…é¡»è€ƒè™‘åˆ°nil/nullï¼Œ ä»¥ä¾¿åœ¨å°è¯•å¯¹ nullè°ƒç”¨ isEqual()  å‡½æ•°æ—¶å€™ï¼Œä¸ä¼šå¼•å‘ç©ºæŒ‡é’ˆæŠ¥é”™ï¼Œå…¶ä»–çš„ï¼Œæˆ‘ä»¬éƒ½å¾ˆå¥½ï¼ŒJavaå¯¹Booleanï¼ŒDoubleï¼ŒStringç±»å‹å…·æœ‰ç›¸åŒçš„equals() å‡½æ•°ã€‚</p>
<blockquote>
<p>What do you expect this to evaluate to:</p>
<p>(0 / 0) == (0 / 0)</p>
<p>According to IEEE 754, which specifies the behavior of double-precision numbers, dividing a zero by zero gives you the special NaN (â€œnot a numberâ€) value. Strangely enough, NaN is not equal to itself.</p>
<p>In Java, the == operator on primitive doubles preserves that behavior, but the equals() method on the Double class does not. Lox uses the latter, so doesnâ€™t follow IEEE. These kinds of subtle incompatibilities occupy a dismaying fraction of language implementersâ€™ lives.</p>
<p>ä½ å¸Œæœ›çš„è¯„ä¼°ç»“æœæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ</p>
<p>æ ¹æ® IEEE 754, å®ƒè§„å®šäº†åŒç²¾åº¦æ•°å­—çš„è¡Œä¸ºï¼Œå°† 0/0 å¯ä»¥å¾—åˆ°ç‰¹æ®Šçš„ NaNï¼ˆéæ•°å­—å€¼ï¼‰ï¼Œå¥‡æ€ªçš„æ˜¯ï¼ŒNaNå¹¶ä¸ç­‰äºè‡ªå·±ã€‚</p>
<p>åœ¨Javaä¸­ï¼ŒåŸºäºDoubleç±»å‹çš„ == è¿ç®—ç¬¦ä¿ç•™ç€è¿™ç§è¡Œä¸ºï¼Œä½†æ˜¯ Doubleç±»ä¸Šçš„equals() æ–¹æ³•åˆ™ä¸ä¿ç•™è¿™ç§è¡Œä¸ºï¼ŒLoxä½¿ç”¨åè€…ï¼Œå› æ­¤ä¸éµå®ˆIEEEï¼Œè¿™äº›å¾®å¦™çš„ä¸å…¼å®¹æ€§ï¼Œå æ®äº†è¯­è¨€å®ç°è€…ç”Ÿæ´»ä¸­ä»¤äººæ²®ä¸§çš„ä¸€å°éƒ¨åˆ†ã€‚</p>
</blockquote>
<p>And thatâ€™s it! Thatâ€™s all the code we need to correctly interpret a valid Lox expression. But what about an invalid one? In particular, what happens when a subexpression evaluates to an object of the wrong type for the operation being performed?</p>
<p>å°±è¿™æ ·ï¼è¿™å°±æ˜¯æ­£ç¡®è§£é‡Šæœ‰æ•ˆLoxè¡¨è¾¾å¼æ‰€éœ€çš„å…¨éƒ¨ä»£ç ï¼Œä½†æ˜¯æ— æ•ˆçš„å‘¢ï¼Ÿç‰¹åˆ«æ˜¯ï¼Œå½“å­è¡¨è¾¾å¼çš„è®¡ç®—ç»“æœä¸ºæ‰€æ‰§è¡Œæ“ä½œçš„é”™è¯¯ç±»å‹çš„å¯¹è±¡æ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ</p>
<h2 id="ä¸‰runtime-errors"><a class="header" href="#ä¸‰runtime-errors">ä¸‰ã€Runtime Errors</a></h2>
<p>I was cavalier about jamming casts in whenever a subexpression produces an Object and the operator requires it to be a number or a string. Those casts can fail. Even though the userâ€™s code is erroneous, if we want to make a usable language, we are responsible for handling that error gracefully.</p>
<p>æ¯å½“å­è¡¨è¾¾å¼äº§ç”Ÿä¸€ä¸ªObjectï¼Œä½†æ˜¯è¿ç®—ç¬¦éœ€è¦çš„æ˜¯æ•°å­—æˆ–è€…å­—ç¬¦ä¸²æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šéšæ„çš„ä½¿ç”¨å¼ºåˆ¶ç±»å‹è½¬æ¢ã€‚è¿™äº›ç±»å‹è½¬æ¢å¯èƒ½ä¼šå¤±è´¥ï¼Œå³ä½¿ç”¨æˆ·çš„ä»£ç æ˜¯é”™è¯¯çš„ï¼Œä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦åˆ›å»ºä¸€é—¨å¯ç”¨çš„è¯­è¨€ï¼Œæˆ‘ä»¬æœ‰è´£ä»»ä¼˜é›…çš„å¤„ç†è¿™ç§é”™è¯¯ã€‚</p>
<blockquote>
<p>We could simply not detect or report a type error at all. This is what C does if you cast a pointer to some type that doesnâ€™t match the data that is actually being pointed to. C gains flexibility and speed by allowing that, but is also famously dangerous. Once you misinterpret bits in memory, all bets are off.</p>
<p>Few modern languages accept unsafe operations like that. Instead, most are memory safe and ensureâ€”through a combination of static and runtime checksâ€”that a program can never incorrectly interpret the value stored in a piece of memory.</p>
<p>æˆ‘ä»¬æ ¹æœ¬æ— æ³•æ£€æµ‹æˆ–è€…æŠ¥å‘Šç±»å‹é”™è¯¯ï¼Œåœ¨Cè¯­è¨€ä¸­ï¼Œå¦‚æœå°†æŒ‡é’ˆè½¬æ¢ä¸ºå®é™…æ•°æ®ä¸ç›¸ç¬¦çš„æŸä¸ªç±»å‹ï¼ŒCè¯­è¨€é€šå¸¸ä¼šï¼Œå…è®¸ç”¨æˆ·è¿™æ ·è½¬æ¢ï¼Œä»¥è·å–é€Ÿåº¦å’Œçµæ´»æ€§ï¼Œä½†æ˜¯è¿™ä¹Ÿæ˜¯æ€»æ‰€å‘¨çŸ¥çš„å±é™©ï¼Œä¸€æ—¦æˆ‘ä»¬é”™è¯¯çš„è½¬æ¢äº†æŒ‡é’ˆç±»å‹ï¼Œå°†å¯èƒ½äº§ç”Ÿä¸¥é‡çš„é”™è¯¯ã€‚</p>
<p>å¾ˆå°‘æœ‰ç°ä»£è¯­è¨€æ¥å—è¿™æ ·çš„ä¸å®‰å…¨æ“ä½œï¼Œç›¸åï¼Œå¤§å¤šæ•°éƒ½æ˜¯å†…å­˜å®‰å…¨çš„ï¼Œå¹¶ä¸”é€šè¿‡é™æ€å’Œè¿è¡Œæ—¶æ£€æŸ¥çš„ç»„åˆï¼Œç¡®ä¿ç¨‹åºä¸ä¼šé”™è¯¯çš„è§£é‡Šå­˜å‚¨åœ¨å†…å­˜ä¸­çš„å€¼ã€‚</p>
</blockquote>
<p>Itâ€™s time for us to talk about runtime errors. I spilled a lot of ink in the previous chapters talking about error handling, but those were all syntax or static errors. Those are detected and reported before any code is executed. Runtime errors are failures that the language semantics demand we detect and report while the program is running (hence the name).</p>
<p>Right now, if an operand is the wrong type for the operation being performed, the Java cast will fail and the JVM will throw a ClassCastException. That unwinds the whole stack and exits the application, vomiting a Java stack trace onto the user. Thatâ€™s probably not what we want. The fact that Lox is implemented in Java should be a detail hidden from the user. Instead, we want them to understand that a Lox runtime error occurred, and give them an error message relevant to our language and their program.</p>
<p>ç°åœ¨æ˜¯æˆ‘ä»¬è®¨è®ºè¿è¡Œæ—¶é”™è¯¯çš„æ—¶å€™äº†ï¼Œæˆ‘ä»¬å·²ç»åœ¨å‰é¢çš„ç« èŠ‚ä¸­è®¨è®ºäº†é”™è¯¯å¤„ç†ï¼Œä½†æ˜¯å®ƒä»¬éƒ½æ˜¯è¯­æ³•å’Œé™æ€é”™è¯¯ï¼Œåœ¨æ‰§è¡Œä»»ä½•ä»£ç ä¹‹å‰ï¼Œè¿™äº›é”™è¯¯éƒ½ä¼šè¢«æ£€æµ‹å¹¶ä¸”æŠ¥å‘Šï¼Œè¿è¡Œæ—¶é”™è¯¯æ˜¯è¯­è¨€è¯­ä¹‰è¦æ±‚æˆ‘ä»¬åœ¨ç¨‹åºè¿è¡Œæ—¶ï¼Œæ£€æµ‹å¹¶ä¸”æŠ¥å‘Šæ•…éšœï¼ˆå› æ­¤å¾—åï¼‰</p>
<p>ç°åœ¨ï¼Œå¦‚æœæ“ä½œæ•°çš„ç±»å‹å’Œæ­£åœ¨æ‰§è¡Œçš„æ“ä½œè¿ç®—ä¸ç¬¦åˆï¼ŒJavaçš„å¼ºåˆ¶è½¬æ¢å°†å¤±è´¥ï¼ŒJVMä¼šæŠ›å‡ºç±»å‹è½¬æ¢æŠ¥é”™ï¼Œè¿™å°†è§£å¼€æ•´ä¸ªå †æ ˆï¼Œå¹¶ä¸”é€€å‡ºåº”ç”¨ç¨‹åºï¼Œä»è€Œå‘ç”¨æˆ·æŠ›å‡ºJavaå †æ ˆè·Ÿè¸ªï¼Œä½†æ˜¯ï¼Œè¿™å¯èƒ½ä¸æ˜¯æˆ‘ä»¬æƒ³è¦çš„ï¼ŒLoxè¯­è¨€æ˜¯åœ¨Javaä¸­å®ç°çš„è¿™ä¸€ä¸ªäº‹å®ï¼Œåº”è¯¥æ˜¯å¯¹ç”¨æˆ·éšè—çš„ç»†èŠ‚ã€‚ç›¸åï¼Œæˆ‘ä»¬å¸Œæœ›ä»–ä»¬äº†è§£å‘ç”Ÿäº†è¿è¡Œæ—¶é”™è¯¯ï¼Œå¹¶ä¸”å‘ç”¨æˆ·ï¼Œæä¾›å’Œæˆ‘ä»¬è¯­è¨€å’Œç¨‹åºç›¸å…³çš„é”™è¯¯æ¶ˆæ¯ã€‚</p>
<p>The Java behavior does have one thing going for it, though. It correctly stops executing any code when the error occurs. Letâ€™s say the user enters some expression like:</p>
<pre><code>2 * (3 / -&quot;muffin&quot;)
</code></pre>
<p>You canâ€™t negate a muffin, so we need to report a runtime error at that inner - expression. That in turn means we canâ€™t evaluate the / expression since it has no meaningful right operand. Likewise for the *. So when a runtime error occurs deep in some expression, we need to escape all the way out.</p>
<p>ä¸è¿‡ï¼ŒJavaçš„è¡Œä¸ºç¡®å®æœ‰ä¸€ä¸ªåŸå› ï¼Œå½“å‘ç”Ÿé”™è¯¯æ—¶å€™ï¼Œå®ƒä¼šåœæ­¢æ‰§è¡Œä»»ä½•ä»£ç ï¼Œå‡è®¾ç”¨æˆ·è¾“å…¥ä¸‹é¢çš„è¡¨è¾¾å¼</p>
<p>æˆ‘ä»¬æ— æ³•è®¡ç®— muffin çš„è´Ÿå€¼ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦åœ¨å­è¡¨è¾¾å¼è®¡ç®—æ—¶å€™ï¼ŒæŠ¥å‘Šé”™è¯¯ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬ä¹Ÿæ— æ³•è®¡ç®— / ï¼Œå› æ­¤è¯¥æ“ä½œç¬¦çš„å³æ“ä½œæ•°æ²¡æœ‰æ„ä¹‰ï¼ŒåŒæ ·ï¼Œ * è¿ç®—ç¬¦ä¹Ÿä¸€æ ·ã€‚å› æ­¤ï¼Œå½“è¿è¡Œæ—¶é”™è¯¯å‘ç”Ÿåœ¨æ·±å±‚çš„å­è¡¨è¾¾å¼æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šä¸€ç›´å¾€ä¸Šå¿½ç•¥ã€‚</p>
<blockquote>
<p>I donâ€™t know, man, can you negate a muffin?</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/muffin.png?raw=true" alt="muffin" /></p>
</blockquote>
<p>We could print a runtime error and then abort the process and exit the application entirely. That has a certain melodramatic flair. Sort of the programming language interpreter equivalent of a mic drop.</p>
<p>Tempting as that is, we should probably do something a little less cataclysmic. While a runtime error needs to stop evaluating the expression, it shouldnâ€™t kill the interpreter. If a user is running the REPL and has a typo in a line of code, they should still be able to keep the session going and enter more code after that.</p>
<p>æˆ‘ä»¬å¯ä»¥æ‰“å°ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ï¼Œç„¶åç»ˆæ­¢è¿›ç¨‹å¹¶ä¸”é€€å‡ºåº”ç”¨ç¨‹åºï¼Œè¿™æœ‰ä¸€å®šçš„æˆå‰§æ€§ï¼ŒæŸç§è¯­è¨€çš„è§£é‡Šå™¨ï¼Œç›¸å½“äºé™ä¸‹éº¦å…‹é£ã€‚</p>
<p>å°½ç®¡å¦‚æ­¤ï¼Œæˆ‘ä»¬è¿˜æ˜¯åº”è¯¥åšä¸€äº›äº‹æƒ…ï¼Œä¸ä¼šå¼•å‘ç¾éš¾ï¼Œè™½ç„¶ï¼Œè¿è¡Œæ—¶é”™è¯¯éœ€è¦åœæ­¢è®¡ç®—è¡¨è¾¾å¼ï¼Œä½†æ˜¯ï¼Œå®ƒä¸åº”è¯¥åœæ­¢è§£é‡Šå™¨ï¼Œå¦‚æœç”¨æˆ·æ­£åœ¨è¿è¡Œä¸€ä¸ª REPL ç±»å‹çš„ç¨‹åºï¼Œä¸€è¡Œä»£ç ä¸­æœ‰ä¸€ä¸ªé”™è¯¯ï¼Œé‚£ä¹ˆè§£é‡Šå™¨ä¸åº”è¯¥é€€å‡ºï¼Œåº”è¯¥å¯ä»¥ç»§ç»­ä¼šè¯ï¼Œåœ¨ç»ˆç«¯è¾“å…¥æ›´å¤šçš„ä»£ç ã€‚</p>
<h3 id="31-detecting-runtime-errors"><a class="header" href="#31-detecting-runtime-errors">3.1 Detecting runtime errors</a></h3>
<p>æ£€æµ‹è¿è¡Œæ—¶é”™è¯¯</p>
<p>Our tree-walk interpreter evaluates nested expressions using recursive method calls, and we need to unwind out of all of those. Throwing an exception in Java is a fine way to accomplish that. However, instead of using Javaâ€™s own cast failure, weâ€™ll define a Lox-specific one so that we can handle it how we want.</p>
<p>æˆ‘ä»¬çš„æ ‘éå†è§£é‡Šå™¨ï¼Œä½¿ç”¨é€’å½’è°ƒç”¨å®ç°äº†è®¡ç®—åµŒå¥—è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬éœ€è¦è§£å¼€æ‰€æœ‰è¿™äº›ã€‚åœ¨Javaä¸­æŠ›å‡ºå¼‚å¸¸ï¼Œæ˜¯å®ç°è¿™ä¸€ç‚¹çš„å¥½æ–¹æ³•ã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸€ä¸ªç‰¹å®šäºLoxçš„å¤±è´¥ï¼Œè€Œä¸æ˜¯ä½¿ç”¨Javaä¸­é»˜è®¤çš„ç±»å‹è½¬æ¢é”™è¯¯ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§è‡ªå·±æ„æ„¿å¤„ç†æŠ¥é”™ã€‚</p>
<p>Before we do the cast, we check the objectâ€™s type ourselves. So, for unary -, we add:</p>
<p>åœ¨è¿›è¡Œå¼ºåˆ¶ç±»å‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦è‡ªå·±æ£€æŸ¥å¯¹è±¡çš„ç±»å‹ï¼Œå› æ­¤ï¼Œå¯¹äºä¸€å…ƒè¿ç®—ç¬¦</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitUnaryExpr()

      case MINUS:
        checkNumberOperand(expr.operator, right);
        return -(double)right;
		
</code></pre>
<p>The code to check the operand is:</p>
<p>æ£€æŸ¥è¿ç®—æ•°çš„ä»£ç å¦‚ä¸‹ï¼Œ</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitUnaryExpr()

  private void checkNumberOperand(Token operator, Object operand) {
    if (operand instanceof Double) return;
    throw new RuntimeError(operator, &quot;Operand must be a number.&quot;);
  }
  
</code></pre>
<p>When the check fails, it throws one of these:</p>
<p>å½“æ£€æµ‹åˆ°å¤±è´¥ï¼Œæˆ‘ä»¬ä¼šæŠ›å‡ºæŠ¥é”™</p>
<pre><code class="language-java">
// lox/RuntimeError.java, create new file

package com.craftinginterpreters.lox;

class RuntimeError extends RuntimeException {
  final Token token;

  RuntimeError(Token token, String message) {
    super(message);
    this.token = token;
  }
}

</code></pre>
<p>Unlike the Java cast exception, our class tracks the token that identifies where in the userâ€™s code the runtime error came from. As with static errors, this helps the user know where to fix their code.</p>
<p>å’ŒJavaä¸­çš„å¼ºåˆ¶ç±»å‹è½¬æ¢å¼‚å¸¸ä¸ä¸€æ ·ï¼Œæˆ‘ä»¬è‡ªå·±å®ç°çš„ç±»ï¼Œè¿½è¸ªåˆ°ç”¨æˆ·ä»£ç è¿è¡Œæ—¶æŠ¥é”™çš„æ¥æºtokenï¼Œä¸é™æ€é”™è¯¯ä¸€æ ·ï¼Œè¿™æ ·æœ‰åŠ©äºç”¨æˆ·çŸ¥é“å¦‚ä½•ä¿®å¤ä»£ç ã€‚</p>
<blockquote>
<p>I admit the name â€œRuntimeErrorâ€ is confusing since Java defines a RuntimeException class. An annoying thing about building interpreters is your names often collide with ones already taken by the implementation language. Just wait until we support Lox classes.</p>
<p>æˆ‘æ‰¿è®¤ï¼Œæˆ‘ä»¬å®šä¹‰çš„ç±»ï¼Œç±»åæ˜¯RuntimeErrorï¼Œéå¸¸ä»¤äººå›°æƒ‘ï¼Œå› ä¸ºJavaä¸­å®šä¹‰äº†RuntimeException ç±»ï¼Œæ„å»ºè§£é‡Šå™¨çš„ä¸€ä¸ªä»¤äººè®¨åŒçš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬çš„åå­—ç»å¸¸ä¼šå’Œå®ç°è¯­è¨€çš„å·²ç»å­˜åœ¨çš„åå­—ç›¸åŒã€‚éœ€è¦æˆ‘ä»¬è€å¿ƒç­‰å¾…ï¼Œä¸€ç›´åˆ°Loxå®ç°ç±»ã€‚</p>
</blockquote>
<p>We need similar checking for the binary operators. Since I promised you every single line of code needed to implement the interpreters, Iâ€™ll run through them all.</p>
<p>æˆ‘ä»¬è¿˜éœ€è¦å¯¹äºŒå…ƒè¿ç®—ç¬¦è¿›è¡Œç›¸ä¼¼çš„ç±»å‹æ£€æŸ¥ï¼Œæ—¢ç„¶ï¼Œæˆ‘å·²ç»ä¿è¯äº†å®ç°è§£é‡Šå™¨çš„æ¯ä¸€è¡Œä»£ç éƒ½ä¼šå‡ºç°ï¼Œæˆ‘ä¼šæŠŠå®ƒä»¬å†™åœ¨ä¸‹é¢</p>
<pre><code class="language-java">

  @Override
    public Object visitBinaryExpr(Expr.Binary expr) {
        Object left = evaluate(expr.left);
        Object right = evaluate(expr.right);

        switch (expr.operator.type) {
            case GREATER:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &gt; (double) right;
            case GREATER_EQUAL:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &gt;= (double) right;
            case LESS:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &lt; (double) right;
            case LESS_EQUAL:
                checkNumberOperands(expr.operator, left, right);
                return (double) left &lt;= (double) right;
            case MINUS:
                checkNumberOperands(expr.operator, left, right);
                return (double) left - (double) right;
            case PLUS:
                if (left instanceof Double &amp;&amp; right instanceof Double) {
                    return (double) left + (double) right;
                }
                if (left instanceof String &amp;&amp; right instanceof String) {
                    return (String) left + (String) right;
                }
            case SLASH:
                checkNumberOperands(expr.operator, left, right);
                return (double) left / (double) right;
            case STAR:
                checkNumberOperands(expr.operator, left, right);
                return (double) left * (double) right;
            case BANG_EQUAL:
                return !isEqual(left, right);
            case EQUAL_EQUAL:
                return isEqual(left, right);
        }
        return null;
    }


</code></pre>
<pre><code class="language-java">
// lox/Interpreter.java, add after checkNumberOperand()

  private void checkNumberOperands(Token operator,
                                   Object left, Object right) {
    if (left instanceof Double &amp;&amp; right instanceof Double) return;
    
    throw new RuntimeError(operator, &quot;Operands must be numbers.&quot;);
  }


</code></pre>
<blockquote>
<p>Another subtle semantic choice: We evaluate both operands before checking the type of either. Imagine we have a function say() that prints its argument then returns it. Using that, we write:</p>
<p>say(&quot;left&quot;) - say(&quot;right&quot;);</p>
<p>Our interpreter prints â€œleftâ€ and â€œrightâ€ before reporting the runtime error. We could have instead specified that the left operand is checked before even evaluating the right.</p>
<p>å¦å¤–ä¸€ä¸ªå¾®å¦™çš„è¯­ä¹‰é€‰æ‹©ï¼Œæˆ‘ä»¬åœ¨æ£€æŸ¥ä¸¤ä¸ªæ“ä½œæ•°çš„ç±»å‹ä¹‹å‰ï¼Œå¯¹å®ƒä»¬è¿›è¡Œæ±‚å€¼ï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªsay() å‡½æ•°ï¼Œå®ƒæ‰“å°å…¶å‚æ•°ï¼Œç„¶åè¿”å›å®ƒï¼Œä½¿ç”¨è¿™ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬å®ç°</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨åœ¨æŠ¥å‘Šè¿ç®—æ—¶æŠ¥é”™ä¹‹å‰ï¼Œæ‰“å°å‡ºå·¦ã€å³ï¼Œç›¸åï¼Œæˆ‘ä»¬å¯ä»¥æŒ‡å®šåœ¨è®¡ç®—å³æ“ä½œæ•°ä¹‹å‰ï¼Œæ£€æŸ¥å·¦æ“ä½œæ•°ã€‚</p>
</blockquote>
<p>The last remaining operator, again the odd one out, is addition. Since + is overloaded for numbers and strings, it already has code to check the types. All we need to do is fail if neither of the two success cases match.</p>
<p>å‰©ä¸‹æœ€åä¸€ä¸ªæ“ä½œç¬¦ï¼Œæ˜¯åŠ æ³•ï¼Œç”±äº + å¯¹äºæ•°å­—å’Œå­—ç¬¦ä¸²æ˜¯é‡è½½çš„ï¼Œå› æ­¤ï¼Œå®ƒå·²ç»æœ‰ä»£ç è¿›è¡Œç±»å‹æ£€æŸ¥äº†ï¼Œå¦‚æœä¸¤ä¸ªé‡è½½ç±»å‹éƒ½ä¸ç¬¦åˆï¼Œéœ€è¦æŠ¥é”™</p>
<pre><code class="language-java">
// lox/Interpreter.java, in visitBinaryExpr(), replace 1 line

          return (String)left + (String)right;
        }

        throw new RuntimeError(expr.operator,
            &quot;Operands must be two numbers or two strings.&quot;);
      case SLASH:
	  
</code></pre>
<p>That gets us detecting runtime errors deep in the innards of the evaluator. The errors are getting thrown. The next step is to write the code that catches them. For that, we need to wire up the Interpreter class into the main Lox class that drives it.</p>
<p>è¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥æ£€æµ‹åˆ°è®¡ç®—å†…éƒ¨çš„è¿è¡Œæ—¶æŠ¥é”™ï¼Œä¸‹ä¸€æ­¥éœ€è¦ç¼–å†™æ•è·é”™è¯¯çš„ä»£ç ï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å°† Interperterç±»æ·»åŠ åˆ°ä¸»Loxç±»ä¸Šã€‚</p>
<h2 id="å››hooking-up-the-interpreter"><a class="header" href="#å››hooking-up-the-interpreter">å››ã€Hooking Up the Interpreter</a></h2>
<p>è¿æ¥åˆ°è§£é‡Šå™¨</p>
<p>The visit methods are sort of the guts of the Interpreter class, where the real work happens. We need to wrap a skin around them to interface with the rest of the program. The Interpreterâ€™s public API is simply one method.</p>
<p>è®¿é—®æ–¹æ³•æ˜¯è§£é‡Šå™¨ç±»çš„æ ¸å¿ƒï¼Œå› ä¸ºçœŸæ­£çš„å·¥ä½œéƒ½å‘ç”Ÿåœ¨è¿™é‡Œï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒåŒ…è£¹èµ·æ¥ï¼Œä»¥ä¾¿å’Œç¨‹åºçš„å…¶ä»–éƒ¨åˆ†äº¤äº’ï¼Œè§£é‡Šå™¨çš„å…¬å…±APIåªæ˜¯ä¸€ç§æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

  void interpret(Expr expression) { 
    try {
      Object value = evaluate(expression);
      System.out.println(stringify(value));
    } catch (RuntimeError error) {
      Lox.runtimeError(error);
    }
  }
  
</code></pre>
<p>This takes in a syntax tree for an expression and evaluates it. If that succeeds, evaluate() returns an object for the result value. interpret() converts that to a string and shows it to the user. To convert a Lox value to a string, we rely on:</p>
<p>ä¸Šé¢æ–¹æ³•ï¼Œå°†ä¼šè·å–è¡¨è¾¾å¼çš„è§£ææ ‘ï¼Œå¹¶ä¸”å¯¹å…¶æ±‚å€¼ï¼Œå¦‚æœæ±‚å€¼æˆåŠŸï¼Œevaluate()æ–¹æ³•ï¼Œå°†ä¼šè¿”å›ç»“æœå€¼çš„å¯¹è±¡ï¼Œinterpret() æ–¹æ³•ï¼Œä¼šå°†ç»“æœè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶ä¸”è¿”å›ç»™ç”¨æˆ·ï¼Œè¦å°†ç»“æœè½¬ä¸ºå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬éœ€è¦:</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after isEqual()

  private String stringify(Object object) {
    if (object == null) return &quot;nil&quot;;

    if (object instanceof Double) {
      String text = object.toString();
      if (text.endsWith(&quot;.0&quot;)) {
        text = text.substring(0, text.length() - 2);
      }
      return text;
    }

    return object.toString();
  }

</code></pre>
<p>This is another of those pieces of code like isTruthy() that crosses the membrane between the userâ€™s view of Lox objects and their internal representation in Java.</p>
<p>Itâ€™s pretty straightforward. Since Lox was designed to be familiar to someone coming from Java, things like Booleans look the same in both languages. The two edge cases are nil, which we represent using Javaâ€™s null, and numbers.</p>
<p>Lox uses double-precision numbers even for integer values. In that case, they should print without a decimal point. Since Java has both floating point and integer types, it wants you to know which one youâ€™re using. It tells you by adding an explicit .0 to integer-valued doubles. We donâ€™t care about that, so we hack it off the end.</p>
<p>è¿™æ˜¯å¦å¤–ä¸€æ®µï¼Œåƒæ˜¯ isTruthy() æ–¹æ³•çš„ä»£ç ï¼Œå®ƒè·¨è¶Šäº†ç”¨æˆ·å¯¹Loxå¯¹è±¡çš„è§†å›¾å’Œå®ƒä»¬åœ¨Javaä¸­çš„å†…éƒ¨è¡¨ç¤ºä¹‹é—´çš„éš”é˜‚ã€‚</p>
<p>è¿™å¾ˆç®€å•ï¼Œå› ä¸ºLoxçš„è®¾è®¡ä¸ºäº†è®©Javaçš„ä½¿ç”¨è€…ç†Ÿæ‚‰ï¼Œæ‰€ä»¥ï¼Œå¸ƒå°”ç±»å‹åœ¨ä¸¤ç§è¯­è¨€ä¸­å‡ ä¹ç›¸åŒï¼Œè¿™ä¸¤ç§è¾¹ç¼˜æƒ…å†µéƒ½æ˜¯nilï¼Œæˆ‘ä»¬ä½¿ç”¨Javaçš„null å’Œæ•°å­—æ¥è¡¨ç¤º</p>
<p>Loxç”šè‡³å¯¹æ•´æ•°ï¼Œä½¿ç”¨åŒç²¾åº¦ç±»å‹è¡¨ç¤ºï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒä»¬åº”è¯¥æ²¡æœ‰å°æ•°ç‚¹ï¼Œç”±äºJavaæ—¢æœ‰æµ®ç‚¹å‹ï¼Œä¹Ÿæœ‰æ•´æ•°å‹ï¼Œæ‰€ä»¥å®ƒå¸Œæœ›ä½ çŸ¥é“ä½¿ç”¨çš„å“ªä¸€ç§ç±»å‹ï¼Œå®ƒé€šè¿‡æ˜¾å¼çš„å°† .0 æ·»åŠ åˆ°æ•´æ•°ï¼Œç”¨åŒç²¾åº¦è¡¨ç¤ºçš„æ–¹æ³•ï¼Œæ¥å‘ŠçŸ¥ã€‚æˆ‘ä»¬ä¸åœ¨ä¹è¿™ä¸€ç‚¹ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ä»å¤´å¼€å§‹ã€‚</p>
<blockquote>
<p>Yet again, we take care of this edge case with numbers to ensure that jlox and clox work the same. Handling weird corners of the language like this will drive you crazy but is an important part of the job.</p>
<p>Users rely on these detailsâ€”either deliberately or inadvertentlyâ€”and if the implementations arenâ€™t consistent, their program will break when they run it on different interpreters.</p>
<p>å†ä¸€æ¬¡ï¼Œæˆ‘ä»¬ç”¨æ•°å­—æ¥å¤„ç†è¾¹ç¼˜çŠ¶å†µï¼Œä»¥ç¡®ä¿jlox å’Œ cloxçš„å¤„ç†æ–¹å¼ç›¸åŒï¼Œåƒè¿™æ ·çš„å¤„ç†ï¼Œè¯­è¨€ä¸­å¥‡æ€ªè§’è½ä¼šè®©ä½ å‘ç–¯ï¼Œä½†è¿™æ˜¯å·¥ä½œçš„é‡è¦ç»„æˆéƒ¨åˆ†</p>
<p>ç”¨æˆ·æœ‰æ„æˆ–è€…æ— æ„çš„ä¾èµ–è¿™äº›ç»†èŠ‚ï¼Œå¦‚æœå®ç°ä¸ä¸€è‡´ï¼Œä»–ä»¬çš„ç¨‹åºå°†åœ¨ä¸åŒçš„è§£é‡Šå™¨ä¸Šï¼Œå‡ºç°ä¸­æ–­ã€‚</p>
</blockquote>
<h3 id="41-reporting-runtime-errors"><a class="header" href="#41-reporting-runtime-errors">4.1 Reporting runtime errors</a></h3>
<p>æŠ¥å‘Šè¿è¡Œæ—¶æŠ¥é”™</p>
<p>If a runtime error is thrown while evaluating the expression, interpret() catches it. This lets us report the error to the user and then gracefully continue. All of our existing error reporting code lives in the Lox class, so we put this method there too:</p>
<p>å¦‚æœåœ¨è®¡ç®—è¡¨è¾¾å¼æ—¶å€™ï¼Œå¼•å‘è¿è¡Œæ—¶æŠ¥é”™ï¼Œinterpert() æ–¹æ³•ï¼Œå°†ä¼šæ•è·åˆ°è¯¥ç±»å‹çš„é”™è¯¯ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç”¨æˆ·æŠ¥å‘Šé”™è¯¯ï¼Œç„¶åï¼Œä¼˜é›…çš„ç»§ç»­è¿è¡Œï¼Œæˆ‘ä»¬ç°åœ¨ï¼Œæ‰€æœ‰çš„æŠ¥é”™ä»£ç éƒ½åœ¨Loxç±»ä¸­ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬å°†æ­¤æ–¹æ³•å†™åœ¨é‚£é‡Œï¼š</p>
<pre><code class="language-java">
// lox/Lox.java, add after error()

  static void runtimeError(RuntimeError error) {
    System.err.println(error.getMessage() +
        &quot;\n[line &quot; + error.token.line + &quot;]&quot;);
    hadRuntimeError = true;
  }


</code></pre>
<p>We use the token associated with the RuntimeError to tell the user what line of code was executing when the error occurred. Even better would be to give the user an entire call stack to show how they got to be executing that code. But we donâ€™t have function calls yet, so I guess we donâ€™t have to worry about it.</p>
<p>æˆ‘ä»¬ä½¿ç”¨ä¸ RuntimeError å…³è”çš„tokenï¼Œæ¥å‘Šè¯‰ç”¨æˆ·ï¼Œé”™è¯¯å‘ç”Ÿæ—¶å€™æ­£åœ¨è¿è¡Œçš„ä»£ç è¡Œæ•°ï¼Œæ›´å¥½çš„æ–¹æ³•æ˜¯ç»™ç”¨æˆ·ä¸€ä¸ªå®Œæ•´çš„è°ƒç”¨å †æ ˆï¼Œä»¥æ˜¾ç¤ºä»–ä»¬æ˜¯å¦‚ä½•æ‰§è¡Œä»£ç çš„ï¼Œä½†æ˜¯æˆ‘ä»¬è¿˜æ²¡æœ‰å‡½æ•°è°ƒç”¨ï¼Œæ‰€ä»¥ï¼Œæˆ‘æƒ³è¿˜ä¸éœ€è¦æ‹…å¿ƒã€‚</p>
<p>After showing the error, runtimeError() sets this field:</p>
<p>æ˜¾ç¤ºé”™è¯¯åï¼Œå°†æŠŠå˜é‡ hadRuntimeError è®¾ç½®ä¸ºtrue</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

  static boolean hadError = false;
  static boolean hadRuntimeError = false;

  public static void main(String[] args) throws IOException {
  
</code></pre>
<p>That field plays a small but important role.</p>
<p>è¿™ä¸ªå­—æ®µ hadRuntimeErroræœ‰é‡è¦çš„ä½œç”¨</p>
<pre><code class="language-java">
// lox/Lox.java, in runFile()

    run(new String(bytes, Charset.defaultCharset()));

    // Indicate an error in the exit code.
    if (hadError) System.exit(65);
    if (hadRuntimeError) System.exit(70);
  }
  
</code></pre>
<p>If the user is running a Lox script from a file and a runtime error occurs, we set an exit code when the process quits to let the calling process know. Not everyone cares about shell etiquette, but we do.</p>
<p>å¦‚æœç”¨æˆ·æ­£åœ¨ä»æ–‡ä»¶è¿è¡ŒLox è„šæœ¬ï¼Œå¹¶ä¸”å‘ç”Ÿäº†è¿è¡Œæ—¶æŠ¥é”™ï¼Œæˆ‘ä»¬å°†åœ¨è¿›ç¨‹é€€å‡ºæ—¶å€™ï¼Œè®¾ç½®é€€å‡ºä»£ç ï¼Œè®©è°ƒç”¨è¿›ç¨‹çŸ¥é“ï¼Œä¸æ˜¯æ¯ä¸€ä¸ªäººéƒ½å…³å¿ƒshell é€€å‡ºä¿¡å·ï¼Œä½†æ˜¯æˆ‘ä»¬ç¡®å®å…³å¿ƒã€‚</p>
<blockquote>
<p>If the user is running the REPL, we donâ€™t care about tracking runtime errors. After they are reported, we simply loop around and let them input new code and keep going.</p>
<p>å¦‚æœç”¨æˆ·æ­£åœ¨è¿è¡Œ REPL, æˆ‘ä»¬ä¸å…³å¿ƒè·Ÿè¸ªè¿è¡Œæ—¶æŠ¥é”™ï¼Œåœ¨è¿è¡Œæ—¶æŠ¥é”™æŠ¥å‘Šåï¼Œæˆ‘ä»¬åªéœ€è¦å¾ªç¯ï¼Œè®©ç”¨æˆ·ç»§ç»­è¾“å…¥æ–°ä»£ç å¹¶ä¸”ç»§ç»­è§£é‡Šè¿è¡Œã€‚</p>
</blockquote>
<h3 id="42-running-the-interpreter"><a class="header" href="#42-running-the-interpreter">4.2 Running the interpreter</a></h3>
<p>è¿è¡Œè§£é‡Šå™¨</p>
<p>Now that we have an interpreter, the Lox class can start using it.</p>
<p>ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†ä¸€ä¸ªè§£é‡Šå™¨ï¼ŒLoxç±»å¯ä»¥ä½¿ç”¨å®ƒäº†</p>
<pre><code class="language-java">
// lox/Lox.java, in class Lox

public class Lox {
  private static final Interpreter interpreter = new Interpreter();
  static boolean hadError = false;

</code></pre>
<p>We make the field static so that successive calls to run() inside a REPL session reuse the same interpreter. That doesnâ€™t make a difference now, but it will later when the interpreter stores global variables. Those variables should persist throughout the REPL session.</p>
<p>æˆ‘ä»¬å°†å­—æ®µ interpreter è®¾ç½®ä¸ºé™æ€ï¼Œä»¥ä¾¿äºå¯¹ REPLä¼šè¯ä¸­ï¼Œå¯¹äºrun()æ–¹æ³•çš„è¿ç»­è°ƒç”¨ï¼Œä½¿ç”¨ç›¸åŒçš„è§£é‡Šå™¨ï¼Œç°åœ¨ï¼Œè¿™æ ·å¹¶æ²¡æœ‰ä»€ä¹ˆä¸åŒï¼Œä½†æ˜¯ç¨åï¼Œå½“è§£é‡Šå™¨å­˜å‚¨äº†å…¨å±€å˜é‡åï¼Œæƒ…å†µå°±ä¼šå‘ç”Ÿå˜åŒ–ï¼Œè¿™äº›å˜é‡åœ¨ REPL ä¼šè¯ä¸­ä¼šå§‹ç»ˆå­˜åœ¨ã€‚</p>
<p>Finally, we remove the line of temporary code from the last chapter for printing the syntax tree and replace it with this:</p>
<p>æœ€åï¼Œæˆ‘ä»¬åˆ é™¤äº†ä¸Šä¸€ç« ï¼Œç”¨äºæ‰“å°è¯­æ³•æ ‘çš„ä¸€è¡Œä¸´æ—¶ä»£ç ï¼Œå¹¶ä¸”æ›¿æ¢ä¸º</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 1 line

    // Stop if there was a syntax error.
    if (hadError) return;

    interpreter.interpret(expression);
  }

</code></pre>
<p>We have an entire language pipeline now: scanning, parsing, and execution. Congratulations, you now have your very own arithmetic calculator.</p>
<p>As you can see, the interpreter is pretty bare bones. But the Interpreter class and the Visitor pattern weâ€™ve set up today form the skeleton that later chapters will stuff full of interesting gutsâ€”variables, functions, etc. Right now, the interpreter doesnâ€™t do very much, but itâ€™s alive!</p>
<p>æˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ä¸ªå®Œæ•´çš„è¯­è¨€ç®¡é“ï¼Œæ‰«æã€è§£æå’Œæ‰§è¡Œï¼Œæ­å–œä½ ï¼Œç°åœ¨æˆ‘ä»¬æœ‰äº†è‡ªå·±çš„ç®—æœ¯è®¡ç®—å™¨</p>
<p>æ­£å¦‚æˆ‘ä»¬éƒ½å¯ä»¥çœ‹åˆ°çš„ï¼Œç°åœ¨çš„è§£é‡Šå™¨æ˜¯éå¸¸ç®€å•çš„ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬ä»Šå¤©æ„é€ çš„è§£é‡Šå™¨ç±»å’Œè®¿é—®è€…æ¨¡å¼ï¼Œæ„æˆäº†ä¸€ä¸ªæ¡†æ¶ï¼Œåœ¨åé¢ï¼Œå°†ä¼šå……æ»¡æœ‰æ„æ€çš„å†…è„â€”â€”å˜é‡ã€å‡½æ•°ã€‚ç°åœ¨ï¼Œè§£é‡Šå™¨åšçš„ä¸å¤šï¼Œä½†æ˜¯çš„ç¡®æœ‰ä½œç”¨ï¼</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/skeleton.png?raw=true" alt="skeleton" /></p>
<h2 id="äº”challenges-2"><a class="header" href="#äº”challenges-2">äº”ã€CHALLENGES</a></h2>
<p>ä¹ é¢˜</p>
<ol>
<li>
<p>Allowing comparisons on types other than numbers could be useful. The operators might have a reasonable interpretation for strings. Even comparisons among mixed types, like 3 &lt; &quot;pancake&quot; could be handy to enable things like ordered collections of heterogeneous types. Or it could simply lead to bugs and confusion.</p>
<p>Would you extend Lox to support comparing other types? If so, which pairs of types do you allow and how do you define their ordering? Justify your choices and compare them to other languages.</p>
</li>
<li>
<p>Many languages define + such that if either operand is a string, the other is converted to a string and the results are then concatenated. For example, &quot;scone&quot; + 4 would yield scone4. Extend the code in visitBinaryExpr() to support that.</p>
</li>
<li>
<p>What happens right now if you divide a number by zero? What do you think should happen? Justify your choice. How do other languages you know handle division by zero, and why do they make the choices they do?</p>
<p>Change the implementation in visitBinaryExpr() to detect and report a runtime error for this case.</p>
</li>
</ol>
<h2 id=""><a class="header" href="#"></a></h2>
<ol>
<li>
<p>å…è®¸å¯¹æ•°å­—ä¹‹å¤–çš„ç±»å‹è¿›è¡Œæ¯”è¾ƒï¼Œå¯èƒ½ä¼šéå¸¸æœ‰ç”¨ï¼Œè¿ç®—ç¬¦å¯èƒ½å¯¹å­—ç¬¦ä¸²æœ‰åˆç†çš„è§£é‡Šï¼Œå³ä½¿æ˜¯æ··åˆç±»å‹ä¹‹é—´çš„æ¯”è¾ƒï¼Œä¾‹å¦‚ï¼š3 &lt; &quot;pancake&quot;, ä¹Ÿå¯ä»¥æ–¹ä¾¿çš„å®ç°ï¼Œå¼‚æ„ç±»å‹çš„æœ‰åºé›†åˆï¼Œæˆ–è€…å®ƒå¯èƒ½ä¼šå¯¼è‡´é”™è¯¯å’Œæ··ä¹±ã€‚</p>
<p>ä½ ä¼šæ‰©å±•æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œæ”¯æŒä¸åŒçš„æ•°æ®ç±»å‹å—ï¼Ÿå¦‚æœæ‰©å±•ï¼Œä½ ä¼šæ”¯æŒå¯¹äºå“ªäº›ç±»å‹ï¼Œå¦‚ä½•å®šä¹‰å®ƒä»¬çš„å¤§å°ï¼ŒéªŒè¯ä½ çš„æƒ³æ³•ï¼Œå¹¶ä¸”ä¸å…¶ä»–è¯­æ³•è¿›è¡Œæ¯”è¾ƒã€‚</p>
</li>
<li>
<p>è®¸å¤šè¯­è¨€å®šä¹‰+ è¿ç®—ç¬¦ï¼Œå¦‚æœä¸€ä¸ªæ“ä½œæ•°æ˜¯å­—ç¬¦ä¸²ï¼Œé‚£ä¹ˆå¦å¤–ä¸€ä¸ªæ“ä½œæ•°ä¹Ÿä¼šè½¬å˜ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åå°†å®ƒä»¬çš„ç»“æœè¿æ¥ï¼Œä¾‹å¦‚: &quot;scone&quot; + 4 å°†å˜ä¸º &quot;scone4&quot;, æ‰©å±•ä»£ç ï¼Œå®ç°è¿™ä¸ªåŠŸèƒ½</p>
</li>
<li>
<p>å¦‚æœé™¤é›¶ï¼Œç°åœ¨Loxä¼šå‘ç”Ÿä»€ä¹ˆï¼Œä½ è®¤ä¸ºåº”è¯¥å‘ç”Ÿä»€ä¹ˆï¼Ÿè¯æ˜ä½ çš„æƒ³æ³•æ˜¯æ­£ç¡®çš„ã€‚å…¶ä»–è¯­è¨€æ˜¯å¦‚ä½•å®ç°é™¤é›¶çš„ï¼Œä¸ºä»€ä¹ˆä»–ä»¬ä¼šè¿™æ ·åšå‘¢ï¼Ÿ</p>
<p>ä¿®æ”¹ visitBinaryExpr()æ–¹æ³•ï¼Œé‡åˆ°é™¤é›¶æƒ…å†µï¼ŒæŠ¥å‘Šä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯</p>
</li>
</ol>
<h2 id="å…­design-note-static-and-dynamic-typing"><a class="header" href="#å…­design-note-static-and-dynamic-typing">å…­ã€DESIGN NOTE: STATIC AND DYNAMIC TYPING</a></h2>
<p>è®¾è®¡è¯´æ˜ï¼šé™æ€å’ŒåŠ¨æ€ç±»å‹</p>
<p>Some languages, like Java, are statically typed which means type errors are detected and reported at compile time before any code is run. Others, like Lox, are dynamically typed and defer checking for type errors until runtime right before an operation is attempted. We tend to consider this a black-and-white choice, but there is actually a continuum between them.</p>
<p>It turns out even most statically typed languages do some type checks at runtime. The type system checks most type rules statically, but inserts runtime checks in the generated code for other operations.</p>
<p>æœ‰äº›è¯­è¨€ï¼Œä¾‹å¦‚Javaï¼Œæ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œè¿™æ„å‘³ç€ï¼Œåœ¨è¿è¡Œä»»ä½•ä»£ç ä¹‹å‰ï¼Œéƒ½ä¼šåœ¨ç¼–è¯‘æ—¶å€™ï¼Œæ£€æµ‹å¹¶ä¸”æŠ¥å‘Šç±»å‹é”™è¯¯ï¼› å…¶ä»–çš„ï¼Œä¾‹å¦‚ï¼šLoxè¯­è¨€ï¼Œæ˜¯åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œå°†æ£€æŸ¥ç±»å‹é”™è¯¯çš„æ—¶é—´æ¨è¿Ÿåˆ°è¿è¡Œæ—¶å€™ï¼Œç„¶åå†å°è¯•æ“ä½œã€‚æˆ‘ä»¬å€¾å‘äºè¿™æ˜¯ä¸€ä¸ªéé»‘å³ç™½çš„é€‰æ‹©ï¼Œä½†æ˜¯ï¼Œå®é™…ä¸Šï¼Œå®ƒä»¬ä¹‹é—´å­˜åœ¨è¿ç»­åœºæ™¯ã€‚</p>
<p>äº‹å®è¯æ˜ï¼Œå³ä½¿æ˜¯ï¼Œå¤§å¤šæ•°çš„é™æ€ç±»å‹è¯­è¨€ï¼Œä¹Ÿä¼šåœ¨è¿è¡Œæ—¶å€™ï¼Œæ‰§è¡Œä¸€äº›ç±»å‹æ£€æµ‹ã€‚ç±»å‹ç³»ç»Ÿä¼šé™æ€æ£€æŸ¥å¤§å¤šæ•°çš„è§„åˆ™ï¼Œä½†æ˜¯ï¼Œç”Ÿæˆçš„ä»£ç ä¸­è¿˜æ˜¯ä¼šæ’å…¥è¿è¡Œæ—¶æ£€æŸ¥ï¼Œä»¥ç”¨äºå…¶ä»–æ“ä½œã€‚</p>
<p>For example, in Java, the static type system assumes a cast expression will always safely succeed. After you cast some value, you can statically treat it as the destination type and not get any compile errors. But downcasts can fail, obviously. The only reason the static checker can presume that casts always succeed without violating the languageâ€™s soundness guarantees, is because the cast is checked at runtime and throws an exception on failure.</p>
<p>ä¾‹å¦‚ï¼šåœ¨Javaä¸­ï¼Œé™æ€ç±»å‹ç³»ç»Ÿï¼Œæ€»æ˜¯å‡è®¾å¼ºåˆ¶è½¬æ¢è¡¨è¾¾å¼ï¼Œä¸€å®šæ‰§è¡ŒæˆåŠŸã€‚åœ¨å¼ºåˆ¶è½¬æ¢æŸä¸ªå€¼åï¼Œå¯ä»¥å°†å…¶é™æ€çš„è§†ä¸ºç›®æ ‡ç±»å‹ï¼Œè€Œä¸ä¼šå‡ºç°ä»»ä½•çš„ç¼–è¯‘æŠ¥é”™ã€‚ä½†æ˜¯ï¼Œæ˜¾ç„¶ï¼Œä¸æ˜¯æ‰€æœ‰çš„ç±»å‹è½¬æ¢éƒ½èƒ½æˆåŠŸã€‚é™æ€æ£€æŸ¥å™¨ï¼Œå¯ä»¥å‡è®¾å¼ºåˆ¶è½¬æ¢æ€»æ˜¯æˆåŠŸï¼Œå¹¶ä¸”ä¸è¿åè¯­è¨€çš„å¯é æ€§çš„å”¯ä¸€åŸå› æ˜¯ï¼Œå¼ºåˆ¶è½¬æ¢åœ¨è¿è¡Œæ—¶å€™è¿˜ä¼šè¢«æ£€æŸ¥ï¼Œå¹¶ä¸”åœ¨è½¬æ¢å¤±è´¥åï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚</p>
<p>A more subtle example is covariant arrays in Java and C#. The static subtyping rules for arrays allow operations that are not sound. Consider:</p>
<p>ä¸€ä¸ªæ›´åŠ å¾®å¦™çš„ä¾‹å­æ˜¯ï¼ŒJava æˆ–è€… C# ä¸­çš„åå˜æ•°ç»„ï¼Œæ•°ç»„çš„é™æ€å­ç±»å‹è§„åˆ™å…è®¸ä¸æ­£ç¡®çš„æ“ä½œï¼Œä¾‹å¦‚ï¼š</p>
<pre><code class="language-java">
Object[] stuff = new Integer[1];
stuff[0] = &quot;not an int!&quot;;


</code></pre>
<p>This code compiles without any errors. The first line upcasts the Integer array and stores it in a variable of type Object array. The second line stores a string in one of its cells. The Object array type statically allows thatâ€”strings are Objectsâ€”but the actual Integer array that stuff refers to at runtime should never have a string in it! To avoid that catastrophe, when you store a value in an array, the JVM does a runtime check to make sure itâ€™s an allowed type. If not, it throws an ArrayStoreException.</p>
<p>Java could have avoided the need to check this at runtime by disallowing the cast on the first line. It could make arrays invariant such that an array of Integers is not an array of Objects. Thatâ€™s statically sound, but it prohibits common and safe patterns of code that only read from arrays. Covariance is safe if you never write to the array. Those patterns were particularly important for usability in Java 1.0 before it supported generics. James Gosling and the other Java designers traded off a little static safety and performanceâ€”those array store checks take timeâ€”in return for some flexibility.</p>
<p>ä¸Šé¢çš„ä»£ç åœ¨ç¼–è¯‘æ—¶å€™ï¼Œä¸ä¼šæŠ¥é”™ã€‚ç¬¬ä¸€è¡Œä»£ç ï¼Œè½¬æ¢Integeræ•°ç»„ï¼Œå¹¶ä¸”ä¿å­˜åœ¨Objectæ•°ç»„ç±»å‹çš„å˜é‡ stuffä¸­ï¼Œç¬¬äºŒè¡Œä»£ç ï¼Œåœ¨å…¶ä¸­çš„ä¸€ä¸ªæ•°ç»„å•å…ƒä¸­ï¼Œä¿å­˜å­—ç¬¦ä¸²ã€‚Objectæ•°ç»„ï¼Œåœ¨ç¼–è¯‘æ—¶å€™ï¼Œå…è®¸å…¶ä¸­çš„å…ƒç´ æ˜¯å­—ç¬¦ä¸²ï¼ˆå­—ç¬¦ä¸²ä¹Ÿæ˜¯Objectï¼‰ï¼Œä½†æ˜¯ï¼Œåœ¨å®é™…è¿è¡Œæ—¶å€™ï¼Œå¼•ç”¨çš„æ•´æ•°æ•°ç»„ä¸­ä¸åº”è¯¥æœ‰å­—ç¬¦ä¸²ã€‚ä¸ºäº†é¿å…è¿™ç§ç¾éš¾çº§é”™è¯¯ï¼Œå½“ä½ åœ¨æ•°ç»„ä¸­å­˜å‚¨æ•°å€¼æ—¶å€™ï¼ŒJVM å°†ä¼šåœ¨è¿è¡Œæ—¶å€™è¿›è¡Œç±»å‹æ£€æŸ¥ï¼Œä»¥ç¡®ä¿æ˜¯æ­£ç¡®çš„ç±»å‹ï¼Œå¦‚æœå‡ºç°ä¸å…è®¸çš„ç±»å‹ï¼Œå°†ä¼šæŠ›å‡º ArrayStoreException æŠ¥é”™ã€‚</p>
<p>Java ä¹Ÿå¯ä»¥é€šè¿‡é™æ­¢ç¬¬ä¸€è¡Œä»£ç ä¸­çš„ï¼Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œæ¥é¿å…è¿è¡Œæ—¶å€™çš„æ£€æŸ¥ã€‚å®ƒå¯ä»¥ä½¿æ•°ç»„ä¿æŒä¸å˜ï¼Œä»è€Œæ•´æ•°æ•°ç»„ä¸ä¼šå˜ä¸ºå¯¹è±¡æ•°ç»„ã€‚è¿™æ˜¯é™æ€çš„ï¼Œä½†æ˜¯å®ƒç¦æ­¢ï¼Œåªä»æ•°ç»„ä¸­è¯»å–çš„å¸¸è§å®‰å…¨çš„ä»£ç æ¨¡å¼ã€‚å¦‚æœä»ä¸å†™å…¥æ•°ç»„ï¼Œåˆ™åå˜æ•°ç»„æ˜¯å®‰å…¨çš„ã€‚åœ¨Java1.0æ”¯æŒ æ³›å‹ä¹‹å‰ï¼Œè¿™äº›æ¨¡å¼å¯¹äºå¯ç”¨æ€§éå¸¸é‡è¦ã€‚James Gosling å’Œå…¶ä»–çš„Javaè®¾è®¡äººå‘˜ï¼Œäº¤æ¢äº†ä¸€äº›é™æ€å®‰å…¨æ€§å’Œæ€§èƒ½ï¼Œ å› ä¸ºè¿è¡Œæ—¶å€™çš„ç±»å‹æ£€æŸ¥éœ€è¦ä¸€äº›æ—¶é—´ï¼Œä½†æ˜¯æé«˜äº†ä»£ç çš„çµæ´»æ€§ã€‚</p>
<p>There are few modern statically typed languages that donâ€™t make that trade-off somewhere. Even Haskell will let you run code with non-exhaustive matches. If you find yourself designing a statically typed language, keep in mind that you can sometimes give users more flexibility without sacrificing too many of the benefits of static safety by deferring some type checks until runtime.</p>
<p>On the other hand, a key reason users choose statically typed languages is because of the confidence the language gives them that certain kinds of errors can never occur when their program is run. Defer too many type checks until runtime, and you erode that confidence.</p>
<p>å¾ˆå°‘æœ‰ç°ä»£çš„é™æ€ç±»å‹è¯­è¨€ï¼Œåœ¨æŸäº›æ–¹é¢ä¸åšå‡ºè¿™æ ·çš„æƒè¡¡ã€‚ç”šè‡³ï¼ŒHaskellä¹Ÿå…è®¸æˆ‘ä»¬ä½¿ç”¨éç©·å°½åŒ¹é…æ¥è¿è¡Œä»£ç ã€‚å¦‚æœï¼Œä½ åœ¨è®¾è®¡é™æ€è¯­è¨€ã€‚è¯·è®°ä½ï¼Œé€šè¿‡å°†æŸäº›ç±»å‹æ£€æŸ¥æ¨è¿Ÿåˆ°è¿è¡Œæ—¶è¿›è¡Œï¼Œæœ‰æ—¶å€™å¯ä»¥ç»™ç”¨æˆ·æä¾›æ›´é«˜çš„çµæ´»æ€§ï¼Œè€Œä¸”ä¸ä¼šç‰ºç‰²å¤ªå¤šçš„é™æ€å®‰å…¨æ€§èƒ½ã€‚</p>
<p>å¦ä¸€æ–¹é¢ï¼Œç”¨æˆ·é€‰æ‹©é™æ€ç±»å‹è¯­è¨€çš„ä¸€ä¸ªå…³é”®åŸå› æ˜¯ï¼Œè¿™ç§è¯­è¨€è®©ä»–ä»¬ç›¸ä¿¡ï¼Œè¿è¡Œç¨‹åºæ—¶å€™ï¼Œæ°¸è¿œä¸ä¼šå‘ç”Ÿç±»å‹çš„é”™è¯¯ã€‚å¦‚æœå°†è¿‡å¤šçš„ç±»å‹æ£€æŸ¥æ¨è¿Ÿåˆ°è¿è¡Œæ—¶ï¼Œå°†ä¼šå‡å°‘ç”¨æˆ·çš„ä¿¡å¿ƒã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="è¯­å¥å’ŒçŠ¶æ€"><a class="header" href="#è¯­å¥å’ŒçŠ¶æ€">è¯­å¥å’ŒçŠ¶æ€</a></h1>
<blockquote>
<p>All my life, my heart has yearned for a thing I cannot name.</p>
<p>åœ¨æˆ‘çš„ä¸€ç”Ÿä¸­ï¼Œæˆ‘ä¸€ç›´æ¸´æœ›ä¸€ä»¶æ— æ³•å‘½åçš„äº‹æƒ…ã€‚</p>
<p align="center">AndrÃ© Breton, Mad Love </p>
</blockquote>
<p>The interpreter we have so far feels less like programming a real language and more like punching buttons on a calculator. â€œProgrammingâ€ to me means building up a system out of smaller pieces. We canâ€™t do that yet because we have no way to bind a name to some data or function. We canâ€™t compose software without a way to refer to the pieces</p>
<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬æ‹¥æœ‰çš„è§£é‡Šå™¨ï¼Œæ„Ÿè§‰ä¸åƒæ˜¯åœ¨ç¼–ç¨‹ä¸€ç§çœŸæ­£çš„è¯­è¨€ï¼Œæ›´åƒæ˜¯åœ¨è®¡ç®—å™¨ä¸ŠæŒ‰ä¸‹æŒ‰é’®ã€‚å¯¹æˆ‘æ¥è¯´ï¼Œç¼–ç¨‹æ„å‘³ç€ä½¿ç”¨æ›´å°çš„éƒ¨ä»¶ï¼Œæ„é€ ä¸€ä¸ªç³»ç»Ÿã€‚ç°åœ¨æˆ‘ä»¬è¿˜æ— æ³•åšåˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸ºï¼Œæˆ‘ä»¬è¿˜æ— æ³•å°†åç§°ç»‘å®šåˆ°æŸäº›æ•°æ®æˆ–è€…å‡½æ•°ä¸Šï¼Œæˆ‘ä»¬æ— æ³•åœ¨æ²¡æœ‰å¼•ç”¨è¿™äº›ç‰‡æ®µï¼ˆæ•°æ®ã€å‡½æ•°ï¼‰çš„æƒ…å†µä¸‹ç¼–å†™è½¯ä»¶ã€‚</p>
<p>To support bindings, our interpreter needs internal state. When you define a variable at the beginning of the program and use it at the end, the interpreter has to hold on to the value of that variable in the meantime. So in this chapter, we will give our interpreter a brain that can not just process, but remember.</p>
<p>ä¸ºäº†æ”¯æŒç»‘å®šï¼Œæˆ‘ä»¬çš„è§£é‡Šå™¨éœ€è¦å†…éƒ¨çŠ¶æ€ï¼Œå½“æˆ‘ä»¬åœ¨ç¨‹åºçš„å¼€å§‹ï¼Œå®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œå¹¶ä¸”åœ¨ç¨‹åºç»“å°¾ä½¿ç”¨å®ƒï¼Œè§£é‡Šå™¨å¿…é¡»åŒæ—¶ä¿æŒè¯¥å˜é‡çš„å€¼ã€‚æ‰€ä»¥åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†ç»™è§£é‡Šå™¨ä¸€ä¸ªå¤§è„‘ï¼Œå®ƒä¸ä»…ä»…å¯ä»¥è®¡ç®—ï¼Œè€Œä¸”å¯ä»¥è®°å¿†ã€‚</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/brain.png?raw=true" alt="brain" /></p>
<p>State and statements go hand in hand. Since statements, by definition, donâ€™t evaluate to a value, they need to do something else to be useful. That something is called a side effect. It could mean producing user-visible output or modifying some state in the interpreter that can be detected later. The latter makes them a great fit for defining variables or other named entities.</p>
<p>çŠ¶æ€å’Œè¯­å¥æ˜¯é½å¤´å¹¶è¿›çš„ï¼Œæ ¹æ®å®šä¹‰ï¼Œè¯­å¥çš„æ±‚å€¼ç»“æœä¸æ˜¯ä¸€ä¸ªå€¼ï¼Œå› æ­¤ï¼Œå®ƒä»¬éœ€è¦åšå…¶ä»–æœ‰ç”¨çš„äº‹æƒ…ï¼Œè¿™è¢«ç§°ä¸ºå‰¯ä½œç”¨ã€‚è¿™å¯èƒ½æ„å‘³ç€ç”Ÿæˆç”¨æˆ·å¯è§çš„è¾“å‡ºï¼Œæˆ–è€…ä¿®æ”¹è§£é‡Šå™¨ä¸­çš„çŠ¶æ€ï¼Œå¯ä»¥è¢«æ£€æµ‹åˆ°ã€‚åè€…ï¼Œä½¿å¾—å®ƒä»¬éå¸¸é€‚åˆå®šä¹‰å˜é‡æˆ–è€…å…¶ä»–å‘½åçš„å®ä½“ã€‚</p>
<blockquote>
<p>You could make a language that treats variable declarations as expressions that both create a binding and produce a value. The only language I know that does that is Tcl.  Scheme seems like a contender, but note that after a let expression is evaluated, the variable it bound is forgotten. The define syntax is not an expression.</p>
<p>ä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªè¯­è¨€ï¼Œå°†å˜é‡å£°æ˜è§†ä¸ºæ—¢åˆ›å»ºç»‘å®šï¼Œåˆç”Ÿæˆå€¼çš„è¡¨è¾¾å¼çš„è¯­è¨€ã€‚æˆ‘æ‰€çŸ¥é“çš„ï¼Œå”¯ä¸€åšåˆ°è¿™ä¸€ç‚¹çš„è¯­è¨€æ˜¯Tclï¼ŒSchemeçœ‹èµ·æ¥æ˜¯ä¸€ä¸ªç«äº‰è€…ï¼Œä½†æ˜¯è¯·æ³¨æ„ï¼Œåœ¨è®¡ç®— letè¡¨è¾¾å¼åï¼Œå®ƒç»‘å®šçš„å˜é‡å°†è¢«é—å¼ƒã€‚define è¯­å¥ä¸æ˜¯è¡¨è¾¾å¼ã€‚</p>
</blockquote>
<p>In this chapter, weâ€™ll do all of that. Weâ€™ll define statements that produce output (print) and create state (var). Weâ€™ll add expressions to access and assign to variables. Finally, weâ€™ll add blocks and local scope. Thatâ€™s a lot to stuff into one chapter, but weâ€™ll chew through it all one bite at a time.</p>
<p>åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬å°†å®Œæˆæ‰€æœ‰è¿™äº›ï¼Œæˆ‘ä»¬å°†å®šä¹‰ä¸¤ç§è¯­å¥ï¼Œè¾“å‡ºè¯­å¥(print) å’Œ åˆ›å»ºçŠ¶æ€è¯­å¥(var). æˆ‘ä»¬å°†æ·»åŠ è¡¨è¾¾å¼æ¥è®¿é—®å’Œåˆ†é…å˜é‡ã€‚æœ€åï¼Œæˆ‘ä»¬å°†æ·»åŠ å—å’Œå±€éƒ¨ä½œç”¨åŸŸï¼Œè¿™ä¸€ç« å°†ä¼šæ¶‰åŠå¾ˆå¤šå†…å®¹ï¼Œä½†æ˜¯æˆ‘ä»¬å°†ä¸€ç‚¹ä¸€ç‚¹å»å­¦ä¹ ã€‚</p>
<h2 id="ä¸€statements"><a class="header" href="#ä¸€statements">ä¸€ã€Statements</a></h2>
<p>è¯­å¥</p>
<p>We start by extending Loxâ€™s grammar with statements. They arenâ€™t very different from expressions. We start with the two simplest kinds:</p>
<p>æˆ‘ä»¬é¦–å…ˆç”¨è¯­å¥ï¼Œå»æ‰©å±•Loxè¯­è¨€çš„è¯­æ³•ã€‚å®ƒä»¬å’Œè¡¨è¾¾å¼æ²¡æœ‰éå¸¸å¤§çš„åŒºåˆ«ï¼Œæˆ‘ä»¬ä»ä¸¤ç§æœ€ç®€å•çš„ç±»å‹å¼€å§‹ã€‚</p>
<ol>
<li>
<p>An expression statement lets you place an expression where a statement is expected. They exist to evaluate expressions that have side effects. You may not notice them, but you use them all the time in C, Java, and other languages. Any time you see a function or method call followed by a ;, youâ€™re looking at an expression statement.</p>
<p>è¡¨è¾¾å¼è¯­å¥ï¼Œå…è®¸æˆ‘ä»¬å°†è¡¨è¾¾å¼æ”¾ç½®åœ¨éœ€è¦è¯­å¥çš„åœ°æ–¹ï¼Œå®ƒä»¬çš„å­˜åœ¨æ˜¯ä¸ºäº†è¯„ä¼°å…·æœ‰å‰¯ä½œç”¨çš„è¡¨è¾¾å¼. ä½ å¯èƒ½æ²¡æœ‰æ³¨æ„åˆ°å®ƒä»¬ï¼Œä½†æ˜¯ï¼Œåœ¨C/Java å’Œå…¶ä»–è¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ä¸€ç›´åœ¨ä½¿ç”¨å®ƒä»¬ã€‚æ¯å½“æˆ‘ä»¬çœ‹åˆ°å‡½æ•°æˆ–è€…æ–¹æ³•è°ƒç”¨è¯­å¥ï¼Œåé¢ç´§è·Ÿä¸€ä¸ªï¼›ç¬¦å·ï¼Œæˆ‘ä»¬å®é™…ä¸Šåœ¨ä½¿ç”¨è¡¨è¾¾å¼è¯­å¥ã€‚</p>
</li>
<li>
<p>A print statement evaluates an expression and displays the result to the user. I admit itâ€™s weird to bake printing right into the language instead of making it a library function. Doing so is a concession to the fact that weâ€™re building this interpreter one chapter at a time and want to be able to play with it before itâ€™s all done. To make print a library function, weâ€™d have to wait until we had all of the machinery for defining and calling functions before we could witness any side effects.</p>
<p>printè¯­å¥è®¡ç®—è¡¨è¾¾å¼ï¼Œå¹¶ä¸”å°†ç»“æœå±•ç¤ºç»™ç”¨æˆ·ã€‚æˆ‘æ‰¿è®¤ï¼Œå°†printå½“ä½œä¸€ä¸ªè¯­å¥æ·»åŠ åˆ°è¯­è¨€ä¸­ï¼Œè€Œä¸æ˜¯ä½¿å…¶ä½œä¸ºä¸€ä¸ªåº“å‡½æ•°ï¼Œéå¸¸å¥‡æ€ªã€‚è¿™æ ·åšï¼Œæ˜¯å¯¹äºè¿™æ ·ä¸€ä¸ªäº‹å®çš„è®©æ­¥ï¼Œå³æˆ‘ä»¬å°†ä¸€ç« ä¸€ç« çš„æ„å»ºè§£é‡Šå™¨ï¼Œå¹¶ä¸”æˆ‘ä»¬å¸Œæœ›åœ¨å®Œå…¨æ„å»ºå¥½è§£é‡Šå™¨ä¹‹å‰ï¼Œå°±å¯ä»¥ä½¿ç”¨å®ƒã€‚å¦‚æœè¦è®© print æˆä¸ºä¸€ä¸ªåº“å‡½æ•°ï¼Œå¿…é¡»ç­‰åˆ°æ‹¥æœ‰äº†å®šä¹‰å’Œè°ƒç”¨å‡½æ•°çš„æ‰€æœ‰æœºåˆ¶åï¼Œæ‰å¯ä»¥å®ç°ã€‚</p>
</li>
</ol>
<blockquote>
<p>Pascal is an outlier. It distinguishes between procedures and functions. Functions return values, but procedures cannot. There is a statement form for calling a procedure, but functions can only be called where an expression is expected. There are no expression statements in Pascal.</p>
<p>Pascal è¯­è¨€æœ‰äº›ä¸åŒï¼Œå®ƒä¼šåŒºåˆ†è¿‡ç¨‹å’Œå‡½æ•°ï¼Œå‡½æ•°è¿”å›å€¼ï¼Œä½†æ˜¯ï¼Œè¿‡ç¨‹ä¸ä¼šè¿”å›ç»“æœã€‚æœ‰ä¸€ç§ç”¨äºè°ƒç”¨è¿‡ç¨‹çš„è¯­å¥å½¢å¼ï¼Œä½†æ˜¯åªèƒ½åœ¨éœ€è¦è¡¨è¾¾å¼çš„åœ°æ–¹è°ƒç”¨å‡½æ•°ã€‚Pascalä¸­æ²¡æœ‰è¡¨è¾¾å¼è¯­å¥ã€‚</p>
</blockquote>
<blockquote>
<p>I will note with only a modicum of defensiveness that BASIC and Python have dedicated print statements and they are real languages. Granted, Python did remove their print statement in 3.0â€‰.â€‰.â€‰. </p>
<p>æˆ‘åªä¼šç¨å¾®è¾©è§£ä¸€ä¸‹ï¼ŒBASIC å’Œ Pythonæ˜¯çœŸæ­£çš„è¯­è¨€ï¼Œä½†æ˜¯å®ƒä»¬ä¹Ÿå­˜åœ¨printè¯­å¥ï¼Œå½“ç„¶ï¼Œåœ¨Python3.0 ä»¥åï¼Œåˆ é™¤äº† print è¯­å¥ğŸ˜„ã€‚</p>
</blockquote>
<p>New syntax means new grammar rules. In this chapter, we finally gain the ability to parse an entire Lox script. Since Lox is an imperative, dynamically typed language, the â€œtop levelâ€ of a script is simply a list of statements. The new rules are:</p>
<p>æ–°çš„è¯­æ³•æ„å‘³ç€æ–°çš„è¯­æ³•è§„åˆ™ï¼Œåœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬æœ€ç»ˆå°†è·å¾—è§£ææ•´ä¸ªLoxè„šæœ¬çš„èƒ½åŠ›ã€‚å› ä¸ºï¼ŒLoxæ˜¯ä¸€é—¨å‘½ä»¤å¼çš„åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œæ‰€ä»¥ï¼Œè„šæœ¬çš„é¡¶å±‚è¯­æ³•è§„åˆ™ï¼Œåªæ˜¯ä¸€ä¸ªè¯­å¥çš„åˆ—è¡¨ã€‚æ–°çš„è¯­æ³•è§„åˆ™åŒ…å«ï¼š</p>
<pre><code>program      â€”â€”&gt; statement* EOF ;

statement    â€”â€”&gt; exprStmt
             | printStmt ;
			 
exprStmt     â€”â€”&gt; expression &quot;;&quot; ;
printStmt    â€”â€”&gt; &quot;print&quot; expression &quot;;&quot; ;

</code></pre>
<p>The first rule is now program, which is the starting point for the grammar and represents a complete Lox script or REPL entry. A program is a list of statements followed by the special â€œend of fileâ€ token. The mandatory end token ensures the parser consumes the entire input and doesnâ€™t silently ignore erroneous unconsumed tokens at the end of a script.</p>
<p>Right now, statement only has two cases for the two kinds of statements weâ€™ve described. Weâ€™ll fill in more later in this chapter and in the following ones. The next step is turning this grammar into something we can store in memoryâ€”syntax trees.</p>
<p>ç¬¬ä¸€æ¡è§„åˆ™ç°åœ¨æ˜¯ç¨‹åºï¼Œå®ƒæ˜¯è¯­æ³•çš„èµ·ç‚¹ï¼Œè¡¨ç¤ºä¸€ä¸ªå®Œæ•´çš„Loxè„šæœ¬æˆ–è€…REPL è¿‡ç¨‹ï¼Œç¨‹åºæ˜¯ä¸€ä¸ªè¯­å¥åˆ—è¡¨ï¼Œåé¢è·Ÿéšè€…æ–‡ä»¶ç»“æŸæ ‡å¿— EOF, å¼ºåˆ¶ç»“æŸ tokenï¼Œç¡®ä¿è§£é‡Šå™¨å¯ä»¥ä½¿ç”¨æ•´ä¸ªè¾“å…¥ï¼Œå¹¶ä¸”ä¸ä¼šåœ¨è„šæœ¬ç»“æŸæ—¶å€™ï¼Œå¿½ç•¥é”™è¯¯çš„æœªä½¿ç”¨çš„token</p>
<p>ç°åœ¨ï¼Œå¯¹äºæˆ‘ä»¬æè¿°çš„è¯­å¥ï¼Œæˆ‘ä»¬åªæœ‰ä¸¤ç§ç±»å‹ã€‚æˆ‘ä»¬å°†åœ¨æœ¬ç« çš„æœ€åï¼Œå¡«å†™æ›´å¤šçš„å†…å®¹ã€‚ä¸‹é¢ï¼Œæˆ‘ä»¬å°†å°è¯•å°†è¿™ç§è¯­æ³•ï¼Œè½¬æ¢ä¸ºå¯ä»¥ä¿å­˜åœ¨è¯­æ³•æ ‘ä¸­çš„ä¸œè¥¿ã€‚</p>
<h3 id="11-statement-syntax-trees"><a class="header" href="#11-statement-syntax-trees">1.1 Statement syntax trees</a></h3>
<p>è¯­å¥è¯­æ³•æ ‘</p>
<p>There is no place in the grammar where both an expression and a statement are allowed. The operands of, say, + are always expressions, never statements. The body of a while loop is always a statement.</p>
<p>Since the two syntaxes are disjoint, we donâ€™t need a single base class that they all inherit from. Splitting expressions and statements into separate class hierarchies enables the Java compiler to help us find dumb mistakes like passing a statement to a Java method that expects an expression.</p>
<p>That means a new base class for statements. As our elders did before us, we will use the cryptic name â€œStmtâ€. With great foresight, I have designed our little AST metaprogramming script in anticipation of this. Thatâ€™s why we passed in â€œExprâ€ as a parameter to defineAst(). Now we add another call to define Stmt and its subclasses.</p>
<p>è¯­æ³•è§„åˆ™ä¸­ï¼Œä¸å…è®¸åŒæ—¶ä½¿ç”¨è¡¨è¾¾å¼å’Œè¯­å¥ã€‚ä¾‹å¦‚ï¼š+ è¿ç®—ç¬¦ï¼Œå§‹ç»ˆæ˜¯è¡¨è¾¾å¼ï¼Œè€Œä¸æ˜¯è¯­å¥ã€‚while å¾ªç¯çš„ä¸»ä½“æ°¸è¿œæ˜¯è¯­å¥ã€‚</p>
<p>å› ä¸ºï¼Œè¯­å¥å’Œè¡¨è¾¾å¼æ˜¯ä¸ç›¸äº¤çš„ï¼Œæˆ‘ä»¬ä¸éœ€è¦ä¸€ä¸ªè¯­å¥å’Œè¡¨è¾¾å¼éƒ½ç»§æ‰¿çš„åŸºç±»ã€‚å°†è¡¨è¾¾å¼å’Œè¯­å¥æ‹†åˆ†ä¸ºä¸åŒçš„ç±»ï¼Œå¯ä»¥ä½¿å¾—Javaç¼–è¯‘å™¨ï¼Œèƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬å‘ç°ä¸€äº›æ„šè ¢çš„é”™è¯¯ï¼Œä¾‹å¦‚ï¼šå°†è¯­å¥ä¼ é€’ç»™éœ€è¦è¡¨è¾¾å¼çš„ Javaæ–¹æ³•ã€‚</p>
<p>è¿™æ„å‘³ç€ï¼Œè¯­å¥å­˜åœ¨ä¸€ä¸ªæ–°çš„åŸºç±»ã€‚æ­£å¦‚æˆ‘ä»¬çš„å‰è¾ˆé‚£æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨Stmt å½“ä½œæ–°çš„åŸºç±»çš„åç§°ã€‚æˆ‘ä»¬éå¸¸æœ‰è¿œè§çš„è®¾è®¡äº†ASTå…ƒç¼–ç¨‹è„šæœ¬ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬å°† &quot;Expr&quot; å½“ä½œå‚æ•°ä¼ é€’ç»™ defineAst()å‡½æ•°çš„åŸå› ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬å°†æ·»åŠ ä¸€ä¸ªæ–°çš„è°ƒç”¨ï¼Œæ¥å®šä¹‰Stmt å’Œå®ƒçš„å­ç±»ã€‚</p>
<blockquote>
<p>Not really foresight: I wrote all the code for the book before I sliced it into chapters.</p>
<p>å®é™…ä¸Šï¼Œæ²¡æœ‰ä»€ä¹ˆå…ˆè§ä¹‹æ˜ï¼Œæˆ‘æ˜¯å…ˆæŠŠæ‰€æœ‰ä»£ç éƒ½å®Œæˆåï¼Œæ‰å¼€å§‹å°†æœ¬ä¹¦åˆ†æˆè¿™äº›ç« èŠ‚çš„ã€‚</p>
</blockquote>
<pre><code class="language-java">
// tool/GenerateAst.java, in main()

      &quot;Unary    : Token operator, Expr right&quot;
    ));

    defineAst(outputDir, &quot;Stmt&quot;, Arrays.asList(
      &quot;Expression : Expr expression&quot;,
      &quot;Print      : Expr expression&quot;
    ));
  }
  
</code></pre>
<blockquote>
<p>The generated code for the new nodes is in Appendix II: Expression statement, Print statement.</p>
<p>ä¸ºæ–°èŠ‚ç‚¹ç”Ÿæˆçš„ä»£ç å¯ä»¥æŸ¥çœ‹ é™„å½•II, è¡¨è¾¾å¼è¯­å¥ï¼Œprintè¯­å¥ã€‚</p>
</blockquote>
<p>Run the AST generator script and behold the resulting â€œStmt.javaâ€ file with the syntax tree classes we need for expression and print statements. Donâ€™t forget to add the file to your IDE project or makefile or whatever.</p>
<p>è¿è¡Œ AST ç”Ÿæˆè„šæœ¬ï¼ŒæŸ¥çœ‹ç”Ÿæˆçš„ &quot;Stmt.java&quot; æ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«è¡¨è¾¾å¼å’Œprintè¯­å¥ï¼Œæ‰€éœ€çš„è¯­æ³•æ ‘ç±»ã€‚ä¸è¦å¿˜è®°å°†ç”Ÿæˆçš„æ–‡ä»¶ï¼Œæ·»åŠ åˆ°é¡¹ç›®ä¸­ã€‚</p>
<h3 id="12-parsing-statements"><a class="header" href="#12-parsing-statements">1.2 Parsing statements</a></h3>
<p>è§£æè¯­å¥</p>
<p>The parserâ€™s parse() method that parses and returns a single expression was a temporary hack to get the last chapter up and running. Now that our grammar has the correct starting rule, program, we can turn parse() into the real deal.</p>
<p>è§£æå™¨çš„parse() æ–¹æ³•è§£æå¹¶ä¸”è¿”å›ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸´æ—¶çš„ç ´è§£æ–¹å¼ï¼Œè®©æœ€åä¸€ç« å¯åŠ¨è¿è¡Œã€‚æ—¢ç„¶ï¼Œæˆ‘ä»¬çš„ç¨‹åºæœ‰äº†æ­£ç¡®çš„å¼€å§‹è§„åˆ™ï¼Œ program, æˆ‘ä»¬å°±å¯ä»¥æŠŠparse() æ–¹æ³•å˜ä¸ºçœŸæ­£çš„å¤„ç†æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, method parse(), replace 7 lines

  List&lt;Stmt&gt; parse() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();
    while (!isAtEnd()) {
      statements.add(statement());
    }

    return statements; 
  }
</code></pre>
<blockquote>
<p>What about the code we had in here for catching ParseError exceptions? Weâ€™ll put better parse error handling in place soon when we add support for additional statement types.</p>
<p>æˆ‘ä»¬ä¹‹å‰ç”¨äºæ•è·ParseErrorå¼‚å¸¸çš„ä»£ç å‘¢ï¼Ÿå½“æˆ‘ä»¬æ·»åŠ å¯¹äºå…¶ä»–è¯­å¥ç±»å‹çš„æ”¯æŒæ—¶å€™ï¼Œæˆ‘ä»¬å°†å¾ˆå¿«å®ç°æ›´å¥½çš„è§£æé”™è¯¯å¤„ç†</p>
</blockquote>
<p>This parses a series of statements, as many as it can find until it hits the end of the input. This is a pretty direct translation of the program rule into recursive descent style. We must also chant a minor prayer to the Java verbosity gods since we are using ArrayList now.</p>
<p>è¿™ä¸ªæ–°çš„parse() æ–¹æ³•ï¼Œå°†ä¼šè§£æä¸€ç³»åˆ—çš„è¯­å¥ï¼Œå°½å¯èƒ½å¤šï¼Œç›´åˆ°è¾“å…¥çš„ç»“å°¾ã€‚è¿™æ˜¯å°†program è¯­æ³•è§„åˆ™ï¼Œéå¸¸ç›´æ¥çš„è½¬æ¢ä¸ºé€’å½’ä¸‹é™çš„æ ·å¼ã€‚ç”±äºæˆ‘ä»¬ç°åœ¨ä½¿ç”¨ ArrayList(),æ‰€ä»¥ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¼•å…¥ Javaçš„ ArrayListæ¨¡å—</p>
<pre><code class="language-java">
// lox/Parser.java

package com.craftinginterpreters.lox;

import java.util.ArrayList;
import java.util.List;

</code></pre>
<p>A program is a list of statements, and we parse one of those statements using this method:</p>
<p>ç¨‹åºæ˜¯ä¸€ç³»åˆ—çš„è¯­å¥ç»„æˆçš„ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ statement() æ–¹æ³•è§£æå…¶ä¸­çš„ä¸€ä¸ªè¯­å¥</p>
<pre><code class="language-java">
// lox/Parser.java, add after expression()

  private Stmt statement() {
    if (match(PRINT)) return printStatement();

    return expressionStatement();
  }
  
</code></pre>
<p>A little bare bones, but weâ€™ll fill it in with more statement types later. We determine which specific statement rule is matched by looking at the current token. A print token means itâ€™s obviously a print statement.</p>
<p>If the next token doesnâ€™t look like any known kind of statement, we assume it must be an expression statement. Thatâ€™s the typical final fallthrough case when parsing a statement, since itâ€™s hard to proactively recognize an expression from its first token.</p>
<p>ä¸Šé¢çš„å‡½æ•°æœ‰äº›ç®€å•ï¼Œä½†æ˜¯ï¼Œç¨åæˆ‘ä»¬å°†ä¼šä½¿ç”¨æ›´å¤šçš„è¯­å¥ç±»å‹æ¥å¡«å…… statement() ï¼Œé€šè¿‡æŸ¥çœ‹å½“å‰çš„tokenï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šåŒ¹é…å“ªä¸€ä¸ªç‰¹å®šçš„è¯­å¥è§„åˆ™ã€‚print tokenï¼Œè¡¨ç¤ºå½“å‰çš„è¯­å¥æ˜¯printè¯­å¥ã€‚</p>
<p>å¦‚æœï¼Œä¸‹ä¸€ä¸ªtokençœ‹èµ·æ¥ä¸åƒæ˜¯ä»»ä½•å·²çŸ¥çš„è¯­å¥ç±»å‹ï¼Œæˆ‘ä»¬å…ˆå‡è®¾å®ƒï¼Œå¿…é¡»æ˜¯è¡¨è¾¾å¼è¯­å¥ï¼Œè¿™æ˜¯è§£æè¯­å¥æ—¶å€™ï¼Œå…¸å‹çš„æœ€ç»ˆå¤±è´¥æ¡ˆä¾‹ï¼Œå› ä¸ºå¾ˆéš¾ä»ç¬¬ä¸€ä¸ªtokenï¼Œå°±åˆ¤æ–­å‡ºè¡¨è¾¾å¼</p>
<p>Each statement kind gets its own method. First print:</p>
<p>æ¯ä¸ªè¯­å¥éƒ½æœ‰è‡ªå·±çš„å¯¹åº”æ–¹æ³•ï¼Œé¦–å…ˆæ˜¯printè¯­å¥</p>
<pre><code class="language-java">
// lox/Parser.java, add after statement()

  private Stmt printStatement() {
    Expr value = expression();
    consume(SEMICOLON, &quot;Expect ';' after value.&quot;);
    return new Stmt.Print(value);
  }
</code></pre>
<p>Since we already matched and consumed the print token itself, we donâ€™t need to do that here. We parse the subsequent expression, consume the terminating semicolon, and emit the syntax tree.</p>
<p>å› ä¸ºæˆ‘ä»¬å·²ç»åŒ¹é…åˆ°å¹¶ä¸”ä½¿ç”¨äº† print token,æ‰€ä»¥ï¼Œæˆ‘ä»¬ä¸éœ€è¦åœ¨è¿™é‡Œè¿™æ ·åšã€‚æˆ‘ä»¬å°†è§£æåç»­çš„è¡¨è¾¾å¼ï¼Œä½¿ç”¨ç»ˆæ­¢åˆ†å·ï¼Œç”Ÿæˆè¯­æ³•æ ‘ã€‚</p>
<p>If we didnâ€™t match a print statement, we must have one of these:</p>
<p>å¦‚æœæˆ‘ä»¬æ²¡æœ‰åŒ¹é…åˆ°print è¯­å¥ï¼Œåˆ™å¿…é¡»æ˜¯ä¸‹é¢çš„åœºæ™¯ä¹‹ä¸€</p>
<pre><code class="language-java">
// lox/Parser.java, add after printStatement()

  private Stmt expressionStatement() {
    Expr expr = expression();
    consume(SEMICOLON, &quot;Expect ';' after expression.&quot;);
    return new Stmt.Expression(expr);
  }


</code></pre>
<p>Similar to the previous method, we parse an expression followed by a semicolon. We wrap that Expr in a Stmt of the right type and return it.</p>
<p>ä¸å‰é¢çš„æ–¹æ³•ç±»ä¼¼ï¼Œæˆ‘ä»¬è§£æåé¢è·Ÿéšè€…åˆ†å·çš„è¡¨è¾¾å¼ï¼Œæˆ‘ä»¬å°†ExpråŒ…è£…åœ¨æ­£ç¡®çš„Stmtç±»å‹ä¸­ï¼Œå¹¶ä¸”è¿”å›ã€‚</p>
<h3 id="13-executing-statements"><a class="header" href="#13-executing-statements">1.3 Executing statements</a></h3>
<p>æ‰§è¡Œè¯­å¥</p>
<p>Weâ€™re running through the previous couple of chapters in microcosm, working our way through the front end. Our parser can now produce statement syntax trees, so the next and final step is to interpret them. As in expressions, we use the Visitor pattern, but we have a new visitor interface, Stmt.Visitor, to implement since statements have their own base class.</p>
<p>æˆ‘ä»¬åœ¨å¾®è§‚ä¸–ç•Œå®Œæˆäº†å‰é¢çš„å‡ ç« ï¼Œåœ¨å‰ç«¯å·¥ä½œã€‚æˆ‘ä»¬çš„è§£æå™¨ç°åœ¨å¯ä»¥ç”Ÿæˆè¯­æ³•æ ‘ï¼Œå› æ­¤ï¼Œä¸‹é¢çš„å¹¶ä¸”æ˜¯æœ€åçš„æ­¥éª¤æ˜¯ï¼Œå¦‚ä½•è§£é‡Šå®ƒä»¬ã€‚å’Œè¡¨è¾¾å¼ä¸€æ ·ï¼Œæˆ‘ä»¬ä½¿ç”¨è®¿é—®è€…æ¨¡å¼ï¼Œè®¿é—®è€…ï¼Œå› ä¸ºæ¯ä¸€ä¸ªå…·ä½“çš„statementç±»ï¼Œéƒ½æœ‰ç›¸åŒçš„åŸºç±»ã€‚</p>
<p>We add that to the list of interfaces Interpreter implements.</p>
<p>æˆ‘ä»¬å°†å…¶æ·»åŠ åˆ°è§£é‡Šå™¨å®ç°çš„æ¥å£åˆ—è¡¨ä¸­</p>
<pre><code class="language-java">
// lox/Interpreter.java, replace 1 line

class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
  void interpret(Expr expression) { 

</code></pre>
<blockquote>
<p>Java doesnâ€™t let you use lowercase â€œvoidâ€ as a generic type argument for obscure reasons having to do with type erasure and the stack. Instead, there is a separate â€œVoidâ€ type specifically for this use. Sort of a â€œboxed voidâ€, like â€œIntegerâ€ is for â€œintâ€.</p>
<p>Java ä¸­ä¸å…è®¸ä½¿ç”¨å°å†™çš„ void å½“ä½œæ³›å‹ç±»å‹å‚æ•°ï¼ŒåŸå› ä¸æ˜ï¼Œä¸ç±»å‹æ“¦é™¤å’Œå †æ ˆæœ‰å…³ï¼Œç›¸åï¼Œæœ‰ä¸€ä¸ªå•ç‹¬çš„Voidç±»å‹ï¼Œä¸“é—¨ç”¨äºè¿™ç§ç”¨é€”ï¼ŒVoidç±»å‹ä¹‹äº voidï¼Œæœ‰ç‚¹ç±»ä¼¼ Integerç±»å‹ä¹‹äº int</p>
</blockquote>
<p>Unlike expressions, statements produce no values, so the return type of the visit methods is Void, not Object. We have two statement types, and we need a visit method for each. The easiest is expression statements.</p>
<p>å’Œè¡¨è¾¾å¼ä¸åŒï¼Œè¯­å¥ä¸ç”Ÿæˆå€¼ï¼Œæ‰€ä»¥ï¼Œvisitæ–¹æ³•çš„è¿”å›å€¼ç±»å‹æ˜¯ Voidï¼Œè€Œä¸æ˜¯Objectï¼Œæˆ‘ä»¬æœ‰ä¸¤ç§è¯­å¥ç±»å‹ï¼Œæ¯ä¸ªéƒ½éœ€è¦ä¸€ç§è®¿é—®æ–¹æ³•ï¼Œæœ€ç®€å•çš„æ˜¯è¡¨è¾¾å¼è¯­å¥ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after evaluate()

  @Override
  public Void visitExpressionStmt(Stmt.Expression stmt) {
    evaluate(stmt.expression);
    return null;
  }

</code></pre>
<p>We evaluate the inner expression using our existing evaluate() method and discard the value. Then we return null. Java requires that to satisfy the special capitalized Void return type. Weird, but what can you do?</p>
<p>æˆ‘ä»¬ä½¿ç”¨ä¹‹å‰å®ç°çš„æ–¹æ³• evaluate() è®¡ç®—è¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä¸¢å¼ƒè®¡ç®—ç»“æœï¼Œè¿”å› nullï¼ŒJavaéœ€è¦æ»¡è¶³ç‰¹æ®Šçš„Void ç±»å‹çš„å€¼ã€‚æˆ‘ä»¬è¿˜éœ€è¦åšä»€ä¹ˆï¼Ÿ</p>
<blockquote>
<p>Appropriately enough, we discard the value returned by evaluate() by placing that call inside a Java expression statement.</p>
<p>åˆé€‚çš„æ˜¯ï¼Œæˆ‘ä»¬å°† evaluate() è¿”å›çš„å€¼ï¼Œæ”¾å…¥è¡¨è¾¾å¼è¯­å¥ä¸­ï¼Œä»è€Œä¸¢å¼ƒè¯¥å€¼</p>
</blockquote>
<p>The print statementâ€™s visit method isnâ€™t much different.</p>
<p>printè¯­å¥çš„è®¿é—®æ–¹æ³•ï¼Œæ²¡æœ‰å¤ªå¤šçš„ä¸åŒ</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitExpressionStmt()

  @Override
  public Void visitPrintStmt(Stmt.Print stmt) {
    Object value = evaluate(stmt.expression);
    System.out.println(stringify(value));
    return null;
  }


</code></pre>
<p>Before discarding the expressionâ€™s value, we convert it to a string using the stringify() method we introduced in the last chapter and then dump it to stdout.</p>
<p>åœ¨ä¸¢å¼ƒè¡¨è¾¾å¼çš„å€¼ä¹‹å‰ï¼Œæˆ‘ä»¬ä½¿ç”¨ä¸Šä¸€ç« ä»‹ç»çš„ stringify() æ–¹æ³•å°†ç»“æœè½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œç„¶åï¼Œå°†å…¶å­˜å‚¨åˆ° stdout</p>
<p>Our interpreter is able to visit statements now, but we have some work to do to feed them to it. First, modify the old interpret() method in the Interpreter class to accept a list of statementsâ€”in other words, a program.</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨ï¼Œç°åœ¨å¯ä»¥è®¿é—®è¯­å¥ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬éœ€è¦å…ˆåšä¸€äº›å·¥ä½œï¼Œæ¥å‘ä»–ä»¬æä¾›ä¿¡æ¯ï¼Œé¦–å…ˆï¼Œä¿®æ”¹æ—§çš„interpret() ï¼Œæ¥å—ä¸€ä¸ªè¯­å¥åˆ—è¡¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå‚æ•°æ˜¯ä¸€ä¸ªprogram</p>
<pre><code class="language-java">
// lox/Interpreter.java, method interpret(), replace 8 lines

  void interpret(List&lt;Stmt&gt; statements) {
    try {
      for (Stmt statement : statements) {
        execute(statement);
      }
    } catch (RuntimeError error) {
      Lox.runtimeError(error);
    }
  }
  
</code></pre>
<p>This replaces the old code which took a single expression. The new code relies on this tiny helper method:</p>
<p>è¿™å°†æ›¿æ¢é‡‡ç”¨å•ä¸ªè¡¨è¾¾å¼çš„æ—§ä»£ç ï¼Œæ–°çš„ä»£ç éœ€è¦ä¸€ä¸ª æ–°çš„ execute()å‡½æ•°</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after evaluate()

  private void execute(Stmt stmt) {
    stmt.accept(this);
  }


</code></pre>
<p>Thatâ€™s the statement analogue to the evaluate() method we have for expressions. Since weâ€™re working with lists now, we need to let Java know.</p>
<p>ä¸Šé¢æ˜¯ç±»ä¼¼äº evaluate() å¤„ç†è¡¨è¾¾å¼çš„å¤„ç†è¯­å¥æ–¹æ³•ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨å¤„ç†åˆ—è¡¨ï¼Œæ‰€ä»¥éœ€è¦å¼•å…¥ List</p>
<pre><code class="language-java">
// lox/Interpreter.java

package com.craftinginterpreters.lox;

import java.util.List;

class Interpreter implements Expr.Visitor&lt;Object&gt;,


</code></pre>
<p>The main Lox class is still trying to parse a single expression and pass it to the interpreter. We fix the parsing line like so:</p>
<p>ä¸»Lox ç±»ï¼Œä»ç„¶åœ¨å°è¯•è§£æå•ä¸ªè¡¨è¾¾å¼ï¼Œå¹¶ä¸”ä¼ é€’ç»™è§£é‡Šå™¨ï¼Œæˆ‘ä»¬è¿™æ ·ä¿®å¤è§£æè¡Œ</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 1 line

 Parser parser = new Parser(tokens);
    List&lt;Stmt&gt; statements = parser.parse();

    // Stop if there was a syntax error.


</code></pre>
<p>And then replace the call to the interpreter with this:</p>
<p>ç„¶åï¼Œè§£é‡Šå™¨çš„è°ƒç”¨ï¼Œæ›¿æ¢ä¸º</p>
<pre><code class="language-java">
// lox/Lox.java, in run(), replace 1 line

    if (hadError) return;

    interpreter.interpret(statements);
  }
  
</code></pre>
<p>Basically just plumbing the new syntax through. OK, fire up the interpreter and give it a try. At this point, itâ€™s worth sketching out a little Lox program in a text file to run as a script. Something like:</p>
<p>åŸºæœ¬ä¸Šï¼Œå°±æ˜¯é€šè¿‡ç®¡é“ä¼ é€’æ–°è¯­æ³•ã€‚å¥½çš„ï¼Œæˆ‘ä»¬å¼€å§‹å¯åŠ¨ç¿»è¯‘ï¼Œå¹¶ä¸”å¼€å§‹è¿è¡Œã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æ–‡ä»¶ä¸­æ„é€ ä¸€ä¸ªç®€å•çš„ç¨‹åºï¼Œå½“ä½œLoxè„šæœ¬æ‰§è¡Œã€‚</p>
<pre><code class="language-java">
print &quot;one&quot;;
print true;
print 2 + 1;

</code></pre>
<p>It almost looks like a real program! Note that the REPL, too, now requires you to enter a full statement instead of a simple expression. Donâ€™t forget your semicolons.</p>
<p>ä¸Šé¢çš„çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªçœŸæ˜¯çš„ç¨‹åºäº†ï¼Œè¯·æ³¨æ„ï¼ŒREPL ç°åœ¨ä¹Ÿè¦æ±‚æˆ‘ä»¬è¾“å…¥å®Œæ•´çš„è¯­å¥ï¼Œè€Œä¸æ˜¯ç®€å•çš„è¡¨è¾¾å¼ï¼Œä¸è¦å¿˜è®°åˆ†å·</p>
<h2 id="äºŒglobal-variables"><a class="header" href="#äºŒglobal-variables">äºŒã€Global Variables</a></h2>
<p>å…¨å±€å˜é‡</p>
<p>Now that we have statements, we can start working on state. Before we get into all of the complexity of lexical scoping, weâ€™ll start off with the easiest kind of variablesâ€”globals. We need two new constructs.</p>
<p>æ—¢ç„¶ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†è¯­å¥ï¼Œæˆ‘ä»¬å¯ä»¥ç ”ç©¶çŠ¶æ€äº†ï¼Œåœ¨æˆ‘ä»¬äº†è§£è¯æ±‡èŒƒå›´çš„å¤æ‚æ€§ä¹‹å‰ï¼Œæˆ‘ä»¬å°†ä»æœ€ç®€å•çš„å…¨å±€å˜é‡å¼€å§‹ã€‚æˆ‘ä»¬éœ€è¦ä¸¤ä¸ªæ–°çš„æ„é€ ã€‚</p>
<ol>
<li>
<p>A variable declaration statement brings a new variable into the world.</p>
<p>ä¸€ä¸ªå˜é‡å£°æ˜è¯­å¥ï¼Œä¸ºä¸–ç•Œå¸¦æ¥äº†ä¸€ä¸ªæ–°çš„å˜é‡</p>
<pre><code>var beverage = &quot;espresso&quot;;
</code></pre>
<p>This creates a new binding that associates a name (here â€œbeverageâ€) with a value (here, the string &quot;espresso&quot;).</p>
<p>ä¸Šé¢çš„å£°æ˜è¯­å¥ï¼Œå°†ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ç»‘å®šï¼Œç»‘å®šäº†ä¸€ä¸ªåç§°ï¼ˆbeverage) å’Œ å¯¹åº”çš„å€¼ï¼ˆ espressoï¼‰ä¹‹é—´çš„å…³ç³»</p>
</li>
<li>
<p>Once thatâ€™s done, a variable expression accesses that binding. When the identifier â€œbeverageâ€ is used as an expression, it looks up the value bound to that name and returns it.</p>
<p>å®Œæˆåï¼Œå˜é‡è¡¨è¾¾å¼å°†è®¿é—®è¯¥ç»‘å®šï¼Œå½“æ ‡è¯†ç¬¦ beverage ç”¨ä½œè¡¨è¾¾å¼æ—¶å€™ï¼Œå®ƒä¼šæŸ¥æ‰¾ç»‘å®šåˆ°è¯¥åç§°çš„å€¼ï¼Œå¹¶ä¸”è¿”å›è¯¥å€¼ã€‚</p>
<pre><code>
print beverage; // &quot;espresso&quot;.

</code></pre>
</li>
</ol>
<p>Later, weâ€™ll add assignment and block scope, but thatâ€™s enough to get moving.</p>
<p>ç¨åï¼Œæˆ‘ä»¬å°†ä»‹ç»èµ‹å€¼å’Œå—èŒƒå›´ï¼Œä½†æ˜¯ç°åœ¨è¶³å¤Ÿæˆ‘ä»¬å¼€å§‹äº†ã€‚</p>
<blockquote>
<p>Global state gets a bad rap. Sure, lots of global stateâ€”especially mutable stateâ€”makes it hard to maintain large programs. Itâ€™s good software engineering to minimize how much you use.</p>
<p>But when youâ€™re slapping together a simple programming language or, heck, even learning your first language, the flat simplicity of global variables helps. My first language was BASIC and, though I outgrew it eventually, it was nice that I didnâ€™t have to wrap my head around scoping rules before I could make a computer do fun stuff.</p>
<p>å…¨å±€çŠ¶æ€å—åˆ°äº†ä¸å¥½çš„è¯„ä»·ï¼Œå½“ç„¶ï¼Œè®¸å¤šå…¨å±€å˜é‡â€”â€”ç‰¹åˆ«æ˜¯å¯å˜å˜é‡ï¼Œä½¿å¾—ç»´æŠ¤å¤§å‹ç¨‹åºå˜å¾—å›°éš¾ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„è½¯ä»¶å·¥ç¨‹ï¼Œå¯ä»¥æœ€å¤§é™åº¦çš„å‡å°‘ä½ çš„ä½¿ç”¨é‡ã€‚</p>
<p>ä½†æ˜¯ï¼Œå½“ä½ æ‹¼å‡‘ä¸€é—¨ç®€å•çš„ç¼–ç¨‹è¯­è¨€ï¼Œæˆ–è€…ï¼Œå½“ä½ å¼€å§‹å­¦ä¹ ç¬¬ä¸€é—¨ç¼–ç¨‹è¯­è¨€æ—¶å€™ï¼Œå…¨å±€å˜é‡çš„ç®€å•æ€§å°†ä¼šæä¾›å¸®åŠ©ã€‚æˆ‘çš„ç¬¬ä¸€é—¨è¯­è¨€æ˜¯ BASICï¼Œå°½ç®¡æœ€ç»ˆï¼Œæˆ‘æ²¡æœ‰ç”¨åˆ°å®ƒï¼Œä½†åœ¨æˆ‘å¯ä»¥è®©è®¡ç®—æœºåšå¾ˆå¤šæœ‰è¶£çš„äº‹æƒ…ä¹‹å‰ï¼Œä¸å¿…è®©è‡ªå·±å»è®°ä½å¤æ‚çš„èŒƒå›´è§„åˆ™ï¼Œè¿™å¾ˆå¥½ã€‚</p>
</blockquote>
<h3 id="21-variable-syntax"><a class="header" href="#21-variable-syntax">2.1 Variable syntax</a></h3>
<p>å˜é‡è¯­æ³•</p>
<p>As before, weâ€™ll work through the implementation from front to back, starting with the syntax. Variable declarations are statements, but they are different from other statements, and weâ€™re going to split the statement grammar in two to handle them. Thatâ€™s because the grammar restricts where some kinds of statements are allowed.</p>
<p>å’Œä¹‹å‰ä¸€æ ·ï¼Œæˆ‘ä»¬å°†ä»è¯­æ³•å¼€å§‹ï¼Œä»å‰åˆ°åå®Œæˆå®ç°ã€‚å˜é‡å£°æ˜æ˜¯è¯­å¥ï¼Œä½†æ˜¯å®ƒä»¬å’Œå…¶ä»–è¯­å¥ä¸åŒï¼Œæˆ‘ä»¬å°†è¯­å¥åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œæ¥å¤„ç†å®ƒä»¬ã€‚è¿™æ˜¯å› ä¸ºè¯­æ³•é™åˆ¶äº†ï¼Œå…è®¸æŸäº›ç±»å‹çš„è¯­å¥çš„ä½ç½®ã€‚</p>
<p>The clauses in control flow statementsâ€”think the then and else branches of an if statement or the body of a whileâ€”are each a single statement. But that statement is not allowed to be one that declares a name. This is OK:</p>
<pre><code>
if (monday) print &quot;Ugh, already?&quot;;

</code></pre>
<p>But this is not:</p>
<pre><code>if (monday) var beverage = &quot;espresso&quot;;
</code></pre>
<p>æ§åˆ¶æµè¯­å¥ä¸­çš„å­å¥è®¤ä¸ºif è¯­å¥çš„thenã€elseåˆ†æ”¯ï¼Œwhileè¯­å¥çš„ä¸»ä½“ï¼Œéƒ½æ˜¯å•ä¸ªè¯­å¥ã€‚ä½†æ˜¯ï¼Œè¿™ä¸ªè¯­å¥ä¸å…è®¸æ˜¯å£°æ˜è¯­å¥ã€‚ä¸¾ä¾‹ï¼š</p>
<p>We could allow the latter, but itâ€™s confusing. What is the scope of that beverage variable? Does it persist after the if statement? If so, what is its value on days other than Monday? Does the variable exist at all on those days?</p>
<p>Code like this is weird, so C, Java, and friends all disallow it. Itâ€™s as if there are two levels of â€œprecedenceâ€ for statements. Some places where a statement is allowedâ€”like inside a block or at the top levelâ€”allow any kind of statement, including declarations. Others allow only the â€œhigherâ€ precedence statements that donâ€™t declare names.</p>
<p>æˆ‘ä»¬Loxå¯ä»¥å…è®¸åé¢çš„ç¨‹åºï¼Œä½†æ˜¯è¿™ä¼šä»¤äººå›°æƒ‘ã€‚beverage å˜é‡çš„ä½œç”¨èŒƒå›´æ˜¯ä»€ä¹ˆï¼Ÿå®ƒåœ¨ ifè¯­å¥ä¹‹å¤–æ˜¯å¦æŒç»­å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨ï¼Œbeverage å˜é‡çš„å€¼æ˜¯ä»€ä¹ˆï¼Ÿè¿™ä¸ªå˜é‡ beverage æ˜¯å¦ä¼šä¸€ç›´å­˜åœ¨ï¼Ÿ</p>
<p>è¿™æ ·çš„ä»£ç ä¼šéå¸¸å¥‡æ€ªï¼Œæ‰€ä»¥ï¼ŒC/Java/friends ç­‰è¯­è¨€ï¼Œéƒ½ä¸å…è®¸è¿™æ ·å†™ã€‚è¿™å¥½åƒæ˜¯è¯´ï¼Œè¯­å¥å­˜åœ¨ä¸¤ä¸ªä¼˜å…ˆçº§ã€‚æŸäº›å…è®¸è¯­å¥çš„åœ°æ–¹â€”â€”ä¾‹å¦‚ï¼Œå—å†…æˆ–è€…é¡¶å±‚ï¼Œå…è®¸ä»»ä½•ç±»å‹çš„è¯­å¥ï¼ŒåŒ…æ‹¬å£°æ˜è¯­å¥ã€‚å…¶ä»–åœ°æ–¹ï¼Œåªå…è®¸å‡ºç°æ›´é«˜çº§åˆ«çš„è¯­å¥ï¼Œä¸åŒ…æ‹¬å£°æ˜ã€‚</p>
<blockquote>
<p>In this analogy, block statements work sort of like parentheses do for expressions. A block is itself in the â€œhigherâ€ precedence level and can be used anywhere, like in the clauses of an if statement. But the statements it contains can be lower precedence. Youâ€™re allowed to declare variables and other names inside the block. The curlies let you escape back into the full statement grammar from a place where only some statements are allowed.</p>
<p>åœ¨ä¸Šé¢çš„ç±»æ¯”ä¸­ï¼Œå—è¯­å¥å¥½åƒæ˜¯è¡¨è¾¾å¼ä¸­çš„å°æ‹¬å·ï¼Œå—æœ¬èº«å¤„äºæ›´é«˜çš„ä¼˜å…ˆçº§ï¼Œå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼šifè¯­å¥çš„å­å¥ä¸­ã€‚ä½†æ˜¯ï¼Œå—åŒ…å«çš„è¯­å¥å¯ä»¥å…·æœ‰æ›´ä½çš„ä¼˜å…ˆçº§ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å—å†…ï¼Œå£°æ˜å˜é‡å’Œå…¶ä»–åç§°ï¼Œæ¸¸æ ‡ï¼Œå…è®¸æˆ‘ä»¬ä»åªå…è®¸æŸäº›è¯­å¥çš„åœ°æ–¹ï¼Œè¿”å›åˆ°å®Œæ•´çš„è¯­å¥è¯­æ³•ã€‚</p>
</blockquote>
<p>To accommodate the distinction, we add another rule for kinds of statements that declare names</p>
<p>ä¸ºäº†é€‚åº”è¿™ç§è§„åˆ™ï¼Œæˆ‘ä»¬ä¸ºå£°æ˜è¯­å¥æ·»åŠ äº†å¦å¤–ä¸€æ¡è¯­æ³•è§„åˆ™</p>
<pre><code>
program       â€”â€”&gt; declaration* EOF;

declaration   â€”â€”&gt; varDecl
	          |   statement;
			  
statement     â€”â€”&gt; exprStmt;
	          |   printStmt;
			  
</code></pre>
<p>Declaration statements go under the new declaration rule. Right now, itâ€™s only variables, but later it will include functions and classes. Any place where a declaration is allowed also allows non-declaring statements, so the declaration rule falls through to statement. Obviously, you can declare stuff at the top level of a script, so program routes to the new rule.</p>
<p>å£°æ˜è¯­å¥ï¼Œç¬¦åˆæœ€æ–°çš„å£°æ˜è¯­æ³•è§„åˆ™ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬çš„å£°æ˜è¯­å¥ï¼Œåªæ˜¯å˜é‡ã€‚ä½†æ˜¯ï¼Œç¨åï¼Œå®ƒå°†åŒ…å«å‡½æ•°å’Œç±»ï¼Œä»»ä½•å…è®¸å£°æ˜è¯­å¥çš„åœ°æ–¹ï¼Œä¹ŸåŒæ—¶å…è®¸å…¶ä»–è¯­å¥ï¼Œå› æ­¤ï¼Œå£°æ˜è§„åˆ™ï¼Œä¹Ÿé€‚åº”äºå…¶ä»–è¯­å¥ã€‚æ˜¾ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨è„šæœ¬çš„é¡¶å±‚å£°æ˜å†…å®¹ï¼Œå› æ­¤ï¼Œç¨‹åºå°†è·¯ç”±åˆ°æ–°è§„åˆ™ã€‚</p>
<p>The rule for declaring a variable looks like:</p>
<p>å£°æ˜å˜é‡çš„è§„åˆ™å¦‚ä¸‹</p>
<pre><code>varDecl      â€”â€”&gt; &quot;var&quot; IDENTIFIER ï¼ˆ &quot;=&quot; expression ) ? &quot;;&quot; ; 
</code></pre>
<p>Like most statements, it starts with a leading keyword. In this case, var. Then an identifier token for the name of the variable being declared, followed by an optional initializer expression. Finally, we put a bow on it with the semicolon</p>
<p>å’Œå¤§å¤šæ•°çš„è¯­å¥ä¸€æ ·ï¼Œå®ƒä»¥ä¸€ä¸ªå‰å¯¼å…³é”®å­—å¼€å§‹ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œå…³é”®å­—æ˜¯ varï¼Œç„¶åï¼Œæ˜¯å£°æ˜çš„å˜é‡çš„åç§°ï¼Œå³ä¸€ä¸ªæ ‡è¯†ç¬¦ tokenï¼Œæœ€åï¼Œè·Ÿéšç€ä¸€ä¸ªå¯é€‰çš„åˆå§‹å€¼è®¾å®šé¡¹è¡¨è¾¾å¼ã€‚åˆ«å¿˜äº†è¯­å¥çš„æœ€åæ˜¯ä¸€ä¸ªåˆ†å·</p>
<p>To access a variable, we define a new kind of primary expression.</p>
<p>ä¸ºäº†è®¿é—®å˜é‡ï¼Œæˆ‘ä»¬å®šä¹‰ä¸€ä¸ªæ–°çš„ä¸»è¡¨è¾¾å¼</p>
<pre><code>
primary           â€”â€”&gt; &quot;true&quot; | &quot;false&quot; | &quot;nil&quot;
                  |   NUMBER | STRING
				  | &quot;(&quot; expression &quot;)&quot;
				  | IDENTIFIER;

</code></pre>
<p>That IDENTIFIER clause matches a single identifier token, which is understood to be the name of the variable being accessed.</p>
<p>IDENTIFIER å­å¥ï¼ŒåŒ¹é…å•ä¸ªæ ‡è¯†ç¬¦tokenï¼Œè¯¥tokenå¯ä»¥è¢«ç†è§£ä¸ºæ­£åœ¨è®¿é—®çš„å˜é‡çš„åç§°ã€‚</p>
<p>These new grammar rules get their corresponding syntax trees. Over in the AST generator, we add a new statement node for a variable declaration.</p>
<p>è¿™äº›æ–°çš„è¯­æ³•è§„åˆ™ï¼Œå¾—åˆ°äº†ç›¸åº”çš„è¯­æ³•æ ‘ã€‚åœ¨ASTç”Ÿæˆå™¨ä¸­ï¼Œæˆ‘ä»¬ä¸ºå˜é‡å£°æ˜æ·»åŠ äº†ä¸€ä¸ªæ–°çš„è¯­å¥èŠ‚ç‚¹</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main(), add â€œ,â€ to previous line

   &quot;Expression : Expr expression&quot;,
      &quot;Print      : Expr expression&quot;,
      &quot;Var        : Token name, Expr initializer&quot;
    ));
	
</code></pre>
<p>It stores the name token so we know what itâ€™s declaring, along with the initializer expression. (If there isnâ€™t an initializer, that field is null.)</p>
<p>Varå˜é‡ä¸­ä¿å­˜åç§°tokenï¼Œä»¥ä¾¿æˆ‘ä»¬çŸ¥é“å®ƒåœ¨å£°æ˜ä»€ä¹ˆï¼Œä»¥åŠåˆå§‹å€¼è®¾å®šé¡¹è¡¨è¾¾å¼ï¼ˆå¦‚æœæ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼Œåˆ™è¯¥å­—æ®µä¸ºç©ºï¼‰</p>
<p>Then we add an expression node for accessing a variable.</p>
<p>ç„¶åï¼Œæˆ‘ä»¬è¿˜è¦åˆ›å»ºä¸€ä¸ªç”¨äºè®¿é—®å˜é‡çš„è¡¨è¾¾å¼èŠ‚ç‚¹</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main(), add â€œ,â€ to previous line

     &quot;Literal  : Object value&quot;,
      &quot;Unary    : Token operator, Expr right&quot;,
      &quot;Variable : Token name&quot;
    ));
	
</code></pre>
<p>Itâ€™s simply a wrapper around the token for the variable name. Thatâ€™s it. As always, donâ€™t forget to run the AST generator script so that you get updated â€œExpr.javaâ€ and â€œStmt.javaâ€ files.</p>
<p>å®ƒåªæ˜¯å˜é‡å tokençš„åŒ…è£…å™¨ï¼Œå°±æ˜¯è¿™æ ·ï¼Œä¸€å¦‚æ—¢å¾€ï¼Œä¸è¦å¿˜è®°è¿è¡ŒASTç”Ÿæˆå™¨è„šæœ¬ï¼Œä»¥ä¾¿è·å¾—æ›´æ–°çš„ &quot;Expr.java&quot; å’Œ &quot;Stmt.java&quot; æ–‡ä»¶</p>
<h3 id="22-è§£æå˜é‡"><a class="header" href="#22-è§£æå˜é‡">2.2 è§£æå˜é‡</a></h3>
<p>Before we parse variable statements, we need to shift around some code to make room for the new declaration rule in the grammar. The top level of a program is now a list of declarations, so the entrypoint method to the parser changes.</p>
<p>åœ¨è§£æè¯­å¥ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦è½¬æ¢ä¸€ä¸‹ä»£ç ï¼Œä¸ºè¯­æ³•ä¸­çš„æ–°å£°æ˜è§„åˆ™è…¾å‡ºç©ºé—´ï¼Œç¨‹åºçš„é¡¶éƒ¨æ˜¯å£°æ˜è¯­å¥ï¼Œå› æ­¤è§£æå™¨çš„å…¥å£ç‚¹å‘ç”Ÿäº†å˜åŒ–ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, in parse(), replace 1 line

  List&lt;Stmt&gt; parse() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();
    while (!isAtEnd()) {
      statements.add(declaration());
    }

    return statements; 
  }
  
</code></pre>
<p>That calls this new method:</p>
<p>å®ƒè°ƒç”¨äº†æ–°æ–¹æ³•ï¼Œ</p>
<pre><code class="language-java">
// lox/Parser.java, add after expression()

  private Stmt declaration() {
    try {
      if (match(VAR)) return varDeclaration();

      return statement();
    } catch (ParseError error) {
      synchronize();
      return null;
    }
  }
  
</code></pre>
<p>Hey, do you remember way back in that earlier chapter when we put the infrastructure in place to do error recovery? We are finally ready to hook that up.</p>
<p>This declaration() method is the method we call repeatedly when parsing a series of statements in a block or a script, so itâ€™s the right place to synchronize when the parser goes into panic mode. The whole body of this method is wrapped in a try block to catch the exception thrown when the parser begins error recovery. This gets it back to trying to parse the beginning of the next statement or declaration.</p>
<p>The real parsing happens inside the try block. First, it looks to see if weâ€™re at a variable declaration by looking for the leading var keyword. If not, it falls through to the existing statement() method that parses print and expression statements.</p>
<p>Remember how statement() tries to parse an expression statement if no other statement matches? And expression() reports a syntax error if it canâ€™t parse an expression at the current token? That chain of calls ensures we report an error if a valid declaration or statement isnâ€™t parsed.</p>
<p>å—¨ï¼Œä½ è¿˜è®°å¾—æˆ‘ä»¬åœ¨ä¸Šä¸€ç« ä¸­çš„æ‰§è¡Œé”™è¯¯æ¢å¤ä»£ç å—ï¼Ÿæˆ‘ä»¬ç»ˆäºå‡†å¤‡å¥½äº†</p>
<p>è¿™ä¸ª declaration() æ–¹æ³•æ˜¯æˆ‘ä»¬è§£æä»£ç å—æˆ–è€…è„šæœ¬ä¸­çš„ä¸€äº›åˆ—è¯­å¥æ—¶å€™ï¼Œä¼šåå¤è°ƒç”¨çš„æ–¹æ³•ï¼Œå› æ­¤ï¼Œå½“è§£æå™¨è¿›å…¥åˆ°ç´§æ€¥æ¨¡å¼åï¼Œå®ƒæ˜¯åŒæ­¥è¿›è¡Œçš„ä¸€ä¸ªä½ç½®ï¼Œè¿™ä¸ªæ–¹æ³•çš„æ•´ä¸ªä¸»ä½“è¢«åŒ…è£…åœ¨ä¸€ä¸ªtryå—ä¸­ï¼Œä»¥æ•è·è§£æå™¨å¼€å§‹é”™è¯¯æ¢å¤æ—¶å€™ï¼ŒæŠ›å‡ºçš„å¼‚å¸¸ã€‚è€Œè¿™æ ·ï¼Œæˆ‘ä»¬åˆå›åˆ°äº†å°è¯•è§£æä¸‹ä¸€ä¸ªè¯­å¥æˆ–è€…å£°æ˜çš„å¼€å¤´ã€‚</p>
<p>çœŸæ­£çš„è§£æå‘ç”Ÿåœ¨tryå†…ï¼Œé¦–å…ˆï¼Œå®ƒé€šè¿‡æŸ¥æ‰¾å‰å¯¼varå…³é”®å­—ï¼Œæ¥æŸ¥çœ‹æˆ‘ä»¬æ˜¯å¦åœ¨å˜é‡å£°æ˜ä¸­ã€‚å¦‚æœæ²¡æœ‰å‘ç° varï¼Œå°†ä¼šæ‰§è¡Œç°æœ‰çš„statement() æ–¹æ³•ï¼Œè§£æprintè¯­å¥å’Œè¡¨è¾¾å¼è¯­å¥ã€‚</p>
<p>è¿˜è®°å¾—ï¼Œå¦‚æœæ²¡æœ‰å…¶ä»–è¯­å¥åŒ¹é…ï¼Œstatement() æ–¹æ³•ï¼Œå¦‚ä½•å°è¯•è§£æè¡¨è¾¾å¼è¯­å¥å—ï¼Ÿå¦‚æœ expression() æ–¹æ³•æ— æ³•åœ¨å½“å‰çš„tokenå¤„ï¼Œè§£æè¡¨è¾¾å¼ï¼Œåˆ™ä¼šæŠ¥å‘Šè¯­æ³•é”™è¯¯ï¼Ÿå¦‚æœæœªè§£ææœ‰æ•ˆçš„å£°æ˜æˆ–è€…è¯­å¥ï¼Œè¯¥è°ƒç”¨é“¾å°†ä¿è¯æˆ‘ä»¬æŠ¥é”™é”™è¯¯ã€‚</p>
<p>When the parser matches a var token, it branches to:</p>
<p>å½“åŒ¹é…åˆ° Var tokenæ—¶å€™ï¼Œå°†ä¼šæ‰§è¡Œ</p>
<pre><code class="language-java">

// lox/Parser.java, add after printStatement()

  private Stmt varDeclaration() {
    Token name = consume(IDENTIFIER, &quot;Expect variable name.&quot;);

    Expr initializer = null;
    if (match(EQUAL)) {
      initializer = expression();
    }

    consume(SEMICOLON, &quot;Expect ';' after variable declaration.&quot;);
    return new Stmt.Var(name, initializer);
  }
  
</code></pre>
<p>As always, the recursive descent code follows the grammar rule. The parser has already matched the var token, so next it requires and consumes an identifier token for the variable name.</p>
<p>Then, if it sees an = token, it knows there is an initializer expression and parses it. Otherwise, it leaves the initializer null. Finally, it consumes the required semicolon at the end of the statement. All this gets wrapped in a Stmt.Var syntax tree node and weâ€™re groovy.</p>
<p>ä¸ä¹‹å‰ä¸€æ ·ï¼Œé€’å½’ä¸‹é™ä»£ç éµå¾ªè¯­æ³•è§„åˆ™ã€‚è§£æå™¨å·²ç»åŒ¹é…äº†varå…³é”®å­—ï¼Œå› æ­¤æ¥ä¸‹æ¥ï¼Œéœ€è¦å¹¶ä¸”ä¼šè·å– varåé¢çš„å˜é‡åã€‚</p>
<p>ç„¶åï¼Œå¦‚æœæ¥ä¸‹æ¥å¾—åˆ°ä¸€ä¸ª = tokenï¼Œæˆ‘ä»¬çŸ¥é“è¿™æ˜¯ä¸€ä¸ªåˆå§‹å€¼èµ‹å€¼è¡¨è¾¾å¼ï¼Œå¹¶ä¸”è§£æè¿™ä¸ªè¯­å¥ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬ä¼šå®šä¹‰åˆå§‹é¡¹ä¸ºnullï¼Œæœ€åï¼Œæˆ‘ä»¬åœ¨è¯­å¥çš„ç»“å°¾éœ€è¦åŒ…å« ; ã€‚æ‰€æœ‰è¿™äº›éƒ½è¢«å°è£…æˆä¸€ä¸ª Stmt.Var è¯­æ³•æ ‘ï¼Œæˆ‘ä»¬æ˜¯æœ‰è¶£çš„</p>
<p>Parsing a variable expression is even easier. In primary(), we look for an identifier token.</p>
<p>è§£æä¸€ä¸ªå˜é‡è¡¨è¾¾å¼æ›´åŠ å®¹æ˜“ã€‚åœ¨primary() æ–¹æ³•é‡Œé¢ï¼Œæˆ‘ä»¬ä¼šæŸ¥çœ‹å•ä¸ªæ ‡è¯†ç¬¦</p>
<pre><code>
// lox/Parser.java, in primary()

     return new Expr.Literal(previous().literal);
    }

    if (match(IDENTIFIER)) {
      return new Expr.Variable(previous());
    }

    if (match(LEFT_PAREN)) {
	
</code></pre>
<p>That gives us a working front end for declaring and using variables. All thatâ€™s left is to feed it into the interpreter. Before we get to that, we need to talk about where variables live in memory.</p>
<p>è¿™ä¸ºæˆ‘ä»¬å£°æ˜å’Œä½¿ç”¨ä¸€ä¸ªå˜é‡æä¾›äº†ä¸€ä¸ªæœ‰æ•ˆçš„å‰ç«¯ï¼Œå‰©ä¸‹çš„å°±æ˜¯è®©å®ƒç»§ç»­è§£æã€‚åœ¨å¼€å§‹ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦è®¨è®ºå˜é‡åœ¨å†…å­˜ä¸­çš„ä½ç½®</p>
<h2 id="ä¸‰environments"><a class="header" href="#ä¸‰environments">ä¸‰ã€Environments</a></h2>
<p>ç¯å¢ƒ</p>
<p>The bindings that associate variables to values need to be stored somewhere. Ever since the Lisp folks invented parentheses, this data structure has been called an environment.</p>
<p>å°†å˜é‡å’Œå€¼å…³è”çš„ç»‘å®šå…³ç³»ï¼Œéœ€è¦ä¿å­˜åœ¨æŸä¸ªä½ç½®ï¼Œè‡ªä»lispå‘æ˜äº†æ‹¬å·ï¼Œè¿™ç§æ•°æ®ç»“æ„ç§°ä¸ºç¯å¢ƒ</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/environment.png?raw=true" alt="environment" /></p>
<blockquote>
<p>I like to imagine the environment literally, as a sylvan wonderland where variables and values frolic.</p>
<p>æˆ‘å–œæ¬¢æŠŠç¯å¢ƒæƒ³è±¡æˆä¸€ä¸ªæ£®æ—ä»™å¢ƒï¼Œå˜é‡å’Œå˜é‡å€¼åœ¨å…¶ä¸­å¬‰æˆã€‚</p>
</blockquote>
<p>You can think of it like a map where the keys are variable names and the values are the variableâ€™s, uh, values. In fact, thatâ€™s how weâ€™ll implement it in Java. We could stuff that map and the code to manage it right into Interpreter, but since it forms a nicely delineated concept, weâ€™ll pull it out into its own class.</p>
<p>æˆ‘ä»¬å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆä¸€ä¸ªæ˜ å°„ï¼Œå…¶ä¸­keyæ˜¯å˜é‡åï¼Œvalueæ˜¯å˜é‡åå¯¹åº”çš„å€¼ã€‚äº‹å®ä¸Šï¼Œè¿™å°±æ˜¯æˆ‘ä»¬ç”¨Javaå®ç°çš„æ–¹å¼ã€‚æˆ‘ä»¬å¯ä»¥å°†è¯¥æ˜ å°„å’Œç®¡ç†å®ƒçš„ä»£ç ï¼Œå¡«å……åˆ°è§£é‡Šå™¨ä¸­ï¼Œä½†æ˜¯ï¼Œç”±äºå®ƒå½¢æˆäº†ä¸€ä¸ªå¾ˆå¥½çš„æ¦‚å¿µï¼Œæ‰€ä»¥æˆ‘ä»¬å°†æŠŠå®ƒæ”¾åˆ°è‡ªå·±çš„ç±»ä¸­ã€‚</p>
<blockquote>
<p>Java calls them maps or hashmaps. Other languages call them hash tables, dictionaries (Python and C#), hashes (Ruby and Perl), tables (Lua), or associative arrays (PHP). Way back when, they were known as scatter tables.</p>
<p>Javaä¸­ç§°ä¸º map æˆ–è€… hashmap, å…¶ä»–è¯­è¨€ç§°å®ƒæ˜¯ hash table, dictionaries(Python å’Œ C#ï¼‰ï¼Œhash(Ruby å’Œ Perl),table(Lua) , associative arrays(PHP), è€Œå¾ˆä¹…ä»¥å‰ï¼Œå®ƒè¢«ç§°ä¸º æ•£ç‚¹è¡¨</p>
</blockquote>
<p>Start a new file and add:</p>
<p>æ·»åŠ ä¸€ä¸ªæ–°çš„æ–‡ä»¶</p>
<pre><code class="language-java">
// lox/Environment.java, create new file

package com.craftinginterpreters.lox;

import java.util.HashMap;
import java.util.Map;

class Environment {
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
}

</code></pre>
<p>Thereâ€™s a Java Map in there to store the bindings. It uses bare strings for the keys, not tokens. A token represents a unit of code at a specific place in the source text, but when it comes to looking up variables, all identifier tokens with the same name should refer to the same variable (ignoring scope for now). Using the raw string ensures all of those tokens refer to the same map key.</p>
<p>æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªjava Mapæ¥å­˜å‚¨ç»‘å®šå…³ç³»ï¼Œå®ƒä½¿ç”¨å­—ç¬¦ä¸²å½“ä½œkeyï¼Œè€Œä¸æ˜¯token. tokenè¡¨ç¤ºæºæ–‡ä»¶ç‰¹å®šä½ç½®çš„ä»£ç å•å…ƒï¼Œä½†æ˜¯åœ¨æŸ¥æ‰¾å˜é‡æ—¶å€™ï¼Œæ‰€æœ‰å…·æœ‰å½¢åŒåç§°çš„æ ‡è¯†ç¬¦tokenï¼Œéƒ½å·²ç»å¼•ç”¨ç›¸åŒçš„å˜é‡ï¼ˆæš‚æ—¶å¿½ç•¥èŒƒå›´ï¼‰. ä½¿ç”¨åŸå§‹å­—ç¬¦ä¸²ï¼Œå¯ä»¥ä¿è¯è¿™äº›tokenéƒ½å¯¹åº”ç€åŒä¸€ä¸ªmap key.</p>
<p>There are two operations we need to support. First, a variable definition binds a new name to a value.</p>
<p>æˆ‘ä»¬è¿˜éœ€è¦æ”¯æŒä¸¤ç§æ“ä½œï¼Œé¦–å…ˆï¼Œå˜é‡å®šä¹‰å°†æ–°åç§°ç»‘å®šåˆ°ä¸€ä¸ªå…·ä½“çš„å€¼</p>
<pre><code>
lox/Environment.java, in class Environment

  void define(String name, Object value) {
    values.put(name, value);
  }
  
</code></pre>
<p>Not exactly brain surgery, but we have made one interesting semantic choice. When we add the key to the map, we donâ€™t check to see if itâ€™s already present. That means that this program works:</p>
<p>ä¸æ˜¯ä¸€ä¸ªè„‘éƒ¨æ‰‹æœ¯ï¼Œä½†æ˜¯æˆ‘ä»¬åšäº†ä¸€ä¸ªæœ‰è¶£çš„è¯­ä¹‰é€‰æ‹©ã€‚å½“æˆ‘ä»¬å°†keyæ·»åŠ åˆ°mapä¸­åï¼Œæˆ‘ä»¬ä¸ä¼šæ£€æŸ¥å®ƒæ˜¯å¦å·²ç»å­˜åœ¨ï¼Œè¿™æ„å‘³ç€ï¼Œè¿™ä¸ªç¨‹åºå¯ä»¥æ˜¯ </p>
<pre><code class="language-java">
var a = &quot;before&quot;;
print a; // &quot;before&quot;.
var a = &quot;after&quot;;
print a; // &quot;after&quot;.

</code></pre>
<p>A variable statement doesnâ€™t just define a new variable, it can also be used to redefine an existing variable. We could choose to make this an error instead. The user may not intend to redefine an existing variable. (If they did mean to, they probably would have used assignment, not var.) Making redefinition an error would help them find that bug.</p>
<p>However, doing so interacts poorly with the REPL.  In the middle of a REPL session, itâ€™s nice to not have to mentally track which variables youâ€™ve already defined. We could allow redefinition in the REPL but not in scripts, but then users would have to learn two sets of rules, and code copied and pasted from one form to the other might not work.</p>
<p>å˜é‡è¯­å¥ä¸ä»…ä»…å®šä¹‰ä¸€ä¸ªæ–°å˜é‡ï¼Œå®ƒè¿˜å¯ä»¥ç”¨äºé‡æ–°å®šä¹‰ä¸€ä¸ªç°æœ‰å˜é‡ã€‚æˆ‘ä»¬å¯ä»¥é€‰æ‹©å°†å…¶è®¾ç½®ä¸ºé”™è¯¯ï¼Œç”¨æˆ·å¯èƒ½ä¸æ‰“ç®—é‡æ–°å®šä¹‰ç°æœ‰å˜é‡ï¼Œï¼ˆå¦‚æœç”¨æˆ·çœŸçš„æƒ³è¦è¿™æ ·åšï¼Œå¯èƒ½ä¼šä½¿ç”¨èµ‹å€¼ï¼Œè€Œä¸æ˜¯å˜é‡ï¼‰ï¼Œé‡æ–°å®šä¹‰é”™è¯¯ï¼Œå°†å¸®åŠ©ç”¨æˆ·æ‰¾åˆ°é”™è¯¯ã€‚</p>
<p>ç„¶è€Œï¼Œè¿™æ ·åšå°†ä¼šä½¿å¾— REPL çš„äº¤äº’å¾ˆå·®ï¼Œåœ¨ä¸€ä¸ªREPLçš„ä¼šè¯ä¸­ï¼Œæœ€å¥½ä¸è¦è·Ÿè¸ªå·²ç»å®šä¹‰çš„å˜é‡ã€‚æˆ‘ä»¬å¯ä»¥å…è®¸åœ¨ REPLä¸­é‡æ–°å®šä¹‰ï¼Œä½†æ˜¯ä¸å…è®¸åœ¨è„šæœ¬ä¸­é‡æ–°å®šä¹‰ã€‚ä½†æ˜¯ï¼Œç”¨æˆ·å¿…é¡»å­¦ä¹ ä¸¤ç»„è§„åˆ™ï¼Œä»£ç ä»ä¸€ä¸ªåœ°æ–¹å¤åˆ¶åˆ°å…¶ä»–åœ°æ–¹ï¼Œå¯èƒ½ä¸èµ·ä½œç”¨ã€‚</p>
<blockquote>
<p>My rule about variables and scoping is, â€œWhen in doubt, do what Scheme doesâ€. The Scheme folks have probably spent more time thinking about variable scope than we ever willâ€”one of the main goals of Scheme was to introduce lexical scoping to the worldâ€”so itâ€™s hard to go wrong if you follow in their footsteps.</p>
<p>Scheme allows redefining variables at the top level.</p>
<p>æˆ‘å…³äºå˜é‡å’Œä½œç”¨èŒƒå›´çš„è§„åˆ™æ˜¯ï¼Œå½“æœ‰ç–‘é—®æ—¶å€™ï¼ŒåšSchemeåšçš„äº‹ã€‚Schemeå¯èƒ½èŠ±è´¹äº†æ›´å¤šçš„æ—¶é—´æ¥æ€è€ƒå˜é‡èŒƒå›´ï¼ŒSchemeçš„ä¸»è¦ç›®æ ‡æ˜¯å‘å…¨ä¸–ç•Œä»‹ç»è¯æ±‡èŒƒå›´ï¼Œæ‰€ä»¥å¦‚æœä½ è¿½éšä»–ä»¬çš„è„šæ­¥ï¼Œå°†å¾ˆéš¾å‡ºé”™</p>
<p>Schemeå…è®¸åœ¨é¡¶å±‚é‡æ–°å®šä¹‰å˜é‡</p>
</blockquote>
<p>So, to keep the two modes consistent, weâ€™ll allow itâ€”at least for global variables. Once a variable exists, we need a way to look it up.</p>
<p>æ‰€ä»¥ï¼Œä¸ºäº†ä¿æŒä¸¤ç§æ¨¡å¼çš„ä¸€è‡´æ€§ï¼Œæˆ‘ä»¬è‡³å°‘å…è®¸å…¨å±€å˜é‡ä½¿ç”¨è¿™ç§æ¨¡å¼ï¼Œä¸€æ—¦å˜é‡å·²ç»å­˜åœ¨ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¸€ç§æ–¹æ³•æ¥æŸ¥æ‰¾å®ƒã€‚</p>
<pre><code class="language-java">
// lox/Environment.java, in class Environment

class Environment {
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();

  Object get(Token name) {
    if (values.containsKey(name.lexeme)) {
      return values.get(name.lexeme);
    }

    throw new RuntimeError(name,
        &quot;Undefined variable '&quot; + name.lexeme + &quot;'.&quot;);
  }

  void define(String name, Object value) {
  
</code></pre>
<p>This is a little more semantically interesting. If the variable is found, it simply returns the value bound to it. But what if itâ€™s not? Again, we have a choice:</p>
<ul>
<li>
<p>Make it a syntax error.</p>
</li>
<li>
<p>Make it a runtime error.</p>
</li>
<li>
<p>Allow it and return some default value like nil.</p>
</li>
</ul>
<p>è¿™åœ¨è¯­ä¹‰ä¸Šæ›´æœ‰æ„æ€ï¼Œå¦‚æœæ‰¾åˆ°äº†å˜é‡ï¼Œæˆ‘ä»¬åªä¼šè¿”å›å˜é‡ç»‘å®šçš„å€¼ï¼Œå¦‚æœæ‰¾ä¸åˆ°å˜é‡ï¼Œæˆ‘ä»¬è¯¥å¦‚ä½•é€‰æ‹©å‘¢ï¼Ÿ</p>
<ul>
<li>
<p>åˆ¤æ–­ä¸ºè¯­æ³•é”™è¯¯</p>
</li>
<li>
<p>è§¦å‘è¿è¡Œæ—¶é”™è¯¯</p>
</li>
<li>
<p>å…è®¸è¿™ç§åœºæ™¯ï¼Œå¹¶ä¸”è¿”å›ä¸€äº›é»˜è®¤åˆå§‹å€¼ï¼Œä¾‹å¦‚: nil</p>
</li>
</ul>
<p>Lox is pretty lax, but the last option is a little too permissive to me. Making it a syntax errorâ€”a compile-time errorâ€”seems like a smart choice. Using an undefined variable is a bug, and the sooner you detect the mistake, the better.</p>
<p>The problem is that using a variable isnâ€™t the same as referring to it. You can refer to a variable in a chunk of code without immediately evaluating it if that chunk of code is wrapped inside a function. If we make it a static error to mention a variable before itâ€™s been declared, it becomes much harder to define recursive functions.</p>
<p>Loxè¯­è¨€éå¸¸å®½æ¾ï¼Œä½†æ˜¯æœ€åä¸€ä¸ªé€‰é¡¹ï¼Œå¯¹äºæˆ‘ä»¬æ¥è¯´ï¼Œè¿‡äºå®½æ¾äº†ï¼Œå°†å…¶ä½œä¸ºä¸€ä¸ªè¯­æ³•é”™è¯¯ï¼ˆç¼–è¯‘æ—¶é”™è¯¯ï¼‰çœ‹èµ·æ¥æ˜¯ä¸€ä¸ªæ˜æ™ºçš„é€‰æ‹©ï¼Œä½¿ç”¨æœªå®šä¹‰çš„å˜é‡æ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œè¶Šæ—©å‘ç°è¶Šå¥½ã€‚</p>
<p>é—®é¢˜æ˜¯ï¼Œä½¿ç”¨å˜é‡å’Œå¼•ç”¨å˜é‡ä¸åŒï¼Œå¦‚æœä»£ç å—å°è£…åœ¨å‡½æ•°ä¸­ï¼Œåˆ™å¯ä»¥å¼•ç”¨ä»£ç å—ä¸­çš„å˜é‡ï¼Œè€Œæ— éœ€ç«‹å³å¯¹å…¶æ±‚å€¼ï¼›å¦‚æœæˆ‘ä»¬åœ¨å£°æ˜å˜é‡ä¹‹å‰ä½¿ç”¨å®ƒï¼Œæ˜¯ä¸€ä¸ªé™æ€é”™è¯¯ï¼Œé‚£ä¹ˆå®šä¹‰é€’å½’å‡½æ•°ï¼Œå°±ä¼šå˜å¾—æ›´åŠ å›°éš¾ã€‚</p>
<p>We could accommodate single recursionâ€”a function that calls itselfâ€”by declaring the functionâ€™s own name before we examine its body. But that doesnâ€™t help with mutually recursive procedures that call each other. Consider:</p>
<p>æˆ‘ä»¬å¯ä»¥å®¹çº³å•ä¸ªé€’å½’ï¼Œå³åœ¨æ£€æŸ¥å‡½æ•°ä½“ä¹‹å‰ï¼Œå£°æ˜å‡½æ•°è‡ªèº«çš„åç§°ï¼Œæ¥è°ƒç”¨è‡ªèº«çš„å‡½æ•°ï¼Œä½†è¿™å¯¹ç›¸äº’è°ƒç”¨çš„é€’å½’è¿‡ç¨‹æ²¡æœ‰å¸®åŠ©ï¼Œä¾‹å¦‚:</p>
<pre><code class="language-java">
fun isOdd(n) {
  if (n == 0) return false;
  return isEven(n - 1);
}

fun isEven(n) {
  if (n == 0) return true;
  return isOdd(n - 1);
}


</code></pre>
<p>The isEven() function isnâ€™t defined by the time we are looking at the body of isOdd() where itâ€™s called. If we swap the order of the two functions, then isOdd() isnâ€™t defined when weâ€™re looking at isEven()â€™s body.</p>
<p>isEven() å‡½æ•°åœ¨isOdd() è¿è¡Œåˆ°å¯¹åº”ä»£ç æ—¶å€™ï¼Œè¿˜æ²¡å®šä¹‰ï¼Œå¦‚æœæˆ‘ä»¬äº¤æ¢è¿™ä¸¤ä¸ªå‡½æ•°çš„ä½ç½®ï¼Œé‚£ä¹ˆï¼Œå½“æˆ‘ä»¬è¿è¡Œ isEven() å‡½æ•°åˆ°isOdd() å‡½æ•°æ—¶å€™ï¼ŒisOdd() å‡½æ•°åŒæ ·æ²¡æœ‰å®šä¹‰ã€‚</p>
<blockquote>
<p>Granted, this is probably not the most efficient way to tell if a number is even or odd (not to mention the bad things that happen if you pass a non-integer or negative number to them). Bear with me.</p>
<p>å½“ç„¶ï¼Œä¸Šé¢çš„æ–¹æ³•ä¸æ˜¯åˆ¤æ–­ä¸€ä¸ªæ•°å­—å¥‡å¶æ€§çš„æœ€æœ‰æ•ˆçš„æ–¹æ³•ï¼Œï¼ˆæ›´ä¸ç”¨è¯´ï¼Œå¦‚æœæˆ‘ä»¬ä¼ é€’ä¸€ä¸ªéæ•´æ•°æˆ–è€…è´Ÿæ•°ä¼šå‘ç”Ÿä»€ä¹ˆï¼‰ï¼Œå…ˆå¿å—è¿™ä¸ªä»£ç å§</p>
<p>Some statically typed languages like Java and C# solve this by specifying that the top level of a program isnâ€™t a sequence of imperative statements. Instead, a program is a set of declarations which all come into being simultaneously. The implementation declares all of the names before looking at the bodies of any of the functions.</p>
<p>ä¸€äº›é™æ€è¯­è¨€ï¼ˆä¾‹å¦‚: Java, C#) ,é€šè¿‡æŒ‡å®šç¨‹åºçš„é¡¶å±‚ä¸æ˜¯å‘½ä»¤è¯­å¥åºåˆ—æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œç›¸åçš„ï¼Œé¡¶å±‚çš„ç¨‹åºæ˜¯ä¸€ç»„åŒæ—¶å‡ºç°çš„å£°æ˜ï¼Œåœ¨æŸ¥çœ‹ä»»ä½•å‡½æ•°ä¸»ä½“ä¹‹å‰ï¼Œå…ˆå£°æ˜æ‰€æœ‰å‡½æ•°åç§°ã€‚</p>
<p>Older languages like C and Pascal donâ€™t work like this. Instead, they force you to add explicit forward declarations to declare a name before itâ€™s fully defined. That was a concession to the limited computing power at the time. They wanted to be able to compile a source file in one single pass through the text, so those compilers couldnâ€™t gather up all of the declarations first before processing function bodies.</p>
<p>åƒæ˜¯ C/Pascal è¿™æ ·çš„è¯­è¨€æ— æ³•è¿™æ ·å·¥ä½œï¼Œç›¸åï¼Œå®ƒä¼šè¦æ±‚ä½¿ç”¨è€…ï¼Œæ·»åŠ æ˜¾å¼çš„å£°æ˜ï¼Œåœ¨å®Œå…¨å®šä¹‰ä¹‹å‰ã€‚è¿™æ˜¯å¯¹å½“æ—¶ï¼Œæœ‰é™çš„è®¡ç®—èƒ½åŠ›çš„å¦¥åã€‚å®ƒä»¬å¸Œæœ›èƒ½å¤Ÿåœ¨æ–‡æœ¬çš„ä¸€æ¬¡ä¼ é€’ä¸­ç¼–è¯‘ä¸€ä¸ªæºæ–‡ä»¶ï¼Œå› æ­¤è¿™äº›ç¼–è¯‘å™¨ï¼Œæ— æ³•åœ¨å¤„ç†å‡½æ•°ä½“ä¹‹å‰ï¼Œæ”¶é›†åˆ°æ‰€æœ‰å£°æ˜ã€‚</p>
</blockquote>
<p>Since making it a static error makes recursive declarations too difficult, weâ€™ll defer the error to runtime. Itâ€™s OK to refer to a variable before itâ€™s defined as long as you donâ€™t evaluate the reference. That lets the program for even and odd numbers work, but youâ€™d get a runtime error in:</p>
<p>ç”±äºå°†å…¶è®¾ç½®ä¸ºé™æ€è¯­æ³•é”™è¯¯ï¼Œä¼šä½¿å¾—é€’å½’å‡½æ•°çš„å®šä¹‰éå¸¸å›°éš¾ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å°†é”™è¯¯å»¶è¿Ÿåˆ°è¿è¡Œæ—¶ï¼Œåªè¦ä¸è®¡ç®—å¼•ç”¨ï¼Œåœ¨å®šä¹‰å˜é‡ä¹‹å‰ï¼Œå¼•ç”¨å˜é‡æ˜¯å…è®¸çš„ï¼Œè¿™ä½¿å¾—ä¸Šé¢çš„åˆ¤æ–­æ•°å­—å¥‡å¶æ€§æ–¹æ³•å¯ä»¥è¿è¡Œã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å°†å¾—åˆ°ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ï¼Œå¦‚æœ:</p>
<pre><code class="language-java">
print a;
var a = &quot;too late!&quot;;

</code></pre>
<p>As with type errors in the expression evaluation code, we report a runtime error by throwing an exception. The exception contains the variableâ€™s token so we can tell the user where in their code they messed up.</p>
<p>ä¸è¡¨è¾¾å¼æ±‚å€¼ä»£ç ä¸­çš„ç±»å‹é”™è¯¯ä¸€æ ·ï¼Œæˆ‘ä»¬é€šè¿‡æŠ›å‡ºå¼‚å¸¸æ¥æŠ¥å‘Šè¿è¡Œé”™è¯¯ï¼Œå¼‚å¸¸åŒ…å«äº†å˜é‡çš„tokenï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å‘Šè¯‰ç”¨æˆ·ä»–ä»¬åœ¨ä»£ç å“ªé‡Œå‡ºé”™äº†</p>
<h3 id="31-interpreting-global-variables"><a class="header" href="#31-interpreting-global-variables">3.1 Interpreting global variables</a></h3>
<p>è§£é‡Šå…¨å±€å˜é‡</p>
<p>The Interpreter class gets an instance of the new Environment class.</p>
<p>è§£é‡Šå™¨ç±»å‹ï¼Œè·å–ä¸€ä¸ªæ–°çš„Envç±»å®ä¾‹</p>
<pre><code class="language-java">
// lox/Interpreter.java, in class Interpreter

class Interpreter implements Expr.Visitor&lt;Object&gt;,
                             Stmt.Visitor&lt;Void&gt; {
  private Environment environment = new Environment();

  void interpret(List&lt;Stmt&gt; statements) {


</code></pre>
<p>We store it as a field directly in Interpreter so that the variables stay in memory as long as the interpreter is still running.</p>
<p>æˆ‘ä»¬åœ¨è§£æå™¨ä¸­ï¼ŒæŠŠè¿™ä¸ªå®ä¾‹ä½œä¸ºå­—æ®µï¼Œç›´æ¥å­˜å‚¨èµ·æ¥ï¼Œè¿™æ ·ï¼Œåªè¦è§£é‡Šå™¨ä»ç„¶åœ¨è¿è¡Œï¼Œå˜é‡å°±å¯ä»¥ç•™åœ¨å†…å­˜ä¸­ã€‚</p>
<p>We have two new syntax trees, so thatâ€™s two new visit methods. The first is for declaration statements.</p>
<p>æˆ‘ä»¬æœ‰ä¸¤ä¸ªæ–°çš„è¯­æ³•æ ‘ï¼Œè¿™ä¸¤ä¸ªæ–°çš„è®¿é—®æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªæ˜¯å£°æ˜è¯­å¥ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitPrintStmt()

  @Override
  public Void visitVarStmt(Stmt.Var stmt) {
    Object value = null;
    if (stmt.initializer != null) {
      value = evaluate(stmt.initializer);
    }

    environment.define(stmt.name.lexeme, value);
    return null;
  }

</code></pre>
<p>If the variable has an initializer, we evaluate it. If not, we have another choice to make. We could have made this a syntax error in the parser by requiring an initializer. Most languages donâ€™t, though, so it feels a little harsh to do so in Lox.</p>
<p>We could make it a runtime error. Weâ€™d let you define an uninitialized variable, but if you accessed it before assigning to it, a runtime error would occur. Itâ€™s not a bad idea, but most dynamically typed languages donâ€™t do that. Instead, weâ€™ll keep it simple and say that Lox sets a variable to nil if it isnâ€™t explicitly initialized.</p>
<p>å¦‚æœå˜é‡æœ‰ä¸€ä¸ªåˆå§‹å€¼ï¼Œæˆ‘ä»¬å°±å¯¹å…¶æ±‚å€¼ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹å€¼ï¼Œæˆ‘ä»¬è¿˜æœ‰ä¸€ä¸ªé€‰æ‹©ï¼Œå¯èƒ½éœ€è¦ä¸€ä¸ªåˆå§‹å€¼è®¾å®šé¡¹ï¼Œä»è€Œä½¿è¿™æˆä¸ºè§£é‡Šå™¨ä¸­çš„è¯­æ³•é”™è¯¯ï¼Œç„¶è€Œï¼Œå¤§å¤šæ•°è¯­è¨€éƒ½ä¸è¿™æ ·åšï¼Œæ‰€ä»¥ï¼ŒLoxè¿™æ ·åšï¼Œæœ‰äº›è‹›åˆ»ã€‚</p>
<p>æˆ‘ä»¬å¯èƒ½ä¼šè®©å®ƒå˜ä¸ºè¿è¡Œæ—¶é”™è¯¯ï¼Œæˆ‘ä»¬å…è®¸ç”¨æˆ·å®šä¹‰ä¸€ä¸ªæœªåˆå§‹åŒ–çš„å˜é‡ï¼Œä½†æ˜¯ï¼Œå¦‚æœä»£ç åœ¨åˆ†é…å€¼ä¹‹å‰ï¼Œè®¿é—®äº†è¯¥å˜é‡ï¼Œåˆ™ä¼šæŠ¥é”™ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªåä¸»æ„ï¼Œä½†æ˜¯å¤§å¤šæ•°çš„åŠ¨æ€ç±»å‹è¯­è¨€ä¸ä¼šè¿™æ ·åšï¼Œç›¸åï¼Œæˆ‘ä»¬å°†ä¿æŒç®€å•ã€‚å¦‚æœæ²¡æœ‰æ˜¾å¼åˆå§‹åŒ–ï¼Œåˆ™Loxå°†å˜é‡è®¾ç½®ä¸ºnil</p>
<pre><code class="language-java">
var a;
print a; // &quot;nil&quot;.

</code></pre>
<p>Thus, if there isnâ€™t an initializer, we set the value to null, which is the Java representation of Loxâ€™s nil value. Then we tell the environment to bind the variable to that value.</p>
<p>å› æ­¤ï¼Œå¦‚æœæ²¡æœ‰åˆå§‹å€¼è®¾å®šé¡¹ï¼Œæˆ‘ä»¬å°†å€¼è®¾ç½®ä¸ºnullï¼Œè¿™æ˜¯Loxè¯­è¨€ä¸­çš„nilçš„Javaè¡¨ç¤ºï¼Œç„¶åï¼Œæˆ‘ä»¬å°†Envå®ä¾‹ä¸­ï¼Œå¯¹åº”å˜é‡çš„å€¼è®¾ç½®ä¸ºnil</p>
<p>Next, we evaluate a variable expression.</p>
<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è®¡ç®—ä¸€ä¸ªå˜é‡è¡¨è¾¾å¼</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitUnaryExpr()

  @Override
  public Object visitVariableExpr(Expr.Variable expr) {
    return environment.get(expr.name);
  }
  
</code></pre>
<p>This simply forwards to the environment which does the heavy lifting to make sure the variable is defined. With that, weâ€™ve got rudimentary variables working. Try this out:</p>
<p>è¿™åªæ˜¯ç®€å•çš„è½¬å‘åˆ°Envï¼Œenvè¿›è¡Œè®¡ç®—ï¼Œç¡®ä¿å®šä¹‰äº†å˜é‡ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å°±æœ‰äº†åŸºæœ¬çš„å˜é‡ï¼Œ</p>
<pre><code class="language-java">
var a = 1;
var b = 2;
print a + b;

</code></pre>
<p>We canâ€™t reuse code yet, but we can start to build up programs that reuse data.</p>
<p>æˆ‘ä»¬è¿˜ä¸èƒ½å¤ç”¨ä»£ç ï¼Œä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å¼€å§‹æ„å»ºå¤ç”¨æ•°æ®çš„ç¨‹åºã€‚</p>
<h2 id="å››assignment"><a class="header" href="#å››assignment">å››ã€Assignment</a></h2>
<p>èµ‹å€¼</p>
<p>Itâ€™s possible to create a language that has variables but does not let you reassignâ€”or mutateâ€”them. Haskell is one example. SML supports only mutable references and arraysâ€”variables cannot be reassigned. Rust steers you away from mutation by requiring a mut modifier to enable assignment.</p>
<p>Mutating a variable is a side effect and, as the name suggests, some language folks think side effects are dirty or inelegant. Code should be pure math that produces valuesâ€”crystalline, unchanging onesâ€”like an act of divine creation. Not some grubby automaton that beats blobs of data into shape, one imperative grunt at a time.</p>
<p>å¯ä»¥åˆ›å»ºä¸€ç§è¯­è¨€ï¼Œå…·æœ‰å˜é‡ï¼Œä½†æ˜¯ä¸å…è®¸é‡æ–°èµ‹å€¼ï¼Œæˆ–è€…ä¿®æ”¹å˜é‡å€¼ï¼ŒHaskellå°±æ˜¯è¿™æ ·çš„ä¸€é—¨è¯­è¨€ã€‚SMLä»…æ”¯æŒå¯å˜å¼•ç”¨ï¼Œå¹¶ä¸”ä¸èƒ½é‡æ–°èµ‹å€¼æ•°ç»„å˜é‡ã€‚Rusté€šè¿‡ mutä¿®æ”¹å™¨ï¼Œé‡æ–°èµ‹å€¼ï¼Œå¼•å¯¼æˆ‘ä»¬è¿œç¦»çªå˜ã€‚</p>
<p>ä¸€ä¸ªå˜é‡çš„çªå˜æ˜¯ä¸€ä¸ªå‰¯ä½œç”¨ï¼Œæ­£å¦‚åå­—æ‰€æš—ç¤ºçš„ï¼Œä¸€äº›è¯­è¨€å­¦å®¶è®¤ä¸ºå‰¯ä½œç”¨æ˜¯ä¸å¥½çš„ï¼Œä»£ç åº”è¯¥æ˜¯çº¯ç²¹çš„æ•°å­¦ï¼Œå®ƒå¯ä»¥äº§ç”Ÿç»“æ™¶çš„ã€ä¸å˜çš„ä»·å€¼è§‚ï¼Œå°±åƒæ˜¯ç¥åˆ›é€ çš„è¡Œä¸ºä¸€æ ·ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªè‚®è„çš„æœºå™¨äººï¼Œä¸€æ¬¡åªèƒ½å‘å‡ºä¸€å£°å‘½ä»¤æ€§çš„å’•å™œå£°éŸ³ï¼ŒæŠŠä¸€å †å †æ•°æ®æ‰“æˆå½¢çŠ¶ã€‚</p>
<blockquote>
<p>I find it delightful that the same group of people who pride themselves on dispassionate logic are also the ones who canâ€™t resist emotionally loaded terms for their work: â€œpureâ€, â€œside effectâ€, â€œlazyâ€, â€œpersistentâ€, â€œfirst-classâ€, â€œhigher-orderâ€.</p>
<p>æˆ‘è§‰å¾—ä»¤äººå…´å¥‹çš„æ˜¯ï¼ŒåŒæ ·ä¸€ç¾¤ä»¥å†·é™çš„é€»è¾‘ä¸ºè£çš„äººï¼Œä¹Ÿæ— æ³•æŠ—æ‹’ä»–ä»¬å·¥ä½œä¸­å……æ»¡æƒ…æ„Ÿçš„æœ¯è¯­ï¼Œçº¯ç²¹ã€å‰¯ä½œç”¨ã€æ‡’æƒ°ã€æ‰§ç€ã€ä¸€æµã€é«˜é˜¶ã€‚</p>
</blockquote>
<p>Lox is not so austere. Lox is an imperative language, and mutation comes with the territory. Adding support for assignment doesnâ€™t require much work. Global variables already support redefinition, so most of the machinery is there now. Mainly, weâ€™re missing an explicit assignment notation.</p>
<p>Loxå¹¶æ²¡æœ‰é‚£ä¹ˆä¸¥è‚ƒï¼ŒLoxæ˜¯ä¸€ç§å‘½ä»¤å¼è¯­è¨€ï¼Œå¯å˜æ€§ä¼´éšç€ä½œç”¨åŸŸè€Œæ¥ï¼ŒLoxæ”¯æŒèµ‹å€¼ä¸éœ€è¦åšå¾ˆå¤šçš„å·¥ä½œã€‚å…¨å±€å˜é‡å·²ç»æ”¯æŒé‡æ–°å®šä¹‰ï¼Œæ‰€ä»¥ç°åœ¨å¤§å¤šæ•°çš„æœºåˆ¶å·²ç»å­˜åœ¨ï¼Œä¸»è¦é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬ç°åœ¨ç¼ºå°‘ä¸€ä¸ªæ˜ç¡®çš„èµ‹å€¼ç¬¦å·ã€‚</p>
<h3 id="41-assignment-syntax"><a class="header" href="#41-assignment-syntax">4.1 Assignment syntax</a></h3>
<p>èµ‹å€¼è¯­æ³•</p>
<p>That little = syntax is more complex than it might seem. Like most C-derived languages, assignment is an expression and not a statement. As in C, it is the lowest precedence expression form. That means the rule slots between expression and equality (the next lowest precedence expression).</p>
<p>= ç¬¦å·çš„è¯­æ³•æ¯”çœ‹èµ·æ¥æ›´åŠ å¤æ‚ï¼Œä¸å¤§å¤šæ•°çš„Cæ´¾ç”Ÿè¯­è¨€ä¸€æ ·ï¼Œèµ‹å€¼æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼è€Œä¸æ˜¯ä¸€ä¸ªè¯­å¥ï¼Œå’ŒCä¸­ä¸€æ ·ï¼Œå®ƒæ˜¯æœ€ä½ä¼˜å…ˆçº§çš„è¡¨è¾¾å¼å½¢å¼ï¼Œè¿™æ„å‘³ç€è§„åˆ™ä»‹äºè¡¨è¾¾å¼å’Œç›¸ç­‰ä¹‹é—´ã€‚</p>
<blockquote>
<p>In some other languages, like Pascal, Python, and Go, assignment is a statement.</p>
<p>åœ¨ä¸€äº›å…¶ä»–è¯­è¨€ä¸­ï¼Œåƒæ˜¯ Pascal, Python, Go, èµ‹å€¼æ˜¯ä¸€ä¸ªè¯­å¥</p>
</blockquote>
<pre><code class="language-java">
expression     â†’ assignment ;
assignment     â†’ IDENTIFIER &quot;=&quot; assignment
               | equality ;

</code></pre>
<p>This says an assignment is either an identifier followed by an = and an expression for the value, or an equality (and thus any other) expression. Later, assignment will get more complex when we add property setters on objects, like:</p>
<p>ä¸Šé¢çš„è¯­æ³•è§„åˆ™æ„å‘³ç€ï¼Œèµ‹å€¼è¡¨è¾¾å¼æ˜¯ ä¸€ä¸ªæ ‡è¯†ç¬¦è·Ÿéšè€…ä¸€ä¸ª= ç¬¦å· å’Œä¸€ä¸ªå€¼è¡¨è¾¾å¼ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªç­‰å¼è¡¨è¾¾å¼ï¼Œç¨åï¼Œæˆ‘ä»¬åœ¨å¯¹è±¡ä¸Šï¼Œæ·»åŠ å±æ€§è®¾ç½®ï¼Œèµ‹å€¼å°†å˜å¾—æ›´åŠ å¤æ‚ï¼Œä¾‹å¦‚ï¼š</p>
<pre><code class="language-java">
instance.field = &quot;value&quot;;

</code></pre>
<p>The easy part is adding the new syntax tree node.</p>
<p>æœ€ç®€å•çš„æ–¹å¼æ˜¯ï¼Œæ·»åŠ æ–°çš„è¯­æ³•æ ‘èŠ‚ç‚¹ã€‚</p>
<pre><code>
// tool/GenerateAst.java, in main()

 defineAst(outputDir, &quot;Expr&quot;, Arrays.asList(
      &quot;Assign   : Token name, Expr value&quot;,
      &quot;Binary   : Expr left, Token operator, Expr right&quot;,
	  
</code></pre>
<p>It has a token for the variable being assigned to, and an expression for the new value. After you run the AstGenerator to get the new Expr.Assign class, swap out the body of the parserâ€™s existing expression() method to match the updated rule.</p>
<p>å®ƒæœ‰ä¸€ä¸ªè¢«èµ‹å€¼å˜é‡çš„tokenï¼Œå’Œä¸€ä¸ªæ–°å€¼çš„è¡¨è¾¾å¼ï¼Œåœ¨æˆ‘ä»¬è¿è¡ŒAstGeneratoråï¼Œå°†ä¼šå¾—åˆ°ä¸€ä¸ªæ–°çš„Expr.Assign ç±»ï¼Œäº¤æ¢è§£æå™¨ç°æœ‰expression() æ–¹æ³•ï¼ŒåŒ¹é…æ›´æ–°åçš„è§„åˆ™ã€‚</p>
<pre><code class="language-java">
// lox/Parser.java, in expression(), replace 1 line

 private Expr expression() {
    return assignment();
  }


</code></pre>
<p>Here is where it gets tricky. A single token lookahead recursive descent parser canâ€™t see far enough to tell that itâ€™s parsing an assignment until after it has gone through the left-hand side and stumbled onto the =. You might wonder why it even needs to. After all, we donâ€™t know weâ€™re parsing a + expression until after weâ€™ve finished parsing the left operand.</p>
<p>The difference is that the left-hand side of an assignment isnâ€™t an expression that evaluates to a value. Itâ€™s a sort of pseudo-expression that evaluates to a â€œthingâ€ you can assign to. Consider:</p>
<p>è¿™å°±æ˜¯æ£˜æ‰‹çš„åœ°æ–¹ï¼Œä¸€ä¸ªå•ä¸€çš„tokenï¼Œå‰ç»é€’å½’ä¸‹é™è§£æå™¨çœ‹ä¸åˆ°è¶³å¤Ÿè¿œçš„åœ°æ–¹ï¼Œç›´åˆ°å®ƒé€šè¿‡å·¦ä¾§å¹¶ä¸”å¶ç„¶å‘ç°= ç¬¦å·ä¹‹åï¼Œæ‰èƒ½åˆ¤æ–­å‡ºå®ƒæ­£åœ¨è§£æèµ‹å€¼ã€‚ä½ å¯èƒ½æƒ³çŸ¥é“å®ƒä¸ºä»€ä¹ˆéœ€è¦è¿™æ ·åšã€‚æ¯•ç«Ÿï¼Œæˆ‘ä»¬åœ¨åˆ†æè¿‡å·¦æ“ä½œæ•°åï¼Œæ‰èƒ½çŸ¥é“æˆ‘ä»¬æ­£åœ¨è§£æä¸€ä¸ª+ è¡¨è¾¾å¼</p>
<p>ä¸åŒä¹‹å¤„æ˜¯ï¼Œèµ‹å€¼è¡¨è¾¾å¼çš„å·¦ä¾§ï¼Œä¸æ˜¯è®¡ç®—ä¸ºå€¼çš„è¡¨è¾¾å¼ï¼Œè¿™æ˜¯ä¸€ç§ä¼ªè¡¨è¾¾å¼ï¼Œå…¶è®¡ç®—ç»“æœå¯ä»¥æ˜¯èµ‹å€¼è¡¨è¾¾å¼çš„èµ‹å€¼å¯¹è±¡ï¼Œè¯·è€ƒè™‘ï¼š</p>
<pre><code class="language-java">

var a = &quot;before&quot;;
a = &quot;value&quot;;


</code></pre>
<p>On the second line, we donâ€™t evaluate a (which would return the string â€œbeforeâ€). We figure out what variable a refers to so we know where to store the right-hand side expressionâ€™s value. The classic terms for these two constructs are l-value and r-value. All of the expressions that weâ€™ve seen so far that produce values are r-values. An l-value â€œevaluatesâ€ to a storage location that you can assign into.</p>
<p>ä¸Šé¢ä»£ç çš„ç¬¬äºŒè¡Œï¼Œæˆ‘ä»¬ä¸è®¡ç®—a çš„å€¼ï¼ˆæ­¤æ—¶ï¼Œaå˜é‡å°†ä¼šè¿”å›å­—ç¬¦ä¸² before), æˆ‘ä»¬å¼„æ¸…æ¥šå˜é‡a æ‰€æŒ‡çš„æ˜¯ä»€ä¹ˆï¼Œè¿™æ ·æˆ‘ä»¬å°±çŸ¥é“åœ¨å“ªé‡Œï¼Œå­˜å‚¨å³ä¾§è¡¨è¾¾å¼çš„å€¼ã€‚è¿™ä¸¤ä¸ªæ„é€ çš„ç»å…¸æœ¯è¯­æ˜¯ï¼Œå·¦å€¼å’Œå³å€¼ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬é‡åˆ°çš„æ‰€æœ‰äº§ç”Ÿå€¼çš„è¡¨è¾¾å¼éƒ½æ˜¯å³å€¼ï¼Œå·¦å€¼çš„æ±‚å€¼ï¼Œæ˜¯å¯ä»¥å­˜å‚¨å³å€¼çš„ä½ç½®ã€‚</p>
<blockquote>
<p>In fact, the names come from assignment expressions: l-values appear on the left side of the = in an assignment, and r-values on the right.</p>
<p>äº‹å®ä¸Šï¼Œè¿™äº›åç§°æ¥è‡ªèµ‹å€¼è¡¨è¾¾å¼ï¼Œåœ¨èµ‹å€¼è¡¨è¾¾å¼ä¸­ï¼Œå·¦å€¼å‡ºç°åœ¨å·¦ä¾§ï¼Œå³å€¼å‡ºç°åœ¨å³ä¾§ã€‚</p>
</blockquote>
<p>We want the syntax tree to reflect that an l-value isnâ€™t evaluated like a normal expression. Thatâ€™s why the Expr.Assign node has a Token for the left-hand side, not an Expr. The problem is that the parser doesnâ€™t know itâ€™s parsing an l-value until it hits the =. In a complex l-value, that may occur many tokens later.</p>
<p>æˆ‘ä»¬å¸Œæœ›è¯­æ³•æ ‘ååº”çš„å·¦å€¼ä¸åƒæ˜¯æ™®é€šè¡¨è¾¾å¼é‚£æ ·çš„æ±‚å€¼ï¼Œè¿™å°±æ˜¯ Expr.Assign èŠ‚ç‚¹åœ¨å·¦ä¾§æœ‰ä¸€ä¸ªtokenï¼Œè€Œä¸æ˜¯ Exprï¼Œé—®é¢˜æ˜¯ï¼Œè§£æå™¨åœ¨è§£æåˆ° = ç¬¦å·ä¹‹å‰ï¼Œä¸çŸ¥é“å®ƒæ­£åœ¨è§£æå·¦å€¼ï¼Œåœ¨å¤æ‚çš„å·¦å€¼åœºæ™¯ï¼Œè¿™å¯èƒ½ä¼šåœ¨ä»¥åçš„è®¸å¤štokenä¸­å‡ºç°ã€‚</p>
<pre><code class="language-java">
makeList().head.next = node;

</code></pre>
<blockquote>
<p>Since the receiver of a field assignment can be any expression, and expressions can be as long as you want to make them, it may take an unbounded number of tokens of lookahead to find the =.</p>
<p>ç”±äºå­—æ®µèµ‹å€¼çš„æ¥æ”¶è€…å¯ä»¥æ˜¯ä»»ä½•è¡¨è¾¾å¼ï¼Œå¹¶ä¸”è¡¨è¾¾å¼å¯ä»¥æ˜¯ä»»æ„é•¿åº¦ï¼Œå› æ­¤å¯èƒ½éœ€è¦æ— é™æ•°é‡çš„ tokenåï¼Œæ‰èƒ½å‘ç° = ç¬¦å·</p>
</blockquote>
<p>We have only a single token of lookahead, so what do we do? We use a little trick, and it looks like this:</p>
<p>æˆ‘ä»¬åªæœ‰ä¸€ä¸ªå‰ç»æ€§çš„ tokenï¼Œé‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•å®ç°å‘¢ï¼Œè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªå°æŠ€å·§ï¼Œçœ‹èµ·æ¥åƒè¿™æ ·</p>
<pre><code class="language-java">
// lox/Parser.java, add after expressionStatement()

  private Expr assignment() {
    Expr expr = equality();

    if (match(EQUAL)) {
      Token equals = previous();
      Expr value = assignment();

      if (expr instanceof Expr.Variable) {
        Token name = ((Expr.Variable)expr).name;
        return new Expr.Assign(name, value);
      }

      error(equals, &quot;Invalid assignment target.&quot;); 
    }

    return expr;
  }
  
</code></pre>
<p>Most of the code for parsing an assignment expression looks similar to that of the other binary operators like +. We parse the left-hand side, which can be any expression of higher precedence. If we find an =, we parse the right-hand side and then wrap it all up in an assignment expression tree node.</p>
<p>ç”¨äºè§£æèµ‹å€¼è¡¨è¾¾å¼çš„ä»£ç  çœ‹èµ·æ¥å’Œå¤§éƒ¨åˆ†è§£æäºŒå…ƒè¿ç®—ç¬¦çš„ä»£ç ç›¸ä¼¼ï¼Œæˆ‘ä»¬è§£æå·¦ä¾§ï¼Œå®ƒå¯ä»¥æ˜¯ä»»ä½•ä¼˜å…ˆçº§æ›´é«˜çš„è¡¨è¾¾å¼ï¼Œå¦‚æœæ‰¾åˆ° = ï¼Œæˆ‘ä»¬è§£æå³ä¾§ï¼Œç„¶åå°†å…¶å…¨éƒ¨åŒ…è£…åœ¨èµ‹å€¼è¡¨è¾¾å¼æ ‘èŠ‚ç‚¹ä¸­ã€‚</p>
<blockquote>
<p>We report an error if the left-hand side isnâ€™t a valid assignment target, but we donâ€™t throw it because the parser isnâ€™t in a confused state where we need to go into panic mode and synchronize.</p>
<p>å¦‚æœå·¦ä¾§ä¸æ˜¯æœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡ï¼Œæˆ‘ä»¬ä¼šäº§ç”Ÿä¸€ä¸ªé”™è¯¯ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸ä¼šæŠ›å‡ºé”™è¯¯ï¼Œå› æ­¤è§£æå™¨æ²¡æœ‰å¤„äºæ··ä¹±çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦è¿›å…¥ç´§æ€¥æ¨¡å¼å¹¶è¿›è¡ŒåŒæ­¥ã€‚</p>
</blockquote>
<p>One slight difference from binary operators is that we donâ€™t loop to build up a sequence of the same operator. Since assignment is right-associative, we instead recursively call assignment() to parse the right-hand side.</p>
<p>The trick is that right before we create the assignment expression node, we look at the left-hand side expression and figure out what kind of assignment target it is. We convert the r-value expression node into an l-value representation.</p>
<p>ä¸äºŒè¿›åˆ¶è¿ç®—ç¬¦çš„ä¸€ä¸ªç»†å¾®åŒºåˆ«æ˜¯ï¼Œæˆ‘ä»¬ä¸éœ€è¦å¾ªç¯æ¥æ„å»ºåŒä¸€ä¸ªè¿ç®—ç¬¦çš„åºåˆ—ï¼Œç”±äºèµ‹å€¼æ˜¯å³å…³è”çš„ï¼Œå› æ­¤æˆ‘ä»¬ä¼šé€’å½’è°ƒç”¨ assign() æ¥è§£æå³ä¾§ã€‚</p>
<p>æŠ€å·§æ˜¯ï¼Œåœ¨åˆ›å»ºèµ‹å€¼è¡¨è¾¾å¼èŠ‚ç‚¹å‰ï¼Œæˆ‘ä»¬æŸ¥çœ‹å·¦ä¾§çš„è¡¨è¾¾å¼ï¼Œæ‰¾å‡ºå®ƒæ˜¯ä»€ä¹ˆç±»å‹çš„èµ‹å€¼ç›®æ ‡ï¼Œæˆ‘ä»¬å°†å³å€¼è¡¨è¾¾å¼èŠ‚ç‚¹ï¼Œè½¬æ¢ä¸ºå·¦å€¼è¡¨ç¤ºã€‚</p>
<p>This conversion works because it turns out that every valid assignment target happens to also be valid syntax as a normal expression. Consider a complex field assignment like:</p>
<p>è¿™ç§è½¬æ¢ä¹‹æ‰€ä»¥æœ‰æ•ˆï¼Œæ˜¯å› ä¸ºå®ƒè¯æ˜äº†æ¯ä¸€ä¸ªæœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡éƒ½æ˜¯ä½œä¸ºæ™®é€šè¡¨è¾¾å¼çš„æœ‰æ•ˆè¯­æ³•ï¼Œè€ƒè™‘ä¸€ä¸ªå¤æ‚çš„å­—æ®µèµ‹å€¼ï¼Œä¾‹å¦‚ï¼š</p>
<pre><code>
newPoint(x + 2, 0).y = 3;

</code></pre>
<p>The left-hand side of that assignment could also work as a valid expression.</p>
<p>ä¸Šé¢çš„èµ‹å€¼è¡¨è¾¾å¼çš„å·¦ä¾§ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„è¡¨è¾¾å¼</p>
<pre><code>newPoint(x + 2, 0).y;

</code></pre>
<p>The first example sets the field, the second gets it.</p>
<p>ç¬¬ä¸€ä¸ªç¤ºä¾‹ï¼Œè®¾ç½®å­—æ®µå€¼ï¼Œç¬¬äºŒä¸ªç¤ºä¾‹è·å–å­—æ®µå€¼</p>
<p>This means we can parse the left-hand side as if it were an expression and then after the fact produce a syntax tree that turns it into an assignment target. If the left-hand side expression isnâ€™t a valid assignment target, we fail with a syntax error. That ensures we report an error on code like this:</p>
<p>è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åƒè§£æè¡¨è¾¾å¼ä¸€æ ·ï¼Œè§£æå·¦å€¼ï¼Œç„¶ååœ¨äº‹å®å‘ç”Ÿåï¼Œç”Ÿæˆä¸€ä¸ªè¯­æ³•æ ‘ï¼Œå°†å…¶è½¬æ¢ä¸ºèµ‹å€¼ç›®æ ‡ï¼Œå¦‚æœå·¦ä¾§çš„è¡¨è¾¾å¼ä¸æ˜¯æœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡ï¼Œæˆ‘ä»¬å°†æŠ¥é”™ï¼Œäº§ç”Ÿè¯­æ³•é”™è¯¯ï¼Œè¿™æ ·ï¼Œç¡®ä¿äº†å¦‚ä¸‹ä»£ç ä¼šæŠ¥é”™</p>
<pre><code>
a + b = c;

</code></pre>
<p>Right now, the only valid target is a simple variable expression, but weâ€™ll add fields later. The end result of this trick is an assignment expression tree node that knows what it is assigning to and has an expression subtree for the value being assigned. All with only a single token of lookahead and no backtracking.</p>
<p>ç°åœ¨ï¼Œå”¯ä¸€æœ‰æ•ˆçš„ç›®æ ‡æ˜¯ä¸€ä¸ªç®€å•çš„å˜é‡è¡¨è¾¾å¼ï¼Œä½†æ˜¯æˆ‘ä»¬ç¨åå°†æ·»åŠ å­—æ®µï¼Œè¿™ä¸ªæŠ€å·§çš„æœ€ç»ˆç»“æœæ˜¯ä¸€ä¸ªèµ‹å€¼è¡¨è¾¾å¼æ ‘èŠ‚ç‚¹ï¼Œå®ƒçŸ¥é“è¦èµ‹å€¼çš„å¯¹è±¡ï¼Œå¹¶ä¸”æœ‰ä¸€ä¸ªèµ‹å€¼çš„è¡¨è¾¾å¼å­æ ‘ï¼Œæ‰€æœ‰è¿™äº›éƒ½æ˜¯ä¸€ä¸ªå‰ç»tokenï¼Œæ²¡æœ‰å›æº¯</p>
<blockquote>
<p>You can still use this trick even if there are assignment targets that are not valid expressions. Define a cover grammar, a looser grammar that accepts all of the valid expression and assignment target syntaxes. When you hit an =, report an error if the left-hand side isnâ€™t within the valid assignment target grammar. Conversely, if you donâ€™t hit an =, report an error if the left-hand side isnâ€™t a valid expression.</p>
<p>å³ä½¿å­˜åœ¨æ— æ•ˆè¡¨è¾¾å¼çš„èµ‹å€¼ç›®æ ‡ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ­¤æŠ€å·§ï¼Œå®šä¹‰ä¸€ä¸ªè¦†ç›–è¯­æ³•ï¼Œä¸€ä¸ªæ¥å—æ‰€æœ‰æœ‰æ•ˆè¡¨è¾¾å¼å’Œèµ‹å€¼ç›®æ ‡è¯­æ³•çš„è¾ƒå®½æ¾çš„è¯­æ³•ï¼Œå½“æˆ‘ä»¬é‡åˆ° = æ—¶å€™ï¼Œå¦‚æœå·¦ä¾§ä¸æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„èµ‹å€¼ç›®æ ‡æ—¶å€™ï¼Œåˆ™æŠ¥å‘Šé”™è¯¯ï¼Œç›¸åï¼Œå¦‚æœæ²¡æœ‰é‡åˆ° = ï¼Œ å·¦ä¾§ä¸æ˜¯æœ‰æ•ˆçš„è¡¨è¾¾å¼ï¼Œåˆ™æŠ¥é”™é”™è¯¯</p>
</blockquote>
<blockquote>
<p>Way back in the parsing chapter, I said we represent parenthesized expressions in the syntax tree because weâ€™ll need them later. This is why. We need to be able to distinguish these cases:</p>
<p>åœ¨è§£æé‚£ä¸€ç« ï¼Œè¯´è¿‡åœ¨è¯­æ³•æ ‘ä¸­è¡¨ç¤ºå¸¦æ‹¬å·çš„è¡¨è¾¾å¼ï¼Œå› ä¸ºæˆ‘ä»¬ç¨åä¼šéœ€è¦å®ƒï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆï¼Œæˆ‘ä»¬éœ€è¦èƒ½å¤ŸåŒºåˆ†è¿™äº›æƒ…å†µ</p>
<p>a = 3; // ok</p>
<p>(a) = 3; // error</p>
</blockquote>
<h3 id="42--assignment-semantics"><a class="header" href="#42--assignment-semantics">4.2  Assignment semantics</a></h3>
<p>We have a new syntax tree node, so our interpreter gets a new visit method.</p>
<p>æˆ‘ä»¬æœ‰ä¸€ä¸ªæ–°çš„è¯­æ³•æ ‘èŠ‚ç‚¹ï¼Œæ‰€ä»¥æˆ‘ä»¬çš„è§£é‡Šå™¨æœ‰ä¸€ä¸ªæ–°çš„è®¿é—®æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after visitVarStmt()

  @Override
  public Object visitAssignExpr(Expr.Assign expr) {
    Object value = evaluate(expr.value);
    environment.assign(expr.name, value);
    return value;
  }
  
</code></pre>
<p>For obvious reasons, itâ€™s similar to variable declaration. It evaluates the right-hand side to get the value, then stores it in the named variable. Instead of using define() on Environment, it calls this new method:</p>
<p>ç”±äºæ˜æ˜¾çš„åŸå› ï¼Œå®ƒç±»ä¼¼äºå˜é‡çš„å£°æ˜ï¼Œå®ƒè®¡ç®—å³ä¾§çš„å€¼ï¼Œç„¶åå°†å…¶å­˜å‚¨åœ¨å‘½åå˜é‡ä¸­ï¼Œå®ƒä¸æ˜¯åœ¨environmentä¸Šä½¿ç”¨define() æ–¹æ³•ï¼Œè€Œæ˜¯è°ƒç”¨æ–°çš„æ–¹æ³•</p>
<pre><code class="language-java">
// lox/Environment.java, add after get()

  void assign(Token name, Object value) {
    if (values.containsKey(name.lexeme)) {
      values.put(name.lexeme, value);
      return;
    }

    throw new RuntimeError(name,
        &quot;Undefined variable '&quot; + name.lexeme + &quot;'.&quot;);
  }
  
</code></pre>
<p>The key difference between assignment and definition is that assignment is not allowed to create a new variable. In terms of our implementation, that means itâ€™s a runtime error if the key doesnâ€™t already exist in the environmentâ€™s variable map.</p>
<p>èµ‹å€¼å’Œå®šä¹‰ä¹‹é—´çš„å…³é”®åŒºåˆ«æ˜¯ï¼Œä¸å…è®¸èµ‹å€¼åˆ›å»ºæ–°å˜é‡ï¼Œå°±æˆ‘ä»¬çš„å®ç°è€Œè¨€ï¼Œè¿™æ„å‘³ç€å¦‚æœ environment çš„values ä¸­å¦‚æœä¸å­˜åœ¨é”®ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯ã€‚</p>
<p>The last thing the visit() method does is return the assigned value. Thatâ€™s because assignment is an expression that can be nested inside other expressions, like so:</p>
<p>visit() æ–¹æ³•æ‰€åšçš„æœ€åä¸€ä»¶äº‹æƒ…æ˜¯è¿”å›æŒ‡å®šçš„å€¼ï¼Œè¿™æ˜¯å› ä¸ºèµ‹å€¼æ˜¯ä¸€ä¸ªå¯ä»¥åµŒå¥—åœ¨å…¶ä»–è¡¨è¾¾å¼ä¸­çš„è¡¨è¾¾å¼ï¼Œå¦‚ä¸‹æ‰€ç¤º:</p>
<pre><code class="language-java">
var a = 1;
print a = 2; // &quot;2&quot;.

</code></pre>
<p>Our interpreter can now create, read, and modify variables. Itâ€™s about as sophisticated as early BASICs. Global variables are simple, but writing a large program when any two chunks of code can accidentally step on each otherâ€™s state is no fun. We want local variables, which means itâ€™s time for scope.</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨ï¼Œç°åœ¨å¯ä»¥åˆ›å»ºã€è¯»å–ã€ä¿®æ”¹å˜é‡ï¼Œå®ƒå’Œæ—©æœŸçš„BASICä¸€æ ·å¤æ‚ï¼Œå…¨å±€å˜é‡å¾ˆç®€å•ï¼Œä½†æ˜¯å½“ä»»æ„ä¸¤ä¸ªä»£ç å—å¯èƒ½æ„å¤–çš„è·å–åˆ°å½¼æ­¤çš„çŠ¶æ€æ—¶å€™ï¼Œç¼–å†™ä¸€ä¸ªå¤§å‹ç¨‹åºå¹¶ä¸æœ‰è¶£ã€‚æˆ‘ä»¬éœ€è¦å±€éƒ¨å˜é‡ï¼Œè¿™æ„å‘³ç€ç°åœ¨æ˜¯æˆ‘ä»¬è¿›å…¥åˆ°ä½œç”¨åŸŸçš„æ—¶å€™äº†ã€‚</p>
<blockquote>
<p>Unlike Python and Ruby, Lox doesnâ€™t do implicit variable declaration.</p>
<p>å’ŒPython,Rubyä¸ä¸€æ ·ï¼ŒLoxä¸åšéšå¼å˜é‡å£°æ˜</p>
<p>Maybe a little better than that. Unlike some old BASICs, Lox can handle variable names longer than two characters.</p>
<p>ä¹Ÿè®¸æ¯”BASICå¥½ä¸€äº›ï¼Œä¸ä¸€äº›æ—§çš„BASICä¸åŒï¼ŒLoxå¯ä»¥å¤„ç†é•¿åº¦è¶…è¿‡ä¸¤ä¸ªå­—ç¬¦çš„å˜é‡å</p>
</blockquote>
<h2 id="äº”scope"><a class="header" href="#äº”scope">äº”ã€Scope</a></h2>
<p>ä½œç”¨åŸŸ</p>
<p>A scope defines a region where a name maps to a certain entity. Multiple scopes enable the same name to refer to different things in different contexts. In my house, â€œBobâ€ usually refers to me. But maybe in your town you know a different Bob. Same name, but different dudes based on where you say it.</p>
<p>Lexical scope (or the less commonly heard static scope) is a specific style of scoping where the text of the program itself shows where a scope begins and ends. In Lox, as in most modern languages, variables are lexically scoped. When you see an expression that uses some variable, you can figure out which variable declaration it refers to just by statically reading the code.</p>
<p>ä¸€ä¸ªä½œç”¨åŸŸå®šä¹‰äº†ä¸€ä¸ªåŒºåŸŸï¼Œå…¶ä¸­åŒ…å«åç§°æ˜ å°„åˆ°ç‰¹å®šå®ä½“ã€‚å¤šä¸ªä½œç”¨åŸŸå¯ä»¥ä½¿å¾—ï¼Œç›¸åŒåç§°çš„å˜é‡å¯ä»¥åœ¨ä¸åŒçš„ä¸Šä¸‹æ–‡ä¸­å¼•ç”¨ä¸åŒçš„äº‹ç‰©ã€‚ä¾‹å¦‚ï¼šåœ¨æˆ‘å®¶ï¼ŒBob é€šå¸¸æŒ‡çš„å°±æ˜¯æˆ‘ï¼Œä½†ä¹Ÿè®¸åœ¨ä½ çš„å®¶ä¹¡ï¼Œä½ è¿˜è®¤è¯†ä¸€ä¸ªä¸åŒçš„Bobï¼Œç›¸åŒçš„åå­—ï¼Œä½†æ˜¯æ ¹æ®ä¸åŒçš„åœ°æ–¹ï¼Œå¯ä»¥æŒ‡ä»£ä¸åŒçš„äººã€‚</p>
<p>è¯æ±‡ä½œç”¨åŸŸï¼ˆæˆ–è€…ä¸å¤ªå¸¸è§çš„é™æ€ä½œç”¨åŸŸï¼‰æ˜¯ä¸€ç§ç‰¹å®šç±»å‹çš„ä½œç”¨åŸŸï¼Œç¨‹åºæ–‡æœ¬æœ¬èº«æ˜¾ç¤ºä½œç”¨åŸŸçš„å¼€å§‹å’Œç»“æŸä½ç½®ã€‚å’Œå¤§å¤šæ•°çš„ç°ä»£è¯­è¨€ä¸€æ ·ï¼Œåœ¨Loxä¸­, å˜é‡çš„ä½œç”¨åŸŸæ˜¯è¯æ±‡çš„ä½œç”¨åŸŸï¼Œå½“æˆ‘ä»¬çœ‹åˆ°ä½¿ç”¨å˜é‡çš„æŸä¸ªè¡¨è¾¾å¼æ—¶å€™ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é™æ€è¯»å–ä»£ç æ¥ç¡®å®šå®ƒå¼•ç”¨çš„æ˜¯å“ªä¸ªå˜é‡ã€‚</p>
<p>For example:</p>
<p>ä¾‹å¦‚: </p>
<pre><code class="language-java">
{
  var a = &quot;first&quot;;
  print a; // &quot;first&quot;.
}

{
  var a = &quot;second&quot;;
  print a; // &quot;second&quot;.
}

</code></pre>
<p>Here, we have two blocks with a variable a declared in each of them. You and I can tell just from looking at the code that the use of a in the first print statement refers to the first a, and the second one refers to the second.</p>
<p>è¿™é‡Œï¼Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªä»£ç å—ï¼Œæ¯ä¸ªå—ä¸­éƒ½å£°æ˜äº†å˜é‡aï¼Œ æˆ‘ä»¬å¯ä»¥ä»ä»£ç ä¸­çœ‹åˆ°ï¼Œç¬¬ä¸€ä¸ªå—ä¸­çš„print æ˜¯æŒ‡firstï¼Œç¬¬äºŒä¸ªå—ä¸­çš„printæ˜¯æŒ‡ second</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/blocks.png?raw=true" alt="blocks" /></p>
<blockquote>
<p>â€œLexicalâ€ comes from the Greek â€œlexikosâ€ which means â€œrelated to wordsâ€. When we use it in programming languages, it usually means a thing you can figure out from source code itself without having to execute anything.</p>
<p>Lexical æ¥è‡ªäºå¸Œè…Šè¯­ Lexikos, æ„æ€æ˜¯ä¸å•è¯æœ‰å…³ï¼Œå½“æˆ‘ä»¬åœ¨ç¼–ç¨‹è¯­è¨€ä¸­ä½¿ç”¨å®ƒæ—¶ï¼Œå®ƒé€šå¸¸æ„å‘³ç€ä½ å¯ä»¥ä»æºä»£ç ä¸­æ‰¾å‡ºï¼Œè€Œä¸å¿…æ‰§è¡Œä»»ä½•ä¸œè¥¿ã€‚</p>
<p>Lexical scope came onto the scene with ALGOL. Earlier languages were often dynamically scoped. Computer scientists back then believed dynamic scope was faster to execute. Today, thanks to early Scheme hackers, we know that isnâ€™t true. If anything, itâ€™s the opposite.</p>
<p>ALGOL è¯­è¨€ä¸­å‡ºç°äº†è¯æ±‡ä½œç”¨åŸŸæ¦‚å¿µï¼Œæ—©æœŸçš„è¯­è¨€ï¼Œé€šå¸¸æ˜¯åŠ¨æ€èŒƒå›´çš„ï¼Œå½“æ—¶çš„ç§‘å­¦å®¶è®¤ä¸ºåŠ¨æ€èŒƒå›´æ‰§è¡Œé€Ÿåº¦æ›´å¿«ï¼Œç°åœ¨ï¼Œå¤šäºäº†æ—©æœŸçš„Scheme é»‘å®¢ï¼Œæˆ‘ä»¬ç›´åˆ°è¿™ä¸ªç»“è®ºä¸å‡†ç¡®ï¼Œå¦‚æœè¦é‡æ–°ä¸‹ç»“è®ºï¼Œç­”æ¡ˆæ˜¯åŠ¨æ€ä½œç”¨åŸŸä¼šæ›´æ…¢ã€‚</p>
<p>Dynamic scope for variables lives on in some corners. Emacs Lisp defaults to dynamic scope for variables. The binding macro in Clojure provides it. The widely disliked with statement in JavaScript turns properties on an object into dynamically scoped variables.</p>
<p>å˜é‡çš„åŠ¨æ€ä½œç”¨åŸŸå­˜åœ¨äºæŸäº›è§’è½ï¼ŒEmacs Lispé»˜è®¤å˜é‡æ˜¯åŠ¨æ€ä½œç”¨åŸŸçš„ï¼ŒClojure é€šè¿‡ç»‘å®šå®æä¾›äº†å®ƒï¼ŒJavaScriptè¯­è¨€ä¸­å¹¿å—æ¬¢è¿çš„withè¯­å¥å°†å¯¹è±¡çš„å±æ€§è½¬æ¢ä¸ºåŠ¨æ€ä½œç”¨åŸŸçš„å˜é‡</p>
</blockquote>
<p>This is in contrast to dynamic scope where you donâ€™t know what a name refers to until you execute the code. Lox doesnâ€™t have dynamically scoped variables, but methods and fields on objects are dynamically scoped.</p>
<p>è¿™ä¸åŠ¨æ€ä½œç”¨åŸŸä¸åŒï¼Œåœ¨åŠ¨æ€ä½œç”¨åŸŸä¸­ï¼Œåœ¨æ‰§è¡Œä»£ç ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸éœ€è¦çŸ¥é“åç§°æŒ‡ä»£çš„æ˜¯ä»€ä¹ˆï¼ŒLoxæ²¡æœ‰åŠ¨æ€ä½œç”¨åŸŸå˜é‡ï¼Œä½†æ˜¯å¯¹è±¡ä¸Šçš„æ–¹æ³•å’Œå­—æ®µæ˜¯åŠ¨æ€ä½œç”¨åŸŸçš„</p>
<pre><code class="language-java">

class Saxophone {
  play() {
    print &quot;Careless Whisper&quot;;
  }
}

class GolfClub {
  play() {
    print &quot;Fore!&quot;;
  }
}

fun playIt(thing) {
  thing.play();
}

</code></pre>
<p>When playIt() calls thing.play(), we donâ€™t know if weâ€™re about to hear â€œCareless Whisperâ€ or â€œFore!â€ It depends on whether you pass a Saxophone or a GolfClub to the function, and we donâ€™t know that until runtime.</p>
<p>å½“å‡½æ•°playIt() è°ƒç”¨thing.play() æ—¶å€™ï¼Œæˆ‘ä»¬ä¸çŸ¥é“è¿”å›å€¼æ˜¯ â€œCareless Whisperâ€ è¿˜æ˜¯ â€œFore!â€ï¼Œè¿™å–å†³äºä½ æ˜¯æŠŠ Saxophone è¿˜æ˜¯ GolfClub ä¼ é€ç»™å‡½æ•°ï¼Œè€Œæˆ‘ä»¬çŸ¥é“è¿è¡Œæ—¶å€™ï¼Œæ‰èƒ½çŸ¥é“å®å‚ä¿¡æ¯</p>
<p>Scope and environments are close cousins. The former is the theoretical concept, and the latter is the machinery that implements it. As our interpreter works its way through code, syntax tree nodes that affect scope will change the environment. In a C-ish syntax like Loxâ€™s, scope is controlled by curly-braced blocks. (Thatâ€™s why we call it block scope.)</p>
<p>ä½œç”¨åŸŸå’Œç¯å¢ƒæ˜¯ç›¸ä¼¼æ¦‚å¿µï¼Œä½œç”¨åŸŸæ˜¯ä¸€ä¸ªç†è®ºä¸Šçš„æ¦‚å¿µï¼Œç¯å¢ƒæ˜¯å®ç°ä½œç”¨åŸŸçš„ä¸€ä¸ªæœºåˆ¶ã€‚å½“æˆ‘ä»¬çš„è§£é‡Šå™¨ï¼Œç´§éšä»£ç è¿è¡Œæ—¶å€™ï¼Œä½œç”¨åŸŸå˜åŒ–ä¼šå¯¼è‡´è¯­æ³•æ ‘çš„èŠ‚ç‚¹çš„ç¯å¢ƒçš„å˜åŒ–ã€‚åœ¨ç±»Cè¯­è¨€ï¼Œä¾‹å¦‚Loxä¸­ï¼Œä½œç”¨åŸŸä½¿ç”¨å¤§æ‹¬å·æ§åˆ¶ï¼ˆè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ç§°ä½œç”¨åŸŸä¸ºå—èŒƒå›´çš„åŸå› ï¼‰</p>
<pre><code class="language-java">
{
  var a = &quot;in block&quot;;
}
print a; // Error! No more &quot;a&quot;.

</code></pre>
<p>The beginning of a block introduces a new local scope, and that scope ends when execution passes the closing }. Any variables declared inside the block disappear.</p>
<p>å—çš„å¼€å§‹å¼•å…¥äº†ä¸€ä¸ªæ–°çš„æœ¬åœ°å˜é‡ï¼Œå½“è¿è¡Œåˆ°å³æ‹¬å·æ—¶å€™ï¼Œä½œç”¨åŸŸç»“æŸã€‚å—å†…å£°æ˜çš„å˜é‡å°†ä¼šæ¶ˆå¤±ã€‚</p>
<h3 id="51-nesting-and-shadowing"><a class="header" href="#51-nesting-and-shadowing">5.1 Nesting and shadowing</a></h3>
<p>A first cut at implementing block scope might work like this:</p>
<ul>
<li>
<p>As we visit each statement inside the block, keep track of any variables declared.</p>
</li>
<li>
<p>After the last statement is executed, tell the environment to delete all of those variables.</p>
</li>
</ul>
<p>å®ç°å—èŒƒå›´çš„ç¬¬ä¸€æ­¥å¯èƒ½æ˜¯è¿™æ ·çš„ï¼Œ</p>
<ul>
<li>
<p>å½“æˆ‘ä»¬è®¿é—®å—å†…çš„æ¯ä¸€ä¸ªè¯­å¥æ—¶å€™ï¼Œä¼šè·Ÿè¸ªå£°æ˜çš„ä»»ä½•å˜é‡</p>
</li>
<li>
<p>æ‰§è¡Œæœ€åä¸€æ¡è¯­å¥æ—¶å€™ï¼Œå‘Šè¯‰ç¯å¢ƒåˆ é™¤æ‰€æœ‰çš„å˜é‡</p>
</li>
</ul>
<p>That would work for the previous example. But remember, one motivation for local scope is encapsulationâ€”a block of code in one corner of the program shouldnâ€™t interfere with some other block. Check this out:</p>
<p>è¿™é€‚ç”¨äºå‰é¢çš„æ¼”ç¤ºï¼Œä½†è¯·æ³¨æ„ï¼Œå±€éƒ¨å˜é‡çš„ä¸€ä¸ªåŠ¨æœºæ˜¯å°è£…â€”â€”ç¨‹åºæŸä¸ªéƒ¨åˆ†çš„ä»£ç ï¼Œä¸ä¼šå½±å“å¦å¤–ä¸€éƒ¨åˆ†çš„ä»£ç ï¼Œçœ‹çœ‹ä¸‹é¢</p>
<pre><code class="language-java">
// How loud?
var volume = 11;

// Silence.
volume = 0;

// Calculate size of 3x4x5 cuboid.
{
  var volume = 3 * 4 * 5;
  print volume;
}

</code></pre>
<p>Look at the block where we calculate the volume of the cuboid using a local declaration of volume. After the block exits, the interpreter will delete the global volume variable. That ainâ€™t right. When we exit the block, we should remove any variables declared inside the block, but if there is a variable with the same name declared outside of the block, thatâ€™s a different variable. It shouldnâ€™t get touched.</p>
<p>When a local variable has the same name as a variable in an enclosing scope, it shadows the outer one. Code inside the block canâ€™t see it any moreâ€”it is hidden in the â€œshadowâ€ cast by the inner oneâ€”but itâ€™s still there.</p>
<p>When we enter a new block scope, we need to preserve variables defined in outer scopes so they are still around when we exit the inner block. We do that by defining a fresh environment for each block containing only the variables defined in that scope. When we exit the block, we discard its environment and restore the previous one.</p>
<p>We also need to handle enclosing variables that are not shadowed.</p>
<p>çœ‹çœ‹è¿™ä¸ªå—ï¼Œæˆ‘ä»¬ç”¨æœ¬åœ°å˜é‡ volumeä¿å­˜é•¿æ–¹ä½“ä½“ç§¯è®¡ç®—å€¼ï¼Œå—é€€å‡ºåï¼Œè§£é‡Šå™¨å°†ä¼šåˆ é™¤å…¨å±€å˜é‡volume, è¿™æ˜¯ä¸å¯¹çš„ï¼Œå½“æˆ‘ä»¬åˆ é™¤å—æ—¶å€™ï¼Œæˆ‘ä»¬åº”è¯¥åˆ é™¤å—å†…æ‰€æœ‰çš„å˜é‡ï¼Œä½†æ˜¯ï¼Œå¦‚æœåœ¨å—å¤–å£°æ˜äº†ä¸€ä¸ªåŒåå˜é‡åï¼Œé‚£å°±æ˜¯å¦å¤–ä¸€ä¸ªå˜é‡ï¼Œå®ƒä¸åº”è¯¥è¢«è®¿é—®åˆ°</p>
<p>å½“å±€éƒ¨å˜é‡å’Œå—ä¸­çš„å˜é‡åŒåï¼Œå®ƒä¼šéšè—å¤–éƒ¨å˜é‡ï¼Œå—å†…çš„ä»£ç å°†æ— æ³•çœ‹åˆ°å¤–éƒ¨å˜é‡ï¼Œå®ƒéšè—åœ¨å†…éƒ¨ä»£ç æŠ•å°„çš„é˜´å½±ä¸­ï¼Œä½†æ˜¯å®ƒä»ç„¶å­˜åœ¨ã€‚</p>
<p>å½“æˆ‘ä»¬è¿›å…¥åˆ°ä¸€ä¸ªæ–°çš„å—ä½œç”¨åŸŸæ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦ä¿ç•™åœ¨å¤–éƒ¨èŒƒå›´å†…å£°æ˜çš„å˜é‡ï¼Œè¿™æ ·å½“ï¼Œæˆ‘ä»¬é€€å‡ºå†…éƒ¨å—æ—¶å€™ï¼Œè¿™äº›å¤–éƒ¨å˜é‡ä»ç„¶å­˜åœ¨ã€‚æˆ‘ä»¬é€šè¿‡ä¸ºæ¯ä¸€ä¸ªå—ï¼Œæä¾›ä¸€ä¸ªenvironmentï¼Œæ¥å®ç°ã€‚è¯¥ç¯å¢ƒä»…åŒ…å«åœ¨è¯¥ä½œç”¨åŸŸä¸­å®šä¹‰çš„å˜é‡, å½“æˆ‘ä»¬é€€å‡ºä»£ç å—æ—¶å€™ï¼Œæˆ‘ä»¬å°†ä¸¢å¼ƒå®ƒçš„ç¯å¢ƒï¼Œå¹¶ä¸”æ¢å¤ä»¥å‰çš„ç¯å¢ƒã€‚</p>
<p>æˆ‘ä»¬è¿˜éœ€è¦å¤„ç†æœªéšè—çš„å°é—­å˜é‡</p>
<pre><code class="language-java">
var global = &quot;outside&quot;;
{
  var local = &quot;inside&quot;;
  print global + local;
}

</code></pre>
<p>Here, global lives in the outer global environment and local is defined inside the blockâ€™s environment. In that print statement, both of those variables are in scope. In order to find them, the interpreter must search not only the current innermost environment, but also any enclosing ones.</p>
<p>We implement this by chaining the environments together. Each environment has a reference to the environment of the immediately enclosing scope. When we look up a variable, we walk that chain from innermost out until we find the variable. Starting at the inner scope is how we make local variables shadow outer ones.</p>
<p>åœ¨è¿™é‡Œï¼Œå˜é‡global å­˜åœ¨äºå¤–éƒ¨ç¯å¢ƒå˜é‡ä¸­ï¼Œå˜é‡ local å®šä¹‰åœ¨ä»£ç å—ä¸­ï¼Œåœ¨printè¯­å¥ä¸­ï¼Œè¿™ä¸¤ä¸ªå˜é‡éƒ½åœ¨ä½œç”¨åŸŸä¸­ï¼Œä¸ºäº†æ‰¾åˆ°å®ƒä»¬ï¼Œè§£é‡Šå™¨ä¸ä»…éœ€è¦æœç´¢å½“å‰æœ€å†…éƒ¨çš„ç¯å¢ƒï¼Œè¿˜å¿…é¡»æœç´¢ä»»ä½•å°é—­çš„ç¯å¢ƒã€‚</p>
<p>æˆ‘ä»¬é€šè¿‡å°†ç¯å¢ƒé“¾æ¥åœ¨ä¸€èµ·æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œæ¯ä¸ªç¯å¢ƒéƒ½å…·æœ‰å¯¹ç´§é‚»çš„å°é—­èŒƒå›´çš„ç¯å¢ƒçš„å¼•ç”¨ï¼Œå½“æˆ‘ä»¬æŸ¥æ‰¾ä¸€ä¸ªå˜é‡æ—¶å€™ï¼Œæˆ‘ä»¬ä»æœ€é‡Œé¢å‘å¤–éå†è¯¥é“¾ï¼Œç›´åˆ°æ‰¾åˆ°è¯¥å˜é‡ï¼Œä»å†…éƒ¨èŒƒå›´å¼€å§‹ï¼Œæˆ‘ä»¬å°†å¦‚ä½•ä½¿å¾—å±€éƒ¨å˜é‡è¦†ç›–å¤–éƒ¨å˜é‡</p>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/chaining.png?raw=true" alt="chain" /></p>
<blockquote>
<p>While the interpreter is running, the environments form a linear list of objects, but consider the full set of environments created during the entire execution. An outer scope may have multiple blocks nested within it, and each will point to the outer one, giving a tree-like structure, though only one path through the tree exists at a time.</p>
<p>å½“è§£é‡Šå™¨è¿è¡Œæ—¶å€™ï¼Œç¯å¢ƒå½¢æˆäº†ä¸€ä¸ªçº¿æ€§çš„å¯¹è±¡åˆ—è¡¨ï¼Œä½†è¦è€ƒè™‘åœ¨æ•´ä¸ªæ‰§è¡Œè¿‡ç¨‹ä¸­åˆ›å»ºçš„å…¨å¥—ç¯å¢ƒã€‚ä¸€ä¸ªå¤–éƒ¨ä½œç”¨åŸŸå¯èƒ½å­˜åœ¨å¤šä¸ªåµŒå¥—åœ¨å…¶ä¸­çš„å—ï¼Œæ¯ä¸ªå—éƒ½ä¼šæŒ‡å‘å¤–éƒ¨çš„å—ï¼Œä»è€Œå½¢æˆä¸€ä¸ªç±»ä¼¼æ ‘çš„ç»“æ„ï¼Œå°½ç®¡ä¸€æ¬¡åªä¼šå­˜åœ¨ä¸€æ¡é€šå‘æ ‘çš„è·¯å¾„</p>
<p>The boring name for this is a parent-pointer tree, but I much prefer the evocative cactus stack.</p>
<p>è¿™ä¸ªæ— èŠçš„åå­—æ˜¯ä¸€ä¸ªçˆ¶æŒ‡é’ˆæ ‘ï¼Œä½†æˆ‘æ›´åŠ å–œæ¬¢èƒ½å¼•å‘å…±é¸£çš„ä»™äººæŒå †æ ˆè¿™ä¸ªåå­—ã€‚</p>
</blockquote>
<p><img src="https://github.com/Kua-Fu/blog-book-images/blob/main/crafting-interpreters/cactus.png?raw=true" alt="cactus" /></p>
<p>Before we add block syntax to the grammar, weâ€™ll beef up our Environment class with support for this nesting. First, we give each environment a reference to its enclosing one.</p>
<p>åœ¨å°†å—è¯­æ³•æ·»åŠ åˆ°è¯­æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å°†å¢å¼ºenvironment ç±»å¯¹äºåµŒå¥—çš„æ”¯æŒï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬å°†ç»™æ¯ä¸ªenvironmentå¯¹å…¶å°é—­ç¯å¢ƒçš„å¼•ç”¨</p>
<pre><code class="language-java">
// lox/Environment.java, in class Environment

class Environment {
  final Environment enclosing;
  private final Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
  
</code></pre>
<p>This field needs to be initialized, so we add a couple of constructors.</p>
<p>è¿™ä¸ªå­—æ®µéœ€è¦åˆå§‹åŒ–ï¼Œå› æ­¤æˆ‘ä»¬å°†æ·»åŠ ä¸€äº›æ„é€ å‡½æ•°</p>
<pre><code class="language-java">
// lox/Environment.java, in class Environment

  Environment() {
    enclosing = null;
  }

  Environment(Environment enclosing) {
    this.enclosing = enclosing;
  }
  
</code></pre>
<p>æ— å‚æ•°æ„é€ å‡½æ•°ï¼Œç”¨äºç»“æŸé“¾çš„å…¨å±€ä½œç”¨åŸŸç¯å¢ƒï¼Œå¦ä¸€ä¸ªæ„é€ å‡½æ•°åˆ›å»ºä¸€ä¸ªåµŒå¥—åœ¨ç»™å®šå¤–éƒ¨ä½œç”¨åŸŸå†…çš„æ–°çš„æœ¬åœ°ä½œç”¨åŸŸã€‚</p>
<p>We donâ€™t have to touch the define() methodâ€”a new variable is always declared in the current innermost scope. But variable lookup and assignment work with existing variables and they need to walk the chain to find them. First, lookup:</p>
<p>æˆ‘ä»¬ä¸éœ€è¦è§¦åŠdefine() æ–¹æ³•â€”â€”ä¸€ä¸ªæ–°çš„å˜é‡æ€»æ˜¯åœ¨å½“å‰æœ€å†…éƒ¨çš„ä½œç”¨åŸŸä¸­å£°æ˜ï¼Œä½†æ˜¯å˜é‡æŸ¥æ‰¾å’Œèµ‹å€¼ï¼Œå’Œç°æœ‰å˜é‡ä¸€èµ·å·¥ä½œã€‚å®ƒä»¬éœ€è¦éå†é“¾æ‰å¯ä»¥æ‰¾åˆ°ï¼Œé¦–å…ˆï¼ŒæŸ¥æ‰¾ï¼š</p>
<pre><code class="language-java">
// lox/Environment.java, in get()


      return values.get(name.lexeme);
    }

    if (enclosing != null) return enclosing.get(name);

    throw new RuntimeError(name,
        &quot;Undefined variable '&quot; + name.lexeme + &quot;'.&quot;);
		
</code></pre>
<p>If the variable isnâ€™t found in this environment, we simply try the enclosing one. That in turn does the same thing recursively, so this will ultimately walk the entire chain. If we reach an environment with no enclosing one and still donâ€™t find the variable, then we give up and report an error as before.</p>
<p>Assignment works the same way.</p>
<p>å¦‚æœåœ¨å½“å‰çš„ç¯å¢ƒä¸­æ— æ³•æ‰¾åˆ°æŸä¸ªå˜é‡ï¼Œæˆ‘ä»¬åªéœ€è¦å°è¯•ä½¿ç”¨å°é—­å˜é‡ï¼Œè¿™åè¿‡æ¥é€’å½’åšåŒæ ·çš„äº‹æƒ…ï¼Œæœ€ç»ˆå°†ä¼šéå†æ•´æ¡é“¾ï¼Œå¦‚æœæˆ‘ä»¬åˆ°è¾¾æŸä¸ªç¯å¢ƒï¼Œä¸å­˜åœ¨å°é—­å˜é‡ï¼Œä»ç„¶æ‰¾ä¸åˆ°å˜é‡ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†æ”¾å¼ƒï¼Œå¹¶ä¸”å‘ä¹‹å‰é‚£æ ·æŠ¥å‘Šé”™è¯¯ã€‚</p>
<p>å˜é‡èµ‹å€¼çš„å·¥ä½œæ–¹å¼ç›¸åŒã€‚</p>
<pre><code class="language-java">
// lox/Environment.java, in assign()

      values.put(name.lexeme, value);
      return;
    }

    if (enclosing != null) {
      enclosing.assign(name, value);
      return;
    }

    throw new RuntimeError(name,
	
</code></pre>
<blockquote>
<p>Itâ€™s likely faster to iteratively walk the chain, but I think the recursive solution is prettier. Weâ€™ll do something much faster in clox.</p>
<p>è¿­ä»£éå†é“¾å¯èƒ½æ›´å¿«ï¼Œä½†æ˜¯æˆ‘è®¤ä¸ºé€’å½’è§£å†³æ–¹æ¡ˆæ›´åŠ å¥½ï¼Œæˆ‘ä»¬å°†åœ¨cloxä¸­åšä¸€äº›æ›´å¿«çš„äº‹æƒ…ã€‚</p>
</blockquote>
<p>Again, if the variable isnâ€™t in this environment, it checks the outer one, recursively.</p>
<p>åŒæ ·ï¼Œå¦‚æœå˜é‡ä¸åœ¨å½“å‰ç¯å¢ƒä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæŸ¥è¯¢å¤–éƒ¨ç¯å¢ƒï¼Œä¸€ç›´é€’å½’ã€‚</p>
<h3 id="52-block-syntax-and-semantics"><a class="header" href="#52-block-syntax-and-semantics">5.2 Block syntax and semantics</a></h3>
<p>å—è¯­æ³•å’Œè¯­ä¹‰</p>
<p>Now that Environments nest, weâ€™re ready to add blocks to the language. Behold the grammar:</p>
<p>ç°åœ¨æˆ‘ä»¬æ”¯æŒäº†åµŒå¥—ç¯å¢ƒï¼Œæˆ‘ä»¬å‡†å¤‡å‘è¯­æ³•ä¸­æ·»åŠ å—è¯­æ³•ï¼Œ</p>
<pre><code>
statement      â†’ exprStmt
               | printStmt
               | block ;

block          â†’ &quot;{&quot; declaration* &quot;}&quot; ;

</code></pre>
<p>A block is a (possibly empty) series of statements or declarations surrounded by curly braces. A block is itself a statement and can appear anywhere a statement is allowed. The syntax tree node looks like this:</p>
<p>å—æ˜¯ç”±å¤§æ‹¬å·åŒ…å›´çš„ä¸€ç³»åˆ—è¯­å¥æˆ–è€…å£°æ˜ï¼ˆå¯èƒ½æ˜¯ç©ºçš„ï¼‰ï¼Œå—æœ¬èº«å°±æ˜¯ä¸€æ¡è¯­å¥ï¼Œå¯ä»¥å‡ºç°åœ¨å…è®¸è¯­å¥å‡ºç°çš„ä»»ä½•åœ°æ–¹ï¼Œè¯­æ³•æ ‘èŠ‚ç‚¹å¦‚ä¸‹æ‰€ç¤º</p>
<pre><code class="language-java">
// tool/GenerateAst.java, in main()

    defineAst(outputDir, &quot;Stmt&quot;, Arrays.asList(
      &quot;Block      : List&lt;Stmt&gt; statements&quot;,
      &quot;Expression : Expr expression&quot;,
	  
</code></pre>
<p>It contains the list of statements that are inside the block. Parsing is straightforward. Like other statements, we detect the beginning of a block by its leading tokenâ€”in this case the {. In the statement() method, we add:</p>
<p>å®ƒåŒ…å«å—å†…çš„è¯­å¥åˆ—è¡¨ï¼Œè§£æå¾ˆç®€å•ï¼Œä¸å…¶ä»–è¯­å¥ä¸€æ ·ï¼Œæˆ‘ä»¬é€šè¿‡å‰å¯¼tokenæ£€æµ‹å—çš„å¼€å§‹ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œæ˜¯ {, åœ¨ statement() æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬æ·»åŠ </p>
<pre><code class="language-java">
// lox/Parser.java, in statement()

    if (match(PRINT)) return printStatement();
    if (match(LEFT_BRACE)) return new Stmt.Block(block());

    return expressionStatement();
	
</code></pre>
<p>All the real work happens here:</p>
<p>çœŸçš„è§£æå‘ç”Ÿåœ¨</p>
<pre><code class="language-java">
// lox/Parser.java, add after expressionStatement()


  private List&lt;Stmt&gt; block() {
    List&lt;Stmt&gt; statements = new ArrayList&lt;&gt;();

    while (!check(RIGHT_BRACE) &amp;&amp; !isAtEnd()) {
      statements.add(declaration());
    }

    consume(RIGHT_BRACE, &quot;Expect '}' after block.&quot;);
    return statements;
  }
  
</code></pre>
<p>We create an empty list and then parse statements and add them to the list until we reach the end of the block, marked by the closing }. Note that the loop also has an explicit check for isAtEnd(). We have to be careful to avoid infinite loops, even when parsing invalid code. If the user forgets a closing }, the parser needs to not get stuck.</p>
<p>Thatâ€™s it for syntax. For semantics, we add another visit method to Interpreter.</p>
<p>æˆ‘ä»¬åˆ›å»º1ä¸ªç©ºåˆ—è¡¨ï¼Œç„¶åè§£æè¯­å¥ï¼Œå¹¶ä¸”å°†å®ƒä»¬æ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼Œç›´åˆ°åˆ°è¾¾å—çš„ç»“å°¾ï¼Œæ ‡è®°æ˜¯ }, æ³¨æ„ï¼Œå¾ªç¯è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶æ˜¯isAtEnd() , ä¸ºäº†é˜²æ­¢è¿›å…¥æ— é™å¾ªç¯ä¸­ï¼Œå³ä½¿åœ¨è§£ææ— æ•ˆä»£ç æ—¶å€™ä¹Ÿåº”è¯¥è¿™æ ·åšã€‚å¦‚æœç”¨æˆ·å¿˜è®°äº†å—ç»“å°¾çš„ }, ä»£ç ä¹Ÿä¸ä¼šä¸€ç›´å¾ªç¯ã€‚</p>
<p>è¿™å°±æ˜¯è¯­æ³•ï¼Œå¯¹äºè¯­ä¹‰ï¼Œæˆ‘ä»¬éœ€è¦å‘è§£é‡Šå™¨æ·»åŠ ä¸€ä¸ªæ–°çš„è®¿é—®æ–¹æ³•ã€‚</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after execute()

  @Override
  public Void visitBlockStmt(Stmt.Block stmt) {
    executeBlock(stmt.statements, new Environment(environment));
    return null;
  }
  
</code></pre>
<blockquote>
<p>Having block() return the raw list of statements and leaving it to statement() to wrap the list in a Stmt.Block looks a little odd. I did it that way because weâ€™ll reuse block() later for parsing function bodies and we donâ€™t want that body wrapped in a Stmt.Block.</p>
<p>è®©block() æ–¹æ³•è¿”å›åŸå§‹è¯­å¥åˆ—è¡¨ï¼Œå¹¶å°†å…¶ç•™ç»™statement() æ–¹æ³•ï¼Œå°†åˆ—è¡¨åŒ…è£…åœ¨ Stmt.Blockä¸­ï¼Œçœ‹èµ·æ¥æœ‰äº›æ€ªï¼Œæˆ‘è¿™æ ·åšæ˜¯å› ä¸ºç¨åï¼Œæˆ‘ä»¬å°†å¤ç”¨block() æ¥è§£æå‡½æ•°ä½“ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›å‡½æ•°ä½“åŒ…è£…åœ¨ Stmt.Block ä¸­ã€‚</p>
</blockquote>
<p>To execute a block, we create a new environment for the blockâ€™s scope and pass it off to this other method:</p>
<p>è¦æ‰§è¡Œä¸€ä¸ªå—ï¼Œæˆ‘ä»¬ä¸ºå—çš„ä½œç”¨åŸŸåˆ›å»ºä¸€ä¸ªæ–°çš„environmentï¼Œå¹¶å°†å…¶ä¼ é€’ç»™å¦ä¸€ä¸ªæ–¹æ³•</p>
<pre><code class="language-java">
// lox/Interpreter.java, add after execute()

  void executeBlock(List&lt;Stmt&gt; statements,
                    Environment environment) {
    Environment previous = this.environment;
    try {
      this.environment = environment;

      for (Stmt statement : statements) {
        execute(statement);
      }
    } finally {
      this.environment = previous;
    }
  }
</code></pre>
<p>This new method executes a list of statements in the context of a given environment. Up until now, the environment field in Interpreter always pointed to the same environmentâ€”the global one. Now, that field represents the current environment. Thatâ€™s the environment that corresponds to the innermost scope containing the code to be executed.</p>
<p>To execute code within a given scope, this method updates the interpreterâ€™s environment field, visits all of the statements, and then restores the previous value. As is always good practice in Java, it restores the previous environment using a finally clause. That way it gets restored even if an exception is thrown.</p>
<p>è¿™ä¸ªæ–°æ–¹æ³•åœ¨ç»™å®šç¯å¢ƒçš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œè¯­å¥åˆ—è¡¨ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼ŒInterpreterä¸­çš„environment å­—æ®µï¼Œå§‹ç»ˆæŒ‡å‘çš„æ˜¯å…¨å±€å˜é‡ environment,ç°åœ¨ï¼Œè¯¥å­—æ®µï¼Œè¡¨ç¤ºçš„æ˜¯å½“å‰çš„environment, è¿™æ˜¯ä¸åŒ…å«è¦æ‰§è¡Œçš„ä»£ç çš„æœ€å†…éƒ¨èŒƒå›´å¯¹åº”çš„environment.</p>
<p>è¦åœ¨ç»™å®šèŒƒå›´å†…æ‰§è¡Œä»£ç ï¼Œæ­¤æ–¹æ³•ä¼šæ›´æ–° interpreterçš„ environmentå­—æ®µï¼Œè®¿é—®æ‰€æœ‰çš„è¯­å¥ï¼Œç„¶åå†æ¢å¤ environment ä¸ºä¹‹å‰çš„å€¼ï¼Œæ­£å¦‚Javaçš„è‰¯å¥½å®è·µä¸€æ ·ï¼Œå®ƒä½¿ç”¨ finallyå­å¥æ¢å¤ä»¥å‰çš„ç¯å¢ƒï¼Œè¿™æ ·ï¼Œå³ä½¿æŠ›å‡ºå¼‚å¸¸ï¼Œå®ƒä¹Ÿèƒ½æ¢å¤</p>
<blockquote>
<p>Manually changing and restoring a mutable environment field feels inelegant. Another classic approach is to explicitly pass the environment as a parameter to each visit method. To â€œchangeâ€ the environment, you pass a different one as you recurse down the tree. You donâ€™t have to restore the old one, since the new one lives on the Java stack and is implicitly discarded when the interpreter returns from the blockâ€™s visit method.</p>
<p>æ‰‹åŠ¨æ›´æ”¹å’Œæ¢å¤ä¸€ä¸ªå¯å˜çš„environmentå­—æ®µçœ‹èµ·æ¥ä¸å¤ªåˆé€‚ï¼Œå¦ä¸€ç§ç»å…¸çš„æ–¹å¼æ˜¯ï¼Œå°†environmentå½“ä½œå‚æ•°ï¼Œæ˜¾å¼ä¼ é€’ç»™æ¯ä¸ªè®¿é—®æ–¹æ³•ï¼Œè¦æ”¹å˜ç¯å¢ƒï¼Œåœ¨æ ‘ä¸‹é€’å½’æ—¶å€™ä¼ é€’ä¸€ä¸ªä¸åŒçš„environment,æˆ‘ä»¬ä¸éœ€è¦æ¢å¤æ—§çš„ï¼Œå› ä¸ºæ–°çš„environment å­˜åœ¨äºJavaå †æ ˆä¸­ï¼Œå¹¶ä¸”å½“è§£é‡Šå™¨ä»å—çš„è®¿é—®æ–¹æ³•è¿”å›æ—¶å€™ï¼Œè¢«éšå¼çš„ä¸¢å¼ƒ</p>
<p>I considered that for jlox, but itâ€™s kind of tedious and verbose adding an environment parameter to every single visit method. To keep the book a little simpler, I went with the mutable field.</p>
<p>æˆ‘è€ƒè™‘åœ¨jloxä¸­è¿™æ ·å®ç°ï¼Œä½†æ˜¯åœ¨æ¯ä¸ªå•ç‹¬çš„è®¿é—®æ–¹æ³•ä¸­æ·»åŠ ä¸€ä¸ªenvironmentå‚æ•°æœ‰äº›å†—ä½™ä¹å‘³ï¼Œä¸ºäº†è®©æœ¬ä¹¦æ›´åŠ ç®€æ´ï¼Œæˆ‘ä½¿ç”¨äº†å¯å˜å­—æ®µã€‚</p>
</blockquote>
<p>Surprisingly, thatâ€™s all we need to do in order to fully support local variables, nesting, and shadowing. Go ahead and try this out:</p>
<p>ä»¤äººæƒŠè®¶çš„æ˜¯ï¼Œä¸ºäº†å®Œå…¨æ”¯æŒå±€éƒ¨å˜é‡ã€åµŒå¥—å’Œéšè—ï¼Œæˆ‘ä»¬éœ€è¦åšçš„å°±æ˜¯è¿™äº›ï¼Œç»§ç»­å°è¯•ä¸‹é¢ä»£ç </p>
<pre><code class="language-java">
var a = &quot;global a&quot;;
var b = &quot;global b&quot;;
var c = &quot;global c&quot;;
{
  var a = &quot;outer a&quot;;
  var b = &quot;outer b&quot;;
  {
    var a = &quot;inner a&quot;;
    print a;
    print b;
    print c;
  }
  print a;
  print b;
  print c;
}
print a;
print b;
print c;

</code></pre>
<p>Our little interpreter can remember things now. We are inching closer to something resembling a full-featured programming language.</p>
<p>æˆ‘ä»¬çš„è§£é‡Šå™¨ç°åœ¨èƒ½è®°ä½ä¸œè¥¿äº†ï¼Œæˆ‘ä»¬æ­£é€æ­¥æ¥è¿‘ä¸€é—¨åŠŸèƒ½é½å…¨çš„ç¼–ç¨‹è¯­è¨€ã€‚</p>
<h2 id="å…­challenges"><a class="header" href="#å…­challenges">å…­ã€CHALLENGES</a></h2>
<p>ä¹ é¢˜</p>
<ol>
<li>
<p>The REPL no longer supports entering a single expression and automatically printing its result value. Thatâ€™s a drag. Add support to the REPL to let users type in both statements and expressions. If they enter a statement, execute it. If they enter an expression, evaluate it and display the result value.</p>
<p>REPL ä¸å†æ”¯æŒè¾“å…¥å•ä¸ªè¡¨è¾¾å¼å¹¶ä¸”è‡ªåŠ¨æ‰“å°ç»“æœå€¼ï¼Œè¿™æ˜¯ä¸€ä¸ªä¼˜åŒ–ç‚¹ï¼Œå‘REPL æ·»åŠ æ”¯æŒï¼Œå…è®¸ç”¨æˆ·åŒæ—¶è¾“å…¥è¡¨è¾¾å¼å’Œè¯­å¥ï¼Œå¦‚æœè¾“å…¥ä¸€æ¡è¯­å¥ï¼Œç›´æ¥æ‰§è¡Œï¼Œå¦‚æœè¾“å…¥è¡¨è¾¾å¼ï¼Œè®¡ç®—è¡¨è¾¾å¼å€¼ï¼Œç„¶åè¾“å‡ºç»“æœã€‚</p>
</li>
<li>
<p>Maybe you want Lox to be a little more explicit about variable initialization. Instead of implicitly initializing variables to nil, make it a runtime error to access a variable that has not been initialized or assigned to, as in:</p>
<pre><code class="language-java">
// No initializers.
var a;
var b;

a = &quot;assigned&quot;;
print a; // OK, was assigned first.

print b; // Error!

</code></pre>
<p>ä¹Ÿè®¸æˆ‘ä»¬å¸Œæœ›Loxï¼Œåœ¨å˜é‡åˆå§‹åŒ–æ–¹é¢æ›´åŠ æ˜ç¡®ä¸€äº›ï¼Œä¸å…¶éšå¼çš„å°†å˜é‡åˆå§‹åŒ–ä¸ºnilï¼Œä¸å¦‚å°†è®¿é—®å°šæœªåˆå§‹åŒ–æˆ–è€…èµ‹å€¼çš„å˜é‡è®¾ç½®ä¸ºè¿è¡Œæ—¶é”™è¯¯</p>
</li>
<li>
<p>What does the following program do?</p>
<p>ä»¥ä¸‹ç¨‹åºåšä»€ä¹ˆï¼Ÿ</p>
<pre><code class="language-java">
var a = 1;
{
  var a = a + 2;
  print a;
}
</code></pre>
<p>What did you expect it to do? Is it what you think it should do? What does analogous code in other languages you are familiar with do? What do you think users will expect this to do?</p>
<p>ä½ å¸Œæœ›å®ƒåšä»€ä¹ˆï¼Ÿè¿™æ˜¯ä½ è®¤ä¸ºå®ƒåº”è¯¥åšçš„å—ï¼Ÿä½ ç†Ÿæ‚‰çš„å…¶ä»–è¯­è¨€ä¸­æ˜¯è¿™æ ·çš„å—ï¼Ÿä½ è®¤ä¸ºç”¨æˆ·å¸Œæœ›çš„è¿”å›ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿ</p>
</li>
</ol>
<h2 id="ä¸ƒdesign-note-implicit-variable-declaration"><a class="header" href="#ä¸ƒdesign-note-implicit-variable-declaration">ä¸ƒã€DESIGN NOTE: IMPLICIT VARIABLE DECLARATION</a></h2>
<p>è®¾è®¡æ€æƒ³: éšå¼å˜é‡å£°æ˜</p>
<p>Lox has distinct syntax for declaring a new variable and assigning to an existing one. Some languages collapse those to only assignment syntax. Assigning to a non-existent variable automatically brings it into being. This is called implicit variable declaration and exists in Python, Ruby, and CoffeeScript, among others. JavaScript has an explicit syntax to declare variables, but can also create new variables on assignment. Visual Basic has an option to enable or disable implicit variables.</p>
<p>When the same syntax can assign or create a variable, each language must decide what happens when it isnâ€™t clear about which behavior the user intends. In particular, each language must choose how implicit declaration interacts with shadowing, and which scope an implicitly declared variable goes into.</p>
<p>Lox åœ¨å£°æ˜æ–°çš„å˜é‡å’Œå¯¹å˜é‡èµ‹å€¼ï¼Œæœ‰ä¸åŒçš„è¯­æ³•ï¼Œæœ‰äº›è¯­è¨€å°†å®ƒä»¬åˆå¹¶ä¸ºä¸€ç§è¯­æ³•ï¼Œå¯¹ä¸€ä¸ªä¸å­˜åœ¨çš„å˜é‡èµ‹å€¼ï¼Œä¼šè‡ªåŠ¨å£°æ˜ã€‚è¿™ç§°ä¸ºéšå¼å˜é‡å£°æ˜ã€‚æ”¯æŒéšå¼å˜é‡å£°æ˜çš„è¯­è¨€æœ‰Python/Ruby/CoffeeScriptç­‰ç­‰ã€‚JavaScriptå…·æœ‰å£°æ˜å˜é‡çš„æ˜¾å¼è¯­æ³•ï¼Œä½†æ˜¯ä¹Ÿæ”¯æŒåœ¨å˜é‡èµ‹å€¼æ—¶å€™ç›´æ¥åˆ›å»ºã€‚Visual Basic å…·æœ‰ç¦ç”¨å¯ç”¨éšå¼å˜é‡å£°æ˜çš„é€‰é¡¹ã€‚</p>
<p>å½“ç›¸åŒçš„è¯­æ³•å¯ä»¥èµ‹å€¼æˆ–è€…åˆ›å»ºå˜é‡æ—¶å€™ï¼Œæ¯ç§è¯­è¨€å¿…é¡»å†³å®šåœ¨ä¸æ¸…æ¥šç”¨æˆ·æƒ³è¦çš„è¡Œä¸ºæ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿç‰¹åˆ«æ˜¯ï¼Œæ¯ç§è¯­è¨€éƒ½å¿…é¡»é€‰æ‹©éšå¼å˜é‡å£°æ˜ä¸é˜´å½±å¦‚ä½•äº¤äº’ï¼Ÿä»¥åŠéšå¼å£°æ˜çš„å˜é‡å±äºä»€ä¹ˆä½œç”¨åŸŸï¼Ÿ</p>
<ul>
<li>In Python, assignment always creates a variable in the current functionâ€™s scope, even if there is a variable with the same name declared outside of the function.</li>
</ul>
<p>åœ¨Pythonä¸­ï¼Œèµ‹å€¼æ€»æ˜¯åœ¨å½“å‰å‡½æ•°çš„ä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªå˜é‡ï¼Œå³ä½¿åœ¨å‡½æ•°å¤–éƒ¨å·²ç»å­˜åœ¨ä¸€ä¸ªåŒåçš„å˜é‡</p>
<ul>
<li>Ruby avoids some ambiguity by having different naming rules for local and global variables. However, blocks in Ruby (which are more like closures than like â€œblocksâ€ in C) have their own scope, so it still has the problem. Assignment in Ruby assigns to an existing variable outside of the current block if there is one with the same name. Otherwise, it creates a new variable in the current blockâ€™s scope.</li>
</ul>
<p>Rubyé€šè¿‡å¯¹å…¨å±€å˜é‡å’Œå±€éƒ¨å˜é‡ä½¿ç”¨ä¸åŒçš„å‘½åè§„åˆ™ï¼Œæ¥é¿å…ä¸€äº›æ­§ä¹‰ã€‚ç„¶è€Œï¼ŒRubyä¸­çš„å—ï¼ˆæ›´åƒæ˜¯é—­åŒ…è€Œä¸æ˜¯Cä¸­çš„å—ï¼‰æœ‰è‡ªå·±çš„ä½œç”¨åŸŸï¼Œæ‰€ä»¥å®ƒä»ç„¶å­˜åœ¨é—®é¢˜ã€‚å¦‚æœå­˜åœ¨åŒåçš„å˜é‡ï¼ŒRubyä¸­çš„èµ‹å€¼ï¼Œå°†ä¼šèµ‹å€¼ç»™å½“å‰å—å¤–éƒ¨çš„åŒåå˜é‡ã€‚å¦åˆ™ï¼Œå¦‚æœå½“å‰å—çš„å¤–éƒ¨ä¸å­˜åœ¨åŒåå˜é‡ï¼Œæˆ‘ä»¬å°†åœ¨å½“å‰å—çš„ä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ã€‚</p>
<ul>
<li>
<p>CoffeeScript, which takes after Ruby in many ways, is similar. It explicitly disallows shadowing by saying that assignment always assigns to a variable in an outer scope if there is one, all the way up to the outermost global scope. Otherwise, it creates the variable in the current function scope.</p>
<p>CoffeeScriptåœ¨å¾ˆå¤šæ–¹é¢éƒ½å’ŒRubyç›¸åŒï¼Œå®ƒæ˜ç¡®ç¦æ­¢é˜´å½±ï¼Œè¡¨è¾¾å¼èµ‹å€¼æ€»æ˜¯åˆ†é…ç»™å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œä¸€ç›´åˆ°æœ€å¤–å±‚çš„å…¨å±€ä½œç”¨åŸŸï¼Œå¦åˆ™ï¼Œå®ƒå°†åœ¨å½“å‰å‡½æ•°ä½œç”¨åŸŸä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ã€‚</p>
</li>
<li>
<p>In JavaScript, assignment modifies an existing variable in any enclosing scope, if found. If not, it implicitly creates a new variable in the global scope.</p>
<p>åœ¨JavaScriptä¸­ï¼Œèµ‹å€¼ä¼šä¿®æ”¹å°é—­ä½œç”¨åŸŸå†…çš„å·²ç»å­˜åœ¨çš„å˜é‡ï¼Œå¦‚æœèƒ½æ‰¾åˆ°ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°†åœ¨å…¨å±€èŒƒå›´å†…ï¼Œéšå¼åˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡ã€‚</p>
</li>
</ul>
<p>The main advantage to implicit declaration is simplicity. Thereâ€™s less syntax and no â€œdeclarationâ€ concept to learn. Users can just start assigning stuff and the language figures it out.</p>
<p>Older, statically typed languages like C benefit from explicit declaration because they give the user a place to tell the compiler what type each variable has and how much storage to allocate for it. In a dynamically typed, garbage-collected language, that isnâ€™t really necessary, so you can get away with making declarations implicit. It feels a little more â€œscriptyâ€, more â€œyou know what I meanâ€.</p>
<p>éšå¼å˜é‡å£°æ˜çš„ä¼˜ç‚¹æ˜¯ç®€å•ï¼Œè¯­æ³•æ›´å°‘ï¼Œä¹Ÿä¸éœ€è¦å­¦ä¹ &quot;å£°æ˜&quot; ç­‰æœ¯è¯­ï¼Œç”¨æˆ·åªéœ€è¦èµ‹å€¼ï¼Œè¯­è¨€å°†ä¼šè§£å†³å£°æ˜ã€‚</p>
<p>è€çš„é™æ€ç±»å‹è¯­è¨€ï¼Œä¾‹å¦‚Cï¼Œä»æ˜¾å¼å£°æ˜ä¸­å—ç›Šï¼Œå› ä¸ºå®ƒä»¬ä¸ºç”¨æˆ·æä¾›äº†ä¸€ä¸ªåœ°æ–¹ï¼Œå¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œæ¯ä¸ªå˜é‡çš„ç±»å‹ï¼Œä»¥åŠä¸ºå…¶åˆ†é…çš„å­˜å‚¨ç©ºé—´ã€‚åœ¨åŠ¨æ€ç±»å‹ï¼Œæ”¯æŒåƒåœ¾æ”¶é›†çš„è¯­è¨€ä¸­ï¼Œå˜é‡æ˜¾å¼å£°æ˜ï¼Œå¹¶ä¸æ˜¯å¿…é¡»çš„ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨éšå¼å˜é‡å£°æ˜ï¼Œ</p>
<p>But is that a good idea? Implicit declaration has some problems.</p>
<p>éšå¼å˜é‡å£°æ˜æ˜¯ä¸€ä¸ªå¥½ä¸»æ„å—ï¼Ÿå®é™…ä¸Šï¼Œå®ƒå­˜åœ¨ä¸€äº›é—®é¢˜ã€‚</p>
<ul>
<li>A user may intend to assign to an existing variable, but may have misspelled it. The interpreter doesnâ€™t know that, so it goes ahead and silently creates some new variable and the variable the user wanted to assign to still has its old value. This is particularly heinous in JavaScript where a typo will create a global variable, which may in turn interfere with other code.</li>
</ul>
<p>ç”¨æˆ·å¯èƒ½æ‰“ç®—å¯¹ä¸€ä¸ªå·²æœ‰å˜é‡èµ‹å€¼ï¼Œä½†æ˜¯å¯èƒ½æ‹¼é”™äº†ã€‚è§£é‡Šå™¨å¹¶ä¸çŸ¥é“ï¼Œæ‰€ä»¥ä¼šè‡ªåŠ¨åˆ›å»ºä¸€äº›æ–°çš„å˜é‡ã€‚è€Œç”¨æˆ·æƒ³è¦æ›´æ–°çš„å˜é‡æ²¡æœ‰å˜åŒ–ï¼Œè¿™åœ¨JavaScriptä¸­æ›´åŠ çªå‡ºï¼Œå› ä¸ºæ‹¼å†™é”™è¯¯ï¼Œä¼šåˆ›å»ºä¸€ä¸ªå…¨å±€å˜é‡ï¼Œå¯èƒ½ä¼šå½±å“å…¶ä»–ä»£ç </p>
<ul>
<li>
<p>JS, Ruby, and CoffeeScript use the presence of an existing variable with the same nameâ€”even in an outer scopeâ€”to determine whether or not an assignment creates a new variable or assigns to an existing one. That means adding a new variable in a surrounding scope can change the meaning of existing code. What was once a local variable may silently turn into an assignment to that new outer variable.</p>
<p>JS,Ruby, CoffeeScript ä¸­ï¼Œé€šè¿‡åˆ¤æ–­ï¼Œå½“å‰å˜é‡æ˜¯å¦å­˜åœ¨ï¼ˆå³ä½¿å­˜åœ¨äºå¤–éƒ¨ä½œç”¨åŸŸä¸­ï¼‰ï¼Œæ¥å†³å®šåˆ›å»ºä¸€ä¸ªæ–°çš„å˜é‡è¿˜æ˜¯èµ‹å€¼ç»™ç°æœ‰å˜é‡ï¼Œè¿™æ„å‘³ç€åœ¨é™„è¿‘ä½œç”¨åŸŸä¸­æ·»åŠ æ–°å˜é‡ï¼Œå¯èƒ½ä¼šæ”¹å˜ç°æœ‰ä»£ç çš„å«ä¹‰ã€‚æ›¾ç»æ˜¯å±€éƒ¨å˜é‡çš„å†…å®¹å¯èƒ½ä¼šé»˜é»˜å˜ä¸ºå¯¹æ–°çš„å¤–éƒ¨å˜é‡çš„èµ‹å€¼ã€‚</p>
</li>
<li>
<p>In Python, you may want to assign to some variable outside of the current function instead of creating a new variable in the current one, but you canâ€™t.</p>
<p>åœ¨Pythonä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¸Œæœ›èµ‹å€¼ç»™å½“å‰å‡½æ•°ä¹‹å¤–çš„æŸä¸ªå˜é‡ï¼Œè€Œä¸æ˜¯å‡½æ•°ä¸­æ–°åˆ›å»ºçš„å˜é‡ï¼Œä½†æ˜¯æ— æ³•å®ç°ã€‚</p>
</li>
</ul>
<p>Over time, the languages I know with implicit variable declaration ended up adding more features and complexity to deal with these problems.</p>
<p>éšç€æ—¶é—´çš„æ¨ç§»ï¼Œæˆ‘æ‰€çŸ¥é“çš„æ”¯æŒéšå¼å˜é‡å£°æ˜çš„è¯­è¨€ï¼Œæœ€ç»ˆå¢åŠ äº†æ›´å¤šçš„ç‰¹æ€§å’Œå¤æ‚æ€§æ¥å¤„ç†ï¼Œè¿™äº›é—®é¢˜ã€‚</p>
<ul>
<li>
<p>Implicit declaration of global variables in JavaScript is universally considered a mistake today. â€œStrict modeâ€ disables it and makes it a compile error.</p>
<p>JavaScript çš„å…¨å±€å˜é‡çš„éšå¼å£°æ˜ï¼Œè¢«æ™®éè®¤ä¸ºæ˜¯ä¸€ä¸ªé”™è¯¯ï¼Œä¸¥æ ¼æ¨¡å¼å·²ç»ç¦ç”¨ï¼Œå¹¶ä¸”æŠŠå®ƒå½“ä½œä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚</p>
</li>
<li>
<p>Python added a global statement to let you explicitly assign to a global variable from within a function. Later, as functional programming and nested functions became more popular, they added a similar nonlocal statement to assign to variables in enclosing functions.</p>
<p>Pythonæ·»åŠ äº†ä¸€ä¸ª global è¯­å¥ï¼Œå…è®¸æˆ‘ä»¬åœ¨å†…éƒ¨å‡½æ•°ä¸­ï¼Œæ˜¾å¼çš„å¯¹å…¨å±€å˜é‡èµ‹å€¼ï¼Œåæ¥ï¼Œéšç€å‡½æ•°å¼ç¼–ç¨‹å’ŒåµŒå¥—å‡½æ•°è¶Šæ¥è¶Šæµè¡Œï¼ŒPython æ·»åŠ äº†ä¸€ä¸ªç±»å‹çš„è¯­å¥ nonlocal ï¼Œå¯¹å°é—­å‡½æ•°ä¸­çš„å˜é‡è¿›è¡Œèµ‹å€¼ã€‚</p>
</li>
<li>
<p>Ruby extended its block syntax to allow declaring certain variables to be explicitly local to the block even if the same name exists in an outer scope.</p>
<p>Ruby æ‰©å±•äº†è¯­æ³•ï¼Œå…è®¸å£°æ˜æŸäº›å˜é‡ä¸ºå—çš„æ˜¾å¼æœ¬åœ°å˜é‡ï¼Œå³ä½¿åœ¨å¤–éƒ¨ä½œç”¨åŸŸä¸­å­˜åœ¨ç›¸åŒåç§°çš„å˜é‡ã€‚</p>
</li>
</ul>
<p>Given those, I think the simplicity argument is mostly lost. There is an argument that implicit declaration is the right default but I personally find that less compelling.</p>
<p>My opinion is that implicit declaration made sense in years past when most scripting languages were heavily imperative and code was pretty flat. As programmers have gotten more comfortable with deep nesting, functional programming, and closures, itâ€™s become much more common to want access to variables in outer scopes. That makes it more likely that users will run into the tricky cases where itâ€™s not clear whether they intend their assignment to create a new variable or reuse a surrounding one.</p>
<p>So I prefer explicitly declaring variables, which is why Lox requires it.</p>
<p>è€ƒè™‘åˆ°è¿™äº›ï¼Œæˆ‘è®¤ä¸ºéšå¼å˜é‡å£°æ˜ç®€å•æ€§çš„ä¼˜ç‚¹å®é™…æ˜¯é”™è¯¯çš„ï¼Œæœ‰ä¸€ç§è§‚ç‚¹è®¤ä¸ºï¼Œéšå¼å˜é‡å£°æ˜æ˜¯æ­£ç¡®çš„é»˜è®¤æ–¹å¼ï¼Œæˆ‘ä¸ªäººä¸è¿™ä¹ˆè®¤ä¸ºã€‚</p>
<p>æˆ‘çš„è§‚ç‚¹æ˜¯ï¼Œåœ¨è¿‡å»çš„å‡ å¹´ä¸­ï¼Œéšå¼å£°æ˜æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå½“æ—¶å¤§å¤šæ•°çš„è„šæœ¬è¯­è¨€éƒ½æ˜¯å¿…è¦çš„ï¼Œè€Œä¸”ä»£ç è¯­æ³•éƒ½éå¸¸ç®€å•ï¼Œéšç€ç¨‹åºå‘˜è¶Šæ¥è¶Šç†Ÿæ‚‰æ·±åº¦åµŒå¥—ã€å‡½æ•°å¼ç¼–ç¨‹ã€é—­åŒ…ï¼Œæƒ³è¦è®¿é—®å¤–éƒ¨ä½œç”¨åŸŸä¸­çš„å˜é‡çš„éœ€æ±‚è¶Šæ¥è¶Šæ™®éï¼Œè¿™ä½¿å¾—ç”¨æˆ·æ›´æœ‰å¯èƒ½é‡åˆ°æ£˜æ‰‹çš„çŠ¶å†µï¼Œå³ä»–ä»¬ä¸æ¸…æ¥šè‡ªå·±çš„èµ‹å€¼æ˜¯åˆ›å»ºæ–°çš„å˜é‡ï¼Œè¿˜æ˜¯å¯¹å‘¨å›´çš„åŒåå˜é‡èµ‹å€¼</p>
<p>æ‰€ä»¥ï¼Œæˆ‘æ›´å–œæ¬¢æ˜¾å¼å£°æ˜å˜é‡ï¼Œè¿™å°±æ˜¯Loxéœ€è¦æ˜¾å¼å£°æ˜çš„åŸå› ã€‚</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
