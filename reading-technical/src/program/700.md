# The Next 700 Programming Languages

<p align="center"> The Next 700 Programming Languages </p>

<p align="center"> P. J. Landin  </p>

<p align="center"> Univac Division of Sperry Rand Corp., New York, New York </p>

> "... today... 1,700 special programming languages used to 'com- municate' in over 700 application areas."
> <p align="center"> --Computer Software Issues, </p>
> <p align="center"> an American Mathematical Association Prospectus, July 1965.</p>



   A family of unimplemented computing languages is described that is intended to span differences of application area by a unified framework. This framework dictates the rules about the uses of user-coined names, and the conventions about characterizing functional relationships. Within this framework the design of a specific language splits into two independent parts. One is the choice of written appearances of programs (or more generally, their physical representation). The other is the choice of the abstract entities (such as numbers, character-strings, lists of them, functional relations among them) that can be referred to in the language.


The system is biased towards "expressions" rather than "statements." It includes a nonprocedural (purely functional) subsystem that aims to expand the class of users' needs that can be met by a single print-instruction, without sacrificing the important properties that make conventional right-hand-side expressions easy to construct and understand. 

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

è¯¥æ–‡æ¡£æè¿°äº†ä¸€ä¸ªæœªå®ç°çš„è®¡ç®—è¯­è¨€å®¶æ—ï¼Œæ—¨åœ¨é€šè¿‡ä¸€ä¸ªç»Ÿä¸€æ¡†æ¶è·¨è¶Šä¸åŒåº”ç”¨é¢†åŸŸçš„å·®å¼‚ã€‚è¯¥æ¡†æ¶è§„å®šäº†å…³äºç”¨æˆ·åˆ›é€ çš„åç§°çš„ä½¿ç”¨è§„åˆ™ï¼Œä»¥åŠå…³äºæè¿°åŠŸèƒ½å…³ç³»çš„æƒ¯ä¾‹ã€‚åœ¨è¿™ä¸ªæ¡†æ¶å†…ï¼Œç‰¹å®šè¯­è¨€çš„è®¾è®¡åˆ†ä¸ºä¸¤ä¸ªç‹¬ç«‹éƒ¨åˆ†ã€‚ä¸€ä¸ªæ˜¯ç¨‹åºçš„ä¹¦é¢è¡¨ç°å½¢å¼ï¼ˆæˆ–æ›´å¹¿æ³›åœ°è¯´ï¼Œå®ƒä»¬çš„ç‰©ç†è¡¨ç¤ºï¼‰çš„é€‰æ‹©ã€‚å¦ä¸€ä¸ªæ˜¯å¯ä»¥åœ¨è¯­è¨€ä¸­å¼•ç”¨çš„æŠ½è±¡å®ä½“ï¼ˆå¦‚æ•°å­—ã€å­—ç¬¦å­—ç¬¦ä¸²ã€å®ƒä»¬çš„åˆ—è¡¨ã€å®ƒä»¬ä¹‹é—´çš„åŠŸèƒ½å…³ç³»ï¼‰çš„é€‰æ‹©ã€‚


è¯¥ç³»ç»Ÿåå‘äº"è¡¨è¾¾å¼"è€Œä¸æ˜¯"è¯­å¥"ã€‚å®ƒåŒ…æ‹¬ä¸€ä¸ªéç¨‹åºåŒ–ï¼ˆçº¯å‡½æ•°å¼ï¼‰çš„å­ç³»ç»Ÿï¼Œæ—¨åœ¨æ‰©å±•ç”¨æˆ·çš„éœ€æ±‚ç±»åˆ«ï¼Œè¿™äº›éœ€æ±‚å¯ä»¥é€šè¿‡å•ä¸ªæ‰“å°æŒ‡ä»¤æ¥æ»¡è¶³ï¼Œè€Œä¸ä¼šç‰ºç‰²ä½¿ä¼ ç»Ÿå³ä¾§è¡¨è¾¾å¼æ˜“äºæ„å»ºå’Œç†è§£çš„é‡è¦å±æ€§

</details>


## 1. Introduction

Most programming languages are partly a way of expressing things in terms of other things and partly a basic set of given things. The IsWIM (If you See What I Mean) system is a byproduct of an attempt to disentangle these two aspects in some current languages. 

This attempt has led the author to think that many linguistic idiosyneracies are concerned with the former rather than the latter, whereas aptitude for a particular class of tasks is essentially determined by the latter rather than the former. The conclusion follows that many language characteristics are irrelevant to the alleged problem orientation. 

IsWIM is an attempt at a general purpose system for describing things in terms of other things, that can be problem-oriented by appropriate choice of "primitives." So it is not a language so much as a family of languages, of which each member is the result of choosing a set of primitives. The possibilities concerning this set and what is needed to specify such a set are discussed below.

IsWIM is not alone in being a family, even after mere syntactic variations have been discounted (see Section 4). In practice, this is true of most languages that achieve more than one implementation, and if the dialects are well disciplined, they might with luck be characterized as differences in the set of things provided by the library or operating system. Perhaps had ALGOL 60 been launched as a family instead of proclaimed as a language, it would have fielded some of the less relevant criticisms of its deficiencies

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€åœ¨æŸç§ç¨‹åº¦ä¸Šæ˜¯ä¸€ç§ä»¥å…¶ä»–äº‹ç‰©çš„å½¢å¼æ¥è¡¨è¿°äº‹ç‰©çš„æ–¹å¼ï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸€å¥—åŸºç¡€çš„ç»™å®šäº‹ç‰©ã€‚ISWIMï¼ˆå¦‚æœä½ æ˜ç™½æˆ‘åœ¨è¯´ä»€ä¹ˆï¼‰ç³»ç»Ÿæ˜¯å°è¯•åœ¨ä¸€äº›å½“å‰è¯­è¨€ä¸­è§£å¼€è¿™ä¸¤ä¸ªæ–¹é¢çš„å‰¯äº§å“ã€‚

è¿™ç§å°è¯•è®©ä½œè€…è®¤ä¸ºï¼Œè®¸å¤šè¯­è¨€ç‰¹æ€§æ›´å¤šåœ°ä¸å‰è€…ç›¸å…³ï¼Œè€Œéåè€…ï¼Œè€Œå¯¹ç‰¹å®šç±»åˆ«ä»»åŠ¡çš„é€‚åº”æ€§åŸºæœ¬ä¸Šç”±åè€…å†³å®šè€Œéå‰è€…ã€‚æ‰€ä»¥å¾—å‡ºçš„ç»“è®ºæ˜¯ï¼Œå¾ˆå¤šè¯­è¨€ç‰¹æ€§ä¸æ‰€è°“çš„é—®é¢˜å¯¼å‘æ— å…³ã€‚

ISWIM æ˜¯ä¸€ç§å°è¯•ï¼Œæ—¨åœ¨é€šè¿‡é€‰æ‹©é€‚å½“çš„â€œåŸè¯­â€æ¥æè¿°äº‹ç‰©ä¸å…¶ä»–äº‹ç‰©çš„å…³è”æ€§ï¼Œä»è€Œå®ç°é¢å‘é—®é¢˜çš„æè¿°ç³»ç»Ÿã€‚å› æ­¤ï¼Œä¸å…¶è¯´å®ƒæ˜¯ä¸€ç§è¯­è¨€ï¼Œä¸å¦‚è¯´æ˜¯ä¸€ç§è¯­è¨€å®¶æ—ï¼Œå…¶ä¸­æ¯ä¸ªæˆå‘˜éƒ½æ˜¯é€‰æ‹©ä¸€ç»„åŸè¯­çš„ç»“æœã€‚ä¸‹é¢è®¨è®ºäº†ä¸è¯¥é›†åˆæœ‰å…³çš„å¯èƒ½æ€§ä»¥åŠæŒ‡å®šæ­¤ç±»é›†åˆæ‰€éœ€çš„å†…å®¹ã€‚

ISWIM å¹¶ä¸æ˜¯å”¯ä¸€ä¸€ä¸ªå®¶æ—ï¼Œå³ä½¿åœ¨å‰”é™¤äº†çº¯ç²¹çš„è¯­æ³•å˜ä½“ä¹‹åï¼ˆè§ç¬¬4èŠ‚ï¼‰ã€‚å®é™…ä¸Šï¼Œè¿™å¯¹äºå®ç°äº†ä¸æ­¢ä¸€ç§å®ç°çš„å¤§å¤šæ•°è¯­è¨€æ¥è¯´éƒ½æ˜¯çœŸå®çš„ï¼Œå¦‚æœæ–¹è¨€æœ‰å¾ˆå¥½çš„è§„èŒƒï¼Œé‚£ä¹ˆå®ƒä»¬å¯èƒ½è¢«æè¿°ä¸ºç”±åº“æˆ–æ“ä½œç³»ç»Ÿæä¾›çš„ä¸€ç»„äº‹ç‰©çš„å·®å¼‚ã€‚ä¹Ÿè®¸å¦‚æœ ALGOL 60 è¢«ä½œä¸ºä¸€ä¸ªå®¶æ—æ¨å‡ºï¼Œè€Œä¸æ˜¯è¢«å®£å¸ƒä¸ºä¸€ç§è¯­è¨€ï¼Œå®ƒå¯èƒ½ä¼šé¿å…ä¸€äº›ä¸å¤ªç›¸å…³çš„æ‰¹è¯„ã€‚

</details>


At first sight the facilities provided in IsWIM will appear comparatively meager. This appearance will be especially misleading to someone who has not appreciated how much of current manuals are devoted to the explanation of common (i.e., problem-orientation independent) logical structure rather than problem-oriented specialties. For example, in almost every language a user can coin names, obeying certain rules about the contexts in which the name is used and their relation to the textual segments that introduce, define, declare, or otherwise constrain its use. These rules vary considerably from one language to another, and frequently even within a single language there may be different conventions for different classes of names, with near-analogies that come irritatingly close to being exact. (Note that restrictions on what names can be coined also vary, but these are trivial differences. When they have any logical significance it is likely to be pernicious, by leading to puns such as ALGOL'S integer labels.)

So rules about user-coined names is an area in which we might expect to see the history of computer applications give ground to their logic. Another such area is in specifying functional relations. In fact these two areas are closely related since any use of a user-coined name implicitly involves a functional relation; e.g., compare

$ x(x+a) $

where $x = b -4- 2c$



$ f(b+2c) $

where $f(x) = x(x+a) $


ISWIM is thus part. programming language and part program for research. A possible first step in the research program is 1700 doctoral theses called "A Correspondence between x and Church's X-notation.

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

ä¹ä¸€çœ‹ï¼ŒISWIM æä¾›çš„åŠŸèƒ½ä¼šæ˜¾å¾—ç›¸å¯¹è¾ƒå°‘ã€‚è¿™ç§è§‚ç‚¹å°†å°¤å…¶è¯¯å¯¼é‚£äº›è¿˜æ²¡æœ‰æ„è¯†åˆ°å½“å‰æ‰‹å†Œä¸­æœ‰å¤šå°‘æ˜¯ä¸“é—¨ç”¨æ¥è§£é‡Šå¸¸è§ï¼ˆå³ï¼Œä¸é—®é¢˜å¯¼å‘æ— å…³ï¼‰çš„é€»è¾‘ç»“æ„ï¼Œè€Œéé—®é¢˜å¯¼å‘çš„ç‰¹æ®Šæ€§çš„äººã€‚ä¾‹å¦‚ï¼Œåœ¨å‡ ä¹æ¯ä¸€ç§è¯­è¨€ä¸­ï¼Œç”¨æˆ·éƒ½å¯ä»¥åˆ›é€ åç§°ï¼Œåœ¨åç§°ä½¿ç”¨çš„ä¸Šä¸‹æ–‡ä»¥åŠå®ƒä»¬å’Œä»‹ç»ã€å®šä¹‰ã€å£°æ˜æˆ–è€…ä»¥å…¶ä»–æ–¹å¼é™åˆ¶å…¶ä½¿ç”¨çš„æ–‡æœ¬æ®µè½çš„å…³ç³»æ–¹é¢éµå¾ªæŸäº›è§„åˆ™ã€‚è¿™äº›è§„åˆ™ä»ä¸€ç§è¯­è¨€åˆ°å¦ä¸€ç§è¯­è¨€ä¼šæœ‰å¾ˆå¤§çš„å·®å¼‚ï¼Œç”šè‡³åœ¨ä¸€ç§è¯­è¨€å†…ä¹Ÿå¯èƒ½å­˜åœ¨ä¸åŒç±»åˆ«çš„åç§°çš„ä¸åŒæƒ¯ä¾‹ï¼Œè¿‘ä¼¼çš„ç±»æ¯”ä¼šè®©äººçƒ¦èºä¸å®‰ï¼Œå› ä¸ºå®ƒä»¬æ¥è¿‘äºå®Œå…¨ä¸€è‡´ã€‚ï¼ˆè¯·æ³¨æ„ï¼Œå¯ä»¥åˆ›é€ çš„åç§°çš„é™åˆ¶ä¹Ÿä¼šæœ‰æ‰€ä¸åŒï¼Œä½†è¿™äº›éƒ½æ˜¯å¾®ä¸è¶³é“çš„å·®å¼‚ã€‚å½“å®ƒä»¬å…·æœ‰ä»»ä½•é€»è¾‘æ„ä¹‰çš„æ—¶å€™ï¼Œå¯èƒ½ä¼šå¼•èµ·æ¶åŠ£çš„æ•ˆæœï¼Œæ¯”å¦‚å¯¼è‡´åƒ ALGOL çš„æ•´æ•°æ ‡ç­¾é‚£æ ·çš„åŒå…³è¯­ã€‚ï¼‰


å› æ­¤ï¼Œå…³äºç”¨æˆ·åˆ›é€ çš„åç§°çš„è§„åˆ™æ˜¯æˆ‘ä»¬å¯ä»¥é¢„æœŸçœ‹åˆ°è®¡ç®—æœºåº”ç”¨ç¨‹åºçš„å†å²è®©ä½äºå…¶é€»è¾‘çš„é¢†åŸŸä¹‹ä¸€ã€‚å¦ä¸€ä¸ªè¿™æ ·çš„é¢†åŸŸæ˜¯åœ¨æŒ‡å®šåŠŸèƒ½å…³ç³»æ–¹é¢ã€‚äº‹å®ä¸Šï¼Œè¿™ä¸¤ä¸ªé¢†åŸŸæ˜¯å¯†åˆ‡ç›¸å…³çš„ï¼Œå› ä¸ºä»»ä½•ä½¿ç”¨ç”¨æˆ·åˆ›é€ çš„åç§°éƒ½éšå«äº†ä¸€ä¸ªåŠŸèƒ½å…³ç³»ã€‚ä¾‹å¦‚ï¼Œæ¯”è¾ƒä¸€ä¸‹ã€‚


$ x(x+a) $

where $ x=b-4-2c $

å’Œ

$ f(b+2c) $

where $ f(x)=x(x+a) $


å› æ­¤ï¼ŒISWIM æ˜¯ç¼–ç¨‹è¯­è¨€çš„ä¸€éƒ¨åˆ†ï¼Œä¹Ÿæ˜¯ç ”ç©¶é¡¹ç›®çš„ä¸€éƒ¨åˆ†ã€‚ç ”ç©¶é¡¹ç›®çš„å¯èƒ½çš„ç¬¬ä¸€æ­¥æ˜¯ 1700 ç¯‡åä¸ºâ€œ x ä¸ Church's X-è®°æ³•ä¹‹é—´çš„å¯¹åº”å…³ç³»â€çš„åšå£«è®ºæ–‡ã€‚

</details>



## 2ã€The where-Notation

In ordinary mathematical communication, these uses of 'where' require no explanation. Nor do the following: 

$ f(b+2c) + f(2b-c) $


where $ f(x) = x(x+a) $

$ f(b+2c) + f(2b-c) $


where $ f(x) = x(x+a) $

and $b=\mu/(\mu+1)$

and $c=\nu/(\nu+1)$

$g(f$ where $f(x)=ax^{2}+bx+c$,

$\mu/(\mu+1)$

$\nu/(\nu+1))$

where $g(f,p,q) = f(p+2q, 2p-q)$


A phrase of the form 'where definition' will be called a "where-clause." An expression of the form 'expression where-clause' is a "where-expression." Its two principal components are called, respectively, its "main clause" and its "supporting definition." To put 'where' into a programming language the following questions need answers

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

åœ¨æ™®é€šçš„æ•°å­¦äº¤æµä¸­ï¼Œè¿™äº›â€œwhereâ€çš„ä½¿ç”¨ä¸éœ€è¦è§£é‡Šã€‚ä»¥ä¸‹æƒ…å†µä¹Ÿä¸éœ€è¦è§£é‡Šï¼š


$ f(b+2c) + f(2b-c) $


where $ f(x) = x(x+a) $

$ f(b+2c) + f(2b-c) $


where $ f(x) = x(x+a) $

and $b=\mu/(\mu+1)$

and $c=\nu/(\nu+1)$

$g(f$ where $f(x)=ax^{2}+bx+c$,

$\mu/(\mu+1)$

$\nu/(\nu+1))$

where $g(f,p,q) = f(p+2q, 2p-q)$

ä¸€ä¸ªå½¢å¼ä¸º â€œwhere definitionâ€ çš„çŸ­è¯­å°†è¢«ç§°ä¸º â€œwhereå­å¥â€ã€‚ä¸€ä¸ªå½¢å¼ä¸º â€œexpression where-clauseâ€ çš„è¡¨è¾¾å¼æ˜¯ä¸€ä¸ª â€œwhereè¡¨è¾¾å¼â€ã€‚å®ƒçš„ä¸¤ä¸ªä¸»è¦ç»„æˆéƒ¨åˆ†åˆ†åˆ«è¢«ç§°ä¸ºå…¶â€œä¸»å¥â€å’Œå…¶â€œæ”¯æŒå®šä¹‰â€ã€‚è¦å°† â€œwhereâ€ æ”¾å…¥ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œéœ€è¦å›ç­”ä»¥ä¸‹é—®é¢˜ï¼š

</details>


Linguistic Structure. What structures of expression can appropriately be qualified by a where-clause, e.g., conditional expressions, operand-listings, statements, declarations, where-expressions?

Likewise, what structures of expression can appropriately be written as the right-hand side (rhs) of a supporting definition? What contexts are appropriate for a where-expression, e.g., as an arm of a conditional expression, an operator, the main-clause of a where-expression, the left-hand side (lhs) of a supporting definition, the rhs of a supporting definition?

Syntax. Having answered the above questions, what are the rules for writing the acceptable configurations unambiguously? E.g., where are brackets optional or obligatory? or other punctuation? or line breaks? or indentation? Note the separation of decisions about structure from decisions about syntax. (This is not a denial that language designers might iterate, like hardware designers who distinguish levels of hardware design.) 

Semantic Constraints on Linguistic Structure. In the above examples each main clause was a numerical expression; i.e., given appropriate meanings for the various identifiers in it, it denoted a number. What other kinds of meaning are appropriate for a mainclause, e.g., arrays, functions, structure descriptions, print-formats?

Likewise what kinds of meaning are appropriate for rhs's of supporting definitions? Notice there is not a third question analogous to the third question above under linguistic structure. This is because a where-expression must mean the same kind of thing as its main clause and hence raises no new question concerning what contexts are meaningful. Notice also that the questions about meaning are almost entirely independent of those about structure. They depend on classifying expressions in two ways that run across each other. 


<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

è¯­è¨€ç»“æ„ã€‚å“ªäº›è¡¨è¾¾å¼ç»“æ„å¯ä»¥æ°å½“åœ°è¢«ä¸€ä¸ª where å­å¥æ‰€ä¿®é¥°ï¼Œä¾‹å¦‚ï¼Œæ¡ä»¶è¡¨è¾¾å¼ï¼Œæ“ä½œæ•°åˆ—è¡¨ï¼Œè¯­å¥ï¼Œå£°æ˜ï¼Œwhere è¡¨è¾¾å¼ï¼Ÿ

åŒæ ·ï¼Œå“ªäº›è¡¨è¾¾å¼çš„ç»“æ„å¯ä»¥é€‚å½“åœ°ä½œä¸ºæ”¯æŒå®šä¹‰çš„å³ä¾§ï¼ˆrhsï¼‰ç¼–å†™ï¼Ÿå“ªäº›ä¸Šä¸‹æ–‡é€‚åˆç”¨whereè¡¨è¾¾å¼ï¼Œä¾‹å¦‚ï¼Œä½œä¸ºæ¡ä»¶è¡¨è¾¾å¼çš„åˆ†æ”¯ï¼Œæ“ä½œç¬¦ï¼Œwhere è¡¨è¾¾å¼çš„ä¸»ä»å¥ï¼Œæ”¯æŒå®šä¹‰çš„å·¦ä¾§ï¼ˆlhsï¼‰ï¼Œæ”¯æŒå®šä¹‰çš„ rhs ï¼Ÿ

è¯­æ³•ã€‚å›ç­”äº†ä¸Šè¿°é—®é¢˜åï¼Œå¦‚ä½•å†™å‡ºå¯æ¥å—çš„é…ç½®çš„æ˜ç¡®è§„åˆ™æ˜¯ä»€ä¹ˆï¼Ÿä¾‹å¦‚ï¼Œæ‹¬å·æ˜¯å¯é€‰è¿˜æ˜¯å¿…éœ€çš„ï¼Ÿæˆ–è€…å…¶ä»–æ ‡ç‚¹ç¬¦å·ï¼Ÿæˆ–è€…æ¢è¡Œç¬¦ï¼Ÿæˆ–è€…ç¼©è¿›ï¼Ÿè¯·æ³¨æ„å°†å…³äºç»“æ„çš„å†³å®šä¸å…³äºè¯­æ³•çš„å†³å®šåˆ†å¼€ã€‚ï¼ˆè¿™å¹¶ä¸æ˜¯å¦è®¤è¯­è¨€è®¾è®¡è€…å¯èƒ½ä¼šåƒåŒºåˆ†ä¸åŒçº§åˆ«çš„ç¡¬ä»¶è®¾è®¡çš„ç¡¬ä»¶è®¾è®¡è€…ä¸€æ ·è¿›è¡Œè¿­ä»£ã€‚ï¼‰

å¯¹è¯­è¨€ç»“æ„çš„è¯­ä¹‰çº¦æŸã€‚åœ¨ä¸Šè¿°ä¾‹å­ä¸­ï¼Œæ¯ä¸ªä¸»ä»å¥éƒ½æ˜¯ä¸€ä¸ªæ•°å€¼è¡¨è¾¾å¼ï¼›ä¹Ÿå°±æ˜¯è¯´ï¼Œç»™å®šå…¶ä¸­å„ç§æ ‡è¯†ç¬¦çš„é€‚å½“å«ä¹‰ï¼Œå®ƒè¡¨ç¤ºä¸€ä¸ªæ•°å­—ã€‚ä¸»ä»å¥é€‚åˆä»€ä¹ˆå…¶ä»–ç±»å‹çš„å«ä¹‰ï¼Œä¾‹å¦‚ï¼Œæ•°ç»„ï¼Œå‡½æ•°ï¼Œç»“æ„æè¿°ï¼Œæ‰“å°æ ¼å¼ï¼Ÿ

åŒæ ·ï¼Œæ”¯æŒå®šä¹‰çš„ rhs é€‚åˆå“ªç§ç±»å‹çš„å«ä¹‰ï¼Ÿæ³¨æ„ï¼Œæ²¡æœ‰ä¸ä¸Šè¿°è¯­è¨€ç»“æ„ä¸‹çš„ç¬¬ä¸‰ä¸ªé—®é¢˜ç±»ä¼¼çš„ç¬¬ä¸‰ä¸ªé—®é¢˜ã€‚è¿™æ˜¯å› ä¸º where è¡¨è¾¾å¼å¿…é¡»è¡¨ç¤ºä¸å…¶ä¸»ä»å¥ç›¸åŒç±»å‹çš„ä¸œè¥¿ï¼Œå› æ­¤ä¸ä¼šå¼•èµ·å…³äºå“ªäº›ä¸Šä¸‹æ–‡æ˜¯æœ‰æ„ä¹‰çš„æ–°é—®é¢˜ã€‚è¿˜è¦æ³¨æ„ï¼Œå…³äºæ„ä¹‰çš„é—®é¢˜å‡ ä¹å®Œå…¨ç‹¬ç«‹äºå…³äºç»“æ„çš„é—®é¢˜ã€‚å®ƒä»¬ä¾èµ–äºä»¥å½¼æ­¤äº¤å‰çš„ä¸¤ç§æ–¹å¼å¯¹è¡¨è¾¾å¼è¿›è¡Œåˆ†ç±»

</details>



Outcome. What is the outcome of the more recondite structural configurations among those deemed admissible, e.g. mixed nests of where-expressions, function definitions, conditional expressions, etc.?

Experimental programming has led the author to think that there is no configuration, however unpromising it might seem when judged cold, that will not turn up quite naturally. Furthermore, some configurations of 'where' that might first appear to reflect somewhat pedantic distinctions, in fact provide close matches for current language features such as name/value and own (see [2, 3]).

All these questions are not answered in this paper. The techniques for answering them are outlined in Section 4

One other issue arises when 'where' is added to a programming language-types and specifications. A method of expressing these functionally is explained in [2]. It amounts to using named transfer-functions instead of class names like integer, i.e., writing

where $ n = round(n) $

instead of the specification

integer $ n $ 

Thus the use of functional notation does not jeopardize the determination of type from textual evidence

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

ç»“æœã€‚åœ¨é‚£äº›è¢«è®¤ä¸ºå¯æ¥å—çš„ç»“æ„é…ç½®ä¸­ï¼Œæ›´éš¾ä»¥ç†è§£çš„ç»“æ„é…ç½®çš„ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿä¾‹å¦‚æ··åˆçš„whereè¡¨è¾¾å¼ã€å‡½æ•°å®šä¹‰ã€æ¡ä»¶è¡¨è¾¾å¼ç­‰çš„åµŒå¥—ç»“æ„ã€‚

å®éªŒç¼–ç¨‹ä½¿ä½œè€…è®¤ä¸ºï¼Œæ— è®ºæŸç§é…ç½®çœ‹èµ·æ¥å¤šä¹ˆä¸å…·å‰æ™¯ï¼Œåªè¦è¿›è¡Œå®é™…å°è¯•ï¼Œå®ƒéƒ½ä¼šè‡ªç„¶åœ°å‡ºç°ã€‚æ­¤å¤–ï¼Œä¸€äº›åˆçœ‹èµ·æ¥å¯èƒ½æ˜¾å¾—æœ‰äº›å­¦ç©¶æ°”çš„'where'é…ç½®ï¼Œå®é™…ä¸Šä¸å½“å‰çš„è¯­è¨€ç‰¹æ€§ï¼ˆå¦‚åç§°/å€¼å’Œownï¼‰éå¸¸åŒ¹é…ï¼ˆå‚è§[2, 3]ï¼‰ã€‚

æ‰€æœ‰è¿™äº›é—®é¢˜åœ¨æœ¬æ–‡ä¸­éƒ½æ²¡æœ‰å¾—åˆ°è§£ç­”ã€‚å›ç­”å®ƒä»¬çš„æŠ€æœ¯åœ¨ç¬¬4èŠ‚ä¸­æœ‰æ‰€æ¦‚è¿°ã€‚

å½“'where'æ·»åŠ åˆ°ç¼–ç¨‹è¯­è¨€ä¸­æ—¶ï¼Œè¿˜ä¼šå‡ºç°å…¶ä»–é—®é¢˜â€”â€”ç±»å‹å’Œè§„èŒƒã€‚åœ¨[2]ä¸­è§£é‡Šäº†è¿™äº›åŠŸèƒ½æ€§è¡¨è¾¾çš„æ–¹æ³•ã€‚è¿™å°±åƒä½¿ç”¨å‘½åè½¬ç§»å‡½æ•°è€Œä¸æ˜¯åƒæ•´æ•°ä¸€æ ·çš„ç±»åï¼Œå³ï¼Œç¼–å†™


where $ n = round(n) $

è€Œä¸æ˜¯ç±»å‹

integer $ n $ 

å› æ­¤ï¼Œä½¿ç”¨å‡½æ•°ç¬¦å·å¹¶ä¸ä¼šå±åŠä»æ–‡æœ¬è¯æ®ä¸­ç¡®å®šç±»å‹ã€‚

</details>



## 3. Physical ISWIM and :Logical ISWIM

Like ALGOL 60, ISWIM has no prescribed physical appearance. ALGOL 60'S designers sought to avoid commitment to any particular sets of characters or type faces. Accordingly they distinguish between "publication language," "reference language" and "hardware languages." Of these the reference language was the standard and was used in the report itself whenever pieces of ALGOL 60 occurred. Publication and hardware languages are transliterations of the reference language, varying according to the individual taste, needs and physical constraints on available type faces and characters. 

Such variations are different physical representations of a single abstraction, whose most faithful physical representation is the reference language. In describing ISWIM we distinguish an abstract language called "logical ISWIM," whose texts are made up of "textual elements," characterized without commitment to a particular physical representation. There is a physical representation suitable for the medium of this report, and used for presenting each piece of ISWIM that occurs in this report. So this physical representation corresponds to "reference ALGOL 60," and is called "reference ISWIM," or the "ISWIM reference representation," or the "ISWIM reference language." 

To avoid imprecision one should never speak just of "ISWIM," but always of "logical IswxM" or of "such-and-such physical ISWlM." However, in loose speech, where the precise intention is clear or unimportant, we refer to "ISWlM" without qualification. We aim at a more formal relation between physical and logical languages than was the case in the ALGOL 60. This is necessary since we wish to systematize and mechanize the use of different physical representations. 

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

å°±åƒ ALGOL 60 ä¸€æ ·ï¼ŒISWIM æ²¡æœ‰è§„å®šçš„ç‰©ç†è¡¨ç°å½¢å¼ã€‚ALGOL 60 çš„è®¾è®¡è€…ä»¬åŠ›å›¾é¿å…å¯¹ä»»ä½•ç‰¹å®šçš„å­—ç¬¦é›†æˆ–å­—ä½“ç±»å‹çš„æ‰¿è¯ºã€‚å› æ­¤ï¼Œä»–ä»¬åŒºåˆ†äº†â€œå‡ºç‰ˆè¯­è¨€â€ï¼Œâ€œå‚è€ƒè¯­è¨€â€å’Œâ€œç¡¬ä»¶è¯­è¨€â€ã€‚å…¶ä¸­ï¼Œå‚è€ƒè¯­è¨€æ˜¯æ ‡å‡†ï¼Œä¸”åœ¨æŠ¥å‘Šæœ¬èº«ä¸­ï¼Œæ¯å½“å‡ºç° ALGOL 60 çš„éƒ¨åˆ†æ—¶ï¼Œéƒ½ä¼šä½¿ç”¨è¯¥è¯­è¨€ã€‚å‡ºç‰ˆå’Œç¡¬ä»¶è¯­è¨€æ˜¯å‚è€ƒè¯­è¨€çš„è½¬å†™ï¼Œå®ƒä»¬æ ¹æ®ä¸ªäººå“å‘³ã€éœ€æ±‚ä»¥åŠå¯ç”¨å­—ä½“å’Œå­—ç¬¦çš„ç‰©ç†é™åˆ¶è€Œå˜åŒ–ã€‚

è¿™äº›å˜åŒ–æ˜¯å•ä¸ªæŠ½è±¡çš„ä¸åŒç‰©ç†è¡¨ç¤ºå½¢å¼ï¼Œå…¶æœ€å¿ å®çš„ç‰©ç†è¡¨ç¤ºå½¢å¼æ˜¯å‚è€ƒè¯­è¨€ã€‚åœ¨æè¿° ISWIM æ—¶ï¼Œæˆ‘ä»¬åŒºåˆ†äº†ä¸€ä¸ªç§°ä¸ºâ€œé€»è¾‘ ISWIM â€çš„æŠ½è±¡è¯­è¨€ï¼Œå…¶æ–‡æœ¬ç”±â€œæ–‡æœ¬å…ƒç´ â€ç»„æˆï¼Œä¸ä¾èµ–äºç‰¹å®šçš„ç‰©ç†è¡¨ç¤ºå½¢å¼ã€‚å¯¹äºæœ¬æŠ¥å‘Šçš„åª’ä»‹æ¥è¯´ï¼Œå­˜åœ¨ä¸€ç§é€‚åˆçš„ç‰©ç†è¡¨ç¤ºå½¢å¼ï¼Œç”¨äºå‘ˆç°æœ¬æŠ¥å‘Šä¸­å‡ºç°çš„æ¯ä¸ª ISWIM ç‰‡æ®µã€‚å› æ­¤ï¼Œè¿™ç§ç‰©ç†è¡¨ç¤ºå½¢å¼å¯¹åº”äºâ€œå‚è€ƒ ALGOL 60 â€ï¼Œå¹¶è¢«ç§°ä¸ºâ€œå‚è€ƒ ISWIM â€æˆ–â€œ ISWIM å‚è€ƒè¡¨ç¤ºå½¢å¼â€æˆ–â€œ ISWIM å‚è€ƒè¯­è¨€â€ã€‚

ä¸ºäº†é¿å…ä¸å‡†ç¡®ï¼Œæˆ‘ä»¬æ°¸è¿œä¸åº”è¯¥åªè°ˆè®ºâ€œ ISWIM â€ï¼Œè€Œåº”è¯¥æ€»æ˜¯è°ˆè®ºâ€œé€»è¾‘ ISWXM â€æˆ–â€œæŸç§ç‰©ç† ISWIM â€ã€‚ç„¶è€Œï¼Œåœ¨æ¾æ•£çš„å£è¯­ä¸­ï¼Œå¦‚æœç²¾ç¡®çš„æ„å›¾æ˜ç¡®æˆ–ä¸é‡è¦ï¼Œæˆ‘ä»¬å¯ä»¥ä¸åŠ é™å®šåœ°æåˆ°â€œ ISWIMâ€ã€‚æˆ‘ä»¬çš„ç›®æ ‡æ˜¯åœ¨ç‰©ç†è¯­è¨€å’Œé€»è¾‘è¯­è¨€ä¹‹é—´å»ºç«‹æ¯” ALGOL 60 æ›´æ­£å¼çš„å…³ç³»ã€‚æˆ‘ä»¬éœ€è¦è¿™æ ·åšï¼Œå› ä¸ºæˆ‘ä»¬å¸Œæœ›ç³»ç»ŸåŒ–å’Œæœºæ¢°åŒ–åœ°ä½¿ç”¨ä¸åŒçš„ç‰©ç†è¡¨ç¤ºã€‚

</details>



## 4. Four Levels of Abstraction 


The "physical/logical" terminology is often used to distinguish features that are a fortuitous consequence of physical conditions from features that are in some sense more essential. This idea is carried further by making a similar distinction among the "more essential" features. In fact ISWIM is presented here as a four-level concept comprising the following:

(1) physical ISWIM'S, of which one is the reference language and others are various publication and hardware languages (not described here)

(2) logical ISWIM, which is uncommitted as to character sets and type faces, but committed as to the sequence of textual elements, and the grammatical rules for grouping them, e.g., by parentheses, indentation and precedence relations.

(3) abstract ISWIM, which is uncommitted as to the grammatical rules of sequence and grouping, but committed as to the grammatical categories and their nesting structure. Thus abstract Iswim is a â€œtree languageâ€™ of which logical ISWIM is one linearization

(4) applicative expressions (AEs), which constitute another tree language, structurally more austere than abstract ISWIM,and providing certain basic grammatical categories in terms of which all of Iswim's more numerous categories can be expressed.

The set of acceptable texts of a physical Iswim is specified by the relations between 1 and 2, and between 2 and 3. The outcome of each text is specified by these relations, together with a "frame of reference", i.e., a rule that associates a meaning with each of a chosen set of identifiers


These are the things that vary from one member of our language family to the next. The specification of the family is completed by the relation between abstract ISWIM and AEs, together with an abstract machine that interpret AEs. These elements are the same for all members of the family and are not discussed in this paper (see [1, 2, 4]).

The relationship between physical ISWIM and logical ISWIM is fixed by saying what physical texts represent each logical element, and also what layout is permitted in stringing them together. The relationship between logical ISWIM and abstract ISWIM is fixed by a formal grammar not unlike the one in the ALGOL 60 report, together with astatement connecting the phrase categories with the abstract grammatical categories

These two relations cover what is usually called the â€œsyntaxâ€™ or â€œgrammarâ€™ of a language. In this paper syntax is not discussed beyond a few general remarks anda few examples whose meaning should be obvious

The relationship between abstract ISWIM and AEs is fixed by giving the form of AE equivalent to each abstract ISWIM grammatical category. It happens that these latter include a subset that exactly matches AEs. Hence this link in our chain of relations is roughly a mapping of ISWIM into an essential  kernelâ€™ of ISWIM, of which all the rest is mere decoration.

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

â€œç‰©ç†/é€»è¾‘â€æœ¯è¯­ç»å¸¸ç”¨æ¥åŒºåˆ†é‚£äº›å¶ç„¶ç”±ç‰©ç†æ¡ä»¶äº§ç”Ÿçš„ç‰¹æ€§å’Œåœ¨æŸç§æ„ä¹‰ä¸Šæ›´æœ¬è´¨çš„ç‰¹æ€§ã€‚è¿™ä¸ªç†å¿µåœ¨åŒºåˆ†â€œæ›´æœ¬è´¨â€ç‰¹æ€§ä¸­å¾—åˆ°äº†è¿›ä¸€æ­¥ä½“ç°ã€‚äº‹å®ä¸Šï¼ŒISWIMåœ¨è¿™é‡Œè¢«ä½œä¸ºä¸€ä¸ªå››çº§æ¦‚å¿µå±•ç°ï¼ŒåŒ…æ‹¬ä»¥ä¸‹å‡ ç‚¹ï¼š

1. ç‰©ç†ISWIMï¼Œå…¶ä¸­ä¸€ä¸ªæ˜¯å‚è€ƒè¯­è¨€ï¼Œå…¶ä»–çš„æ˜¯å„ç§å‡ºç‰ˆå’Œç¡¬ä»¶è¯­è¨€ï¼ˆè¿™é‡Œæ²¡æœ‰æè¿°ï¼‰

1. é€»è¾‘ISWIMï¼Œå®ƒä¸ä¾èµ–äºå­—ç¬¦é›†å’Œå­—ä½“ï¼Œä½†ä¾èµ–äºæ–‡æœ¬å…ƒç´ çš„é¡ºåºå’Œå°†å®ƒä»¬åˆ†ç»„çš„è¯­æ³•è§„åˆ™ï¼Œä¾‹å¦‚ä½¿ç”¨æ‹¬å·ã€ç¼©è¿›å’Œä¼˜å…ˆå…³ç³»

1. æŠ½è±¡ISWIMï¼Œå®ƒä¸ä¾èµ–äºé¡ºåºå’Œåˆ†ç»„çš„è¯­æ³•è§„åˆ™ï¼Œä½†ä¾èµ–äºè¯­æ³•ç±»åˆ«åŠå…¶åµŒå¥—ç»“æ„ã€‚å› æ­¤ï¼ŒæŠ½è±¡ISWIMæ˜¯ä¸€ç§â€œæ ‘å½¢è¯­è¨€â€ï¼Œé€»è¾‘ISWIMæ˜¯å…¶ä¸€ç§çº¿æ€§è¡¨ç¤ºå½¢å¼

1. åº”ç”¨è¡¨è¾¾å¼ï¼ˆAEsï¼‰ï¼Œå®ƒä»¬æ„æˆäº†å¦ä¸€ç§æ ‘å½¢è¯­è¨€ï¼Œç»“æ„ä¸Šæ¯”æŠ½è±¡ISWIMæ›´ä¸ºç®€æ´ï¼Œå¹¶æä¾›äº†ä¸€äº›åŸºæœ¬çš„è¯­æ³•ç±»åˆ«ï¼Œå¯ä»¥æ ¹æ®è¿™äº›ç±»åˆ«è¡¨è¾¾ISWIMä¸­æ›´å¤šçš„ç±»åˆ«ã€‚

ä¸€ä¸ªç‰©ç† ISWIM çš„æ¥å—æ–‡æœ¬é›†æ˜¯ç”± 1 å’Œ 2 ä¹‹é—´çš„å…³ç³»ï¼Œä»¥åŠ 2 å’Œ 3 ä¹‹é—´çš„å…³ç³»æ¥è§„å®šçš„ã€‚æ¯ä¸ªæ–‡æœ¬çš„ç»“æœç”±è¿™äº›å…³ç³»åŠä¸€ä¸ªâ€œå‚ç…§ç³»â€è§„å®šï¼Œå‚ç…§ç³»æŒ‡çš„æ˜¯ä¸€ä¸ªè§„åˆ™ï¼Œå®ƒå°†æ¯ä¸ªé€‰å®šçš„æ ‡è¯†ç¬¦é›†åˆçš„æ„ä¹‰å…³è”èµ·æ¥

è¿™äº›æ˜¯ä»æˆ‘ä»¬çš„è¯­è¨€å®¶æ—çš„ä¸€ä¸ªæˆå‘˜åˆ°å¦ä¸€ä¸ªæˆå‘˜ä¹‹é—´å˜åŒ–çš„äº‹ç‰©ã€‚é€šè¿‡æŠ½è±¡ ISWIM å’Œ AEs ä¹‹é—´çš„å…³ç³»ä»¥åŠè§£é‡Š AEs çš„æŠ½è±¡æœºå™¨æ¥å®Œæˆå¯¹å®¶æ—çš„è§„èŒƒã€‚è¿™äº›å…ƒç´ å¯¹äºå®¶æ—çš„æ‰€æœ‰æˆå‘˜éƒ½æ˜¯ç›¸åŒçš„ï¼Œå¹¶ä¸”æœ¬æ–‡ä¸­æ²¡æœ‰è®¨è®ºï¼ˆè¯·å‚è§[1, 2, 4]ï¼‰

ç‰©ç† ISWIM å’Œé€»è¾‘ ISWIM ä¹‹é—´çš„å…³ç³»æ˜¯é€šè¿‡è¯´æ˜å“ªäº›ç‰©ç†æ–‡æœ¬è¡¨ç¤ºæ¯ä¸ªé€»è¾‘å…ƒç´ ä»¥åŠåœ¨å°†å®ƒä»¬è¿æ¥åœ¨ä¸€èµ·æ—¶å…è®¸çš„å¸ƒå±€æ¥å›ºå®šçš„ã€‚é€»è¾‘ ISWIM å’ŒæŠ½è±¡ ISWIM ä¹‹é—´çš„å…³ç³»æ˜¯é€šè¿‡ç±»ä¼¼äº ALGOL 60 æŠ¥å‘Šä¸­ä½¿ç”¨çš„æ­£å¼è¯­æ³•ä»¥åŠå°†çŸ­è¯­ç±»åˆ«ä¸æŠ½è±¡è¯­æ³•ç±»åˆ«è”ç³»èµ·æ¥çš„è¯­å¥æ¥å›ºå®šçš„

è¿™ä¸¤ä¸ªå…³ç³»æ¶µç›–äº†é€šå¸¸è¢«ç§°ä¸ºè¯­è¨€çš„â€œè¯­æ³•â€æˆ–â€œå¥æ³•â€ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œé™¤äº†ä¸€äº›ä¸€èˆ¬æ€§çš„è¯„è®ºå’Œå‡ ä¸ªåº”è¯¥å¾ˆæ˜æ˜¾çš„ä¾‹å­ä¹‹å¤–ï¼Œä¸ä¼šè®¨è®ºè¯­æ³•

æŠ½è±¡ ISWIM å’Œ AEs ä¹‹é—´çš„å…³ç³»æ˜¯é€šè¿‡ç»™å‡ºä¸æ¯ä¸ªæŠ½è±¡ ISWIM è¯­æ³•ç±»åˆ«ç­‰ä»·çš„ AE çš„å½¢å¼æ¥å›ºå®šçš„ã€‚åè€…åŒ…æ‹¬äº†ä¸€ä¸ªä¸ AEs å®Œå…¨åŒ¹é…çš„å­é›†ã€‚å› æ­¤ï¼Œåœ¨æˆ‘ä»¬çš„å…³ç³»é“¾ä¸­ï¼Œè¿™ä¸ªé“¾æ¥å¤§è‡´æ˜¯å°† ISWIM æ˜ å°„åˆ°ä¸€ä¸ªæ ¸å¿ƒçš„â€œå†…æ ¸â€ï¼Œå…¶ä½™çš„éƒ½æ˜¯è£…é¥°å“

</details>


## 5. Abstract ISWIM

The texts of abstract ISWIM are composite information structures called amessage's. The following structure definition defines the class amessage in terms of a class called identifier. It also defines several functions for manipulating amessage's. These comprise the predicates demand, simple, infixed, etc; also the selectors body, rator,leflarm, nee, etc; also (taking for granted certain unformalized conventions concerning structure definitions) the constructors, consdemand, conscombination (elsewhere abbreviated to combine), consstandardadef, etc. Examples of reference ISWIM are given alongside, against the right margin.


An amessage is either a demand, and has a body which is an aexpression,or else a definition,

$ [Print \qquad a+2b $

$ [Def \qquad x=a+2b $

<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

æŠ½è±¡ISWIMçš„æ–‡æœ¬æ˜¯ç”±ç§°ä¸ºamessageçš„ä¿¡æ¯ç»“æ„ç»„æˆçš„ã€‚ä»¥ä¸‹çš„ç»“æ„å®šä¹‰å°†ç±»amessageå®šä¹‰ä¸ºä¸€ä¸ªç§°ä¸ºæ ‡è¯†ç¬¦çš„ç±»ã€‚å®ƒä¹Ÿå®šä¹‰äº†å‡ ä¸ªç”¨äºå¤„ç†amessageçš„å‡½æ•°ã€‚è¿™äº›åŒ…æ‹¬éœ€æ±‚ã€ç®€å•ã€ä¸­ç¼€ç­‰è°“è¯ï¼›è¿˜æœ‰é€‰æ‹©å™¨bodyã€ratorã€leflarmã€neeç­‰ï¼›è¿˜æœ‰ï¼ˆå‡è®¾æ¥å—æŸäº›æœªæ­£å¼åŒ–çš„ç»“æ„å®šä¹‰çº¦å®šï¼‰æ„é€ å‡½æ•°ï¼Œå¦‚consdemandã€conscombinationï¼ˆåœ¨å…¶ä»–åœ°æ–¹ç¼©å†™ä¸ºcombineï¼‰ã€consstandardadefç­‰ã€‚å‚ç…§ISWIMçš„ç¤ºä¾‹é’ˆå¯¹å³è¾¹è¾¹ç•Œç»™å‡ºã€‚

ä¸€ä¸ªæ¶ˆæ¯å¯èƒ½æ˜¯ä¸€ä¸ªéœ€æ±‚ï¼Œå®ƒçš„ä¸»ä½“æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªå®šä¹‰.

</details>



### 5.1  where rec

an aexpression (aexp) is 

#### 5.1.1 either simple, and has a body which is an identifier

$ [C Ath231'' $

#### 5.1.2  or a combination, 

in which case 

* it has a rator, 

	which is an aexp, 
	
	$ [sin(a+2b) $
	
* and a rand,

	which is an aexp,

  $  a+2b $

#### 5.1.3  or conditional, in which case it is 

* either two-armed, 

	and has a condition, which is an aexp, and a leftarm, which is an aexp, and a rightarm, which is an aexp, 

	$ [p\to a+2b ; \quad 2a-b$

* or one-armed, 
	
	and has a condition, which is an aexp, and an arm, which is an aexp

	$ [p\to 2a-b$

### 5.1.4 or a listing, and has a body which is an aexp-list, 

$ [a+b,c+d,e+f $

#### 5.1.5 or beet, and has 

* a mainclause, 

	which is an aexp, 

	$ [x(x+1) \quad where  \quad x=a+2b $

* and a support 

	which is an adef

	$ let \quad x=a+2b; \quad x(x+1) $

### 5.2 and an a definition (adef)

#### 5.2.1  is either standard, 

and has 

a definee (nee), which is an abv,

and a defniens (niens), which is an aexp

$ [x=a+2b $

#### 5.2.2 or functionform, 

and has 

* a lefthandside (lhs) which is an abv-list of length $\ge 2$

* and a righthandside (rhs), which is an aexp

$[f(x)=x(x+1)$

#### 5.2.3 or programpoint,

and has a body which is an adef.

$[pp \quad f(x)=x(x+1)$

#### 5.2.4 or circular, 

and has a body which is an adef.

$ [rcc \quad f(n)=(n=0) \to 1; nf(n-1)$

#### 5.2.5 or simultaneous, 

and has a body, which is an adef-list.

$ [x=a+2b \quad and \quad y=2a-b$

#### 5.2.6 or beet, and has

a mainclause which is an adef and a support, which is an adef

$ f(y)=x(x+y) \quad where \quad x=a+2b$

### 5.3 where an abv is

#### 5.3.1 either simple,

and has a body, which is an identifier.

#### 5.3.2 or else, is an abv-list.

$ [k, (y, z), w$

A program-point definition introduces a deviant kind of function. Applying such a function precipitates premature termination of the where-expression containing it, and causes its result to be delivered as the value of theentire where expression.


Program-points are ISWIM's, nearest thing to jumping. Assignment is covered as a particular case of an operator. For both of these the precise specification is in terms of the underlying abstract machine.


<details> <summary> ğŸª¶ ğŸ¦‰ğŸ¦ŠğŸ¿ ğŸª¶</summary>

### 5.1 å…¶ä¸­å…³äºrecï¼Œå¯èƒ½æ˜¯

#### 5.1.1 ç®€å•çš„ï¼Œå…¶ä¸»ä½“æ˜¯ä¸€ä¸ªæ ‡è¯†ç¬¦

$ [C Ath231'' $

#### 5.1.2 æˆ–è€…æ˜¯ä¸€ä¸ªç»„åˆï¼Œ

(1) å®ƒæœ‰ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼

$ [sin(a+2b) $
	
(2) å’Œä¸€ä¸ªæ“ä½œæ•°, ä¹Ÿæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼

  $  a+2b $
	

#### 5.1.3 æˆ–è€…æ˜¯æ¡ä»¶çš„ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒæ˜¯

(1) ä¸¤ä¸ªåˆ†æ”¯çš„, å¹¶ä¸”å…·æœ‰ä¸€ä¸ªæ¡ä»¶ï¼Œè¿™æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå·¦å€¼æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œå³å€¼æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œ

$ [p\to a+2b ; \quad 2a-b$

(2) æˆ–è€…æ˜¯å•åˆ†æ”¯ï¼Œå¹¶ä¸”å…·æœ‰ä¸€ä¸ªæ¡ä»¶ï¼Œè¿™æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œä¸€ä¸ªåˆ†æ”¯ï¼Œä¹Ÿæ˜¯è¡¨è¾¾å¼ã€‚

$ [p\to 2a-b$
	
	
#### 5.1.4 æˆ–è€…æ˜¯åˆ—è¡¨ï¼Œæ‹¥æœ‰ä¸€ä¸ªä¸»ä½“ï¼Œè¿™æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼åˆ—è¡¨

$ [a+b,c+d,e+f $

#### 5.1.5 æˆ–è€…ï¼Œ

(1) å…·æœ‰ä¸€ä¸ªä¸»å¥ï¼Œè¿™æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼

$ [x(x+1) \quad where  \quad x=a+2b $

(2) æˆ–è€…æœ‰ä¸€ä¸ªå®šä¹‰

$ let \quad x=a+2b; \quad x(x+1) $


### 5.2 ä¸€ä¸ªå®šä¹‰ï¼Œå¯èƒ½æ˜¯

#### 5.2.1 å®ƒå¯ä»¥æ˜¯æ ‡å‡†çš„

æœ‰ä¸ªå®šä¹‰è€…å’Œè¢«å®šä¹‰è€…

$ [x=a+2b $

#### 5.2.2 æˆ–è€…æ˜¯å‡½æ•°å½¢å¼ï¼Œ

å®ƒæœ‰ä¸€ä¸ªå·¦å€¼æ˜¯é•¿åº¦ $\ge 2$ çš„ç¼©ç•¥è¯åˆ—è¡¨ï¼Œè¿˜æœ‰ä¸€ä¸ªå³å€¼ï¼Œæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼

$[f(x)=x(x+1)$

#### 5.2.3 æˆ–è€…æ˜¯ç¨‹åºï¼Œ

å¹¶ä¸”æœ‰ä¸€ä¸ªä¸»ä½“ï¼Œè¿™æ˜¯ä¸€ä¸ªå®šä¹‰ã€‚


$[pp \quad f(x)=x(x+1)$

#### 5.2.4 æˆ–è€…æ˜¯ç¯å½¢çš„ï¼Œ

å¹¶ä¸”æœ‰ä¸€ä¸ªæ˜¯å®šä¹‰çš„ä¸»ä½“ã€‚

$ [rcc \quad f(n)=(n=0) \to 1; nf(n-1)$

#### 5.2.5 æˆ–è€…æ˜¯åŒæ—¶çš„ï¼Œ

å¹¶ä¸”æœ‰ä¸€ä¸ªä¸»ä½“ï¼Œè¿™æ˜¯ä¸€ä¸ªå®šä¹‰åˆ—è¡¨

$ [x=a+2b \quad and \quad y=2a-b$

#### 5.2.6 æˆ–è€…

ä¸€ä¸ªä¸»å¥æ˜¯ä¸€ä¸ªå®šä¹‰ï¼Œè€Œä¸€ä¸ªä»å¥æ˜¯ä¸€ä¸ªå®šä¹‰

$ f(y)=x(x+y) \quad where \quad x=a+2b$

### 5.3 å…¶ä¸­ï¼Œç®€ç§°

#### 5.3.1 è¦ä¹ˆæ˜¯ç®€å•çš„ï¼Œå¹¶ä¸”å…·æœ‰ä¸€ä¸ªæ ‡è¯†ç¬¦ã€‚

#### 5.3.2 æˆ–è€…æ˜¯ä¸€ä¸ªç®€ç§°åˆ—è¡¨ã€‚

$ [k, (y, z), w$


ç¨‹åºç‚¹å®šä¹‰å¼•å…¥äº†ä¸€ç§å¼‚å¸¸çš„å‡½æ•°ã€‚ åº”ç”¨æ­¤ç±»å‡½æ•°ä¼šå¯¼è‡´åŒ…å«è¯¥å‡½æ•°çš„ where è¡¨è¾¾å¼æå‰ç»ˆæ­¢ï¼Œå¹¶å¯¼è‡´å…¶ç»“æœä½œä¸ºæ•´ä¸ª where è¡¨è¾¾å¼çš„å€¼è¿›è¡Œä¼ é€’ã€‚

ç¨‹åºç‚¹æ˜¯ ISWIM çš„ï¼Œæœ€æ¥è¿‘è·³è·ƒçš„ä¸œè¥¿ã€‚ èµ‹å€¼è¢«è§†ä¸ºè¿ç®—ç¬¦çš„ç‰¹æ®Šæƒ…å†µã€‚ å¯¹äºè¿™ä¸¤è€…ï¼Œç²¾ç¡®çš„è§„èŒƒæ˜¯æ ¹æ®åº•å±‚æŠ½è±¡æœºæ¥è¿›è¡Œçš„ã€‚


</details>
